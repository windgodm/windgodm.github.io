[{"id":"e13f0f4c0a8cc181704cbc8ca9e68ace","title":"IA32e硬件与操作系统中断机制","content":"IA32e中断前言\n\n\n\n\n\n\n\n\n前置知识：\n\nIA32e 全局描述符表（GDT）\n平坦模式\n描述符的字段\n\n\n\n后置知识：\n\nTSS\n\n\n\n\n\n\n\n\n\n\n这部分内容主要为intel白皮书的笔记，主要关注64位和软件相关的信息，忽略了影子栈和32位下的情况，还有优先级\nsdm-vol3(v77)：\n\n第6章：关于中断和异常处理\n\n6.1：概述\n\n6.2：异常和中断向量\n\n6.3：中断源\n\n6.4：异常源\n\n6.5：异常分类\n\n6.8：启用和禁用中断\n\n6.10：IDT 描述符\n\n6.12：处理异常和中断\n\n6.14：特定于IA-32e模式和64位子模式的信息\n\n\n\n\n异常和中断概述异常和中断：指示处理器有需要注意的事，通常会强制切换控制流\n来源：随机发生，来自硬件的信号、软件的INT n指令、处理器错误（比如除0）\n异常和中断向量向量号（vector number）：\n\n每个异常（exception）和中断条件（interrupt condition）分配一个唯一的数\n作为中断描述符表（IDT）的索引\n范围0~255\n0~31：IA-32架构保留\n32~255：用户定义\n\n\n\n异常和中断源中断源：\n\n外部（硬件）中断\n软件生成的中断\nINT n指令强制隐式调用中断号为n的中断处理程序\n0~255都可以作为指令参数\n不会使用EFLAGS的IF标记\n\n\n\n异常源：\n\n处理器检测 到 程序错误 异常\n软件生成的异常\n通过INT n指令产生的异常不会把错误代码入栈；而异常处理程序会尝试弹出错误代码，可能会导致错误的返回位置\n\n\n机器检测异常\n\n异常分类按照产生的原因和处理的方式分类：\n\nfaults：可以被改正的异常，改正后将返回到产生异常的指令（然后再次执行）\ntraps：返回到下一条指令\naborts：不允许产生异常的程序或任务继续运行\n\n保护模式保留的异常和中断![vol-3a-t-6-1 Protected-Mode Exceptions and Interrupts](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-t-6-1 Protected-Mode Exceptions and Interrupts.jpg)\n![vol-3a-t-6-1 Protected-Mode Exceptions and Interrupts (Contd.)](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-t-6-1 Protected-Mode Exceptions and Interrupts (Contd.).jpg)\n启用和禁用中断根据处理器的状态以及EFLAGS中的IF和RF，处理器抑制某些中断的产生\n\nRF：设置时，调试异常（#DB）将无法生成（更多信息：17.3.1.1）\n\n切换ss通常需要两条指令：\nMOV SS, AX\nMOV ESP, StackTop\n\n为了保护切换时的原子性，在MOV或POP修改SS时：\n\n下一条指令禁用指令断点（类似EFLAGS.RF=1）\n数据断点将被抑制直到两条指令完成\n在两条指令完成后交付单步陷阱\n连续的加载SS只有第一条加载指令遵循以上规则\n\n优先级如果出现多个中断，将按优先级处理\n中断描述符表（IDT）IDTR寄存器保存着IDT的基址，8字节对齐\nIDT存有有三种类型的门描述符（gate descriptor）：\n\n任务门描述符\n中断门描述符\n陷阱门描述符\n\nIA32 三种门描述符的格式\n![vol-3a-f-6-2 IDT Gate Descriptors](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-6-2 IDT Gate Descriptors.jpg)\nIA32e IDT表项由8字节拓展为16字节，以支持64位的地址偏移\n![vol-3a-f-6-8 64-Bit IDT Gate Descriptors](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-6-8 64-Bit IDT Gate Descriptors.png)\nTYPE字段同IA32\nIST（Interrupt Stack Table）字段用于栈切换基址\n异常与中断流程找到处理函数根据中断向量，找到处理函数：\n![vol-3a-f-6-3 Interrupt Procedure Call](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-6-3 Interrupt Procedure Call.jpg)\nIA32切换到处理函数IA32下，根据中断前特权级别和中断（描述符上）的特权级别，有两种情况：\n\n级别不变，在中断时的栈上，将相关寄存器入栈\n级别改变，切换到处理函数的栈，再将相关寄存器入栈\n\n注意：\n\n级别改变时会先额外入栈SS、ESP\n只有异常才会入栈Error Code（通过int n指令产生的不入栈）\n\n![vol-3a-f-6-4  Stack Usage on Transfers to Interrupt and Exception-Handling Routines](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-6-4  Stack Usage on Transfers to Interrupt and Exception-Handling Routines.jpg)\nIA32e切换到处理函数的不同栈元素由4字节变为8字节，入栈内容一样\n新SS强制为0，从TSS中获取新RSP\nIA32e 中断栈表（IST）IA32e中可以使用IST机制替代前面的栈切换机制\n中断描述符（IDT）的IST字段用于在TSS中索引（4位，范围0~7）\n\n\n\n\n\n\n\n\n\n当IST为0时，新栈指针为TSS的RSP0，否则为对应的ISTn\n当使用影子栈时，处理器提供一个MSRIA32_INTERRUPT_SSP_TABLE\n![vol-3a-f-6-10 Interrupt Shadow Stack Table](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-6-10 Interrupt Shadow Stack Table.jpg)\n返回到中断或异常前代码使用iret或iretd指令：将弹出切换时入栈的参数恢复对应寄存器，然后返回\n参考\n官方文档\nsdm-vol3(v77)\n\n\nIA32中断异常的解说\nIA-32的中断和异常处理 - 知乎 (zhihu.com)\n\n\nIA32e中断异常解说；在windows上使用windbg跟踪从32/64通过syscall进内核过程\nWindows x64内核学习笔记（二）—— IA-32e模式_lzyddf的博客-CSDN博客\n\n\n\nIA32e系统调用硬件支持前言\n\n\n\n\n\n\n\n\n主要关注IA32e的系统调用，忽略兼容模式\nsdm-vol3(v77)：\n\n2.2.1：IA32e 拓展特性启用寄存器\n5.8.7：快速调用系统过程 与 SYSENTER SYSEXIT\n5.8.8：64位模式的快速系统调用\n\nIA32e为系统调用机制提供了一些支持，以便以受控制的方式从R3切换到R0\nSYSENTER SYSEXIT该对指令目的是为了提供一个机制，允许快速调用操作系统或执行过程\nSYSENTER可以在任意权限级别下进入R0\nSYSEXIT用于在R0下返回\n两条执行跳转时将从MSR寄存器和通用寄存器中获取所需的信息，以减少对内存的访问\n所有信息需要由调用过程显式保存\n\n\n\n\n\n\n\n\n\nNehalem微架构：\n\nIA32_SYSENTER_CS 174H\nIA32_SYSENTER_ESP 175H\nIA32_SYSENTER_EIP 176H\n\nIA32：\n\nSYSENTER\n\n目标代码段：msr[IA32_SYSENTER_CS]\n\n目标指令：msr[IA32_SYSENTER_EIP]\n\n栈段：msr[IA32_SYSENTER_CS] + 8\n\n栈指针：msr[IA32_SYSENTER_ESP]\n\n\n\nSYSEXIT\n\n目标代码段：msr[IA32_SYSENTER_CS] + 16\n\n目标指令：EDX\n\n栈段：msr[IA32_SYSENTER_CS] + 24\n\n栈指针：ECX\n\n\n\n\nIA32e（msr寄存器拓展到64位，使用时也是读64位）：\n\nSYSENTER\n目标代码段：msr[IA32_SYSENTER_CS]（非NULL选择子）\n新CS属性：base=0, limit=FFFFFFFFH\n目标指令：msr[IA32_SYSENTER_EIP]\n栈段：msr[IA32_SYSENTER_CS] + 8\n新SS属性：base=0, limit=FFFFFFFFH\n栈指针：msr[IA32_SYSENTER_ESP]\n\n\nSYSEXIT\n目标代码段：msr[IA32_SYSENTER_CS] + 32\n新CS属性：L-bit=1（强制到64位模式）\n目标指令：RDX\n栈段：msr[IA32_SYSENTER_CS] + 40\n栈指针：RCX\n\n\n\n快速系统调用MSR[IA32_EFER]（0xC0000080）的第0位指示是否支持SYSCALL和SYSRET指令\nSYSCALL、SYSRET是为平坦模式设计的，连同SYSENTER、SYSEXIT适用于IA-32e模式，但前面一对在兼容模式（或保护模式）下不支持\nCPUID.80000001H.EDX[bit 11]指示是否支持SYSCALL、SYSRET\nSYSCALL用于在R3下进入R0\nSYSRET用于在R0下返回到R3\n\n\n\n\n\n\n\n\n\nNehalem微架构：\n\nIA32_EFER C0000080H\nIA32_STAR C0000081H\nIA32_LSTAR C0000082H\nIA32_FMASK C0000084H\n\nSYSCALL和SYSRET会保存和恢复RFLAGS寄存器\n然后类似前面，也是使用MSR寄存器和通用寄存器\n\nSYSCALL\n由处理器将RFLAGS存入R11；下一条指令的RIP存入RCX（返回地址）\n目标代码段：msr[IA32_STAR][47:32]（非NULL选择子）\n目标指令：msr[IA32_LSTAR]\n栈段：msr[IA32_STAR][47:32] + 8\nRFLAGS：RFLAGS &amp; msr[IA32_FMASK]\n\n\nSYSRET\n目标代码段：msr[IA32_STAR][63:48] + 16（非NULL选择子）\n目标指令：RCX\n栈段：msr[IA32_STAR][63:48] + 8\nRFLAGS：R11\n\n\n\n操作系统应该保证这两条指令跳转时所切换的GDT/LDT表项内容的正确性\n栈指针也不会被保存和恢复，栈的切换交由操作系统实现\n上述所用MSR寄存器的布局\n![vol-3a-f-5-14 MSRs Used by SYSCALL and SYSRET](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-5-14 MSRs Used by SYSCALL and SYSRET.jpg)\n参考\n官方文档\nsdm-vol3(v77)\nsdm-vol4(v78)\n\n\n\nwindows系统调用概述概述（指IA32架构下的windows系统）\n系统调用的大致机制为：\n通过硬件支持的中断或陷阱指令，进入到内核中的系统调用分发函数，然后再执行对应的系统调用处理函数\nwindows有两个服务表（SDT），存储了系统调用的信息，第二个表用于GUI程序：\ntypedef struct _KSERVICE_TABLE_DESCRIPTOR\n&#123;\n    PULONG Base;   &#x2F;&#x2F; address or offsets&#39; array\n    PULONG Count;\n    ULONG Limit;   &#x2F;&#x2F; number of array\n    PUCHAR Number;\n    &#x2F;&#x2F; ...\n&#125; KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;\n\nKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;       &#x2F;&#x2F; SDT\nKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow; &#x2F;&#x2F; SDTS (+gui)\n\n两个SDT的Base字段指向一个数组，存储了各个系统调用处理函数的地址，该数组又被称为SSDT\n内核还维护着两个全局指针指向两个地址/偏移量数组（SSDT）：\nKiServiceTable，W32pServiceTable\n获取某个系统调用函数地址的方式：\n&#x2F;&#x2F; x86\naddr[i] &#x3D; (DWORD*)KiServiceTable[i];\n\n&#x2F;&#x2F; x64\naddr[i] &#x3D; KiServiceTable + (DWORD*)KiServiceTable[i] &gt;&gt; 4;\n\n\n\n进入内核的方式思路\n通过中断（int 2e）或者陷阱指令（sysenter、syscall），进入内核\n通过指定进入内核的位置为系统调用分发函数，实现系统调用\n中断2E 实现（过时）\n通过中断INT 0x2E实现系统调用\nIDT中0x2E表项对应KiSystemService，实现了系统调用的分发\nsysenter 实现（过时）\n通过IA32的快速调用指令SYSENTER/SYSEXIT实现（对硬件而言，32、64位都支持该指令）\nmsr[IA32_SYSENTER_CS]（174H）为通过SYSENTER指令进入内核的位置\n由windows系统初始化为KiFastCallEntry\nsyscall 实现（现用）\n通过IA32e的快速系统调用指令SYSCALL/SYSRET实现（对硬件而言只在64位下支持）\nmsr[IA32_LSTAR]（C000_0082H）为通过SYSCALL指令进入内核的位置\n由windows系统初始化为KiSystemCall64\nwin10进入内核win10版本号：21H2\n处理器：AMD\n简单跟踪程序对CreateFile系统调用的执行过程\nx64程序R3部分进入的过程：\n; test64.exe main\ncall qword ptr ds:[&lt;&amp;CreateFileW&gt;]\n\n; kernel32.dll, CreateFileW, STUB\njmp qword ptr ds:[&lt;&amp;CreateFileW&gt;]\n\n; kernelbase.dll, CreateFileW, 简单处理参数\n...\ncall CreateFileInternal\n; kernelbase.dll, CreateFileInternal, 处理参数\n...\ncall qword ptr ds:[&lt;&amp;NtCreateFile&gt;]\n\n; ntdll.dll, NtCreateFile\n...\n\nntdll.dll NtCreateFile的代码，其他系统调用的代码也是一样的格式：\nmov r10, rcx ; 保存rcx，syscall会把下一条指令（返回）地址存在rcx\nmov eax, 55  ; 调用号\ntest byte ptr ds:[7FFE0308h], 1 ; 检查是否支持syscall\njne l_int\nsyscall ; 通过syscall进入内核\nret\nl_int:\nint 2E ; 通过中断进入内核\nret\n\n\n\nx64程序 系统调用 R0入口sysenter在64位内核中已被弃用\nsyscall的系统调用分发函数 = msr[IA32_LSTAR]，windbg读出是KiSystemCall64\n1: kd&gt; rdmsr C0000082\nmsr[c0000082] &#x3D; fffff804&#96;33a0c2c0\n1: kd&gt; u fffff804&#96;33a0c2c0 l1\nnt!KiSystemCall64:\nfffff804&#96;33a0c2c0 0f01f8          swapgs\n\n\n\n简单贴一下KiSystemCall64开头的汇编：\n（21H2的 KPCR 大小为 178H，KPRCB 似乎因为对齐从 gs:180H开始）\nswapgs                   ; 切换gs\nmov     gs:10h, rsp      ; [gs+10h] _KPCR.UserRsp\nmov     rsp, gs:1A8h     ; [gs+180h+28h] _KPRCB.RspBase\npush    2Bh\npush    qword ptr gs:10h\npush    r11              ; syscall 之前的 rflags\npush    33h\npush    rcx              ; syscall 下一条指令的地址（返回到R3的地址）\nmov     rcx, r10         ; 恢复rcx寄存器\n\n\n\nint 2E的系统调用分发函数，windbg读出是KiIsrThunk+0x170\n1: kd&gt; dq idtr+10*2E l2\nffff8780&#96;16f4d2e0  339f8e00&#96;0010d770 00000000&#96;fffff804\n1: kd&gt; u fffff804339fd770 l3\nnt!KiIsrThunk+0x170:\nfffff804&#96;339fd770 6a2e            push    2Eh\nfffff804&#96;339fd772 55              push    rbp\nfffff804&#96;339fd773 e999060000      jmp     nt!KiIsrLinkage (fffff804&#96;339fde11)\n\n\n\nx32程序R3部分切换到x64之前的部分：\n; test32.exe main\ncall qword ptr ds:[&lt;&amp;CreateFileW&gt;]\n\n; kernel32.dll, CreateFileW, STUB\njmp qword ptr ds:[&lt;&amp;CreateFileW&gt;]\n\n; kernelbase.dll, CreateFileW, 简单处理参数\n...\ncall CreateFileInternal\n; kernelbase.dll, CreateFileInternal, 处理参数\n...\ncall qword ptr ds:[&lt;&amp;NtCreateFile&gt;]\n\n; ntdll.dll, NtCreateFile\n...\ncall edx ; Wow64SystemServiceCall\n\n; ntdll.dll, Wow64SystemServiceCall\njmp dword ptr ds:[&lt;Wow64Transition&gt;]\n\nntdll.dll NtCreateFile的代码：\nmov     eax, 55h ; NtCreateFile\nmov     edx, offset _Wow64SystemServiceCall@0 ; Wow64SystemServiceCall()\ncall    edx ; Wow64SystemServiceCall() ; Wow64SystemServiceCall()\nretn    2Ch\n\n这个Wow64SystemServiceCall在CE中识别为KiFastSystemCall，作用是切换到64位：\n; x32 asm\n774F7000 | EA 09704F77 3300         | jmp far 33:774F7009\n; x64 asm\n774F7009 | 41 FF A7 F8000000        | jmp qword [r15 + 0xf8]\n\n\n\n小结windows的系统调用机制大概为：\nx64一般使用syscall指令陷入内核中的系统调用分发函数\nx32先变成64位，再陷入\n中断请求级概述windows使用IRQL（Interrupt ReQuest Level，中断请求级）管理中断优先级，这是一个IA32硬件支持的功能\nwindows为各优先级别赋予了意义：\n\nPASSIVE LEVEL（0）：最低级别，全部用户模式代码和大多数内核代码\nAPC LEVEL（1）：异步过程调用（APC）的级别\nDISPATCH LEVEL（2）：最高级别的软件IRQL，线程分发器、延迟过程调用（DPC）的级别\n\n参考\n《逆向工程实战》（《Practical Reverse Engineering》）\nWindows x64内核学习笔记（二）—— IA-32e模式_lzyddf的博客-CSDN博客\n\nlinux系统调用概述（指IA32架构下的linux系统）\n给ubuntu2004添加系统调用虚拟机版本：VM 16.1.0\n系统版本：ubuntu-20.04.1，VM便捷安装\n查看内核版本（uname -a）：5.15.0-58\n修改内核下载内核源码（https://www.kernel.org/），选择 5.15.90 版本（longterm）\n解压到 /usr/src\n添加系统调用号\nsudo gedit arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscall_64.tbl\n\n第一部分的系统调用号为1~448，第二部分为512以后，在448和512之间都可以添加新系统调用\n449\t64\thw\t\t\tsys_hw\n\n\n\n添加系统调用函数声明\nsudo gedit include&#x2F;linux&#x2F;syscalls.h \n\n在最后一个系统调用函数声明后添加\nasmlinkage long sys_hw(int arg);\n\n\n\n添加系统调用函数定义\nsudo gedit kernel&#x2F;sys.c\n\n在最后添加\nasmlinkage long sys_hw(int arg)\n&#123;\n\tprintk(&quot;hello world, arg&#x3D;%d\\n&quot;, arg);\n\treturn 0;\n&#125;\n\n\n\n编译内核安装编译所需工具\nsudo apt-get install make\nsudo apt-get install build-essential openssl\nsudo apt-get install libncurses5-dev libssl-dev\nsudo apt-get install zlibc minizip\nsudo apt-get install libidn11-dev libidn11\nsudo apt-get install bison flex\nsudo apt-get install libelf-dev\nsudo apt-get install dwarves\nsudo apt-get install zstd\n\n安装上面的几个似乎会附带安装下面这几个\nsudo apt-get install pkg-config\nsudo apt-get install libc6-dev\n\n\n\n删除编译生成文件、内核配置文件\nsudo make mrproper\nsudo make clean\n\n\n\n配置\n使用旧配置，在/boot中\ncp &#x2F;boot&#x2F;config-5.15.0-58-generic .&#x2F;.config\n\n修改.config：\nCONFIG_SYSTEM_TRUSTED_KEYS&#x3D;&quot;&quot;\nCONFIG_SYSTEM_REVOCATION_KEYS&#x3D;&quot;&quot;\nCONFIG_DEBUG_INFO_BTF&#x3D;n\n\n\n\n编译\n编译内核，大概7~8分钟\nsudo make bzImage -j8\n\n编译模块，\nsudo make modules -j8\n\n\n\n启动文件\n备份\nsudo cp &#x2F;etc&#x2F;default&#x2F;grub &#x2F;etc&#x2F;default&#x2F;grub.bak\n\n\n\n安装\n安装模块\nsudo make INSTALL_MOD_STRIPE&#x3D;1 modules_install\n\n安装内核 重启\nsudo make install\nsudo reboot\n\n\n\n参考\nUbuntu上增加系统调用（需要编译内核）Peanutty的博客-CSDN博客\nUbuntu20.04下添加自定义系统调用 编程菜玑的博客-CSDN博客\n在Ubuntu下添加系统调用 - 简书 (jianshu.com)\n内核错误: No rule to make target ‘debian/canonical-certs.pem‘, needed by ‘certs/x509_certificate_list‘ Imagine Miracle的博客-CSDN博客\n在Ubuntu 18.04 下编译Linux内核 - 简书 (jianshu.com)\nUbuntu虚拟机扩展磁盘空间 Vis-Lin的博客-CSDN博客\n\n","slug":"IA32e-exception","date":"2023-01-19T04:00:00.000Z","categories_index":"Windows","tags_index":"windows,note,kernel","author_index":"御史神风"},{"id":"a0e830c45ad93252cf7ca59a00282739","title":"VMP还原思路","content":"1 摘要1.1 关于代码优化与还原关于还原，我认为难点是工作量大，需要自动化提升效率\n还原和混淆是一对反义词，相同点是保证代码功能相近，不同是一个是使代码更易读，后者则相反\n而代码优化非常类似，也要保证代码功能相近，不同是减少代码的体积或运行速度\n所以我感觉还原和代码优化有很多共通点\n然后尝试了一下从编译的角度去做自动化还原，这里分享一下思路，算是画一个不太完美的句号吧\n1.2 还原流程我的还原流程简单来说就三步：\n\n识别汇编对应的语义（翻译虚拟机字节码）\n虚拟指令转换成C\n二次编译，利用编译器优化\n\n第三步可以针对性的实现一些优化，因为vmp是一个基于栈的虚拟机，编译器的优化效果有限\n第一步是我做的比较多的一部分，在后面的实现过程会说具体思路\n2 实现过程2.1 Handler语义识别这一步说的是怎么判断Handler对应的虚拟机指令\n2.1.1 浅谈VMP的CFGHandler识别首先绕不开一个问题，怎么找到Handler在哪\n关于VMP 3.X的架构这里简单说一下\n在VMP2中会有一个分发器，所有Handler的地址都存在一个数组中，很容易就能把所有Handler找出来；但到了3，分发方式变成从字节码中解码出下一条指令的地址\n2.1.2 模拟执行输出虚拟指令目前分析到两种跳转方式：\nmov reg&#96;&#96;jmp reg\n\n或\npush reg&#96;&#96;ret\n\n我的思路是模拟执行，遇到jmp reg或者push ; ret时就代表一条Handler已经结束，reg中的是下一条Handler的地址\n所以可以构建一个Handler 虚拟地址到虚拟指令的映射\n模拟执行还有一个好处，对于不同的虚拟指令，在Handler中下断，让Handler自己解密字节码中的内容，然后提取出来\n2.1.3 Handler识别关于Handler的语义是什么就省略了\n根据jmp reg或push ; ret把Handler提取出来后，现在就需要识别其对应的虚拟机指令\n两种思路：\n\n正则表达式匹配（速度块）\nDAG或者数据流图匹配\n\n2.1.3.1 正则匹配这是我目前正在用的方案，对汇编代码使用正则表达式匹配\n矛盾点是正则规则越严格，漏判越严重，规则越宽松，误判越严重\n缓解方案是对汇编代码先进行一次优化，参考编译原理中的死代码消除，对寄存器的使用进行分析\n以一个加法的Handler为例：\n比如优化前的Handler：\n\n其中4、5、10、11行连续对rdi寄存器进行了写入，显然前三条写入是无效的\n优化后的Handler：\n\n正则匹配：\n\n2.1.3.2 DAG匹配这部分只是做一个尝试\n同样是加法的例子，这是其DAG图（不太严格，因为x86复杂指令集有点麻烦）\n蓝色下划线是从栈获取的操作数\n绿色下划线是将结果和RFLAGS放回栈\n\n2.1.4 识别结果模拟执行顺序执行的片段：\n\n2.2 控制流还原2.2.1 虚拟机指令DU分析先分析每条虚拟机指令对栈的读写，然后构建DU链\n接着利用DU链进行一次简单的优化，包括常量传播，折叠一些变量在VM栈和VM寄存器上的移动，还有简单的MBA表达式优化（简化接下来的判断分支等步骤）\n2.2.2 判断是否为分支进行到这里就可以判断是jmp还是jcc\njmp的例子（左边是每条指令起始时VM字节码指针和VM栈指针）：\n\njcc的例子：\n\n区别就是RET之前的一条语句PUSH的是否为一个立即数（依赖前面的常量传播优化）\n2.2.3 获取分支去向接下来就可以通过DU链，获取分支的两条去向分别是什么\n依据是VMP的分支跳转伪代码为：\nmask &#96;&#96;&#x3D;&#96; &#96;-&#96;&#96;1&#96; &#96;+&#96; &#96;flag&#96;&#96;a1 &#96;&#96;&#x3D;&#96; &#96;mask &amp; FAddr&#96;&#96;a2 &#96;&#96;&#x3D;&#96; &#96;~mask &amp; TAddr&#96;&#96;jmp &#96;&#96;&#x3D;&#96; &#96;a1 &#96;&#96;+&#96; &#96;a2\n\n这里是识别的例子：\n\n2.2.4 获取分支条件（未完善）这里我大致分成了两步：\n\n识别判断的rflags标志位\n识别~(~x+y)\n\n一个比较标准的test x-y，然后判断CF的例子\n绿色框是上一步的跳转地址计算\n黄色框是rflags标志位的判断\n红色框是计算x-y的rflags\n\n一个and x, x，判断是否为0的例子\n绿框是上一步的跳转地址计算\n黄框是判断其ZF位\n红框是读取内存，然后获取其and x, x的rflags，没识别到\n\n2.2.5 控制流还原杂谈在前面Handler语义识别的时候，难免会有错漏，出现识别不了的语句\n在模拟执行还原控制流时，妥协做法是停止该分支的分析\n这里截取了一段控制流\n每个圈圈是一个虚拟指令基本块\n这里绿色箭头的是前面flag=1分支、红色箭头是前面flag=0的分支\n红色圈圈的是遇到未知虚拟指令或模拟执行错误，停止分析的块\n\n2.3 还原成C（做的不太好）这一步随便水水了，只做了一部分，主要工作量太大了\n将虚拟指令输出成对应的C语言代码，然后上编译器编译\n给个加法的例子吧：\n\n3 结尾（欢迎指教）3.1 收获比较喜欢写代码吧，vmp代码还原的自动化又是个需要写很多代码的工程，就比较感兴趣，断断续续大学花了不少时间在这上面\n最大的收获是经验吧，写的时候花了很多时间在debug上，实际写的时间根本没多少\n我也明白，先设计好再写代码可以减少很多写代码和debug的时间，但缺乏还原经验，设计的时候无从入手，也考虑不周全，只能边写边想\n算是积累了一些经验吧\n然后实践了一下编译原理的入门知识，一个非常有意思的领域，希望以后有机会继续深入学习下去吧\n3.2 关于分析深度和还原难度在还原的过程中，我发现对虚拟机架构的分析越多，获得更多关于壳的信息，就能写出更容易实现、更有针对性、更有效果的优化\n有点类似窥孔优化的思路，牺牲通用性，以便实现和提高效果\n4 相关链接VMP架构与虚拟机指令：\nVMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering\n虚拟机分支分析：\n[分享]VMP学习笔记之万用门（七）-加壳脱壳-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)\nvmp3.5模拟x86分支指令je、jne、jge和jl的分析-软件逆向-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)\n编译原理（哪本书不记得了）：\n\n基本块的有向无环图表示\nDU链\n\n加密与解密\n","slug":"VMP-deobf","date":"2023-01-11T04:00:00.000Z","categories_index":"Re","tags_index":"re,vmp","author_index":"御史神风"},{"id":"06423ce97f1a4b9a785e5e8bd6e7c6eb","title":"Last Branch Record","content":"Last branch record摘要记录CPU产出的跳转指令，包括call、ret、jmp、中断、异常\n当跳转发生时，会记录跳转指令地址（from）和目的地址（to）\nIA32_DEBUGCTL MSR位于01D9H\nflag：\n\nLBR (last branch/interrupt/exception) flag (bit 0)\n设置该位后，开始记录最近的分支、中断、异常到LBR Stack\n\n\n\nLBR Stack：由n对msr寄存器组成\nLBR Top-of-Stack（TOS）Pointer：指示LBR Stack的栈顶\n文档书签\n\n\n\n\n\n\n\n\nsdm-vol3\n17.4 是概览\n17.4.1 中提到LBR Stack的细节参考 17.5.1、17.9.1（分别对应不同处理器）\n17.9 关于Nehalem微架构\n\n\n\n\n\n\n\n\n\n不同处理器的LBR栈大小：\nsdm-vol-17.4.8 LBR Stack\nTable 17-4. LBR Stack Size and TOS Pointer Range\n\n\n\n\n\n\n\n\n\n不同架构的相关寄存器定义：\nsdm-vol4-2.8，Nehalem微架构，寄存器位置：\n\nIA32_DEBUGCTL 1D9H\nMSR_LASTBRANCH_TOS 1C9H\nMSR_LASTBRANCH_N_FROM_IP\n680H~68FH，16个\nMSR_LASTBRANCH_0_FROM_IP 680H\n\n\nMSR_LASTBRANCH_N_TO_IP\n6C0H~6CFH，16个\nMSR_LASTBRANCH_0_TO_IP 6C0H\n\n\n\nsdm-vol4-2.22，P6 Family\n\nDEBUGCTLMSR 1D9H\nLASTBRANCHFROMIP 1DBH\nLASTBRANCHTOIP 1DCH\n\n示例Nehalem微架构，遍历大小为16的LBR栈：\nunsigned long long fromips[16];\nunsigned long long toips[16];\nfor (int i &#x3D; 0; i &lt; 16; i++)\n    fromips[i] &#x3D; __readmsr(0x680 + i);\nfor (int i &#x3D; 0; i &lt; 16; i++)\n    toips[i] &#x3D; __readmsr(0x6C0 + i);\n\n\n\nNehalem微架构，获取最近的分支记录：\ntos &#x3D; _rdmsr[0x1C9]; &#x2F;&#x2F; MSR_LASTBRANCH_TOS\nlast_from_ip &#x3D; _rdmsr[0x680+tos]; &#x2F;&#x2F; MSR_LASTBRANCH_0_FROM_IP + TOS\nlast_to_ip &#x3D; _rdmsr[0x6C0+tos]; &#x2F;&#x2F; MSR_LASTBRANCH_0_TO_IP + TOS\n\n\n\nFamily 6 获取最近的分支记录：\nlast_from_ip &#x3D; _rdmsr[0x1DB]; &#x2F;&#x2F; LASTBRANCHFROMIP\nlast_to_ip &#x3D; _rdmsr[0x1DC]; &#x2F;&#x2F; LASTBRANCHTOIP\n\n\n\n参考Intel x86_64 LBR &amp; BTS功能_小立爱学习的博客-CSDN博客\n再谈Intel x86_64 LBR功能_小立爱学习的博客-CSDN博客\n(v77)325384-sdm-vol3\n(v77)325384-sdm-vol4\n","slug":"LBR","date":"2023-01-10T04:00:00.000Z","categories_index":"Windows","tags_index":"windows,note,kernel","author_index":"御史神风"},{"id":"771dec62b399749444e273209cdd8e6e","title":"angr-ctf","content":"angr_ctfjakespringer/angr_ctf (github.com)\nangr CTF (oregonctf.org)\nangr符号执行练习 00_angr_find_哔哩哔哩_bilibili\nangr 学习 | SkYe231 Blog (mrskye.cn)\n目录（给出每个level新增或目标知识点）\n\n00 find\n\n01 avoid\n\n02 find condition\n\n03 symbolic registers\n\n指定开始地址\n使用 symbolic bitvector\n给 寄存器 赋 BVS\n\n\n04 symbolic stack\n\n模拟栈空间\npush BVS 到栈上\n\n\n05 symbolic memory\n\n给内存赋 BVS\n字符串转换\n\n\n06 symbolic dynamic memory\n\n简单假内存分配\n\n\n07 symbolic file\n\n构造 symbolic file，用BVS作为数据流\n\n\n08 constraints\n\n剪枝的思路\n添加约束\n\n\n09 hooks\n\nhook 地址（调用位置）\n\n\n10 simprocedures\n\nhook 符号\n\n\n11 sim scanf\n\nglobal插件\n\n\n12 veritesting\n\n13 static binary\n\n使用Angr预先写好的SimProcedures\n\n\n14 shared library\n\n\n00-0506-0910-14\n00 findL52填的是call puts的地址，这是我们想到达的位置\n# L35\npath_to_binary &#x3D; &quot;00_angr_find&quot;  # :string\n\n# L52\nprint_good_address &#x3D; 0x08048694  # :integer (probably in hexadecimal)\n\nF5得到b&#39;JXWVXRKX&#39;\n01 avoid也是找到puts(&quot;Good Job.&quot;)的位置，在函数maybe_good中\n同时avoid_me()这个函数名字就告诉我们是要避免的分支，这个函数会导致一定失败，添加avoid这个函数加速搜索\n# L16-18\nprint_good_address &#x3D; 0x080485E5\nwill_not_succeed_address &#x3D; 0x080485A8\nsimulation.explore(find&#x3D;print_good_address, avoid&#x3D;will_not_succeed_address)\n\nF5得到b&#39;HUJOZMYS&#39;\n02 find condition之前是知道puts(&quot;Good Job.&quot;)的位置，这次假设不知道地址，只知道有这个输出\n（准确的说，之前是找达到call puts的状态；这次是找到标准输出为Good Job.的状态）\n需要注意的是，stdout_output类型是bytes，另外输出里还包括输入提示等字符串\n所以需要用encode和in\n# L24-30\ndef is_successful(state):\n    stdout_output &#x3D; state.posix.dumps(sys.stdout.fileno())\n\treturn &quot;Good Job.&quot;.encode() in stdout_output  # :boolean\n# L36-38\ndef should_abort(state):\n    stdout_output &#x3D; state.posix.dumps(sys.stdout.fileno())\n    return &quot;Try again.&quot;.encode() in stdout_output  # :boolean\n\nF5得到b&#39;HETOBRCU&#39;\n03 symbolic registersAngr 目前不支持用 scanf 读取多个东西（例如：scanf(&quot;%u %u)）在调用 scanf 之后，您必须告诉模拟引擎开始程序，并手动将符号注入寄存器。\n应该在scanf以后开始\n# L17-18\nstart_address &#x3D; 0x08048980  # :integer (probably hexadecimal)\ninitial_state &#x3D; project.factory.blank_state(addr&#x3D;start_address)\n\n\n\n创建 symbolic bitvector\n# L28-33\npassword0_size_in_bits &#x3D; 32  # :integer\npassword0 &#x3D; claripy.BVS(&#39;password0&#39;, password0_size_in_bits)\npassword1_size_in_bits &#x3D; 32  # :integer\npassword1 &#x3D; claripy.BVS(&#39;password1&#39;, password1_size_in_bits)\npassword2_size_in_bits &#x3D; 32  # :integer\npassword2 &#x3D; claripy.BVS(&#39;password2&#39;, password2_size_in_bits)\n\n\n\n设置寄存器为符号值\n# L48-50\ninitial_state.regs.eax &#x3D; password0\ninitial_state.regs.ebx &#x3D; password1\ninitial_state.regs.edx &#x3D; password2\n\n\n\n求解\n# L72-74\nsolution0 &#x3D; solution_state.se.eval(password0)\nsolution1 &#x3D; solution_state.se.eval(password1)\nsolution2 &#x3D; solution_state.se.eval(password2)\n\n\n\nF5得到0xB9FFD04E 0xCCF63FE8 0x8FD4D959\n04 symbolic stack同样是再scanf之后开始，这次scanf的内容被存在栈上\nscanf的调用约定是_cdecl，由调用者传参，所以在调用者平衡栈以后再开始\n# L41\nstart_address &#x3D; 0x08048697\n\n\n\n地址最高（最接近ebp）的局部变量0xC，size为4字节\n# L121\npadding_length_in_bytes &#x3D; 0xC - 4  # :integer\n\n\n\n理论上var_C先于var_10被分配到栈上（高地址、接近ebp先分配）\n调用scanf时，var_C的地址后入栈，函数参数从右到左入栈，所以var_C对应第一个参数pw0\n# L132-133\ninitial_state.stack_push(password0)  # :bitvector (claripy.BVS, claripy.BVV, claripy.BV)\ninitial_state.stack_push(password1)\n\n\n\nF5：1704280884 2382341151\n05 symbolic memory将BVS赋值到内存（angr memory.store默认大端序，需要手动指定为小端序）\n# L24-25\npassword0_address &#x3D; 0x0A1BA1C0\ninitial_state.memory.store(password0_address, password0， endness&#x3D;project.arch.memory_endness)\n\n\n\nbug\n因为python2中str就是字节流，python3中不一样，删掉cast_to=str否则会报错\n需要从 int 转 bytes 转 str\n# L49-50\n# solution0 &#x3D; solution_state.se.eval(password0,cast_to&#x3D;str)\nsolution0 &#x3D; int.to_bytes(solution_state.se.eval(password0), 8, &#39;little&#39;).decode(&quot;utf-8&quot;)\n\n\n\n06 symbolic dynamic memory将BVS赋值到动态分配的内存\n这里提示到上节的问题，Angr默认使用大端序，需要手动指示使用内存序（endness=project.arch.memory_endness），x86的内存序就是小端序\n第一步：填充假堆地址（与05相比多出来的一步）\nfake_heap_address0是在紧挨着extern段之后的位置\n# L27-30\nfake_heap_address0 &#x3D; 0xABCC8E0\npointer_to_malloc_memory_address0 &#x3D; 0x0ABCC8A4\ninitial_state.memory.store(0x0ABCC8A4, fake_heap_address0, endness&#x3D;project.arch.memory_endness)\ninitial_state.memory.store(0x0ABCC8AC, fake_heap_address0 + 8, endness&#x3D;project.arch.memory_endness)\n\n\n\n第二步：填充假输入\n# L35-36\ninitial_state.memory.store(fake_heap_address0, password0, endness&#x3D;project.arch.memory_endness)\ninitial_state.memory.store(fake_heap_address0 + 8, password1, endness&#x3D;project.arch.memory_endness)\n\n\n\nF5UBDKLMBV UNOERNYS\n07 symbolic file题目本意是从文件中读取密码，然后判断是否正确\n为了和别的题目一致，会从控制台读取代码，然后写入文件，这部分应该忽略掉。接下来的代码才是需要分析的，会读取文件并判断是否正确\n显然有许多种解法，而题目本意是学习模拟文件系统，用这种方法去解决\n起始地址应在ignore_me之后（打开文件之前）\n构造symbolic file，用BVS作为数据流（angr.storage.SimFile是大端序）\n# 构造 symbolic file\npassword_file &#x3D; angr.storage.SimFile(filename,\n\tfile_options,\n\tcontent&#x3D;password,\n    size&#x3D;symbolic_file_size_bytes)\n# 写入到状态\ninitial_state.fs.insert(filename, password_file)\n\n\n\n\n\n\n\n\n\n\n\n\nangr 已经不支持angr.state_plugins.SimSymbolicMemory()\n直接向SimFile的content提供BVS即可\n同时SimFile好像不支持file_options参数了，使用会报错\nF5b&#39;AZOMMMZM\\x00，后面还杂数据，不知道什么问题\n08 constraints处理路径爆炸的问题：\n#define REFERENCE_PASSWORD &#x3D; &quot;AABBCCDDEEFFGGHH&quot;;\nint check_equals_AABBCCDDEEFFGGHH(char* to_check, size_t length) &#123;\n    uint32_t num_correct &#x3D; 0;\n    for (int i&#x3D;0; i&lt;length; ++i) &#123;\n        if (to_check[i] &#x3D;&#x3D; REFERENCE_PASSWORD[i]) &#123;\n            num_correct +&#x3D; 1;\n        &#125;\n    &#125;\n    return num_correct &#x3D;&#x3D; length;\n&#125;\n\n\n\n懒得搞了，纯大端序，最后用cast_to=bytes即可得到正确顺序的字符串\n将explore的find改为check_equals_AABBCCDDEEFFGGHH的地址\n以便在比较之前停下来\n然后提取要比较的内容\n# L77-81\nconstrained_parameter_address &#x3D; 0x0804A050 # func arg1 [ebp+8]\nconstrained_parameter_size_bytes &#x3D; 0x10 # func arg2 [ebp+Ch]\nconstrained_parameter_bitvector &#x3D; solution_state.memory.load(\n    constrained_parameter_address,\n    constrained_parameter_size_bytes)\n\n\n\n根据提示，函数名就是比较的目标，也可以动态调试获得\n# L86\nconstrained_parameter_desired_value &#x3D; &quot;AUPDNNPROEZRJWKB&quot; # :string\n\n\n\nF5b&#39;LGCRCDGJHYUNGUJB&#39;\n09 hooks用hook技术，hook调用比较函数的地方，代替前面那个导致路径爆炸的比较函数\n# L26\ncheck_equals_called_address &#x3D; 0x080486B3\n\n# L34-35\n# 需要跳过的指令长度，这里只跳过call，所以是5\ninstruction_to_skip_length &#x3D; 5\n@project.hook(check_equals_called_address, length&#x3D;instruction_to_skip_length)\ndef skip_check_equals_(state):\n    # L40-41\n    user_input_buffer_address &#x3D; 0x0804A054 # :integer, probably hexadecimal\n    user_input_buffer_length &#x3D; 0x10\n\t\n    user_input_string &#x3D; state.memory.load(\n        user_input_buffer_address, \n        user_input_buffer_length\n    )\n    \n    # L55\n    # 静态分析或动态调试获得\n    check_against_string &#x3D; &quot;XYMKBKUHNIQYNQXE&quot; # :string\n\n    state.regs.eax &#x3D; claripy.If(\n        user_input_string &#x3D;&#x3D; check_against_string, \n        claripy.BVV(1, 32), \n        claripy.BVV(0, 32)\n    )\n\n\n\n由angr处理输入，所以直接获取标准输入流\n# L89\nsolution &#x3D; solution_state.posix.dumps(sys.stdin.fileno())\n\n\n\nF5b&#39;ZXIDRXEORJOTFFJNWUFAOUBLOGLQCCGK&#39;\n10 simprocedures用hook技术，这次hook函数开头，而不是调用位置\n定义一个继承自angr.SimProcedure的类，模拟被hook函数功能：\nclass ReplacementCheckEquals(angr.SimProcedure):\n    # L62\n    # 与函数原型一致\n    def run(self, to_check, length):\n        # L66-67\n        user_input_buffer_address &#x3D; to_check\n        user_input_buffer_length &#x3D; length\n\n        user_input_string &#x3D; self.state.memory.load(\n            user_input_buffer_address,\n            user_input_buffer_length\n        )\n\t\t\n        # L76\n        check_against_string &#x3D; &quot;ORSDDWXHZURJRBDH&quot;\n\n        # L81\n        # 返回值\n        return claripy.If(user_input_string &#x3D;&#x3D; check_against_string, claripy.BVV(1, 32), claripy.BVV(0, 32))\n\n\n\nhook check_equals 符号。Angr自动查找与符号相关的地址。或者，你可以使用hook代替hook_symbol并指定函数的地址\n通过hook_symbol，替换目标函数：\ncheck_equals_symbol &#x3D; &quot;check_equals_ORSDDWXHZURJRBDH&quot; # :string\nproject.hook_symbol(check_equals_symbol, ReplacementCheckEquals())\n\n\n\nF5b&#39;MSWKNJNAVTTOZMRY&#39;\n11 sim scanf# class angr.SimProcedure, def run\nself.state.globals[&#39;solution0&#39;] &#x3D; scanf0\nself.state.globals[&#39;solution1&#39;] &#x3D; scanf1\n\nstored_solutions0 &#x3D; solution_state.globals[&#39;solution0&#39;]\nstored_solutions1 &#x3D; solution_state.globals[&#39;solution1&#39;]\n\n\n\nF51448564819 1398294103\n12 veritesting复制11的代码，改一下scanf的模拟函数\n修改创建 simulation manager 代码，开启veritesting\nsimulation &#x3D; project.factory.simgr(initial_state, veritesting&#x3D;True)\n\n\n\nF5b&#39;OQSUWYACEGIKMOQSUWYACEGIKMOQSUWY&#39;\n13 static binary这个挑战与第一个挑战完全相同，只是它被编译为静态二进制文件。通常情况下，Angr会自动用工作更快的simprocedure替换标准库函数。\n下面是一些SimProcedures Angr已经为你写好了。它们实现标准库函数：\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;malloc&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;fopen&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;fclose&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;fwrite&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;getchar&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;strncmp&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;strcmp&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;scanf&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;printf&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;puts&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;exit&#39;]\n# angr.SIM_PROCEDURES[&#39;glibc&#39;][&#39;__libc_start_main&#39;]\n\n# As a reminder, you can hook functions with something similar to:\n# project.hook(malloc_address, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;malloc&#39;]())\n\n\n\n更多：\nhttps://github.com/angr/angr/tree/master/angr/procedures/libc\n复制01的代码，然后添加hook：\nproject.hook(0x08048D10, angr.SIM_PROCEDURES[&#39;glibc&#39;][&#39;__libc_start_main&#39;]())\nproject.hook(0x0804ED40, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;printf&#39;]())\nproject.hook(0x0804ED80, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;scanf&#39;]())\nproject.hook(0x0804F350, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;puts&#39;]())\n\n\n\nF5b&#39;PNMXNMUD&#39;\n14 shared library符号执行so文件\n设置基址：\n# L20-25\nbase &#x3D; 0\nproject &#x3D; angr.Project(path_to_binary, load_options&#x3D;&#123; \n    &#39;main_opts&#39; : &#123; \n        &#39;custom_base_addr&#39; : base \n    &#125; \n&#125;)\n\n\n\n准备从目标函数开始模拟执行，获取其状态：\n# L29-31\npassword_address &#x3D; claripy.BVV(base+0x3000, 32)\npassword &#x3D; claripy.BVS(&#39;password&#39;, 8*8)\npw_size &#x3D; claripy.BVV(8, 32)\n\n# L43-45\nvalidate_function_address &#x3D; base + 0x6D7\ninitial_state &#x3D; project.factory.call_state(validate_function_address, password_address, pw_size)\ninitial_state.memory.store(password_address, password)\n\n\n\n方案一（scaffold14.py）\n在return前hook，添加约束\n# L54-56\n@project.hook(base + 0x77D, length&#x3D;0)\ndef skip_check_equals_(state):\n    state.add_constraints(state.regs.eax !&#x3D; 0)\n\n\n\n方案二（scaffold14_2.py）\n到达return后，添加约束\n# L57-58\nsuccess_address &#x3D; base + 0x783\nsimulation.explore(find&#x3D;success_address)\n\n# L66-67\nsolution_state.add_constraints(solution_state.regs.eax !&#x3D; 0)\nsolution &#x3D; solution_state.se.eval(password, cast_to&#x3D;bytes)\n\n\n\nF5b&#39;PGXSNWTS&#39;\n","slug":"angr-ctf","date":"2022-10-27T04:00:00.000Z","categories_index":"CTF","tags_index":"ctf,re,angr","author_index":"御史神风"},{"id":"dc41c1162c79a34f24cc5f032c462a3c","title":"SFU Compilers class 笔记6","content":"SFU Compilers 笔记 6 语义分析和代码生成2llvm-p hw3 hw4\nPractice LLVM环境如何在不同环境使用makefile：\n\nCSIL Linux机器：make llvmconfig=llvm-config-12 all（似乎是SFU的在线环境）\nmacos或其他：make all\n\n安装下载页面：\nhttp:&#x2F;&#x2F;llvm.org&#x2F;releases&#x2F;download.html\n\nwsl2直接执行以下命令：\napt-get update\napt-get install clang --fix-missing\napt install llvm\n\n\n\nDecaf标准库decaf-stdlib.c：包含Decaf的标准库，包含print_int等函数的实现\ndecaf-stdlib-test.cpp：测试用的C++程序，使用Decaf的标准库\nHello World编译helloword.ll，一个LLVM汇编写的程序：\nllvmconfig&#x3D;llvm-config\nlli_bin&#x3D;&#96;$llvmconfig --bindir&#96;&#x2F;lli\n$lli_bin helloworld.ll\n\n前两行获取lli的路径第3行使用lli 将 LLVM汇编 编译成 可执行文件\n使用Decaf的库函数编译add.ll，并使用Decaf的库函数：（以下命令在run-llvm-code.sh中，makefile中也有）\nllvmconfig&#x3D;llvm-config\n&#96;$llvmconfig --bindir&#96;&#x2F;llvm-as add.ll  # convert LLVM assembly to bitcode\n&#96;$llvmconfig --bindir&#96;&#x2F;llc add.bc   # convert LLVM bitcode to x86 assembly\nclang add.s decaf-stdlib.c -o add \n\n第2行使用LLVM的 llvm-as 将 LLVM汇编 转成 LLVM字节码第3行使用LLVM的 llc 将 字节码 转成 x86汇编第4行使用 clang 将 汇编 转成 机器码（也就是“汇编”）\n递归版加法函数，对应python如下：\ndef rec_add(a, b):\n    if a &#x3D;&#x3D; 0:\n        return b\n    else:\n        return rec_add(a-1, b+1)\n\n给出了框架：\ndefine i32 @add2(i32 %a, i32 %b) &#123;\nentry:\n  %tmp1 &#x3D; icmp eq i32 %a, 0\n  br i1 %tmp1, label %done, label %recurse\nrecurse:\n  ; insert LLVM assembly here  \ndone:\n  ; insert LLVM assembly here\n&#125;\n\nrec_add.ll中是参考答案\n简单递归用LLVM汇编实现阶乘，参考答案在factorial.ll\nLLVM C++ API 简介头文件常用头文件：\nllvm&#x2F;IR&#x2F;DerivedTypes.h\nllvm&#x2F;IR&#x2F;LLVMContext.h\nllvm&#x2F;IR&#x2F;Module.h\nllvm&#x2F;IR&#x2F;Type.h\nllvm&#x2F;IR&#x2F;Verifier.h\nllvm&#x2F;IR&#x2F;IRBuilder.h\n\nIRBuilder.h：包含构建 Decaf 编译器所需的几乎所有功能，返回值都是llvm::Value\n模块&#x2F;&#x2F; this global variable contains all the generated code\nstatic llvm::Module *TheModule;\nstatic llvm::LLVMContext TheContext;\n&#x2F;&#x2F; this is the method used to construct the LLVM intermediate code (IR)\nstatic llvm::IRBuilder&lt;&gt; Builder(TheContext);\n\n生成LLVM汇编：\nTheModule-&gt;print(llvm::errs(), nullptr);\n\n\n\nLLVM::ValueLLVM 中的几乎所有内容，包括类型、常量、函数等，都派生自基类llvm::Value\nLLVM::Type\n\n\n类型\nllvm::Type*\n解释\n\n\n\nvoid\nBuilder.getVoidTy()\njust a void type\n\n\nint\nBuilder.getInt32Ty()\nassume 32 bit integers\n\n\nbool\nBuilder.getInt1Ty()\na one bit integer\n\n\nstring\nBuilder.getInt8PtrTy()\npointer to array of bytes (int8)\n\n\nhelper函数，为每种 Decaf 类型返回正确的 LLVM 类型：\ntypedef enum &#123; voidTy, intTy, boolTy, stringTy, &#125; decafType;\nllvm::Type *getLLVMType(decafType ty) &#123; \n    switch (ty) &#123;\n        case voidTy: return Builder.getVoidTy();\n        case intTy: return Builder.getInt32Ty();\n        case boolTy: return Builder.getInt1Ty();\n        case stringTy: return Builder.getInt8PtrTy(); default: throw runtime_error(&quot;unknown type&quot;);\n    &#125; \n&#125;\n\n\n\nLLVM::Constant初始化为0的常量\n\n\n\n类型\n代码\n\n\n\nint32\nBuilder.getInt32(0)\n\n\nbool\nBuilder.getInt1(0)\n\n\n栈上存储使用栈存储一些对象，比如变量、函数调用参数等（堆需要分配）\n以下API创建一个新位置，返回指向该位置的指针：\n&#x2F;&#x2F; llvm::Type* TYPE\nllvm::AllocaInst *Alloca &#x3D; Builder.CreateAlloca(TYPE, 0, NAME);\n\n使用示例，在栈上创建一个32位整数：\nllvm::AllocaInst *Alloca;\n&#x2F;&#x2F; unlike CreateEntryBlockAlloca the following will\n&#x2F;&#x2F; create the alloca instr at the current insertion point \n&#x2F;&#x2F; rather than at the start of the block\nAlloca &#x3D; llvm::Builder.CreateAlloca(llvm::IntegerType::get(TheContext, 32), 0, &quot;variable_name&quot;);\n\n\n\n当你想给这个位置赋值时，你可以使用Alloca-&gt;getType()访问指向类型 TYPE 的指针\n给变量赋值（lvalue = rvalue）\n&#x2F;&#x2F; 获取rvalue的指针的类型\nconst llvm::PointerType *ptrTy &#x3D; rvalue-&gt;getType()-&gt;getPointerTo();\n&#x2F;&#x2F; 检查lvalue和rvalue的类型是否相等（检查两者的指针）\nptrTy &#x3D;&#x3D; Alloca-&gt;getType()\n&#x2F;&#x2F; 赋值\nllvm::Value *val &#x3D; Builder.CreateStore(rvalue, Alloca);\n\n（Alloca是左值的指针，这里相当于检查type(&amp;rvalue)==type(Alloca)）\n算术和布尔运算比如加法是Builder.CreateAdd\n略\n函数定义函数定义：\nllvm::Type *returnTy;\n&#x2F;&#x2F; assign the correct Type to returnTy\n\nstd::vector&lt;llvm::Type *&gt; args;\n&#x2F;&#x2F; fill up the args vector with types\n\nllvm::Function *func &#x3D; llvm::Function::Create(\n    llvm::FunctionType::get(returnTy, args, false),\n    llvm::Function::ExternalLinkage,\n    Name,\n    TheModule\n);\n\n创建一个基本块来保存函数中的指令：\n&#x2F;&#x2F; Create a new basic block which contains a sequence of LLVM instructions\nllvm::BasicBlock *BB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;entry&quot;, func);\n&#x2F;&#x2F; insert &quot;entry&quot; into symbol table (not used in HW3 but useful in HW4)\n&#x2F;&#x2F; All subsequent calls to IRBuilder will place instructions in this location\nBuilder.SetInsertPoint(BB);\n\n为函数生成代码时需要：\n\n为局部变量创建一个新的符号表\n创建一个基本块BB\nBuilder.SetInsertPoint(BB)\n使用arg_iterator遍历函数参数，并在栈上分配空间\n\n一个参数的写法：\nstring name &#x3D; string(&quot;a&quot;);\nllvm::Function::arg_iterator AI &#x3D; func-&gt;arg_begin();\nAI-&gt;setName(name);\nllvm::AllocaInst *Alloca &#x3D; Builder.CreateAlloca(Builder.getInt32Ty(), nullptr, name.c_str());\n&#x2F;&#x2F; Store the initial value into the alloca.\nBuilder.CreateStore(static_cast&lt;llvm::Value *&gt;(&amp;*AI), Alloca);\n&#x2F;&#x2F; Add to symbol table\nsyms.enter_symtbl(name, Alloca);\n\n遍历写法：\nfor (auto &amp;Arg : func-&gt;args()) &#123;\n  llvm::AllocaInst *Alloca &#x3D; CreateEntryBlockAlloca(func, Arg.getName());\n  &#x2F;&#x2F; Store the initial value into the alloca.\n  Builder.CreateStore(&amp;Arg, Alloca);\n  &#x2F;&#x2F; Add to symbol table\n  syms.enter_symtbl(Arg.getName(), Alloca);\n&#125;\n\n\n\n获取函数信息：\nllvm::BasicBlock *CurBB &#x3D; Builder.GetInsertBlock();\n&#x2F;&#x2F; gives you a link to the current basic block\n\nllvm::Function *func &#x3D; Builder.GetInsertBlock()-&gt;getParent();\n&#x2F;&#x2F; gives you a pointer to the function definition\n\nfunc-&gt;getReturnType()\n&#x2F;&#x2F; gives you the return type of the function\n\n\n\n返回值：\nBuilder.CreateRet(llvm::Value*)\n\n应该通过检测在哪个函数，然后获取其返回值类型，再赋值而不是把返回值类型传递给函数的所有子AST节点（参考上面的获取函数信息）\n初始化返回值：\ntypedef enum &#123; voidTy, intTy, boolTy, stringTy, &#125; decafType;\nllvm::Constant *getZeroInit(decafType ty) &#123; \n    switch (ty) &#123;\n        case intTy: return Builder.getInt32(0);\n        case boolTy: return Builder.getInt1(0);\n        default: throw runtime_error(&quot;unknown type&quot;);\n    &#125; \n&#125;\n\n\n\n\n\n函数调用llvm::Function *call;\n&#x2F;&#x2F; assign this to the pointer to the function to call, \n&#x2F;&#x2F; usually loaded from the symbol table\n\nstd::vector&lt;llvm::Value *&gt; args;\n&#x2F;&#x2F; argvals are the values in the method call, \n&#x2F;&#x2F; e.g. foo(1) would have a vector of size one with value of 1 with type i32.\n\nbool isVoid &#x3D; call-&gt;getReturnType()-&gt;isVoidTy();\nllvm::Value *val &#x3D; Builder.CreateCall(\n    call,\n    args,\n    isVoid ? &quot;&quot; : &quot;calltmp&quot;\n);\n\n\n\n类型提升 booleanllvm::Value *promo &#x3D; Builder.CreateZExt(*i, Builder.getInt32Ty(), &quot;zexttmp&quot;);\n\n\n\n全局字符串llvm::GlobalVariable *GS &#x3D; Builder.CreateGlobalString(s, &quot;globalstring&quot;);\nllvm::Value *stringConst &#x3D; Builder.CreateConstGEP2_32(GS-&gt;getValueType(), GS, 0, 0, &quot;cast&quot;);\n\n\n\n验证验证函数声明\nllvm::verifyFunction(F);\n\n\n\n剩下的（todo）需要hw3\ntodo\n全局变量全局标量\n&#x2F;&#x2F; declare a global variable\nllvm::GlobalVariable *Foo &#x3D; new llvm::GlobalVariable(\n    *TheModule, \n    Builder.getInt32Ty(), \n    false,  &#x2F;&#x2F; variable is mutable\n    llvm::GlobalValue::InternalLinkage, \n    Builder.getInt32(0), \n    &quot;Foo&quot;\n);\n\n&#x2F;&#x2F; use\nllvm::Value *footmp &#x3D; Builder.CreateLoad(Foo, &quot;footmp&quot;);\n\n\n\n全局数组\n定义和标量基本一样，只是类型不同\n&#x2F;&#x2F; array size &#x3D; 10\nllvm::ArrayType *arrayi32 &#x3D; llvm::ArrayType::get(Builder.getInt32Ty(), 10);\n&#x2F;&#x2F; zeroinitalizer: initialize array to all zeroes\nllvm::Constant *zeroInit &#x3D; llvm::Constant::getNullValue(arrayi32);\n&#x2F;&#x2F; declare a global variable\nllvm::GlobalVariable *Foo &#x3D; new llvm::GlobalVariable(*TheModule, arrayi32, false, llvm::GlobalValue::ExternalLinkage, zeroInit, &quot;Foo&quot;);\n\n读写\n&#x2F;&#x2F; access Foo[8]\nllvm::Value *ArrayLoc &#x3D; Builder.CreateStructGEP(arrayi32, Foo, 0, &quot;arrayloc&quot;);\nllvm::Value *Index &#x3D; Builder.getInt32(8);\nllvm::Value *ArrayIndex &#x3D; Builder.CreateGEP(Builder.getInt32Ty(), ArrayLoc, Index, &quot;arrayindex&quot;);\n\n&#x2F;&#x2F; Foo[8] &#x3D; 1\nllvm::Value *ArrayStore &#x3D; Builder.CreateStore(Builder.getInt32(1), ArrayIndex);\n\n&#x2F;&#x2F; Value &#x3D; Foo[8]\nllvm::Value *Value &#x3D; Builder.CreateLoad(ArrayIndex, &quot;loadtmp&quot;);\n\n\n\n获取Array的元素的类型\nllvm::ArrayType *arrayTy &#x3D; (llvm::ArrayType *)GV-&gt;getValueType();\nllvm::Type *Ty &#x3D; arrayTy-&gt;getArrayElementType();\n\n\n\n\n\nllvm::GlobalValue::InternalLinkage 和 ExternalLinkage 区别？\nHomework 3 Expr Codegen前置条件：hw2, llvm-practice\n目录：decafexpr\n修改include\n修改makefile\nyacclib&#x3D;y\nllvmlibs&#x3D;-lz -lncurses -ldl -lpthread -fcxx-exceptions\n\n改为\nyacclib&#x3D;m\nllvmlibs&#x3D;-lm -lncurses -ldl -lpthread -fcxx-exceptions\n\n\n\n挑战目标是实现Decaf语言的变量、简单表达式和函数的代码生成器\n输出是LLVM汇编，然后再编译成二进制文件\n第一步是实现symbol table\n任务 Step 1: 符号表实现一个符号表，跟踪 Decaf 中的变量和方法。\n每个symbol_table对应一个基本块\ntypedef map&lt;string, descriptor*&gt; symbol_table;\ntypedef list&lt;symbol_table &gt; symbol_table_list;\n\n\n\n在HW2的基础上修改AST生成代码，实现符号表\n目录decafsym\nast(hw2) &gt; sym(hw3 step1)\ncp ..&#x2F;decafast&#x2F;answer&#x2F;default-defs.h .&#x2F;answer&#x2F;default-defs.h\ncp ..&#x2F;decafast&#x2F;answer&#x2F;decafast.cc .&#x2F;answer&#x2F;decafsym.cc\ncp ..&#x2F;decafast&#x2F;answer&#x2F;decafast.lex .&#x2F;answer&#x2F;decafsym.lex\ncp ..&#x2F;decafast&#x2F;answer&#x2F;decafast.y .&#x2F;answer&#x2F;decafsym.y\n\n\n\n警告：\n\nclass IdentifierAST\n成员Name暴露了\n\n\nclass TypeAST\n新增了str2\n\n\n\n妈的不做decafsym了：\n\nfunc(a int, b int)，他的顺序和我相反，懒得搞\n要在每次use后面加注释，输出定义在哪行，好麻烦\n\n任务 Step 2:为以下 Decaf 片段提供代码生成器：\n\n算术和布尔表达式\n警告：不要尝试将此作业的布尔表达式短路。\n\n\n函数调用\n函数定义（包括递归函数）\n外部函数（extern func）的声明（所有外部函数都在 decaf-stdlib.c 中定义）\n\n不要为字段（field）声明，即全局变量生成代码\nsym(hw3 step1) &gt; expr(hw3 step2)\ncp ..&#x2F;..&#x2F;decafsym&#x2F;answer&#x2F;default-defs.h .&#x2F;default-defs.h\ncp ..&#x2F;..&#x2F;decafsym&#x2F;answer&#x2F;decafsym.cc .&#x2F;decafexpr.cc\ncp ..&#x2F;..&#x2F;decafsym&#x2F;answer&#x2F;decafsym.lex .&#x2F;decafexpr.lex\ncp ..&#x2F;..&#x2F;decafsym&#x2F;answer&#x2F;decafsym.y .&#x2F;decafexpr.y\n\n\n\n定义域\ndecaf中什么时候会enter_scope（带*表示已经在Codegen中写好）\n\nprogram（root）*\npackage *\nmethod_block *\nblock\n\nWarning\nclass BinaryOpAST\n\tpublic: enum BINARYOP Op;\n\nclass UnaryOpAST\n\tpublic: int Op;\n\t\nclass decafStmtList\n\tpublic: list&lt;decafAST *&gt; stmts;\n\nclass TypeAST\n    public: int Type;\n\ntryCast 返回值可能为null？，调用该函数的地方并没有检测\n    \nclass VariableExprAST\n    总是解引用\n\nclass Method\n    总是在最后添加默认return\n\n\n\n一元二元运算\nValue *L &#x3D; LHS-&gt;Codegen();\nValue *R &#x3D; RHS-&gt;Codegen();\nreturn Builder.CreateAdd(L, R, &quot;addtmp&quot;);\n\n\n\n除法\n\nSDIV：signed \nUDIV：unsigned\nFDIV：float\n\n一元操作\n\nNeg：一元减\nNot：一元非\n\n测试\nclear\nrm decafexpr\nmake decafexpr\ncd ..&#x2F;\npython3 zipout.py -r decafexpr\npython3 check.py -l log.txt\n\n\n\nrm decafexpr; make decafexpr\n.&#x2F;decafexpr &lt; ..&#x2F;testcases&#x2F;dev&#x2F;and.decaf\n\n\n\nHomework 4 Decaf Compiler前置条件：hw3\n目录：decafcomp\n复制decafexpr(hw3)为decafcommp(hw4)：\ncp ..&#x2F;..&#x2F;decafexpr&#x2F;answer&#x2F;decafexpr.cc .&#x2F;decafcomp.cc\ncp ..&#x2F;..&#x2F;decafexpr&#x2F;answer&#x2F;decafexpr.lex .&#x2F;decafcomp.lex\ncp ..&#x2F;..&#x2F;decafexpr&#x2F;answer&#x2F;decafexpr.y .&#x2F;decafcomp.y\n\n并修改include\n修改makefile\nyacclib&#x3D;y\nllvmlibs&#x3D;-lz -lncurses -ldl -lpthread -fcxx-exceptions\n\n改为\nyacclib&#x3D;m\nllvmlibs&#x3D;-lm -lncurses -ldl -lpthread -fcxx-exceptions\n\n\n\n挑战写一个完整的Decaf语言编译器\n任务warning\nVariableExprAST\n没有做类型检查\n因为tAllocaInst和tGlobalVariable\n都是Builder.CreateLoad(Val)\n\nclass FieldSizeAST\n    public: int Size;\n\n\n\n\n\nStep 1: Global Variables即field variables\n全局变量的定义：FieldDeclAST、AssignGlobalVarAST\n数组：（右值）ArrayLocExprAST、（左值）AssignArrayLocAST\nStep 2: Zero initialize all variablesVarDefAST 中在定义后进行0初始化\nStep 3: Control flow and Loops循环AST中会新建一个scope，第一个目的是便于存放BB，用于break、continue\n第二个目的是Condition中可能定义新变量（我不知道decaf支不支持，给出C的例子）\nfor (int i &#x3D; 0; i &lt; 10; i++) j++;\n\n\n\n下面给出对应关系\n\nIfStmtAST\n不需要\n\n\nWhileStmtAST\nloop - continue\nend - break\n\n\nForStmtAST\nnext - continue\nend - break\n\n\n\nStep 4: Short Circuit测试样例\n\nskct：可以静态解决\n\nshort-circuit-bool：只能运行时解决\n\n\n&#x2F;&#x2F; skct\nextern func print_int(int) void;\nextern func print_string(string) void;\n\npackage foo &#123;\n    func foo() bool &#123;\n        print_string(&quot;foo&quot;);\n        return(false);\n    &#125;\n    func main() int &#123;\n        var flag bool;\n        flag &#x3D; true || foo() &amp;&amp; !true;\n        print_int(flag);\n    &#125;\n&#125;\n\n期望输出：1\n我未处理前输出：foo1\n分析\n第11行代码整理如下（优先级：非&gt;与&gt;或）：\nflag &#x3D; true || (foo() &amp;&amp; (!true));\n\n首先，true || any == true，所以flag一定为true\n如果把整个表达式都执行一遍，foo()会输出&quot;foo&quot;，然后输出flag&quot;1&quot;\n但Short Circuit的话，会把||后面的短路掉，foo()不会执行\n短路规则\n\n1 or x == 1、0 or x == x\n\n0 and x == 0、1 and x == x\n\n\n短路思路\n1 编译时短路：\n根据规则，将运算替换成常量。比如将true || a替换为true\n判断变量是否为整数常量，并获取其布尔值：\nllvm::Value *Val\nllvm::ConstantInt *C;\nif ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(Val))) &#123;\n    if(C-&gt;getValue().getBoolValue()) &#123;\n        return Builder.getInt1(true);\n    &#125;\n&#125;\n\n可以先新建两个BB存储L、R的expr，如果优化失败，最后再合并\nauto CurBB &#x3D; Builder.GetInsertBlock();\nauto func &#x3D; CurBB-&gt;getParent();\n&#x2F;&#x2F; ... (gen LBB RBB)\nLBB-&gt;insertInto(func, CurBB);\nRBB-&gt;insertInto(func, CurBB);\nBuilder.SetInsertPoint(CurBB);\nreturn Builder.CreateOr(L, R, &quot;ortmp&quot;);\n\n\n\n2 运行时短路：\n将a || b改写成：\nif (a) &#123;\n\tres &#x3D; true;\n&#125; else if (b) &#123;\n    res &#x3D; true;\n&#125;\n\nif (a) &#123;\n\tres &#x3D; true;\n&#125; else &#123;\n    res &#x3D; b;\n&#125;\n\n将a &amp;&amp; b（等价~(~a || ~b)）改写成：\nif (!a) &#123;\n\tres &#x3D; false;\n&#125; else if (!b) &#123;\n    res &#x3D; false;\n&#125;\n\nif (!a) &#123;\n\tres &#x3D; false;\n&#125; else &#123;\n    res &#x3D; !b;\n&#125;\n\n\n\n缺点：假设a、b是变量，而不是函数调用，那么这个短路显然没有必要\n3 优化（仅思路）：\n思路1：先尝试静态短路，再使用动态短路\n思路2：只使用运行时短路，然后使用常量传播、剪枝等优化，起到静态短路的剪枝效果\n实现1\nif (Op-&gt;Op &#x3D;&#x3D; And) &#123;\n    &#x2F;&#x2F; static short circuit\n    llvm::ConstantInt* C;\n    if ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(L))) &#123;\n        if(!C-&gt;getValue().getBoolValue()) &#123;\n            auto bb &#x3D; llvm::BasicBlock::Create(TheContext);\n            Builder.SetInsertPoint(CurBB);\n            return Builder.getInt1(false);\n        &#125;\n    &#125;\n    if ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(R))) &#123;\n        if(!C-&gt;getValue().getBoolValue()) &#123;\n            Builder.SetInsertPoint(CurBB);\n            return Builder.getInt1(false);\n        &#125;\n    &#125;\n    LBB-&gt;insertInto(func, CurBB);\n    RBB-&gt;insertInto(func, CurBB);\n    Builder.SetInsertPoint(CurBB);\n    return Builder.CreateAnd(L, R, &quot;andtmp&quot;);\n&#125;\n\nif (Op-&gt;Op &#x3D;&#x3D; Or) &#123;\n    &#x2F;&#x2F; static short circuit\n    llvm::ConstantInt* C;\n    if ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(L))) &#123;\n        if(C-&gt;getValue().getBoolValue()) &#123;\n            auto bb &#x3D; llvm::BasicBlock::Create(TheContext);\n            Builder.SetInsertPoint(CurBB);\n            return Builder.getInt1(true);\n        &#125;\n    &#125;\n    if ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(R))) &#123;\n        if(C-&gt;getValue().getBoolValue()) &#123;\n            Builder.SetInsertPoint(CurBB);\n            return Builder.getInt1(true);\n        &#125;\n    &#125;\n    LBB-&gt;insertInto(func, CurBB);\n    RBB-&gt;insertInto(func, CurBB);\n    Builder.SetInsertPoint(CurBB);\n    return Builder.CreateOr(L, R, &quot;ortmp&quot;);\n&#125;\n\n\n\n\n\n实现2\n纯运行时短路\nAnd和Or的区别只有skct BB结尾的CreateCondBr\nif (Op-&gt;Op &#x3D;&#x3D; And) &#123;\n    auto CurBB &#x3D; Builder.GetInsertBlock();\n    auto func &#x3D; CurBB-&gt;getParent();\n    &#x2F;&#x2F; dynamic short circuit\n    auto noskctBB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;noskct&quot;, func);\n    auto endBB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;endskct&quot;, func);\n    &#x2F;&#x2F; cur (skct)\n    auto L &#x3D; LeftValue-&gt;Codegen();\n    auto LBB &#x3D; Builder.GetInsertBlock(); &#x2F;&#x2F; LeftValue codegen maybe create new BB\n    Builder.CreateCondBr(L, noskctBB, endBB);\n    &#x2F;&#x2F; noskct\n    Builder.SetInsertPoint(noskctBB);\n    auto R &#x3D; RightValue-&gt;Codegen();\n    auto RBB &#x3D; Builder.GetInsertBlock(); &#x2F;&#x2F; RightValue codegen maybe create new BB\n    Builder.CreateBr(endBB);\n    &#x2F;&#x2F; endskct\n    Builder.SetInsertPoint(endBB);\n    llvm::PHINode *val &#x3D; Builder.CreatePHI(Builder.getInt1Ty(), 2, &quot;phival&quot;);\n    val-&gt;addIncoming(L, LBB);\n    val-&gt;addIncoming(R, RBB);\n    return val;\n&#125;\n\nif (Op-&gt;Op &#x3D;&#x3D; Or) &#123;\n    auto CurBB &#x3D; Builder.GetInsertBlock();\n    auto func &#x3D; CurBB-&gt;getParent();\n    &#x2F;&#x2F; dynamic short circuit\n    auto noskctBB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;noskct&quot;, func);\n    auto endBB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;endskct&quot;, func);\n    &#x2F;&#x2F; cur (skct)\n    auto L &#x3D; LeftValue-&gt;Codegen();\n    auto LBB &#x3D; Builder.GetInsertBlock(); &#x2F;&#x2F; LeftValue codegen maybe create new BB\n    Builder.CreateCondBr(L, endBB, noskctBB);\n    &#x2F;&#x2F; noskct\n    Builder.SetInsertPoint(noskctBB);\n    auto R &#x3D; RightValue-&gt;Codegen();\n    auto RBB &#x3D; Builder.GetInsertBlock(); &#x2F;&#x2F; RightValue codegen maybe create new BB\n    Builder.CreateBr(endBB);\n    &#x2F;&#x2F; endskct\n    Builder.SetInsertPoint(endBB);\n    llvm::PHINode *val &#x3D; Builder.CreatePHI(Builder.getInt1Ty(), 2, &quot;phival&quot;);\n    val-&gt;addIncoming(L, LBB);\n    val-&gt;addIncoming(R, RBB);\n    return val;\n&#125;\n\n\n\nStep 5: Semantics已实现语法检查\n按在代码中位置排序\n[序号]. “[错误信息]”（[检查位置]）： [描述]\n\n“unknown type”（getLLVMType）：未知变量类型，无法返回对应的llvm::Type\n“unknown type when zero init”（getZeroInit）：该类型不支持零初始化，只支持Int和Bool\n“promoting fail”（tryCast）：类型提升错误，只支持布尔到整型\n“symbol ‘“ + ident +  “‘ not find”（access_symtbl）：没有在符号表中找到\n“no package definition in decaf program”（ProgramAST）：没有Package\n“expect return void, but return something”（ReturnStmtAST）：返回值类型错误\n“expect return something, but return void”（ReturnStmtAST）：返回值类型错误\n“no found symtbl break”（BreakStmtAST）：break失败，可能不在循环语句中\n“no found symtbl continue”（ContinueStmtAST）：continue失败，可能不在循环语句中\n“not a valid lvalue”（AssignVarAST）：左值类型不正确，应为位置，即tAllocaInst或tGlobalVariable\n“lvalue is not glboal array”（AssignArrayLocAST）：左值类型不正确，应为数组tGlobalArray\n“array index should be Integer”（AssignArrayLocAST）：数组下标应为整型\n“too many argments”（MethodCallAST）：传入参数多于函数定义\n“unknown binary op”（BinaryExprAST）：未知二元操作\n“unknown unary op”（UnaryExprAST）：未知一元操作\n“rvalue is not a array”（ArrayLocExprAST）：右值类型不正确，应为数组\n“array index should be Integer”（ArrayLocExprAST）：数组下标应为整型\n\n忽略（不抛出运行时错误）\n\n\n\n\n\n\n\n\n\n该列表参考 Decaf Spec - Decaf Semantics - Type Checking\nSFU Compilers class: Decaf Specification (anoopsarkar.github.io)\n\n算术运算符操作数只能是整型\n逻辑运算符操作数只能是布尔型\n相等运算符操作数类型必须相同\n函数参数应类似于局部变量（已实现）\n与和或运算使用short circuit（已实现）\nIf you have multiple return statements in one block then only the first is used, but the others should still be type checked.\n省略了，写不下去了\n\n注意\ntGlobalVariable对应全局标量，对应llvm中的标量GlobalVariable\ntGlobalArray对应全局数组，对应llvm中的数组GlobalVariable\n测试样例\n\nerr-bool-index：x = xs[true];，数组下标不能为布尔值\nif-scoping：我报错的原因是BlockAST继承自MethodBlockAST\nerr-return-type：类型提升的问题，整型不应该能提升为布尔型\nundefined-return：我把语法错误信息输出到stdout里了\n\nStep 6: Error reporting参考Step5里面的 已实现语法检查 列表\nStep 7: Code optimization (可选)（todo）可选实施以下优化：\n\n将使用堆栈（Alloca）转为使用寄存器（mem2reg）\n简单的peephole优化（instruction combining pass）\nRe-associate expresssions\nEliminate common sub-expressions (GVN)\n简化CFG\n\n可以使用 LLVM opt 工具，该工具执行上述所有优化\n也可以使用 LLVM API FunctionPassManager 实现优化pass，Writing an LLVM Pass — LLVM 16.0.0git documentation\nStep8: Add source-level debug info (可选)（todo）todo\n更正（相对于hw3）BlockAST不再继承自MethodBlockAST\nMethodBlockAST不再新建scope\n现有enter_scope：\n\nProgramAST（root scope）\n\nPackageAST\n\nMethodAST（在BodyCodegen()中）\n\nBlockAST\n\nWhileStmtAST\n\nForStmtAST\n\n\n取消：\n\nMethodBlockAST\n\nIfStmtAST：\n\n\n","slug":"SFU-Compilers-6","date":"2022-09-23T04:00:00.000Z","categories_index":"CS","tags_index":"note,cs,compiler","author_index":"御史神风"},{"id":"40c2cd491a15172739073405816f8de7","title":"SFU Compilers class 笔记5","content":"SFU Compilers 笔记 5 语义分析和代码生成1week8 week9 week10 week11\nWeek 8 Semantics and Runtime SupportSEM1 Scoping语义分析的目标\n\n确保程序有明确意义\n验证前面两步分析中，没有捕获的程序的属性：\n所有变量在使用前声明\n在表达式中使用正确类型\n函数调用具有正确的参数和返回值\n\n\n其次，可能需要收集一些信息以生成代码：\n确定每个标识符（Id）所表示的变量\n构建继承层次结构的内部表示\n跟踪变量的作用域（确定每行代码的域包含哪些变量）\n\n\n\n语义分析的实现\n\n属性语法\n扩充语法规则，在解析期间完成语义分析\nSingle-pass 语义分析\n\n\n递归遍历AST树\n在解析完生成AST树后，遍历AST\n\n\n\n标识符（Name/Identifier）\n\n相同的标识符在程序不同的位置可能指代不同的东西\n\n比如可能是个类名、类型、或是不同的变量等\n\n\n域（scope）\n\n一个实体的域，指的是程序中的一组指向该实体的标识符的位置\n将新变量引入域可能会隐藏旧变量\n\n符号表\n\n将标识符映射到描述符\n语义分析时，不断更新符号表，其中包含域的信息（记录什么在域内）\n典型实现：栈\n基本操作：\npush scope：进入新的域\npop scope：离开域，丢弃（该域的）所有声明\ninsert symbol：添加新标识符到当前域（入栈）\nlookup symbol：寻找某标识符的描述符（从栈顶找第一个具有相同标识符的描述符）\n\n\n\nSpaghetti Stack\n每个栈对应一个域\n每个栈有一个指针，指向上一个域\n寻址标识符时，如果遍历到栈底，则向指针指向的栈顶继续遍历\n\nSingle/Multi-pass 编译\n\nSingle pass编译：\n扫描一次输入，同时完成词法、语法、语义分析和代码生成\nC，C++\n\n\nMulti pass编译：\n需要多次扫描输入\nJava\n\n\n\n有些语言的定义支持Single-Pass，而有些需要Multi-pass\n有些语言比如python则需要动态（在程序运行时）分析作用域\nMulti-pass编译器中的作用域\n\n第一次遍历：解析输入，生成AST\n第二次遍历：遍历AST，获取类的信息\n第三次遍历：遍历AST，做语义分析和代码生成\n\nRuntime SuportActivate Tree，讲控制流受数据流影响（递归函数的例子），讲为什么函数调用要用栈\n栈帧讲的有点乱（纯栈实现调用），好像和传统C的调用约定不一样（可能我没听懂，还是C的舒服）\n后面讲到可以用寄存器优化调用过程（包括栈帧建立）中的变量传递\nsem2 Type Systems（todo）Week 9 Intermediate Representation and SSA FormIR Intermediate RepresentationIR\n前端生成AST，由AST生成IR，由IR生成机器码\nIR独立于编程语言和机器码\n后面讲了一些IR中的概念\n还有条件、循环语句在llvm中的代码思路\nBasic Blocks\n\n基本块（只能）从第一条语句进入，以分支结束\n函数调用将控制流由调用者交给被调用函数\n\nBackpatching\n在处理分支、循环语句的时候，使用类似占位符的机制\n生成一个偏移随机的jmp，待目标地址的代码生成时，再填上jmp的偏移\n表示\n通常用3地址码（op，arg1，arg2，result）\n或三元组（op，arg1，arg2）（指令序号作为隐性result）\nSSA1 Intro to SSA Form\nStatic Single Assignment Form\n\n对每个变量，一处定义（赋值），多处使用\n\n优点\n\n每个变量只有一个定义，更易于数据流分析和优化\n如果变量有N处使用，M处定义（对应N+M条指令），其def-use链大小为（N*M）\nSSA没有降低复杂度，但在定义数量上通常是线性的\n简化了寄存器分配图（reg interference graph）\n\n\n\nWeek 10 Creating SSA FormSSA2 Creating SSA Form讲如何生成 使用phi函数最少的 SSA Form的 中间代码\nSSA Form\n\nSSA生成算法：\n原始算法，by Cytron et al. 1986（这节课讲的）\nLengauer-Tarjan（龙书讲的）\nHarel\n\n\n\n转换为SSA格式\n\n简单思想：在每个join point添加每个变量的phi函数\njoin point：指CFG中，拥有不只一个前驱的节点\nphi函数：（IR中的内容），决定某个变量来源于哪一个前驱\n重点：存在浪费（其实不是每个变量都需要添加）\n\n支配关系（的定义）\n（大写字母表示CFG中的一个节点，或者BB）\n\nX 支配 Y：从起点到Y，必须经过X；换而言之，X必要的影响着Y\nD(X)：X 严格支配的节点的集合\nX 严格支配 Y：X 支配 Y，且 X 不等于 Y\n\n\n支配的属性\n\nSSA form的最根本的属性是：变量的定义 必须支配 变量的使用：\n如果a 通过phi函数 在X中使用，则定义a的块 支配X的前驱\n如果a 不通过phi函数 在X中使用，则定义a的块 支配X\n\n\n\n重点是：a在X定义，若 X 支配 Y，在Y中可以直接使用a，不需要phi\n支配前沿\n\nDominance Frontier，DF(X)是任意Y的集合：\nX支配Y的前驱，X不严格支配Y\n\n\n\n（S(X)：X的后继的集合）\n简单计算DF的方法：\ndef DominanceFrontier(X):\n\tD_X &#x3D; Dominance(X)\n    # 1\n    DF_X &#x3D; Successor(X) - D_X\n    # 2.1\n    for Y in D:\n        DF_X |&#x3D; Successor(Y)\n    # 2.2\n    DF_X -&#x3D; D\n    return DF_X\n\n\n动态计算DF的方法：\ndef DominanceFrontier(X):\n    if X in DF:\n        return DF[X]\n    \n    D_X &#x3D; Dominance(X)\n    # Local(X)\n    Local_X &#x3D; Successor(X) - D_X\n    # Up(X)\n    Up_X &#x3D; set()\n    for K in D_X:\n        Up_X |&#x3D; DF(K) - D_X\n    # DF(X)\n    DF_X &#x3D; Local_X | Up_X\n    DF[X] &#x3D; DF_X\n    return DF_X\n\n\n\n\n若 X 中定义 a，DF(X) 中若使用 a，必须用phi定义一个新的a\n\n我的理解是：若 Y 属于 DF(X)，则必须用phi定义一个新的a，以供Y和Y的后继使用\nSSA3 Creating SSA Form上一课的延续，举了一些计算D()、DF()、插入phi的例子\n转换为SSA Form\n支配关系是嵌套的，可以表示为一棵树\n（如果A支配B、B支配C，意味着起点到C一定经过B，而起点到B又一定经过A，所以起点到C必然先经过A，然后再经过B）\n\n转换过程（下图中DF(2) = {2}）\n\nWeek 11 Register Allocation and Code OptimizationOPT1 Register Allocation（todo）- c_def\n+ c_use\n+ l_def\n\n\n\n\n\nOPT2 Spilling in Register Allocation（todo）def-&gt;store\nload-&gt;use\n有个可以3色的算成4色\nOPT3 Linear Scan Register Allocation（todo）OPT4 Intro to Code Optimization（todo）advanced compiler design and implement\n","slug":"SFU-Compilers-5","date":"2022-09-19T04:00:00.000Z","categories_index":"CS","tags_index":"note,cs,compiler","author_index":"御史神风"},{"id":"4f7d6d0fadf06b2d208599f31c49d097","title":"SFU Compilers class 笔记4","content":"SFU Compilers 笔记 4 语法分析2week7 hw2\nWeek 7 Syntax Directed TranslationLR6 Syntax Directed Translation for LR Parsers语法导向翻译（SDT）用于将解析树（Parse trees）转成中间代码（IR）\n个人感觉实际上就是讲了yacc中的属性语法的原理和作用\n属性语法\n\n语法导向翻译 使用语法生成代码\n使用上下文无关语法（CFG）\n每个语法符号与一个属性关联\n属性可以是字符串、数字、树等对象\n属性语法将字符串与属性关联起来\nAttribute grammars are a method to decorate or annotate the parse tree with the desired output attributes  我的理解是：属性语法是解析树上的“装饰器”，随解析树的生成被调用；目的是为了利用解析树，构建我们所需的输出。\n\nDecaf and LLVM主要讲LLVM的一些基础概念，感觉讲的不完全\nControl Flow in LLVM hw3不需要，hw4需要\nHomework 2 Parser for Decaf前置条件：yacc-practice\n目录：decafast\n复制default为decafast：\ncp default.cc decafast.cc\ncp default.lex decafast.lex\ncp default.y decafast.y\n\n\n\n并修改三个文件中的include：\n\n\n\n\n\n\n\n\n\ndecafast.cc ： #include &quot;default.tab.h&quot; 改为 #include &quot;decafast.tab.h&quot;\ndecafast.lex ： #include &quot;default.tab.h&quot; 改为 #include &quot;decafast.tab.h&quot;.\ndecafast.y ： #include &quot;default.cc&quot; 改为 #include &quot;decafast.cc&quot;\nwsl2平台下需要修改makefile：\n不需要yacclib=y以及-l$(yacclib)\n去掉或将其改为l或m\n\nvar a, b int;\n\nop\n\nreturn ()，AST等价于return，但yyparse的返回值为1\n\nVarDecls，在statement中间有VarDecls，AST等价于将定义放在statement前面，但yyparse的返回值为1\n\n\n","slug":"SFU-Compilers-4","date":"2022-07-29T04:00:00.000Z","categories_index":"CS","tags_index":"note,cs,compiler","author_index":"御史神风"},{"id":"6b5e22753329d2c346dcd0a78d93034d","title":"B站x64内核笔记2 PG","content":"PatchGuardStep 1 设 BigPool 不可执行编写一个驱动，遍历BigPool信息，将可疑的BigPool设置为不可执行，等待蓝屏\n然后分析蓝屏信息得到context入口点，简要分析context入口点\n1 查询所有BigPool使用ZwQuerySystemInformation获取所有BigPool的信息\n细节：申请长度要比第一次查询长度大\n第一次查询获取长度，第二次查询获取数据。\n因为第二次查询时分配的用于接收的空间也属于BigPool，也就说第二次查询时BigPool的数量可能比第一次的要多，除此以外也可能有新生成的。\n关键查询代码：\n&#x2F;&#x2F; 获取数据长度\nstatus &#x3D; ZwQuerySystemInformation(SystemBigPoolInformation, pBigPoolInfo, sizeof(SYSTEM_BIGPOOL_INFORMATION), &amp;returnLength);\n&#x2F;&#x2F; 申请空间\npBigPoolInfo &#x3D;     (PSYSTEM_BIGPOOL_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, returnLength + 0x1000, &#39;tag&#39;);\n&#x2F;&#x2F; 获取数据\nZwQuerySystemInformation(SystemBigPoolInformation, pBigPoolInfo, returnLength + 0x1000, &amp;returnLength);\n\n\n\n2 设置BigPool不可执行（触发蓝屏）需要获取BigPool起始地址的pte、pde，检查其属性\n检查内容：\n\nBigPool长度\npde为4K页面（0x80 = 0）\npte不是noExec（64位 = 0）\npte页面存在（1位 = 1）\n\n关键判断代码：\nif (entry-&gt;SizeInBytes &gt;&#x3D; 0x8000) &#123;\n    if (!(pde &amp; 0x80)) &#123; &#x2F;&#x2F; 4K page\n        &#x2F;&#x2F; bitmap, 1:p, 64:noExec\n        if (((pte &amp; 0x8000000000000000) &#x3D;&#x3D; 0) &amp;&amp; (pte &amp; 1)) &#123;\n            &#x2F;&#x2F; 2.2 Set NoExec\n            count +&#x3D; 1;\n            KdPrint((&quot;[PG] va: 0x%llX size: 0x%X pte: 0x%llX\\n&quot;, va, entry-&gt;SizeInBytes, pte));\n            pte |&#x3D; 0x8000000000000000;\n            *ppte |&#x3D; pte;\n        &#125;\n    &#125;\n&#125;\n\n\n\n！！！最后记得释放ExFreePool(pBigPoolInfo)\n3 分析执行异常蓝屏（0xFC）首先记得设置好dump，拍摄快照，然后运行驱动，2分钟左右会触发蓝屏，使用windbg分析\n驱动调试信息如下：\n[PG] returnLength: 0x31A48\n[PG] returnLength: 0x31A60\n[PG] va: 0xFFFF8585AF113001 size: 0x6F000\n[PG] va: 0xFFFF8585B65AC001 size: 0x33000\n[PG] va: 0xFFFF8585AF182001 size: 0x43000\n\n首先驱动输出了两次查询的数据长度\n然后输出了符合条件的BigPool的信息，可以看到设置了三个BigPool起始4k页面不可执行，其中第二个是BigPool信息那个数组。剩下两个可能是context。\nwindbg的!analyze -v截取结果如下：\nATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY (fc)\n\nArguments:\nArg1: ffff8585af1821fe, Virtual address for the attempted execute.\nArg2: 8a0000000405d963, PTE contents.\nArg3: fffff80105eb39e0, (reserved)\nArg4: 0000000000000000, (reserved)\n\n错误为尝试执行NoExec的内存，然后看Arg1，确定就是由前面第3个被设为不可执行的BigPool触发的\n反汇编该地址（顺便给出运行到该地址时的RCX、RDX）：\nrcx&#x3D;ffff8585af1821fe rdx&#x3D;51ba0dd28a51cdb8\n\nkd&gt; u ffff8585af1821fe\nffff8585&#96;af1821fe 2e483111        xor     qword ptr cs:[rcx],rdx\nffff8585&#96;af182202 9a              ???\nffff8585&#96;af182203 3ceb            cmp     al,0EBh\nffff8585&#96;af182205 59              pop     rcx\n\n这是一段自解密代码，搜索1131482Eh能找到其原本（这段是其加密后的副本），微软给的名称为CmpAppendDllSection，ntoskrnl.exe中的是异或加密前的内容\n4 调试恢复快照，连上windbg，迅速在刚刚Arg1的地方下一个断点，再等两分钟（这次别运行驱动，让他能够正常执行）\nsmc代码解密完自身以后，会解密其余部分：\nffff8585&#96;af18227d 483184cac0000000 xor     qword ptr [rdx+rcx*8+0C0h],rax\nffff8585&#96;af182285 48d3c8          ror     rax,cl\nffff8585&#96;af182288 480fbbc0        btc     rax,rax\nffff8585&#96;af18228c e2ef            loop    ffff8585&#96;af18227d\n\n\n\n解密完其余部分后，会执行call rax，一般都会去到同一个函数，能在ntoskrnl.exe中的INITKDBG段搜到其原本，有人称之为PG入口点\n下面是其开头的汇编，有点普通，建议往下再跟一点然后再去搜\nkd&gt; p\nffff8585&#96;af18229b ffd0            call    rax\nkd&gt; r rax\nrax&#x3D;ffff8585af19c55f\nkd&gt; u ffff8585af19c55f\nffff8585&#96;af19c55f 488bc4          mov     rax,rsp\nffff8585&#96;af19c562 48895808        mov     qword ptr [rax+8],rbx\nffff8585&#96;af19c566 48897018        mov     qword ptr [rax+18h],rsi\nffff8585&#96;af19c56a 48897820        mov     qword ptr [rax+20h],rdi\nffff8585&#96;af19c56e 48895010        mov     qword ptr [rax+10h],rdx\nffff8585&#96;af19c572 55              push    rbp\nffff8585&#96;af19c573 4154            push    r12\nffff8585&#96;af19c575 4155            push    r13\n; ...\nffff8585&#96;af19c5cc 740b            je      ffff8585&#96;af19c5d9\nffff8585&#96;af19c5ce 448838          mov     byte ptr [rax],r15b\nffff8585&#96;af19c5d1 4903c4          add     rax,r12\nffff8585&#96;af19c5d4 83c1ff          add     ecx,0FFFFFFFFh\n\n\n\n更进一步（分析调用源）\n刚触发断点的时候，可以尝试栈回溯，找到调用源\nStep 2 接管页面异常1 接管页面异常接管页面异常，具体hook的方法八仙过海了，然后根据前面分析结果，context入口一般为1131482Eh这句自解密代码，以此为判断标准，决定是否接管\n简述页面异常\n处理页面异常的是0xE号中断，似乎是因为内核隔离，idt的0xE号中断对应为KiPageFaultShadow，这个函数只是个Stub，做切换cr3等工作，然后jmp（不是call）到KiPageFault\n所以直接hookKiPageFault，比较省事\n给出刚进入KiPageFault时的栈：\n\n\n\nrsp offset(hex)\narg\n\n\n\n00\nerror code\n\n\n08\nrip\n\n\n10\ncs\n\n\n18\nrflags\n\n\n20\nrsp（原rsp）\n\n\n28\nss（r0触发异常一般是一样的）\n\n\n+8\nAlign（保证当前rsp16位对齐）\n\n\n+8\n返回地址（原rsp指向）\n\n\n判断标准\n前面说了，根据目前分析的结果，满足一下条件就接管：\n\nerror code == 11h（10h执行异常 + 1页面存在）\n[rip] == 1131482Eh （smc代码开头）\n\n接管处理\n直接恢复rflags、ss、rip，然后直接return（恢复rsp后，rsp就指向原返回地址了）\n细节\n注意栈的平衡，还有寄存器的使用。如果需要用到寄存器，建议先push。然后在还原rsp前pop，还原寄存器\n2 加速蓝屏（由PG检查引发的）Step1设置BigPool不可执行后，可能会有漏网之鱼。比如context是在Step1以后创建的；或者context原本就不在BigPool；或者Context在Step1时不可执行，执行前再设为可执行\n所以需要hook关键内存（PG频繁检查的地方），让漏网之鱼检查出现异常，然后触发蓝屏\n重启虚拟机，拍一个新快照：\n\n重启时不选择调试模式等，正常启动即可\n用DSEFix（hfiref0x/DSEFix(github.com)）加载未签名驱动\n设置休眠时间为从不\n不要附加调试器\n拍摄快照\n\n驱动新增如下功能：\n\n驱动hook memmove\n\n其中使用DSE Fix和hook memmove都会加速蓝屏（PG错误）\n然后运行DSE Fix，加载驱动，等蓝屏\n获取NT_Base小技巧：先按上述步骤，加载驱动后马上蓝屏，因为重启后NT_Base变了，此时可以分析蓝屏文件获取BASE、或者系统函数的地址；修复函数的地址后，再恢复快照加载驱动，等PG蓝屏\n3 分析PG蓝屏（0x109）我这里大概两分钟左右会触发蓝屏\n因为非调试模式没有办法在windbg中接收驱动的调试信息，然后又懒得在虚拟机中把log信息保存成文件，这里只记录了dump文件的信息\nPG蓝屏\nwindbg的!analyze -v截取结果如下：\nCRITICAL_STRUCTURE_CORRUPTION (109)\n\nArguments:\nArg1: a39feeda0d18b86d, Reserved\nArg2: b3b6fb605f96f9a5, Reserved\nArg3: fffff8072d821cc0, Failure type dependent information\nArg4: 0000000000000000\n\n109错误代表由PG错误；即context被调用，然后检查出被patch，接着触发蓝屏\n先看Arg3：\nkd&gt; u fffff8072d821cc0\nnt!memcpy:\nfffff807&#96;2d821cc0 488bc1          mov     rax,rcx\n\nArg3是PG或者说context发现被patch的地址\n正是我的驱动为了加速蓝屏所hook的memcpy，此时该函数已经被PG还原\nArg1、Arg2需要减去两个魔数：\nArg1: a39feeda0d18b86d - A3A03F5891C8B4E8 &#x3D; ffffaf81&#96;7b500385\nArg2: b3b6fb605f96f9a5 - B3B74BDEE4453415 &#x3D; ffffaf81&#96;7b51c590\n\n\n\n先分析解密后的Arg1：\nkd&gt; u ffffaf81&#96;7b500385\nffffaf81&#96;7b500385 2e483111        xor     qword ptr cs:[rcx],rdx\nffffaf81&#96;7b500389 48315108        xor     qword ptr [rcx+8],rdx\nffffaf81&#96;7b50038d 48315110        xor     qword ptr [rcx+10h],rdx\nffffaf81&#96;7b500391 48315118        xor     qword ptr [rcx+18h],rdx\n\nArg1是context的smc起始地址\n然后截取一部分Arg2：\nkd&gt; dqs ffffaf81&#96;7b51c590\nffffaf81&#96;7b51c590  00000000&#96;00000000\nffffaf81&#96;7b51c598  fffff807&#96;2d821cc0 nt!memcpy ; 检测地址\nffffaf81&#96;7b51c5a0  52802a0c&#96;000002aa ; 检测0x2aa个字节，结果为52802a0c\nffffaf81&#96;7b51c5a8  00000000&#96;00000001\nffffaf81&#96;7b51c5b0  00000000&#96;00000000\nffffaf81&#96;7b51c5b8  00000000&#96;00000000\n\nArg2指向一个结构体数组的某一项，这个结构体数组记录了要检测的内容，此时Arg2指向数组中检查出错的那一项\n\n+8h(PVOID)：是校验的地址，对应前面的memcpy的起始地址\n+10h(UINT)：是校验的长度（以校验地址为起始）\n+14h(UINT)：是校验的结果\n\nPG会对校验地址处的数据执行一些运算，然后与校验结果比较判断是否被patch\n非Big Pool地址\n现在问题是Arg1所指向的地址，没有被设置为不可执行\n发现不是Big Pool：\nkd&gt; !pool ffffaf81&#96;7b500385\nPool page ffffaf817b500385 region is Unknown\n\n发现在一片SystemRange中：\nkd&gt; !address ffffaf81&#96;7b500385\nUsage:                  \nBase Address:           ffff8000&#96;00000000\nEnd Address:            ffffc20b&#96;9fa00000\nRegion Size:            0000420b&#96;9fa00000\nVA Type:                SystemRange\n\n\n\n4 IndependentPages通过资料可知有如下API可以分配、修改、释放一片内存，且该内存不在Big Pool中\n\nMmAllocateIndependentPages\n分配内存，初始属性为不可执行\n\n\nSetPageProtection\n设置内存属性\n\n\nMmFreeIndependentPages\n释放内存\n\n\n\n通过对MmAllocateIndependentPagesEx交叉引用分析，可以发现该函数只被context的那个巨大函数所使用，顺便能找出一整套内存分配释放的函数，这几个函数都只被PG调用：\nINIT:FFFFF80103E1ED3D 48 8D 05 BC E4 D2 FF                    lea     rax, MmAllocateIndependentPages\nINIT:FFFFF80103E1ED44 49 89 86 20 02 00 00                    mov     [r14+220h], rax\nINIT:FFFFF80103E1ED4B 48 8D 05 EE 01 D3 FF                    lea     rax, MmFreeIndependentPages\nINIT:FFFFF80103E1ED52 49 89 86 28 02 00 00                    mov     [r14+228h], rax\nINIT:FFFFF80103E1ED59 48 8D 05 80 9F 95 FF                    lea     rax, MmSetPageProtection\nINIT:FFFFF80103E1ED60 49 89 86 30 02 00 00                    mov     [r14+230h], rax\n\n\n\n网上只找到MmAllocateIndependentPages的定义（MmAllocateIndependentPages (codewarrior.cn)）：\nPVOID\nMmAllocateIndependentPages(\n  IN  SIZE_T NumberOfBytes,\n  IN  ULONG Node\n  );\n\n该函数分配的内存为不可执行，也就是需要调用SetPageProtection后才能执行\n这就意味如果要拦截新生成的context，可以只hook修改属性的SetPageProtection\nStep 3 设置 Ind. Page 不可执行1 搜索 Ind. Page现在先拦截已经分配了的context，思路和BigPool类似，也是找大页面，然后设第一个4k页面为不可执行\n因为没有查询的API，所以只能一块一块暴力搜索，如果相邻的两块页面都是存在的，则当成是一起的，以此来判断其大小。这样可能会杀错，但不容易错过（他context总不能分开到两块不相邻的地址空间吧）\n1? 换页问题不确定Ind. Page会不会被换出，换出pte.valid似乎就为0了，就会漏掉；拦截换入可能需要修改页面异常的处理\n2 测试结果（非调式都用了DSEfix）\n没VT、非调试\n测试了一个快照（刚开机），两个小时没错误\n没VT、调试\n换成调试模式，挂windbg，u了一下MmAllocateIndependentPages，全是问号，页面不存在\n有VT、非调试\n测试了一个快照（刚开机），两个小时没错误\n有VT、调试\n测试了一个快照（刚开机），1分钟左右炸了，死机，不关机也不蓝屏\n详情见下面错误分析\n3 错误分析环境：开启VT + 调试模式过1分钟左右会卡住不动，没有蓝屏、没有关机（连不连调试器都一样）\n截取连调试器后，蓝屏前的log：\n*** Fatal System Error: 0x00000109\n                       (0xA3A024E0D7EF077A,0xB3B731672A6D48B2,0xFFFFF80459416CC0,0x0000000000000000)\n\n解密Arg1、2：\n0xA3A024E0D7EF077A - 0xA3A03F5891C8B4E8 &#x3D; 0xFFFFE58846265292\n0xB3B731672A6D48B2 - 0xB3B74BDEE4453415 &#x3D; 0xFFFFE5884628149D\n0xFFFFF80459416CC0 !memcpy\n\narg1应该是smc起始地址，离之前设为NX的bigpool很近，猜测是个bigpool，但没有被设为NX，可能搜索后分配的或者搜索后设为可执行的\n（这里windbg也卡住了，没办法判断这个地址是什么）\narg3应该是校验发现被patch的地址，通过log发现是为了加速蓝屏hook的memcpy\nStep 4 接管内存分配、属性设置由上面错误可知可能是新big pool，或后来被设为可执行的\n所以顺便把Big Pool的分配，Ind. Page的属性设置都hook上\n","slug":"zh-patchguard","date":"2022-07-06T04:00:00.000Z","categories_index":"Windows","tags_index":"windows,note,kernel","author_index":"御史神风"},{"id":"368d5d02963b1ddd739fe7288ce34859","title":"B站x64内核笔记1","content":"IA_32eExtended Feature Enable Register（IA32_EFER，MSR[0xC0000080]）\n\n\n\n\n\n\n\n\n\nvol-3a p69 2.2.1 Extended Feature Enable Register\n![](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-2-4 IA32_EFER MSR Layout.png)第8位为1 就处于IA-32e模式\n[windbg]rdmsr C0000080\nGDTx64 CS描述符\n\n\n\n\n\n\n\n\n\nvol-3a p161 5.2.1 Code-Segment Descriptor in 64-bit Mode\n![](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-5-2 Descriptor Fields with Flags used in IA-32e Mode.png)\n第12位（S）：1=DS/CS\n第11位（Type的第3位）：0=DS，1=CS\n当处于IA-32e模式：\n\n\n\nCS.D(22)\nCS.L(21)\nbit\n\n\n\n0\n0\n16\n\n\n1\n0\n32\n\n\n0\n1\n64\n\n\n1\n1\n#GP fault\n\n\ngdt\n段选择子（清掉低3位）刚好是相对gdtr的偏移\nD L(G,D,L,AVL)，DPL(P,DPL, 1) ，Type(1,C,R,A)\n\n\n\n段选择子\nindex\nD L\nDPL\nType\nFlags\n\n\n\n10\n2\nx64(0010)\nR0(1001)\nCode(1011)\n29b\n\n\n18\n3\n\nR0(1001)\nData(0011)\n493\n\n\n20\n4\nx32(1100)\nR3(1111)\nCode(1011)\ncfb\n\n\n28\n5\n\nR3(1111)\nData(0011)\ncf3\n\n\n30\n6\nx64(0010)\nR3(1111)\nCode(1011)\n2fb\n\n\n38\n7\nNULL\nNULL\nNULL\nNULL\n\n\n[gdtr+0x40] = TSS\n对比x32的描述符\ncs、ds使用64位描述符，强制平坦（段描述符基址永远是0，界限永远是最大）\n32位的基址、界限等信息在64位中不再保留\n[windbg]dq gdtr\n[windbg]dg [off]：解析gdtf+off处的描述符（按64位解析）\ntss段描述符 和 tss\n\n\n\n\n\n\n\n\n\nvol-3a p256 7.2.3 TSS Descriptor in 64-bit mode\n![](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-7-4 Format of TSS and LDT Descriptors in 64-bit Mode.png)\ntss段描述符拓展到128位\n![](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-7-11 64-Bit TSS Format.png)\nIDTx64 IDT\n\n\n\n\n\n\n\n\n\nvol-3a p211 6.14.1 64-Bit Mode IDT\n![](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-6-8 64-Bit IDT Gate Descriptors.png)\n中断描述符拓展到128位\nidt表项的ist项选择使用tss中哪个rsp比如idt-&gt;ist=1，使用的是rsp=tss.ist1\n[windbg]idt：查看所有中断\n[windbg]dq idtr：查看中断描述符表idt\n切换r3进r0\nIA32_FS_BASE MSR[0xC0000100]\nIA32_GS_BASE MSR[0xC0000101]，当前GS（R3指向teb、R0指向kprc）\nIA32_KERNEL_GS_BASE MSR[0xC0000102]，（R3指向kprc、R0指向teb）\ngs r3指向teb，r0切换为kprc，swapgs，切换IA32_GS_BASE 和IA32_KERNEL_GS_BASE\n系统调用\n\nx64内核\nx64程序 syscall sysret\nx32程序 r3转64\n\n\nx32内核\nsysentry\n\n\n\nx32转x64\nntdll的切换方式（系统调用时）：改变cs\nx32切换cs，0x0023（x32_R3_Code）变0x0033（x64_R3_Code）\njmp far 33:00000000 ; (7) EA 00000000 3300\n\nx64回x32（tword 10字节）\n; tword ptr [rax] &#x3D; 00000000 00000000 2300\njmp far tword ptr ds:[rax] ; (3) 48 FF28\n\n\n\nwin10 x32程序会初始化r15、r14、r13，在切换到x64后（进入r0之前）使用\nx32程序可以在r12等切换不会用到的x64寄存器中藏数据\nSMEP和SMAP三重错误会直接关机，不会蓝屏，也不会被windbg捕获\ncr4标志位\n[20] SMEP：r0不能执行r3代码页\n[21] SMAP：r0不能读写r3内存页\n可以通过修改cr4关闭这两个保护，也可以通过汇编指令绕过SMAP(内核int3中断例程的做法)：\nstac作用是设置RFLAGS的AC标志，使得r0可以读写r3\nclac清楚AC标志\nstac ; 0f 01 CB\n\n此时(中断进r0，执行r3代码页)可以读写r0的：GDT、IDT、KVASCODE\n读写r0其他的节会三重异常\n分页（pass）参照别的笔记\nKPTI视频的实验结果：\n刚进int例程时打印的，exe的user cr3=4windbg看到的r3程序的，exe的kernel cr3=2，对r3代码页pml4e没有可执行标志\n使用cr3=4，转换(ntoskrnl.exe)KVASCODE的地址，能得到正确结果使用cr3=4，转换(ntoskrnl.exe).text，pde=0使用cr3=2，转换(ntoskrnl.exe).text，能得到正确结果\n导致r0下不能执行r3代码的两个机制：\n\n开启smep，r0权限不能执行r3代码页\n切换到kernel的cr3，默认对r3代码页没有可执行标志（user cr3没有映射完整的内核）\n\nuser cr3映射的区域：user space(RWE)、KVASCODE(RE)、GDT/IDT(RW)\nkernel cr3映射的区域：user space(没有E)、完整kernel space\nsymbol type viewer可以把pdg转成.h，ida中可以prase c解析.h的结构体\n硬件漏洞 CFG幽灵熔断\n乱序执行对应的利用即为 Meltdown（熔断） ，而预测执行对应的利用即为 Spectre（幽灵）\nlfence指令\n保证读操作串行化\nKiBreapPoint中的补丁代码：\n; ...\n0x00000000   4                 4883c408  add rsp, 8\n0x00000004   5               e8eeffffff  call 0xfffffffffffffff7\n0x00000009   4                 4883c408  add rsp, 8\n0x0000000d   5               e8eeffffff  call 0\n0x00000012   4                 4883c408  add rsp, 8\n0x00000016   5               e8eeffffff  call 9\n0x0000001b   4                 4883c408  add rsp, 8\n0x0000001f   5               e8eeffffff  call 0x12\n; ...\n0x????????                     4883c408  add rsp, 8\n\nadd rsp相当于pop，连续的pop call，使rip上移，最后一个call会去到最下面，整段nop掉不会影响结果，只是用来修补硬件漏洞\n控制流保护（CFG）\ncall _guard_dispatch_icall 等价于call rax\n","slug":"zh-x64krnl","date":"2022-05-17T04:00:00.000Z","categories_index":"Windows","tags_index":"windows,note,kernel","author_index":"御史神风"},{"id":"a1035c3663b3c14e4c1a5b534fff7e3d","title":"SFU Compilers class 笔记3","content":"SFU Compilers 笔记 3 语法分析1week4 p:yacc week5 week6\nWeek 4 Context-Free Grammars（lost）CFG1 Intro to CFGs一个CFG包括：\n\n终止符集合：T（输入符号）\n非终止符集合：N\n开始符号：S ∈ N\n规则集合\n\n应用规则：将规则左侧替换为规则右侧\n以开始符号S作为起始，对非终止符应用规则进行拓展，直到没有非终止符\n拓展过程可以化成一颗语法树，语法左侧为父节点\n最右和最左推导\n最右推导每次把最右边的非终止符应用规则拓展\n两者生成相同的语法树\nCGF2 Ambiguity歧义\n\n相同句子具有不同的语法树\n编程语言不能接受该歧义\n无法确定给定的CFG是否有歧义\n一些CFG本质上是具有歧义的（不存在无歧义的CFG）\n\n\n\n处理歧义\n\n重写语法\n使用优先级和关联性\n\n关联性\n对于以下语法：\nE -&gt; E + EE -&gt; TT -&gt; T * TT -&gt; int\n通过左或右递归消除歧义：\nE -&gt; E + TE -&gt; TT -&gt; T * FT -&gt; int\n（tips：考虑T+T+T的情况，使用前者会有歧义，后者没有（歧义指语法树不同））\nyacc关联性定义\nyacc中的关联性定义（不需要重新定义语法）\n对于：E -&gt; E - E | int\n只需增加关联性定义%left -\n等价于上面的E -&gt; E + int E -&gt; int\nyacc优先级定义\n对于上面的语法，yacc中可以这样写：\n%left -\n%left &#x2F;\n\nE -&gt; E - E | E &#x2F; E | int\n\n写在后面的关联性定义具有更高的优先级（在语法树的更底层）\nCFG3 Push-down Automata对于每种regular语言有一个等效的FSA\n对一个CFG语言有一个等效的pushdown automaton(pda)\nPush-down Automata\n包含：\n\n字母表（终止符）\n栈符号（非终止符和终止符）\n一个fsa\n栈\n\nPractice Yacc（lost）蓝屏，笔记没了，不想补了\nWeek 5 Parsing 1LR1 Shift-Reduce Parsing自顶向下 与 自底向上\n自顶向下：按语法规则拓展\n自底向上：语法规则反向reduce\n自底向上\nreduce最右边的非终止符，即rightmost推导\nShift-Reduce\n自底向上的过程，只有两种操作：shift、reduce\nshift对应于将待处理符号（输入的符号）入栈\nreduce按规则（语法右边）出栈，并入栈新的符号（语法左边）\n冲突\n过程中某一步可能会出现允许多种可能操作的情况（不考虑最终结果）\n\n同时允许shift、reduce：\n可以修复（优先级、关联性）\n\n\n同于允许不同的reduce：\n可能语法本身具有歧义\n通过前瞻修复\n\n\n\n可行前缀 和 Handle\n直觉：只执行能使我们到达起始符号的reduce\n（不太懂）\nhandle总是在栈顶\n自底向上 Shift-Reduce 语法分析算法\n按算法可以处理的cfg语法集从大到小排序（上面的包含下面的）：\n\nLR(k)\nL：从左到右扫描输入\nR：最右推导\nk：前瞻token数\n\n\nLALR(k)\nSLR(k)：simple LR，类似LR(0)，但使用Follow sets\nLR(0)：0前瞻token\n\nLR2 LR(0) ParsingLR 语法分析 概览\n\n从终止符开始，寻找到起始符的路径\n应用 shift 和 reduce 操作（尽可能延迟决定）\nLR语法分析：\nL：从左到右分析\nR：最右推导（自底向上）\n\n\nLR(0) -&gt; SLR(1) -&gt; LR(1) -&gt; LALR(1)\n\n操作\n\nShift\n添加终止符到栈中\n\n\nReduce\n如果栈顶是个可行前缀，则reduce\n\n\n\n基于表的Shift Reduce语法分析\n行号：状态\n列号：终止符 或 非终止符\n左边（终止符的列）是action表右边（非终止符的列）是goto表\n一个栈存储状态\n表的使用：\n\n从输入读取一个字符（终止符）\n跟据栈顶状态s、读取的字符t查 action[s, t]\n\n如果action[s, t] = S5（5是一个状态，图中红色例子）：\n\n将 5 入栈\n\n如果action[s, t] = R4（4是一条规则，图中浅蓝、深蓝例子）：\n\n查找规则 4 为 F -&gt; (T)\n规则右边有3个符号，所以pop3次\n根据栈顶状态s=0、规则左边非终止符n=&#39;F&#39;，查goto[s, n]=1\n将 goto[s, n]=1 入栈\n\n图中的表没有符号的格子代表语法错误\n图中的表action[2, &#39;$&#39;]=A代表到达起始符号，即语法解析成功\n构建Action/Goto表的算法配置集(Configuration/ item set)\n\n每个集是一个语法状态\n使用点规则\nT -&gt; T * • F\n\n\n点在F之前，预测所有F在左边的规则\nT -&gt; T * • F\nF -&gt; • ( T )\nF -&gt; • id\n\n\n这创建了一个配置集（就是求T -&gt; T * • F的闭包）\n\n起始配置集\n\n用S&#39;扩充语法，添加一条规则S&#39; -&gt; S\n求closure(S&#39; -&gt; •  S)\n\n比如上述例子起始配置集closure(S&#39; -&gt; • T)\n后继 Successor(I, X)\n意义：按符号X移动\n\n对于I中所有点后面为X的规则，点向右移动一位\n删除其余规则（没有移动的规则）\n计算（移动后的规则的）闭包\n\n得到的就是该后继配置集\n实例\n\n每个集合对应一个表中的状态（一行）如果是终止符得到的后继（左边的列），则action[I, t] = Successor(I, n) 如果是非终止符得到的后继（右边的列），则goto[I, n] = Successor(I, t) \n其中有些集合有没有后继（点右边没有符号）的规则，则action[I, 空着的t] = R比如action[1, 空着的t] = R1、action[4, 空着的t] = R2 而集合2比较特殊，代表了成功结束，action[2, &#39;$&#39;] = $Accept\n以计算集合3的后继为例，Successor(I3, &#39;(&#39;)：\n\n集合3中点后面为(的只有一条规则（集合3中红色标记）\n移动规则的点（集合5中红色标记的第一条规则）\n计算闭包\n现在只有一条F -&gt; ( • T )，添加T在左边的规则到集合中（橙色左括号）\n现在新增了F和T，T已经找过，添加F在左边的规则（黄色括号）\n现在新增了id、(，没有这两者在左边的规则\n计算闭包完毕\n\n\n该闭包即是I5 = Successor(I3, &#39;(&#39;)\n\n集合5的后继有T、F、id、(\n假设按深度优先，接着计算Successor(I5, &#39;T&#39;)，和上面的步骤一样：\n\n选择集合5中点后面为T的所有规则，移动点构成新集合\n得到&#123;F -&gt; ( T • ), T -&gt; T • * F&#125;\n计算该集合的闭包\n点后面有)、*，分别找出规则左边为这两符号的规则\n刚好都没有，计算闭包完毕\n\n\n该闭包即是I6 = Successor(I5, &#39;T&#39;) \n\n构建表的伪代码（广度优先）：\nfunction items(G’)\n    C &#x3D; &#123; closure(&#123;S’ -&gt; • S&#125;) &#125;; &#x2F;&#x2F; C &#x3D; &#123;起始配置集&#125;\n    do foreach I ∈ C do &#x2F;&#x2F; 遍历C中新添加的配置集\n        foreach X ∈ (N ∪ T) do &#x2F;&#x2F; 遍历集的所有后继\n        \tC &#x3D; C ∪ &#123; Successor(I, X) &#125;; &#x2F;&#x2F; 添加后继配置集到C中（去重）\n    while C changes;\n\n\n\n冲突\nR/N（不构成冲突）：\n集合中有点右边为非终止符的规则（对应非终止符后继），也有点右边什么都没有的规则（对应reduce）\nreduce规则一定是前者求闭包得到的（reduce求闭包就是reduce本身）\naction表（终止符后继）填充reduce，goto表（非终止符后继）填充对应后继\nR/R 冲突：\n集合中有一个以上的点右边什么都没有的规则（对应多个reduce）\nR/T（未定义的行为）：\n（这解决方式不在LR(0)的定义中）对于action表（终止符列），有后继的填后继，没有后继的，填充R\nWeek 6 Parsing 2LR3 SLR(1) ParsingLR(0)：action[s, 空着t] = R\nSLR(1)：action[s, follow(L)] = R，（L是规则的左边）解决部分冲突\n终止符集合：\n\nFirst(N)：非终止符拓展的序列中，第一个的可能取值\n\nFollow(N)：非终止符下一个可能的取值\n\nS是起始符，$ ∈ FOLLOW(S)\nX -&gt; …Aa…，Follow(A)包括a\nX -&gt; …AB…，Follow(A)包括First(B)\nX -&gt; …A，Follow(A)包括Follow(X)\n\n\n\n​    \nSLR(1)\n增加了检测follow的约束，只有满足follow的才会reduce，否则shift\nLR4 LR(1) ParsingLR(1)解决R/T，R/R冲突\nSLR(1)中可能存在follow(L)（Reduce）和shift（T）重合的情况\n也可能存在两个不同L的follow相同的情况（RR冲突）\n解决办法改变Follow的计算方法，同一个L，在不同闭包中的Follow是独立的\n计算闭包时，把新L在旧R中后一个符号作为Follow(L)，并记录下来\n例子1：\nS -&gt; • Aa, $A -&gt; • e, a\n第二条从第一条拓展而来，第一条中A的后一个符号是a，则Follow(A)=a\n例子2：\nS -&gt; • A, =/$A -&gt; • e, =/$\n第二条从第一条拓展而来，第一条中A是规则右边的最后一个符号，则Follow(A) = Follow(S) = {=, $}\n\n图中闭包0，标1的红色箭头就是按例子1的方式计算的follow标2的绿色和橙色箭头就是按例子2的方式继承自前一条规则的follow\nLR5 Precedence and Associativity优先级高的先reduce\n比如*优先级高于+，当前栈中为E+E，预览下一个符号，如果为优先级更高的*则shift，如果下一个符号优先级更低就reduce\nyacc/bison中使用%left、%right的列表来处理优先级（列表中的先后）和关联性（left还是right）\n","slug":"SFU-Compilers-3","date":"2022-05-09T04:00:00.000Z","categories_index":"CS","tags_index":"note,cs,compiler","author_index":"御史神风"},{"id":"b8be4bf58b4cb3abe70be3d848e17901","title":"SFU Compilers class 笔记2","content":"SFU Compilers 笔记2 词法分析week2 wee3 p-lex hw1\nWeek 2 Lexical Analysis 1LEX1 Intro to Regexps词法分析\n将字符串转成tokens\nToken Attributes\n具有属性的例子：T_IDENT (&quot;sqrt&quot;),T_INTCONSTANT (&quot;1&quot;)\nToken: T_IDENTLexeme: (&quot;sqrt&quot;)\n不具有属性的例子：T_WHILE\n实现Lexers：循环和swich扫描器\n\n大量嵌套switch/case\n大量getc()、ungetc()\n容易出错\n难以更改和添加关键字\n\nad-hoc lexer源码：LexTokenInternal in clang\n正则表达式\n大概介绍了下正则表达式\n限制：在设计语言语法时要考虑正则语法，以便于构造正则表达式\nLEX2 Regular ExpresssionsInteger：\ndigit &#x3D; (0|1|2|3|4|5|6|7|8|9)\n&#123;digit&#125;+\n\nIdentifier：\ndigit &#x3D; [0-9]\nletter &#x3D; [a-zA-Z]\n\n&#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*\n\nWhitespace：\n(&quot; &quot;|&quot;\\t&quot;|&quot;\\n&quot;)+\n\nPattern definition for numbers：\ndigit &#x3D; [0-9]\ndigits &#x3D; [0-9]+\nopt_frac &#x3D; (&quot;.&quot;&#123;digits&#125;)?\nopt_exp &#x3D; ((e|E)(\\+|\\-)?&#123;digits&#125;)?\nnum &#x3D; &#123;digits&#125;&#123;opt_frac&#125;&#123;opt_exp&#125;\n\n345, 345.04 , 2e-7, 2e7, 2e+7, 3.14e5\n\n\n\n优先级：\n\n匹配长度\ntoken顺序\n\nWeek 3 Lexical Analysis 2LEX3 Regexps are Trees\n\n\n\n\n\n\n\n\n参考链接：\nxkcd: Regular Expressions\n有点类似于NFA的可视化：\nDebuggex: Online visual regex tester. JavaScript, Python, and PCRE.\n正则优先级：\n\n()\n一元运算符（unary op.）\n用于连接的二元运算符（binary op. for concatenation）\n间隔的二元运算符（binary op. for alternation）\n\n正则表达式是一树\n使用左结合来得到唯一的树\n等价的正则表达式\n可以化简正则表达式\n一些性质：\n\n结合律（Commutative，可交换的）\n分配律\n交换律\nR | R == R\nR*R* == (R*)* == RR*|e == R*\n\nLEX4 Regexps as Automata主要讲了有限状态机（FSA）、DFA、NFA的概念\n还有NFA到DFA的转换思路\nDFA\n对于一个输入，其路径唯一，若能到达终点则为合法\nNFA\n对于一个输入，可能有多条路径，只要有一条能到达终点则为合法\nNFA 转 DFA\n把NFA状态的组合，当成DFA的状态\nDFA vs NFA\n\nDFA不允许有歧义\nDFA不允许无条件转移\nDFA执行速度更快（NFA存在歧义可能需要搜索）\nDFA通常情况状态比NFA少\n最坏情况DFA的状态比NFA多（2的n次方倍，n为NFA的状态数量）\n\nLEX5 Regexps to NFAThompson构造法\n\nRule0（empty language）  \nRule1（x）  \nRule2（empty string，ε）  \nRule3（r1 | r2）  \nRule4（r1r2）  \nRule5（r*）  \n\n\n\n\n\n按照正则表达式树的后序遍历的顺序，根据Rule构造NFA\nlex6 NFA to DFA（todo）ε-closure\nε-closure(s) = {s以及s开始所有能通过ε到达的点}\n转换\n（NFA中大写是状态的集合，小写是单个状态）\n\n\n\n\nNFA\nDFA\n\n\n\nStates\nS\n{X | X ⊆ S}\n\n\nstart\nq ∈ S\nε-closure(q)\n\n\nFinal\nF ⊆ S\n{X | X∩F ≠ ø}\n\n\ntransition\nδ(x,a) = y\nδ(X,a) = ε-closure(δ(x,a)), x∈X\n\n\n最小化DFA\n合并所有转移条件及目标相同的点\n对所有a，δ(X,a) = δ(Y,a)，合并X、Y\nNFA to DFA\n// todo\nstates[0] &#x3D; e-closure(&#123;q0&#125;)\np &#x3D; j &#x3D; 0\nwhile j &lt;&#x3D; p do\n\tfor each symbol c do\n\t\te &#x3D; DFAedge(states[j], c)\n\t\tif e &#x3D;&#x3D; states[i] for some i &lt;&#x3D; p\n\t\tthen Dtrans[j, c] &#x3D; i\n\t\telse\n\t\t\tp &#x3D; p+1\n\t\t\tstates[p] &#x3D; e\n\t\t\tDtrans[j,c] &#x3D; p\n    j &#x3D; j+1\n\n\n\nlex7 NFA to DFA Complexity（pass）pass\nLEX8 Lexical Analyzer使用DFA的词法分析\n\n每个token定义成一个正则表达式\n合并所有正则表达式成一个大的正则表达式\n转换成NFA，DFA，最小化\nDFA识别器必须找到左边一个匹配长度最长的token\n如果两个匹配的token的长度相同的，优先选择token列表中更前面的\n\nLookahead operator\nr1后面必须跟着r2\n匹配r1εr2，并记录下r1和r2结束的位置\n总结\n\nToken =&gt; Pattern (LEX2)\nPattern =&gt; Regular Expression (LEX2)\nRegular Expression =&gt; NFA (LEX5)\nThompson’s Rules\n\n\nNFA =&gt; DFA (LEX4, lex6, lex7)\nSubset construction\nDFA =&gt; minimal DFA\n\n\nDFA =&gt; Table-driven implementation of DFA (lex9)\n\nlex9 Implementing DFAs使用二维数组存储转移表\nT[state_idx, input_symbol] = next_state_idx\ni &#x3D; 0;\nstate &#x3D; 0;\nwhile(input[i]) &#123;\n    state &#x3D; T[state, input[i]];\n    i++;\n&#125;\n\n\n\n压缩转移表\n二维数组占用空间大，且有很多重复元素；链表查询速度慢\n一种解决办法是压缩二维数组，二维数组中有空位（T[i,a]=None），利用这些空位存储信息\n再用一个额外的数组记录新表中每一格所属的状态\n&#x2F;&#x2F; origin\nnext_state &#x3D; T[state, input[i]];\n&#x2F;&#x2F; sparse tables\nidx &#x3D; B[state] + a\nnext_state &#x3D; check[idx] &#x3D;&#x3D; state ? ST[idx] : -1\n\n\n\n示例：\n\n\n\nT(s\\a)\na\nb\nc\nd\n\n\n\n0\n-\n1\n-\n2\n\n\n1\n1\n-\n1\n-\n\n\n2\n1\n2\n1\n-\n\n\n\n\n\nBase(s\\i)\nidx\n\n\n\n0\n2\n\n\n1\n4\n\n\n2\n0\n\n\n\n\n\nidx\n0\n1\n2\n3\n4\n5\n6\n7\n\n\n\ns_0\n\n\n-\n1\n-\n2\n\n\n\n\ns_1\n\n\n\n\n1\n-\n1\n-\n\n\ns_2\n1\n2\n1\n-\n\n\n\n\n\n\nST[]\n1\n2\n1\n1\n1\n2\n1\n-\n\n\ncheck[]\n2\n2\n2\n0\n1\n0\n1\n-\n\n\nlex10 Regexp to DFA（pass）pass\nPractice LexRegexp让Σ = {0, 1}\n\n集合的元素个数：2\nΣ3（三次方）：{000, 001, … , 110, 111}\nΣ*：Σ0 + Σ1 + Σ2 + …\nΣ*中所有等于十进制数字6的regexp：0*110\nΣ*中所有2的幂的regexp：10*\nΣ*中所有偶数的regexp：[0|1]*0\nΣ*中所有BCD码（包括空字符串）的regexp：((0[01][01][01])|(100[01]))* \n\n(0[01][01][01])=07，(100[01]))=89\nSimple Tokenizerapt install make\napt install flex\n\nmake simpletok\n# compiling lex file: simpletok.lex\n# output file: simpletok\n# flex -osimpletok.c simpletok.lex\n# gcc -o .&#x2F;simpletok simpletok.c -ll\n# &#x2F;bin&#x2F;rm -f simpletok.c\n\n.&#x2F;simpletok\n90int  # type this in yourself upto the comment char\n# IDENTIFIER: 90int, LENGTH:5\nCtrl-D # this terminates the standard input stream\n\n\n\nLexical Analysis要求手动预测一组token的识别结果\n计算答案的lex代码在tokenizer2.lex\nProvide the tokenized output for the following input strings using the greedy longest match lexical analysis method. Provide the list of tokens and the lexeme values.\nLexical Analysis using lex要求使用lex实现一组token的识别\n标准答案在tokenizer.lex\nRemove Multi-line Comments目录：rmcomments\n匹配c语言风格多行注释\n正则表达式：\\/\\*((?!\\*\\/).|\\n)*\\*\\/\nlex不支持向前匹配的?!：\nlex写法：\\/\\*(\\n|[^*]|[*]*[^*/])*[*]*\\*\\/\n构造过程：\nregexp_1：\\/\\*[^*]*\\*\\/，匹配非*字符（r1=[^*]）\n能够匹配类型1：/* 123 */，无法匹配类型2的***/结尾的情况\nregexp_2：\\/\\*[^*]*[*]*\\*\\/（r2=[*]*）\n能够匹配类型2：/* 123 *****/，无法匹配类型3的中间有*****+非*字符的情况\nregexp_3：[*]*[^*/]，用于匹配多个*接一个非*且非/的情况（r3=[*]*[^*/]）\n类型3：/* ***** */ \n结合到一起：\\/\\*(\\n|&#123;r1&#125;|&#123;r3&#125;)*&#123;r2&#125;\\*\\/\n最终方案：\n%%\n\\&quot;[^\\&quot;]*\\&quot;  ECHO;\n\\&#x2F;\\&#x2F;.*\t\t&#123; &#125;\n\\&#x2F;\\*(\\n|[^*]|[*]*[^*&#x2F;])*[*]*\\*\\&#x2F;  &#123; &#125;\n.|\\n\tECHO;\n%%\n\n\n\n其他忽略多行注释的解决方案：\n%%\n\\&#x2F;\\*    comment();\n%%\n\ncomment() &#123;\n    char c0, c1;\nloop:\n    while((c0 &#x3D; input()) !&#x3D; &#39;*&#39; &amp;&amp; c0 !&#x3D; 0) &#123;\n        &#x2F;&#x2F; putchar(c0);\n    &#125;\n    \n    if ((c1 &#x3D; input()) !&#x3D; &#39;&#x2F;&#39; &amp;&amp; c0 !&#x3D; 0) &#123;\n        unput(c1);\n        goto loop;\n    &#125;\n\n    &#x2F;&#x2F; if(c0 !&#x3D; 0) putchar(c0);\n&#125;\n\n\n\nMatching a Right Context要求手动预测一组右上下文相关的token的识别结果\n%%\na*b+&#x2F;c+  &#123; printf(&quot;T_AB:%s\\n&quot;, yytext); &#125;\n%%\n\n\n\nMatching a Left Context要求实现左上下文相关的token的识别\n标准答案在leftcontext.lex，需要修改makefile以编译该代码\n%%\noutputfile      BEGIN OUTPUT;\n&lt;OUTPUT&gt;\\&quot;.*\\&quot;  &#123; BEGIN 0; ECHO; printf(&quot; is the output file.\\n&quot;); &#125;\n%%\n\n\n\nBacktracking in Lex（todo）// todo\nCounting with Lex（todo）// todo\nHomework 1 Lexical Analysis前置条件：hw0、lex-practice\n目录：decaflex\n./answer/default.lex为未完成的作业，复制为./answer/decaflex.lex并完成\n规则编写\n参照语言的定义编写即可\n把Keywords的定义放到最前面，不然会无法识别，其余按字母顺序好像也没问题\n注意输出要求，对于[\\n\\v\\f]要求输出其转义序列，而不是转义后的字符，\\r\\n（CRLF）输出一个\\n即可\n即对于T_WHITESPACE，忽略\\r，为了简便直接循环处理：\ncase T_WHITESPACE: &#123;\n    cout &lt;&lt; &quot;T_WHITESPACE &quot;;\n    for (i &#x3D; 0; i &lt; yyleng; i++)&#123;\n        switch(yytext[i])&#123;\n            case 9: cout &lt;&lt; &quot;\\t&quot;; break;\n            case 10: cout &lt;&lt; &quot;\\\\n&quot;; break;\n            case 11: cout &lt;&lt; &quot;\\\\v&quot;; break;\n            case 12: cout &lt;&lt; &quot;\\\\f&quot;; break;\n            case 13: &#x2F;*cout &lt;&lt; &quot;\\\\r&quot;;*&#x2F; break;\n            case 32: cout &lt;&lt; &quot; &quot;; break;\n        &#125;\n    &#125;\n    cout &lt;&lt; endl;\n    break;\n&#125;\n\n\n\n对于T_COMMENT，其正则表达式为\\/\\/.*[\\n]，简便处理，默认是CRLF：\ncase T_COMMENT: &#123;\n    lexeme[yyleng-2] &#x3D; &#39;\\\\&#39;;\n    lexeme[yyleng-1] &#x3D; &#39;n&#39;;\n    cout &lt;&lt; &quot;T_COMMENT &quot; &lt;&lt; lexeme &lt;&lt; endl;\n    break;\n&#125;\n\n","slug":"SFU-Compilers-2","date":"2022-03-15T04:00:00.000Z","categories_index":"CS","tags_index":"note,cs,compiler","author_index":"御史神风"},{"id":"59b8a2ac42b98d74611bef705cd30176","title":"《逆向工程实战》实例D","content":"《逆向工程实战》实例D摘要基本信息\nx86\nDevice Name：\\Device\\ProcPanama\nSymbolLink Name：\\DosDevices\\ProcPanama\nIRP：Create、Close、DeviceIoCtrl\n回调：进程\n函数分析结果\n\nsub_10001019：进程通知回调\n\nsub_10001277：Memcpy\n\nsub_100012B0：修改cr0\n\nsub_100012BC：修改cr0\n\nsub_100012C8*：DeviceIoCtrl\n\n\n功能摘要\n提供接口修改ssdt（CR0关WP）、写入shellcode、触发中断\n功能与shellcode密切相关，没有R3的样本，不知道shellcode是什么\n结构分析IOCTL_0_803 input buffer\n&#x2F;&#x2F; size &gt;&#x3D; 0x20\n+  0  ssdtIdx        4\n+  4  aShellCode     char[0xa]\n+  E  unknown        2\n+ 10  hProc          HANDLE\n+ 14  desiredAccess  4\n+ 18  pid            4\n+ 1C  newBase        void*\n\nIOCTL_1_804 input buffer\n&#x2F;&#x2F; size &#x3D; 0xC\n+ 0  ssdtIdx  4\n+ 4  newBase  void*\n+ 8  oldBase  void*\n\n\n\nMemcpy这个函数的功能就是memcpy\nvoid Memcpy(char* Dst_, char* Src_, unsigned int size);\n\n\n\n书中问到第二个参数从何而来，是否有意义，不太确定是什么意思。我猜测是优化使得对第二个参数的使用变得有点奇怪，比较不直观，详见下面的分析。\n首先检查传入的第一个和第二个参数是否是合法地址\n然后执行了memcpy的操作，有一些优化，所以比较难识别\n反汇编：\n; unsigned int i   (esi)\n; char*        dst (eax)\nmov     esi, [ebp+size]    ; i &#x3D; size\ntest    esi, esi\njbe     short L_end ; jmp if i &#x3D;&#x3D; 0:\nmov     eax, [ebp+Dst_]    ; eax &#x3D; Dst_\nmov     ecx, [ebp+Src_]\nsub     ecx, eax           ; const ecx &#x3D; Src_ - Dst_\nL_continue:\nmov     dl, [ecx+eax]\nmov     [eax], dl          ; *dst &#x3D; *(Src_-Dst_+dst)\ninc     eax                ; dst++\ndec     esi                ; i--\njnz     short L_continue\nL_end:\npop     esi\npop     ebp\nretn    0Ch\n\n反编译：\nunsigned int i &#x3D; size;\nif(i)&#123;\n\tchar* dst &#x3D; Dst_;\n\tdo &#123;\n        *dst &#x3D; *(dst + Src_ - Dst_); &#x2F;&#x2F; Dst_[size-i] &#x3D; Src_[size-i]\n        ++dst;\n        --i;\n    &#125; while( i );\n&#125;\n\n\n\n修改cr0EnableCR0WP proc near\nmov     eax, cr0\nor      eax, 10000h ; cr0 bit[16] &#x3D; 1\nmov     cr0, eax\nretn\nsub_100012B0 endp\n\nDisableCR0WP proc near\nmov     eax, cr0\nand     eax, 0FFFEFFFFh ; cr0 bit[16] &#x3D; 0\nmov     cr0, eax\nretn\nsub_100012BC endp\n\n\n\nDeviceIoCtrl5个控制码\n都是METHOD_BUFFERED，有一个用了UserBuffer输出，有点迷惑\nMETHOD_NEITHER 用的是（In）Type3InputBuffer、（Out）UserBuffer\nRead/Write的Buffer IO用的都是SystemBuffer\nIOCTL_0_803修改了ssdt表项，然后又修改了新的服务例程前10个字节，然后调用打开进程句柄\n最后恢复上面修改的两个东西\nCode 22E00C\nDeviceType 0x22 FILE_DEVICE_UNKNOWN\nFunction 0x803\nMethod 0x0 METHOD_BUFFERED\nAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS  \n\n\n\n部分反编译：\nif( MmIsAddressValid(inBuf-&gt;newBase) ) &#123;\n    pSSDT_i &#x3D; (PVOID *)(KeServiceDescriptorTable[0] + 4 * inBuf-&gt;ssdtIdx);\n    if( MmIsAddressValid(pSSDT_i) ) &#123;\n        oldBase &#x3D; *pSSDT_i; &#x2F;&#x2F; save ssdt[i]\n        DisableCR0WP();\n        *pSSDT_i &#x3D; inBuf-&gt;newBase; &#x2F;&#x2F; change ssdt[i]\n        Memcpy(tempBuf, (char *)inBuf-&gt;newBase, 0xAu);&#x2F;&#x2F; save shellcode 0xA bytes\n        Memcpy((char *)inBuf-&gt;newBase, inBuf-&gt;aShellcode, 0xAu);&#x2F;&#x2F; change shellcode 0xA bytes\n        status &#x3D; ZwOpenProcess(&amp;inBuf-&gt;hProc, inBuf-&gt;desiredAccess, &amp;ObjectAttributes, &amp;ClientId);\n        Memcpy((char *)inBuf-&gt;newBase, tempBuf, 0xAu);&#x2F;&#x2F; re change shellcode 0xA bytes\n        *pSSDT_i &#x3D; oldBase; &#x2F;&#x2F; re change ssdt[i]\n        EnableCR0WP();\n    &#125;\n&#125;\n\n\n\nIOCTL_1_804 set ssdt设置ssdt表项，并保存旧的ssdt表项\nCode 22E010\nDeviceType 0x22 FILE_DEVICE_UNKNOWN\nFunction 0x804\nMethod 0x0 METHOD_BUFFERED\nAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS  \n\n\n\n部分反编译：\ninBuf_1-&gt;oldBase &#x3D; *(PVOID *)(KeServiceDescriptorTable[0] + 4 * inBuf_1-&gt;ssdtIdx); &#x2F;&#x2F; save old ssdt[i]\nDisableCR0WP();\n*pSSDT_i &#x3D; inBuf_1-&gt;newBase; &#x2F;&#x2F; set ssdt[i]\nEnableCR0WP();\n\n\n\nIOCTL_2_805 write g_buffer往一个全局指针分配页池内存，然后往该全局buffer里写入数据，然后对该全局buffer做了一些看不懂的操作\n另外使用了UserBuffer\nCode 22E014\nDeviceType 0x22 FILE_DEVICE_UNKNOWN\nFunction 0x805\nMethod 0x0 METHOD_BUFFERED\nAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS  \n\n\n\nIOCTL_3_806对g_buffer进行了一些操作\nCode 22E018\nDeviceType 0x22 FILE_DEVICE_UNKNOWN\nFunction 0x806\nMMethod 0x0 METHOD_BUFFERED\nAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS\n\n\n\nIOCTL_4_807 add pid往ULONG g_pids[0x10]插入\nCode 22E01C\nDeviceType 0x22 FILE_DEVICE_UNKNOWN\nFunction 0x807\nMethod 0x0 METHOD_BUFFERED\nAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS\n\n\n\n反汇编：\ni &#x3D; Stack-&gt;Parameters.DeviceIoControl.IoControlCode - 0x22E01C;&#x2F;&#x2F; i&#x3D;0\nif ( Stack-&gt;Parameters.DeviceIoControl.IoControlCode &#x3D;&#x3D; 0x22E01C\n&amp;&amp; Stack-&gt;Parameters.DeviceIoControl.OutputBufferLength &#x3D;&#x3D; 4 ) &#123;&#x2F;&#x2F; !!!\n    while ( g_pids[i] ) &#123;\n        if ( (unsigned int)++i &gt;&#x3D; 0x10 )\n        \tbreak;                    &#x2F;&#x2F; g_pids is full\n    &#125;\n    g_pids[i] &#x3D; *(HANDLE *)Irp-&gt;AssociatedIrp.SystemBuffer;\n&#125;\n\n\n\n进程通知回调只有g_buffer不为空时才执行功能\n进程注销则将g_pids[]中对应元素清零\n进程创建则大量的int 2E中断\n进程创建分支的结构：\n&#x2F;&#x2F; void __stdcall OnProcessNotify(\n&#x2F;&#x2F;   PEPROCESS Process,\n&#x2F;&#x2F;   HANDLE ProcessId,\n&#x2F;&#x2F;   PS_CREATE_NOTIFY_INFO *Create)\n\ni &#x3D; 0;\nwhile(g_pids[i] !&#x3D; Process) &#123;\n    i +&#x3D; 4;\n    if(i &lt; 0x40) &#123;\n        continue;\n    &#125;else &#123;\n        if(ObOpenObjectByPointer()) &#123;\n            &#x2F;&#x2F; ...\n        &#125;\n        return;\n    &#125;\n&#125;\n\n","slug":"practicalreD","date":"2022-03-11T04:00:00.000Z","categories_index":"Windows","tags_index":"windows,note,practicalre","author_index":"御史神风"},{"id":"49cfcba348975accba6443ccf555c536","title":"《逆向工程实战》实例B","content":"《逆向工程实战》实例B（练习部分）参照书上对实例BOnProcessNotify(sub_4045F8)、sub_4038F0的分析对实例B进行的一些分析记录\n一个x64的驱动后门\n进程创建回调、sub_4038F0部分是根据书本分析过程复现的记录\n结构体还原在40A590有一个结构体，根据api的调用尝试还原其结构的定义\nOnProcessNotify(sub_4045F8)\n由循环可以确定+0处是结构体指针next，是一个链表\n根据循环结束处的处理，猜测+8是结构体指针last，是一个双向链表\n实际上+0就是LIST_ENTRY，后面有类似RemoveEntryListmacro的代码\n根据其中用到的Mm系列api，可以推出部分结构\n&#x2F;&#x2F; hex\n+   0  next              struc*\n+   8  last              struc*\n+  10  pid               4\n+  14  unknown           0xC\n+  20  strImageFilename  char[0x70]\n+  90  resource          ERESOURCE\n+  F8  unknown           0xF78\n+1070  pMdl              MDL*\n+1078  addr1             void*\n+1080  unknown           0x30\n+10B0  addr2             void*\n\naddr1是通过Mdl重新映射的，addr2是通过ExPoolWithTag分配的\n其中有如下代码，不太确定其意义：\nfor(i &#x3D; stru_40A590.next; ;) &#123;\n    if() &#123;\n        &#x2F;&#x2F; ...\n        if ( i-&gt;addr2 )\n            ExFreePoolWithTag(i-&gt;addr2, &#39;ssss&#39;);\n        &#x2F;&#x2F; ...\n        ExFreePoolWithTag(i, &#39;ssss&#39;);\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;\n\n\n\n进程创建回调DriverEntry中注册了进程回调函数：OnProcessNotify(sub_4045F8)\n只有在进程注销的时候才执行\n进入CriticalRegion并请求ExAcquireResourceExclusiveLite\n然后通过遍历一个双向链表stru_40A590，找到与当前（准备注销的进程）相关（imageFileName和pid相同）的表项，释放表项占用的内存并移出链表\n表项中有一个使用Mdl重映射的地址，会解除该映射\n还有一个通过tag分配的内存（不确定是页池还是非页池），表项本身也是通过tag分配的\n两者都会通过ExFreePoolWithTag(&#39;ssss&#39;)释放\nDeleteFileByIrp(sub_4038F0)该函数的功能是构造一个IRP删除指定的文件，传递IRP后会一直等待直到IRP被处理完成\n（通过交叉引用发现该函数最终被用于删除mbam.sys）\n先是通过Stack = pirp-&gt;Tail.Overlay.CurrentStackLocation获取当前的堆栈\n然后通过Stack[-1]对下一层堆栈进行填充（可能是编译器优化掉了获取下一层堆栈的代码）\n最后调用IofCallDriver把Irp传给别的设备处理（书中猜测是文件系统）\n根据Stack[-1].MajorFunction = IRP_MJ_SET_INFORMATION; // 6可以判断出下面union的是SetFile字段\n填充的比较重要的内容如下：\nbuf &#x3D; 1;\npirp-&gt;AssociatedIrp.SystemBuffer &#x3D; &amp;buf;\n&#x2F;&#x2F; ...\nStack[-1].Parameters.SetFile.DeleteHandle &#x3D; hFile;\nStack[-1].Parameters.SetFile.FileObject &#x3D; pFileObj;\nStack[-1].Parameters.SetFile.FileInformationClass &#x3D; FileDispositionInformation;\nStack[-1].Parameters.SetFile.Length &#x3D; 1;\n\n\n\n\n\n\n\n\n\n\n\n\nIRP_MJ_SET_INFORMATION\nParameters.SetFile.FileInformationClass：SystemBuffer指向的结构体的类型\nParameters.SetFile.Length：SystemBuffer指向结构体的长度\nAssociatedIrp.SystemBuffer：指向包含新信息设置的缓冲区\nNtSetInformationFile function (ntifs.h)\nFileDispositionInformation (13) 请求在文件关闭时将其删除\nFILE_DISPOSITION_INFORMATION_EX structure (ntddk.h)\ntypedef struct _FILE_DISPOSITION_INFORMATION_EX &#123;\nULONG Flags;\n&#125; FILE_DISPOSITION_INFORMATION_EX, *PFILE_DISPOSITION_INFORMATION_EX;\n\n\n\n\nFlag Name\nValue\nMeaning\n\n\n\nFILE_DISPOSITION_DELETE\n0x00000001\nSpecifies the system should delete a file.\n\n\n根据以上信息，FileDispositionInformation指示SystemBuffer的类型为_FILE_DISPOSITION_INFORMATION_EX而该结构体内容为Flags=1，即删除文件的意思\n给IRP添加了一个完成例程Stack_1[-1].CompletionRoutine = CompletaRoutine（sub_4038B4）\n该完成例程会设置IRP的Event，用于通知上一层处理函数（即sub_4038F0）IRP已完成\n在sub_4038F0会等待该事件：\nif ( IofCallDriver(pDevObj_, pirp_1) &#x3D;&#x3D; 0x103 )&#x2F;&#x2F; STATUS_PENDING\n    KeWaitForSingleObject(&amp;Event, Executive, 0, 1u, 0i64);&#x2F;&#x2F; Event will be set in CompletionRoutine\nreturn (unsigned int)pirp_1-&gt;IoStatus.Status;\n\n","slug":"practicalreB","date":"2022-03-08T04:00:00.000Z","categories_index":"Windows","tags_index":"windows,note,practicalre","author_index":"御史神风"},{"id":"a8aaa1ce0f83038b9e68ef408652298f","title":"《逆向工程实战》实例A","content":"《逆向工程实战》实例A参照书上对实例A的分析过程，对实例A的完整分析记录\n一个挺短的驱动后门（x86），用于支持R3程序修改SSDT，估计是xp或者win7时代的\nDriverEntry &amp; DriverUnloadDosDevices是??的别名\nDriverEntry\n只是正常的初始化\nIRP：支持Create、Close、DeviceIoControl：\nmov     ecx, [ebp+DriverObject] ; ecx &#x3D; pDriverObj\n; 0,MJ_CREATE\nmov     dword ptr [ecx+38h], offset MJ_Create_Close_Ioctl\nmov     edx, [ebp+DriverObject]\n; 2,MJ_CLOSE\nmov     dword ptr [edx+40h], offset MJ_Create_Close_Ioctl\nmov     eax, [ebp+DriverObject]\n; 0xE,MJ_DEVICE_CONTROL\nmov     dword ptr [eax+70h], offset MJ_Create_Close_Ioctl\nmov     ecx, [ebp+DriverObject]\n; pDriverObj-&gt;DriverUnload\nmov     dword ptr [ecx+34h], offset DriverUnload\n\n\n\n支持DriverUnload\n先尝试删除符号链接再重新创建\nDriverUnload\n也是正常的卸载\n删除了符号链接和设备\n从传入的驱动对象中获取设备指针：\nmov     eax, [ebp+DriverObject] ; pDriverObj\nmov     ecx, [eax+4]    ; pDriverObj-&gt;DeviceObject\npush    ecx             ; DeviceObject\ncall    ds:IoDeleteDevice\n\n\n\nIRP处理函数Create、Close、DeviceIoCtrl都在同一个函数中\n首先是初始化IRP的返回状态，并获取IRP的类型：\nmov     eax, [ebp+Irp]\nmov     ecx, [ebp+status]\nmov     [eax+18h], ecx  ; Irp-&gt;IoStatus.Status &#x3D; status &#x3D; 0\nmov     edx, [ebp+Irp]\nmov     dword ptr [edx+1Ch], 0 ; Irp-&gt;IoStatus.Information &#x3D; 0\nmov     eax, [ebp+Irp]\nmov     ecx, [eax+60h]  ; ecx &#x3D; Irp-&gt;Tail.Overlay.CurrentStackLocation\nmov     [ebp+stack], ecx\nmov     edx, [ebp+stack]\nmovzx   eax, byte ptr [edx] ; eax &#x3D; stack-&gt;MajorFunction\n\nIoGetCurrentIrpStackLocation是内联的：\nPIO_STACK_LOCATION IoGetCurrentIrpStackLocation(PIRP Irp) &#123;\n    return Irp-&gt;Tail.Overlay.CurrentStackLocation; &#x2F;&#x2F; ret [pIrp + 0x60]\n&#125;\n\n\n\n整个处理逻辑是如果为Create、Close则直接返回成功\n如果为DeviceIoCtrl则检测CTL_CODE\nDeviceIoCtrl\n这一段汇编主要都是对结构体的操作，参照着结构体的定义就行\n需要注意的是，IO_STACK_LOCATION中有个union，要根据IRP的类型选择对应的结构\n这里贴一下实例中用到的偏移：\nIO_STACK_LOCATION\n  0xC  Parameters.DeviceIoControl.IoControlCode\n\nIRP\n  0xC  AssociatedIrp.SystemBuffer\n  0x18 IoStatus.Status\n  0x1C IoStatus.Information\n\n\n\n会判断CTL_CODE是否为0x22C004\n如果不是则返回0xC0000010(STATUS_INVALID_OPERATION)\n如果是则调用sub_103B0\nDeviceIoCtrl处理函数IOCTL_handler(sub_103B0)是处理CTL_CODE=0x22C004的函数（只有一个控制码）\nCTL_CODE 0x22C004\nDeviceType 0x22 FILE_DEVICE_UNKNOWN (def in ntifs.h DEVICE TYPE)\nFunction  0x1\nMethod    0x0   METHOD_NEITHER\nAccess    0x3   FILE_ACCESS_ANY\n\n其中会调用到sub_10460和sub_10550，这两个是一对的函数\nMapLockedMdl(sub_10460)\n这个就是创建一个Mdl、以写权限锁定页面，映射\n*pPMdl &#x3D; IoAllocateMdl(VirtualAddress, Length, 0, 0, 0);\nMmProbeAndLockPages(*pPMdl, KernelMode, IoWriteAccess);\nnewAddr &#x3D; MmMapLockedPagesSpecifyCache(*pPMdl, KernelMode, MmNonCached, 0, 0, NormalPagePriority);\n\n&#x2F;&#x2F; KernelMode 0\n&#x2F;&#x2F; NormalPagePriority 0x10\n\n\n\nMmProbeAndLockPages需要在try中执行，在函数开头会有一段相关的汇编：\npush    ebp\nmov     ebp, esp                ; stack frame\npush    0FFFFFFFFh              ; ???\npush    offset stru_10748       ; ???\npush    offset _except_handler3 ; NewSEH.Handler\nmov     eax, large fs:0\npush    eax                     ; NewSEH.Next &#x3D; pOldSEH\nmov     large fs:0, esp         ; pSEH &#x3D; &amp;NewSEH\nadd     esp, 0FFFFFFF0h\npush    ebx\npush    esi\npush    edi\nmov     [ebp+ms_exc.old_esp], esp\n\n\n\nUnmapLockedMdl(sub_10550)\n这个函数就是解除锁定页面映射、解锁页面，释放Mdl\nvoid __stdcall UnmapMdl(PMDL MemoryDescriptorList, PVOID BaseAddress)\n&#123;\n  MmUnmapLockedPages(BaseAddress, MemoryDescriptorList);\n  MmUnlockPages(MemoryDescriptorList);\n  IoFreeMdl(MemoryDescriptorList);\n&#125;\n\n\n\nIOCTL_handler(sub_103B0)\n现在回到IOCTL_handler(sub_103B0)\n整个函数IRQL处于DpcLevel中，会屏蔽掉线程分发器\nSDT的结构体：\ntypedef struct _KSERVICE_TABLE_DESCRIPTOR\n&#123;\n    PULONG Base;   &#x2F;&#x2F; address or SSDT\n    PULONG Count;\n    ULONG Limit;   &#x2F;&#x2F; number of SSDT\n    PUCHAR Number;\n    &#x2F;&#x2F; ...\n&#125; KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;\n\n\n\n首先通过MapLockedMdl(sub_10460)创建了一个SSDT的写入权限映射：\npSSDT &#x3D; (UINT32 *)MapLockedMdl(\n    &amp;MemoryDescriptorList,\n    KeServiceDescriptorTable.Base,\n    4 * KeServiceDescriptorTable.Limit;)\n\n\n\n然后修改SSDT（符号：KiServiceTable）\n反编译：\nfor ( i &#x3D; 0; i &lt; *newSSDT; ++i ) &#123;\n    if ( newSSDT[i + 1] ) &#123;\n        if ( pSSDT[i] !&#x3D; newSSDT[i + 1] )\n    \t\t_InterlockedExchange(pSSDT[i], newSSDT[i + 1]);\n    &#125;\n&#125;\n\n核心部分反汇编：\nmov     edx, [ebp+var_8]\nmov     eax, [ebp+newSSDT]\nmov     ecx, [eax+edx*4+4] ; ecx &#x3D; newSSDT[i+1]\nmov     edx, [ebp+var_8]\nmov     eax, [ebp+pSSDT]\nlea     edx, [eax+edx*4] ; edx &#x3D; &amp;pSSDT[i]\nxchg    ecx, [edx]      ; swap(newSSDT[i+1], pSSDT[i])\n\n得到输入缓冲区的结构如下：\nconst int SYSCALL_NUM;\n\nstruct INBUF &#123;\n    int number &#x3D; SYSCALL_NUM;\n    void* syscalls[SYSCALL_NUM];\n&#125;\n\n\n\n最后是释放与还原环境\n思考题与总结win10这种办法应该是不行的，ssdt是只读的对只读内存，MmProbeAndLockPages(IoWriteAccess)会导致蓝屏\n书中题目\n（1）这个驱动程序能工作于多核系统吗？\n在《windows kernel programing》中关于高IRQL同步的章节有讲到，提高IRQL不能应对多核情况的线程同步，原因是IRQL是于cpu核心关联的\n即使驱动线程所在的cpu核心的irql等级禁用了中断，另外一个核心的irql可能是0，仍然可以触发低等级的中断\n（2）为什么作者认为需要把IRQL提示到DISPATCH_LEVEL？是否有必要？\n我猜作者的目的是保护SSDT读写过程\n通常R3通过中断进入R0，并传入一个SSDT的索引，指定要执行的SSDT表项\n而DISPATCH_LEVEL是软件中断的最高级别，没有找到系统调用相关的信息，但系统调用也是通过软件中断实现的，猜测是禁用中断来达到禁止系统调用的目的\n（3）普通用户如何通过这个驱动在R0上下文任意执行代码？\n首先需要申请一块非页池内存，写入shellcode\n然后利用该驱动把shellcode的地址写入SSDT\n最后在R3触发对应的中断，就会进入R0并执行shellcode\n（4）假定作者想要通过用户空间的自定义替换某些系统调用，可能会遇到哪些问题？\n首先原系统调用的功能如何保留是个问题，有可能别的程序需要原功能\n然后就是win10直接尝试写入SSDT会蓝屏，MmProbeAndLockPages(IoWriteAccess)也会蓝\n另外shellcode需要在非页池内存中，如果在用户空间或页池中，可能会出现上下文不同或者换出的问题\n","slug":"practicalreA","date":"2022-03-07T04:00:00.000Z","categories_index":"Windows","tags_index":"windows,note,practicalre","author_index":"御史神风"},{"id":"334210967d7f70d0f127f10f28fddeb2","title":"《Windows Kernel Programming》 笔记 8~9 回调","content":"Windows Kernel Programming 笔记 8~9 回调8 进程、线程通知（S5）内核驱动一种重要的机制：在某些重要活动发生时通知驱动\n这章主要关于进程、线程的创建和销毁，还有映像的加载\n\n\n\n\n\n\n\n\n\n使用这些回调的驱动程序必须在PE头中有 IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY 标志\n没有它，注册函数的调用返回 STATUS_ACCESS_DENIED \n需要在 链接器-&gt;命令行 中添加 /integritycheck\n8.1 进程通知驱动可以在进程创建或销毁时收到通知\n\n\n\n\n\n\n\n\n\nwindows还提供另一种通知机制ETW，来记录进程的创建或销毁，这些通知可以被R3的进程接收\n但ETW有固定的1~3s的延迟\n注册进程通知：\nNTSTATUS\nPsSetCreateProcessNotifyRoutineEx (\n\t_In_ PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,\n\t_In_ BOOLEAN Remove);\n\ntypedef void\n(*PCREATE_PROCESS_NOTIFY_ROUTINE_EX) (\n\t_Inout_ PEPROCESS Process,\n\t_In_ HANDLE ProcessId,\n\t_Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo);\n\n进程退出通知的CreateInfo为NULL\n\n\n\n\n\n\n\n\n\n目前系统范围限制为 64 次注册，因此理论上注册功能可能会失败。 \n当进程创建时，回调函数运行在创建进程的线程的上下文\n当进程退出时，回调函数运行在the last thread to exit the process的上下文\n回调函数都运行在critical region（normal kernel APCs disabled）\n提供给回调函数的参数的结构体：\ntypedef struct _PS_CREATE_NOTIFY_INFO &#123;\n    _In_ SIZE_T Size;\n    union &#123;\n        _In_ ULONG Flags;\n        struct &#123;\n            _In_ ULONG FileOpenNameAvailable : 1;\n            _In_ ULONG IsSubsystemProcess : 1;\n            _In_ ULONG Reserved : 30;\n        &#125;;\n    &#125;;\n    _In_ HANDLE ParentProcessId;             &#x2F;&#x2F; 父进程\n    _In_ CLIENT_ID CreatingThreadId;         &#x2F;&#x2F; 创建进程的调用方\n    _Inout_ struct _FILE_OBJECT *FileObject;\n    _In_ PCUNICODE_STRING ImageFileName;\n    _In_opt_ PCUNICODE_STRING CommandLine;\n    _Inout_ NTSTATUS CreationStatus;         &#x2F;&#x2F; 返回给调用者\n&#125; PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;\n\nImageFileName：如果设置了标志 FileOpenNameAvailable 则可用 \nCreationStatus：设置为失败状态可以使进程创建失败（比如STATUS_ACCESS_DENIED）\n\n\n\n\n\n\n\n\n\nwin10 1607开始，提供了另外一个函数PsSetCreateProcessNotifyRoutineEx2\n与之前的类似但invoked on Pico processes，用于WSL\n8.2 实现进程通知实现一个驱动记录所有进程的创建和销毁到一个链表中使用fast mutex保证链表的安全\n结构体定义：\n&#x2F;&#x2F; common.h\n\nenum class RecordType : short &#123;\n    None,\n    ProcessCreate,\n    ProcessExit\n&#125;;\n\nstruct RecordHeader &#123;\n    RecordType type;\n    USHORT size;\n    LARGE_INTEGER time;\n&#125;;\n\nstruct ProcessCreateInfo : RecordHeader &#123;\n    ULONG pid;\n    ULONG parentPid;\n    USHORT cmdLength;\n    USHORT cmdOffset;\n&#125;;\n\nstruct ProcessExitInfo : RecordHeader &#123;\n    ULONG pid;\n&#125;;\n\n&#x2F;&#x2F; driver.h\n\ntemplate&lt;typename T&gt;\nstruct RecordEntry &#123;\n\tLIST_ENTRY Entry;\n\tT Data;\n&#125;;\n\nstruct RecordLinks &#123;\n\tLIST_ENTRY head;\n\tint count;\n\tMyFastMutex mutex;\n&#125;;\n\n\n\n回调函数：\nvoid OnProcessNotify(\n    PEPROCESS Process,\n    HANDLE ProcessId,\n\tPPS_CREATE_NOTIFY_INFO CreateInfo) &#123;\n    if (CreateInfo) &#123;\n    \t&#x2F;&#x2F; process create\n    &#125;\n    else &#123;\n    \t&#x2F;&#x2F; process exit\n    &#125;\n&#125;\n\n\n\n8.3 提供数据给用户模式详情看代码吧\n8.4 线程通知内核提供线程创建和销毁的回调机制\nAPI：PsSetCreateThreadNotifyRoutine、PsRemoveCraeteThreadNotifyRoutine\n回调函数：\nvoid OnThreadNotify(HANDLE ProcessId, HANDLE ThreadId, BOOLEAN Create) &#123;\n\t&#x2F;&#x2F; ...\n&#125;\n\n\n\n8.5 映像加载通知API：PsSetLoadImageNotifyRoutine、PsRemoveLoadImageNotifyRoutine\ntypedef void (*PLOAD_IMAGE_NOTIFY_ROUTINE)(\n    _In_opt_ PUNICODE_STRING FullImageName,\n    _In_ HANDLE ProcessId, &#x2F;&#x2F; pid into which image is being mapped\n    _In_ PIMAGE_INFO ImageInfo);\n\ntypedef struct _IMAGE_INFO &#123;\n    union &#123;\n        ULONG Properties;\n        struct &#123;\n            ULONG ImageAddressingMode : 8; &#x2F;&#x2F; Code addressing mode\n            ULONG SystemModeImage : 1; &#x2F;&#x2F; System mode image\n            ULONG ImageMappedToAllPids : 1; &#x2F;&#x2F; Image mapped into all processes\n            ULONG ExtendedInfoPresent : 1; &#x2F;&#x2F; IMAGE_INFO_EX available\n            ULONG MachineTypeMismatch : 1; &#x2F;&#x2F; Architecture type mismatch\n            ULONG ImageSignatureLevel : 4; &#x2F;&#x2F; Signature level\n            ULONG ImageSignatureType : 3; &#x2F;&#x2F; Signature type\n            ULONG ImagePartialMap : 1; &#x2F;&#x2F; Nonzero if entire image is not mapped\n            ULONG Reserved : 12;\n        &#125;;\n    &#125;;\n    PVOID ImageBase;\n    ULONG ImageSelector;\n    SIZE_T ImageSize;\n    ULONG ImageSectionNumber;\n&#125; IMAGE_INFO, *PIMAGE_INFO;\n\nExtendedInfoPresent：如果该标志位被设置，则IMAGE_INFO是IMAGE_INFO_EX的一部分\n\n\n\n\n\n\n\n\n\n没有映像卸载的回调机制\nProcessId是加载该映像的进程的pid. 对于驱动程序（内核映像），此值为零。\n8.6 练习\n创建一个驱动，监控进程创建；并提供一个客户端用于设置可执行路径黑名单（todo）\n创建一个驱动 （或给S5_SysMon添加功能)），检测远程线程创建（进程中的第一个线程总是“远程”创建的），并通知客户端。写一个测试程序，使用CreateRemoteThread。\n\n2、检测远程线程创建：\n思路：OnThreadNotify的在调用方上下文，检查当前上下文的进程的pid和创建线程的pid是否一致\n通过EPROCESS获取pid比通过pid获取EPROCESS简单一点:\nPsGetProcessId  proc near\n    mov     rax, [rcx+440h] ; PEPROCESS-&gt;UniqueProcessId\n    retn\nPsGetProcessId  endp\n\n检测代码：\nvoid OnThreadNotify(HANDLE ProcessId, HANDLE ThreadId, BOOLEAN Create) &#123;\n\tif (Create) &#123;\n\t\tauto curPid &#x3D; PsGetCurrentProcessId();\n\t\tif (curPid !&#x3D; ProcessId) &#123;\n\t\t\tKdPrint((&quot;Detect remote thread create pid:%u tid:%u rpid:%u&quot;,\n\t\t\t\tHandleToULong(ProcessId),\n\t\t\t\tHandleToULong(ThreadId),\n\t\t\t\tHandleToULong(curPid)));\n\t\t&#125;\n\t&#125;\n&#125;\n\n测试结果：\n被注入进程pid：3480\n注入器pid：5336\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n18:00:59.568: Thread Create\npid:3480 tid:3164\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n18:00:59.569: Image Load\npid:3480 ImageBase:0x6FC30000\nFullImageName:\\Device\\HarddiskVolume3\\Users\\wind\\Desktop\\MyDll.dll\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\nDetect remote thread create pid:3480 tid:3164 rpid:5336\n\n\n\n9 对象、注册表通知9.1 对象通知驱动可以在打开或复制某些对象的句柄时，收到通知。这些对象的类型可以是进程、线程、Desktop(win10)\n\n\n\n\n\n\n\n\n\nDesktop 对象\n一个desktop包括windows、menus、hooks（SetWindowsHookEx）\n当一个用户登录，两个desktop会被创建。\n一个由Winlogon.exe创建名为Winlogon，就是Secure Attention Sequence（Ctrl+Alt+Del）时的桌面\n一个名为default，就是平常看到的桌面\n使用SwitchDesktop()切换desktop\nhttps://scorpiosoftware.net/2019/02/17/windows-10-desktops-vs-sysinternals-desktops/\n注册对象回调相关定义：\nNTSTATUS ObRegisterCallbacks (\n    _In_ POB_CALLBACK_REGISTRATION CallbackRegistration,\n    _Outptr_ PVOID *RegistrationHandle);\n\ntypedef struct _OB_CALLBACK_REGISTRATION &#123;\n    _In_ USHORT Version;\n    _In_ USHORT OperationRegistrationCount;\t\n    _In_ UNICODE_STRING Altitude;\n    _In_ PVOID RegistrationContext;\n    _In_ OB_OPERATION_REGISTRATION *OperationRegistration;\n&#125; OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;\n\ntypedef struct _OB_OPERATION_REGISTRATION &#123;\n    _In_ POBJECT_TYPE *ObjectType;\n    _In_ OB_OPERATION Operations;\n    _In_ POB_PRE_OPERATION_CALLBACK PreOperation;\n    _In_ POB_POST_OPERATION_CALLBACK PostOperation;\n&#125; OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION\n\nOB_CALLBACK_REGISTRATION：\nVersion：必须设为OB_FLT_REGISTRATION_VERSION\nAltitude：字符串格式的数字，是回调执行的顺序（越小越先执行），必须不能与别的重复（增加随机的小数点后数字）\nAltitude重复会返回STATUS_FLT_INSTANCE_ALTITUDE_COLLISION\nRegistrationContext：驱动定义的传递给回调函数的值\nOB_OPERATION_REGISTRATION：\nObjectType：指向全局变量PsProcessType、PsThreadType、ExDesktopObjectType\nOperations：create/open(OB_OPERATION_HANDLE_CREATE)，duplicate(OB_OPERATION_HANDLE_DUPLICATE)\n9.1.1 Pre-Operation 回调在craete/open/duplicate之前\n回调函数会接收到如下结构体：\n&#x2F;&#x2F; 回调函数定义\nOB_PREOP_CALLBACK_STATUS OnPreOpenProcess(\n    PVOID RegistrationContext,\n    POB_PRE_OPERATION_INFORMATION Info)\n\ntypedef struct _OB_PRE_OPERATION_INFORMATION &#123;\n    _In_ OB_OPERATION Operation; &#x2F;&#x2F; craete&#x2F;open&#x2F;duplicate\n    union &#123;\n        _In_ ULONG Flags;\n        struct &#123;\n            _In_ ULONG KernelHandle:1;\n            _In_ ULONG Reserved:31;\n        &#125;;\n    &#125;;\n    _In_ PVOID Object;\n    _In_ POBJECT_TYPE ObjectType;\n    _Out_ PVOID CallContext; &#x2F;&#x2F; &lt;&#x3D;RegistrationContext\n    _In_ POB_PRE_OPERATION_PARAMETERS Parameters;\n&#125; OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;\n\ntypedef union _OB_PRE_OPERATION_PARAMETERS &#123;\n    _Inout_ OB_PRE_CREATE_HANDLE_INFORMATION CreateHandleInformation;\n    _Inout_ OB_PRE_DUPLICATE_HANDLE_INFORMATION DuplicateHandleInformation;\n&#125; OB_PRE_OPERATION_PARAMETERS, *POB_PRE_OPERATION_PARAMETERS;\n\ntypedef struct _OB_PRE_CREATE_HANDLE_INFORMATION &#123;\n    _Inout_ ACCESS_MASK DesiredAccess;\n    _In_ ACCESS_MASK OriginalDesiredAccess;\n&#125; OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;\n\ntypedef struct _OB_PRE_DUPLICATE_HANDLE_INFORMATION &#123;\n    _Inout_ ACCESS_MASK DesiredAccess;\n    _In_ ACCESS_MASK OriginalDesiredAccess;\n    _In_ PVOID SourceProcess;\n    _In_ PVOID TargetProcess;\n&#125; OB_PRE_DUPLICATE_HANDLE_INFORMATION, *POB_PRE_DUPLICATE_HANDLE_INFORMATION;\n\n\n\n9.1.2 Post-Operation 回调在操作完成后，不能修改任何东西，只能看结果\n回调函数接收以下结构体：\ntypedef struct _OB_POST_OPERATION_INFORMATION &#123;\n    _In_ OB_OPERATION Operation; &#x2F;&#x2F; craete&#x2F;open&#x2F;duplicate\n    union &#123;\n        _In_ ULONG Flags;\n        struct &#123;\n            _In_ ULONG KernelHandle:1;\n            _In_ ULONG Reserved:31;\n        &#125;;\n    &#125;;\n    _In_ PVOID Object;\n    _In_ POBJECT_TYPE ObjectType;\n    _In_ PVOID CallContext; &#x2F;&#x2F; &lt;&#x3D;RegistrationContext\n    _In_ NTSTATUS ReturnStatus;\n    _In_ POB_POST_OPERATION_PARAMETERS Parameters;\n&#125; OB_POST_OPERATION_INFORMATION,*POB_POST_OPERATION_INFORMATION;\n\n\n\n9.2 进程保护驱动（S6）保护进程不被注销（禁止打开具有对应权限的句柄）\n修改进程对象的DesiredAccess即可\n也可以去掉Read、Write的Access，达到禁止读写的目的\n初始化：\nOB_OPERATION_REGISTRATION objOps[] &#x3D; &#123;\n    &#123;\n        PsProcessType,\n        OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE,\n        OnPreOpenProcess, &#x2F;&#x2F; pre\n        nullptr           &#x2F;&#x2F; post\n    &#125;\n&#125;;\nOB_CALLBACK_REGISTRATION objCallback &#x3D; &#123;\n    OB_FLT_REGISTRATION_VERSION,\n    1, &#x2F;&#x2F; count\n    RTL_CONSTANT_STRING(L&quot;12345.114514&quot;), &#x2F;&#x2F; altitude\n    nullptr, &#x2F;&#x2F; context\n    objOps\n&#125;;\nstatus &#x3D; ObRegisterCallbacks(&amp;objCallback, &amp;g_data.regHandle);\nif (status &lt; 0) break;\n\n卸载：\nif(g_data.regHandle)\n\tObUnRegisterCallbacks(g_data.regHandle);\n\n回调函数：\nOB_PREOP_CALLBACK_STATUS OnPreOpenProcess(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION Info) &#123;\n\tUNREFERENCED_PARAMETER(RegistrationContext);\n\n\tif (Info-&gt;KernelHandle)\n\t\treturn OB_PREOP_SUCCESS;\n\n\tauto proc &#x3D; (PEPROCESS)Info-&gt;Object;\n\tauto pid &#x3D; HandleToULong(PsGetProcessId(proc));\n\n\tAutoLock&lt;MyFastMutex&gt; lock(g_data.mutex);\n\n\tif (FindProcess(pid)) &#123;\n\t\tInfo-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess &amp;&#x3D; (~PROCESS_TERMINATE);\n\t&#125;\n\n\treturn OB_PREOP_SUCCESS;\n&#125;\n\n\n\n9.3 注册表通知API：CmRegisterCallbackEx、CmUnRegisterCallback\n回调函数说明（MSDN上的全一点）：EX_CALLBACK_FUNCTION (wdm.h) - Windows drivers | Microsoft Docs\nNTSTATUS RegistryCallback (\n    _In_ PVOID CallbackContext,\n    _In_opt_ PVOID Argument1,\n    _In_opt_ PVOID Argument2);\n\n部分内容：\n\n\n\nNotification(Arg1)\nAssociated structure(Arg2)\n\n\n\nRegNtPreDeleteKey\nREG_DELETE_KEY_INFORMATION\n\n\nRegNtPostDeleteKey\nREG_POST_OPERATION_INFORMATION\n\n\nRegNtPreSetValueKey\nREG_SET_VALUE_KEY_INFORMATION\n\n\nRegNtPostSetValueKey\nREG_POST_OPERATION_INFORMATION\n\n\nRegNtPreCreateKey\nREG_PRE_CREATE_KEY_INFORMATION\n\n\nRegNtPostCreateKey\nREG_POST_CREATE_KEY_INFORMATION\n\n\nPre\n回调函数可以做的事：\n\n返回STATUS_SUCCESS，让配置管理器继续处理注册表操作\n返回一些错误状态，让配置管理器不执行操作，并将该错误状态返回给调用方\n处理请求，并返回STATUS_CALLBACK_BYPASS，配置管理器不执行任何操作，并将返回成功状态\n\nPost\n回调函数可以做的事：\n\n监视操作结果\n修改返回给调用方的状态（ReturnStatus），然后回调函数返回STATUS_CALLBACK_BYPASS\n修改返回的参数（REG_xxx_KEY_INFORMATION ），然后回调函数返回STATUS_SUCCESS\n\n性能注意事项\n注册表的读操作经常发生，驱动应避免处理读操作如果确实需要处理读操作，应限制只处理某些key\n写和创建操作相对比较少\n底线很简单：为尽可能少的键做尽可能少的事情 \n9.4 实现注册表通知拓展S5_SysMon，记录RegNtPostSetValueKey且在HKEY_LOCAL_MACHINE目录下的注册表操作\n&#x2F;&#x2F; register\nUNICODE_STRING altitude &#x3D; RTL_CONSTANT_STRING(L&quot;7657.114514&quot;);\nstatus &#x3D; CmRegisterCallbackEx(\n    OnRegistryNotify,\n    &amp;altitude,\n    g_data.pDriverObj,\n    nullptr,\n    &amp;g_data.regCookie,\n    nullptr);\n\n&#x2F;&#x2F; unregister\nstatus &#x3D; CmUnRegisterCallback(g_data.regCookie);\n\n&#x2F;&#x2F; callback\nNTSTATUS OnRegistryNotify(_In_ PVOID CallbackContext, _In_opt_ PVOID Argument1, _In_opt_ PVOID Argument2) &#123;\n\tUNREFERENCED_PARAMETER(CallbackContext);\n\n\tstatic const WCHAR machine[] &#x3D; L&quot;\\\\REGISTRY\\\\MACHINE\\\\&quot;;\n\n\tauto status &#x3D; STATUS_SUCCESS;\n\n\tswitch ((REG_NOTIFY_CLASS)(ULONG_PTR)Argument1) &#123;\n\tcase RegNtPostSetValueKey: &#123;\n\t\tauto args &#x3D; (PREG_POST_OPERATION_INFORMATION)Argument2;\n\t\tif (!args) break;\n\t\tif (args-&gt;Status &lt; 0) break;\n\t\t\n\t\tPCUNICODE_STRING name &#x3D; nullptr;\n\t\tstatus &#x3D; CmCallbackGetKeyObjectIDEx(&amp;g_data.regCookie, args-&gt;Object, nullptr, &amp;name, 0);\n\t\tif (status &lt; 0) break;\n\n\t\tif (wcsncmp(name-&gt;Buffer, machine, ARRAYSIZE(machine) - 1) &#x3D;&#x3D; 0) &#123;\n\t\t\tauto preInfo &#x3D; (PREG_SET_VALUE_KEY_INFORMATION)args-&gt;PreInformation;\n\t\t\t&#x2F;&#x2F;if (!preInfo) break;\n\n\t\t\t&#x2F;&#x2F; alloc\n\t\t\tauto allocSize &#x3D; sizeof(RecordEntry&lt;RegistrySetValueInfo&gt;);\n\t\t\tauto recordEntry &#x3D; (RecordEntry&lt;RegistrySetValueInfo&gt;*)ExAllocatePoolWithTag(\n\t\t\t\tPagedPool,\n\t\t\t\tallocSize,\n\t\t\t\tDRIVER_TAG);\n\t\t\tif (recordEntry &#x3D;&#x3D; nullptr) break;\n\t\t\tRtlZeroMemory(recordEntry, allocSize);\n\t\t\t\n\t\t\tauto&amp; record &#x3D; recordEntry-&gt;Data;\n\t\t\trecord.type &#x3D; RecordType::RegistrySetValue;\n\t\t\trecord.size &#x3D; sizeof(RegistrySetValueInfo);\n\t\t\tKeQuerySystemTimePrecise(&amp;record.time);\n\t\t\trecord.pid &#x3D; HandleToULong(PsGetCurrentProcessId());\n\t\t\trecord.tid &#x3D; HandleToULong(PsGetCurrentThreadId());\n\t\t\twcsncpy_s(record.keyName, name-&gt;Buffer, name-&gt;Length &#x2F; sizeof(WCHAR) - 1);\n\t\t\twcsncpy_s(record.valueName, preInfo-&gt;ValueName-&gt;Buffer, preInfo-&gt;ValueName-&gt;Length &#x2F; sizeof(WCHAR) - 1);\n\t\t\trecord.dataType &#x3D; preInfo-&gt;Type;\n\t\t\trecord.dataSize &#x3D; preInfo-&gt;DataSize;\n\t\t\tmemcpy(record.data, preInfo-&gt;Data, min(record.dataSize, sizeof(record.data)));\n\n\t\t\tPushRecord(&amp;recordEntry-&gt;Entry);\n\t\t&#125;\n\n\t\tCmCallbackReleaseKeyObjectIDEx(name);\n\n\t\tbreak;\n\t&#125;\n\tdefault:\n\t\tbreak;\n\t&#125;\n\n\treturn status;\n&#125;\n\n\n\n9.5 练习\n实现一个驱动程序，除非目标进程正在被调试，否则不允许被线程注入。（todo）\n\n实现一个驱动程序，保护注册表不被修改。客户端可以选择被保护的键。（todo）\n\n实现一个驱动程序，如果它们访问 HKEY_LOCAL_MACHINE，则将来自选定进程（由客户端选择）的注册表写入操作重定向到它们自己的私钥。 如果应用程序正在写入数据，它会转到其私有存储。如果是读取数据，首先检查私有存储，如果没有值，则转到真正的注册表项。这是应用程序沙盒的一个方面。（todo）\n\n\n总结：通知的注册与注销这里直接使用9.4中的练习：添加 I/O control codes 来 enable/disable 通知类型\n使用了bitmap来选择开启或关闭的通知\n这里整个函数都在互斥锁中（和记录通知的LIST_ENTRY用的同一个FAST_MUTEX），也就是不能同时修改bitmap，同时修改bitmap时、也无法向LIST_ENTRY中插入新记录的通知\nvoid SetNotify(UINT8 newBmNotify) &#123;\n\tAutoLock&lt;MyFastMutex&gt; lock(g_data.mutex);\n\tNTSTATUS status;\n\tUINT8 dif &#x3D; g_data.bmNotify ^ newBmNotify;\n\n\tdo &#123;\n\t\t&#x2F;&#x2F; process notification \n\t\tif (dif &amp; SYS_MON_PROCESS_NOTIFY) &#123;\n\t\t\tif (newBmNotify &amp; SYS_MON_PROCESS_NOTIFY)&#123;\n\t\t\t\tKdPrint((&quot;[s5]Process On&quot;));\n\t\t\t\tstatus &#x3D; PsSetCreateProcessNotifyRoutineEx(OnProcessNotify, false);\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\tKdPrint((&quot;[s5]Process Off&quot;));\n\t\t\t\tstatus &#x3D; PsSetCreateProcessNotifyRoutineEx(OnProcessNotify, true);\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F; thread notification\n\t\tif (dif &amp; SYS_MON_THREAD_NOTIFY) &#123;\n\t\t\tif (newBmNotify &amp; SYS_MON_THREAD_NOTIFY) &#123;\n\t\t\t\tKdPrint((&quot;[s5]Thread On&quot;));\n\t\t\t\tstatus &#x3D; PsSetCreateThreadNotifyRoutine(OnThreadNotify);\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\tKdPrint((&quot;[s5]Thread Off&quot;));\n\t\t\t\tstatus &#x3D; PsRemoveCreateThreadNotifyRoutine(OnThreadNotify);\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F; image load notification\n\t\tif (dif &amp; SYS_MON_IMAGE_LOAD_NOTIFY) &#123;\n\t\t\tif (newBmNotify &amp; SYS_MON_IMAGE_LOAD_NOTIFY) &#123;\n\t\t\t\tKdPrint((&quot;[s5]Image Load On&quot;));\n\t\t\t\tstatus &#x3D; PsSetLoadImageNotifyRoutine(OnImageNotify);\n\t\t\t&#125;\n\t\t\telse&#123;\n\t\t\t\tKdPrint((&quot;[s5]Image Load Off&quot;));\n\t\t\t\tstatus &#x3D; PsRemoveLoadImageNotifyRoutine(OnImageNotify);\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F; register notification\n\t\tif (dif &amp; SYS_MON_REGISTRY_SET_VALUE_NOTIFY) &#123;\n\t\t\tif (newBmNotify &amp; SYS_MON_REGISTRY_SET_VALUE_NOTIFY) &#123;\n\t\t\t\tKdPrint((&quot;[s5]Registry Set Value On&quot;));\n\t\t\t\tUNICODE_STRING altitude &#x3D; RTL_CONSTANT_STRING(L&quot;7657.114514&quot;);\n\t\t\t\tstatus &#x3D; CmRegisterCallbackEx(\n\t\t\t\t\tOnRegistryNotify,\n\t\t\t\t\t&amp;altitude,\n\t\t\t\t\tg_data.pDriverObj,\n\t\t\t\t\tnullptr,\n\t\t\t\t\t&amp;g_data.regCookie,\n\t\t\t\t\tnullptr);\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\tKdPrint((&quot;[s5]Registry Set Value Off&quot;));\n\t\t\t\tstatus &#x3D; CmUnRegisterCallback(g_data.regCookie);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125; while (false);\n\n\tg_data.bmNotify &#x3D; newBmNotify;\n&#125;\n\n\n\n练习8，p196，使用注册表来设置保存的信息的最大数量（todo）\n8，p199，添加映像文件名到进程创建信息结构中（见S5_SysMon）\n8，p207，给客户端添加功能：显示线程创建和销毁时所属的进程的映像名（todo）\n8，p209，给驱动添加功能：只记录R3的映像加，客户端显示映像路径、pid、基址（见S5_SysMon）\n8.6，p209，Exercises（todo）\n9.2，p226，添加允许查询当前受保护进程的控制代码（todo）\n9.4，p235，改进 S5_SysMon， 添加 I/O control codes 来 enable/disable 通知类型（见总结：通知的注册与注销）\n9.5，p235，Exercises（todo）\n问题8.6练习，如何通知R3客户端\n勘误8\np207，PsRemoveImageNotifyRoutine应该为PsRemoveLoadImageNotifyRoutine\n","slug":"wkp8-9","date":"2022-03-01T04:00:00.000Z","categories_index":"Windows","tags_index":"windows,note,kernel,wkp","author_index":"御史神风"},{"id":"9e0e6e8e4af299f867f70b1bab4c4ab9","title":"SFU Compilers class 笔记1","content":"SFU Compilers 笔记1 简介week1 hw0\nWeek 1 Introduction to CompilersIN1 Evangelize Compliers内容：\n\nLexing-词法分析\nParsing-句法分析\nType analysis-类型分析\n代码生成和优化\n\n分析下面这两段代码：\nvoid send (char *to, char *from, int count)\n&#123; \n    while (count-- &gt; 0)\n    *to++ &#x3D; *from++;\n&#125;\n\n\nvoid send2 (char *to, char *from, int count)\n&#123; \n    int n &#x3D; (count+7)&#x2F;8; \n    switch (count % 8) &#123; \n    case 0: do &#123; *to++ &#x3D; *from++; \n    case 7: \t *to++ &#x3D; *from++; \n    case 6: \t *to++ &#x3D; *from++; \n    case 5: \t *to++ &#x3D; *from++; \n    case 4: \t *to++ &#x3D; *from++; \n    case 3: \t *to++ &#x3D; *from++; \n    case 2: \t *to++ &#x3D; *from++; \n    case 1: \t *to++ &#x3D; *from++;\n    \t&#125; while(--n &gt; 0); \n    &#125;\n&#125;\n\n第二个switch实际上就是一个goto，跳到do-while循环里\nIN2 Trusting TrustQuine是一个生成自身源代码的程序\nc语言例子，源代码编译出来的可执行程序会输出源代码：\n#include &lt;stdio.h&gt;\nint main()&#123;char *c&#x3D;&quot;#include &lt;stdio.h&gt;%cint main()&#123;char \n*c&#x3D;%c%s%c;printf(c,10,34,c,34,10);&#125;%c&quot;;printf(c,10,34,c,34,10);&#125;\n\n\n\n编译器也有源代码，也需要编译器的编译器来把编译器的源代码编译成编译器\n源代码 不等于 编译出来的可执行文件\n编译器可以插入恶意二进制指令到编译结果中这时编译器的源码是恶意的，而被编译程序的源码是正常的\n更进一步的，编译器的编译器可能会恶意插入指令到编译器中既编译器的源码是正常的，但编译出来的编译器被插入了恶意指令\nIN3 What is a Compiler编译器的需求\n\n支持高级语言特性\n易读的错误信息\n编译速度\n可执行文件速度\n\nBootstrapping a Compiler\n\n先使用机器代码\n制作语言的简单的子集，为其写编译器\n用子集完成语言剩余部分\n解释器：用低级语言写编译器（比如python解释器用C语言编写）\n交叉编译\n\nModern challenges\n\n指令并行性（乱序执行、分支预测）\n并行算法（网格计算、多核计算机）\n内存层级结构：寄存器、缓存、内存\n新架构：GPU、量子计算机、DNA计算机\n硬件级优化（终端内循环优化）\n\nIN4 Stages of a CompilerBuilding a compiler\n编译器的编译器：\n\nyacc = yet another compiler compiler\nbison = yacc的一个版本，GNU项目\n\nStages of a Compiler\n\n分析（前端）\n词法分析（Lexing）\n语法分析（Sytax、Parsing）\n语义分析（类型检查）\n\n\n合成（后端）\n中间代码生成\n代码优化\n代码生成\n\n\n\nhw0windows配置获取作业文件：\ngit clone https:&#x2F;&#x2F;github.com&#x2F;anoopsarkar&#x2F;compilers-class-hw.git\n\n\n\nrmprefix目录中有用于测试的python脚本\nanswer/default.cc为未完成的作业，复制为answer/rmprefix.cc并完成\npython zipout.py：在测试集上运行，并得到结果\npython check.py：检测结果的正确率\nwindows平台操作指南：\n在answer目录下使用powshell编译\ng++ rmprefix.cc -o rmprefix.\n\n在rmprefix目录下使用wsl\npython3 zipout.py\npython3 check.py\n\n\n\n解决方案解决方案1：\nline.erase(0, line.find_first_not_of(&#39;\\t&#39;));\nline.erase(0, line.find_first_not_of(&#39; &#39;));\n\n解决方案2：\nint fn &#x3D; 0;\nfor (fn &#x3D; 0; line[fn]; fn++)&#123;\n    if(line[fn] &#x3D;&#x3D; &#39; &#39;)\n    \tcontinue;\n    if(line[fn] &#x3D;&#x3D; &#39;\\t&#39;)\n    \tcontinue;\n    break;\n&#125;\nline.erase(0, fn);\n\n","slug":"SFU-Compilers-1","date":"2022-02-27T04:00:00.000Z","categories_index":"CS","tags_index":"note,cs,compiler","author_index":"御史神风"},{"id":"08a6adcddaf28cd0d0b42adf778ccd2a","title":"《Windows Kernel Programming》 笔记 6~7 内核机制与IRP","content":"Windows Kernel Programming 笔记 6~7 内核机制与IRP6 内核机制关于windows内核提供的一些机制。这些机制，驱动开发会使用，或者有关。\n6.1 中断优先级中断处理例程（Interrupt Service Routine，ISR）\n中断优先级（Interrupt Request Level，IRQL）：每个硬件中断关联的一个优先级\n每个处理器有自身的IRQL\nIRQL可以等价于CPU的一个寄存器\n所有ISR都运行在发生中断前的线程的上下文中\n\n\n\n\n\n\n\n\n\nThe interrupted thread does not get its quantum reduced because of these “interruptions”. It’s not its fault, so to speak.\nIRQL：\n\nPASSIVE_LEVEL（0）：R3及大多数R0代码工作于此优先级。可以线程调度。\nAPC_LEVEL（1）：特殊的内核APC。可以线程调度。\nDISPATCH_LEVEL（2）：调度器被屏蔽；页池(Paged memory)不能访问；不允许等待内核对象（这回造成系统崩溃）\nDevice IRQL：硬件中断\nHIGH_LEVEL：屏蔽所有中断；通常用于处理链表的API（原子性）\n\n当 IRQL &gt;= 2：\n\n访问页池是危险的，应只使用非页池内存\n等待内核对象会导致系统崩溃（如果等待超时为0则被允许，用于同步）\n\n调度器“运行”在IRQL2，IRQL&gt;=2时调度器将被屏蔽\n[windbg]：! irql查看当前cpu IRQL\n[windbg]：! idt 查看已注册的中断\n提高和降低IRQL\nKIRQL oldIrql;\nKeRaiseIrql(DISPATCH_LEVEL, &amp;oldIrql);\n&#x2F;&#x2F; pass\nKeLowerIrql(oldIrql);\n\n\n\n线程优先级与IRQL\nIRQL是处理器的属性\n线程优先级只有在IRQL&lt;2时才有意义\n任务管理器中以伪进程 系统中断 显示IRQL&gt;=2的运行时间\n6.2 DPC延迟过程调用，Deferred Procedure Calls，DPC\n硬件中断的IRQl&gt;2，IoCompleteRequest只能在IRQL&lt;=DISPATCH_LEVEL(2)时调用\n\n\n\n\n\n\n\n\n\n如果不用DPC，而是选择降低IRQL调用IoCompleteRequest，再提升回去，会造成死锁，原因见 Spin Lock 章节\nDPC机制用于允许ISR尽快调用IoCompleteRequest\n每个cpu有一个DPC队列，KeInsertQueueDpc默认把DPC入队当前CPU\n当ISR返回时，在IRQL降为0前，会检测DPC队列\n如果DPC队列不为空，则IRQL降到2，然后处理DPC队列直到为空\n执行完再降IRQL为0并返回到中断前的代码\n带定时器的DPC\n不是所有的DPC都是由ISR创建的，有些系统机制也会创建DPC，比如内核计时器（KTIMER）\n以下代码是将定时器关联到DPC的示例\nKTimer Timer;\nKDPC TimerDpc;\n\nvoid InitAndStartTimer(ULONG msec) &#123;\n    KeInitializeTimer(&amp;Timer);\n    KeInitializeDpc(&amp;TimerDpc,\n                    OnTimerExpired, &#x2F;&#x2F; callback\n                    nullptr);       &#x2F;&#x2F; passed to callback as &quot;context&quot;\n    \n    &#x2F;&#x2F; relative interval is in 100nsec units (and must be negative)\n    LARGE_INTEGER interval;\n    interval.QuadPart &#x3D; -10000LL * msec;\n    KeSetTimer(&amp;Timer, interval, &amp;TimerDpc);\n&#125;\n\nvoid OnTimerExpried(KDPC* Dpc, PVOID context, PVOID, PVOID) &#123;\n    UNREFERENCED_PARAMETER(Dpc);\n    UNREFERENCED_PARAMETER(context);\n    \n    &#x2F;&#x2F; pass\n&#125;\n\n\n\n6.3 APC异步过程调用，Asynchronous Procedure Calls，APC\n每个线程都有一个关联的APC队列\nAPC类型：\n\nR3 APC：在R3下，只有在线程进入alertable state时，以PASSIVE_LEVEL运行通常通过调用API实现，如：SleepEx、WaitForSingleObjectEx或类似的API等这些函数最后一个参数可以设置线程于alertable state，这时线程会检测APC队列直到为空\n正常R0 APC：在R0下，以PASSIVE_LEVEL运行并抢占R3代码和R3 APC\n特殊R0 APC：在R0下，以APC_LEVEL抢占R3代码、R3 APC、普通R0 APC这些APC被IO系统用于完成IO操作\n\nCritical Regions and Guarded Regions\nCritical Region 阻止 R3、正常R0 APC 运行\nKeEnterCriticalRegion，KeLeaveCriticalRegion\nGuarded Region 阻止所有 APC 运行\nKeEnterGuardedRegion，KeLeaveGuardedRegion\n6.4 SEH结构化异常处理，Structured Exception Handling，SEH\n由指令引起CPU错误会触发异常\n异常类似于中断，区别是异常是同步、可重现的，中断是异步且随时发生的（这里应该是说异常的发生与代码的执行有关，比如坏的闹钟每个早上都不会响而中断是突发的，比如突然发生了地震）\n异常的例子：除0(0)、断点(3)、无效指令(6)、换页错误(14)、栈溢出\n内核异常处理基于IDT（中断调用表，Interrupt Dispatch Table）\n低编号的 中断向量 实际上是 异常处理程序\n引发异常后，会在异常发生的地方搜索处理函数（除了透明处理的异常，如断点）如果找不到，就会向上搜索调用堆栈，直到系统崩溃\n驱动、R3都可以用SEH机制来抛出自定义异常\n使用（c++）RAII包装来确保资源被正确释放\n6.5 系统崩溃如果内核发生未处理的异常，系统就会崩溃通常称为蓝屏（Blue Screen of Death，BSOD）\n蓝屏是一种保护机制，防止崩溃后执行非预期操作修改系统如注册表等、造成不可逆错误\n可以设置系统在系统崩溃时执行一些操作（win10改了设置不知道怎么搞233）\n崩溃转储信息\n[windbg]：!analyze -v，最常用的初步分析dump的指令\n\n\n\n\n\n\n\n\n\n帮助诊断此类问题的一种方法是使用 Driver Verifier。 将在模块 11 中了解 Driver Verifier\n\n\n\n\n\n\n\n\n\n获得故障转储代码后，查看主题为“Bugcheck Code Reference”的windbg文档会很有帮助\n分析转储文件\n转储文件是系统的快照\n!process、!thread、lm、k等指仍能正常使用\n[windbg]：~ns，切换cpu，n是cpu索引（R3是切换线程）\n[windbg]：!running，列出崩溃时所有cpu上的线程；-t，显示线程的调用堆栈\n[windbg]：!stack，列出所有线程的调用堆栈；!stack 0 str ，列出模块或函数名中包含str的线程调用堆栈\n系统挂起\n有时候系统会死循环，不崩溃。系统内核工具NotMyFault可以强制系统崩溃，进而生成转储文件\n如果系统无响应但连接了调试器，且事先在注册表中配置，可以通过组合键产生崩溃这种情况崩溃代码是0xe2（MANUALLY_INITIATED_CRASH）\n6.6 线程同步驱动可能被多个客户端调用，必须以原子方式操作链表 \n内核提供几个原语（primitive）帮助同步，保护数据的并发访问\n6.6.1 InterlockedInterlocked 函数集由硬件提供原子性，非常高效，尽量使用这些函数\n一些驱动使用的Interlocked函数：\n\nInterlockedIncrement/16/ /64\nInterlockedDecrement/16/ /64\nInterlockedAdd/ /64\nInterlockedExchange/8/16/ /64\nInterlockedCompareExchange/ /64/128\n\n\n\n\n\n\n\n\n\n\nInterlockedCompareExchange用于无锁编程，无需使用软件对象实现复杂原子操作\n\n\n\n\n\n\n\n\n\nInterlocked函数在R3下也可用，本质上这些是特殊的CPU指令\n6.6.2 Dispatcher/Waitable 对象内核提供了一组称为 Dispatcher Objects 的原语，也称为 Waitable Objects\n这些对象有一个状态称为有信号和无信号 \n常见 Disapatcher 对象的 signaled 和 nonsignaled 的含义：\n\n\n\n对象类型\nSignal\nNon-Signal\n\n\n\nProcess\n进程已终止\n进程尚未终止\n\n\nThread\n线程已终止\n线程尚未终止\n\n\nMutex\nfree\nheld\n\n\nEvent\nset\nreset\n\n\nSemaphore\n计数大于0\n计数为0\n\n\nTimer\n已过期\n未过期\n\n\nFile\n异步IO完成\n异步IO处理中\n\n\n6.6.3 Mutex互斥锁在空闲时设为有信号\n当一个线程调用一个等待函数等待互斥对象，等待结束后（互斥锁空闲、有信号），互斥锁会马上上锁（无信号），此时该线程成为互斥锁的持有者\n使用示例：\nKMUTEX myMutex;\nLIST_ENTRY data;\n\nvoid Init() &#123;\n    KeInitializeMutex(&amp;myMutex, 0);\n&#125;\n\nvoid DoWork() &#123;\n    &#x2F;&#x2F; wait for mutex to be free, then held the mutex automatically\n    KeWaitForSingleObject(&amp;myMutex, Executive, KernelMode, FALSE, nullptr);\n    \n    __try &#123;\n    \t&#x2F;&#x2F; access data\n    &#125;\n    __finally &#123;\n        &#x2F;&#x2F; release\n    \tKeReleaseMutex(&amp;myMutex, false);\n    &#125;\n&#125;\n\n\n\nRAII包装：\n首先包装mutex，提供初始化、上锁、解锁的接口：\n&#x2F;&#x2F; mutex wrapper\nstruct MyMutex &#123;\n    void Init() &#123;\n        KeInitializeMutex(&amp;_mutex, false);\n    &#125;\n    \n    void Lock()&#123;\n        KeWaitForSingleObject(&amp;_mutex, Executive, KernelMode, FALSE, nullptr);\n    &#125;\n    \n    void Unlock()&#123;\n        KeReleaseMutex(&amp;_mutex, false);\n    &#125;\n    \nprivate:\n    KMUTEX _mutex;\n&#125;\n\n然后包装一个自动锁类型，自动上锁、解锁：（利用变量的自动初始化和析构）\n&#x2F;&#x2F; lock wrapper\ntemplate&lt;typename TLock&gt;\nstruct AutoLock &#123;\n    AutoLock(TLock&amp; lock) : _lock(lock) &#123;\n        lock.Lock();\n    &#125;\n    \n    ~AutoLock() &#123;\n        _lock.Unlock();\n    &#125;\n\nprivate:\n    TLock&amp; _lock;\n&#125;;\n\n使用示例：\nMyMutex myMutex;\n\nvoid Init() &#123;\n    myMutex.Init();\n&#125;\n\nvoid DoWork() &#123;\n    AutoLock&lt;MyMutex&gt; autolock(myMutex);\n    \n    &#x2F;&#x2F; access data\n&#125;\n\n\n\n6.6.4 Fast MutexFast Mutex 是 Mutex 的替代，不一样的特点如下：\n\n无法递归获取，这会造成死锁\n当获取 Fast Mutex 时，IRQL被提升到APC_LEVEL(1)\nFast Mutex 只能无限期等待，无法指定超时时限\n\n\n\n\n\n\n\n\n\n\nfast mutex只能在R0使用，R3只能用mutex\nRAII包装示例：\nclass MyFastMutex &#123;\npublic:\n    void Init();\n    void Lock();\n    void Unlock();\nprivate:\n    FAST_MUTEX _mutex;\n&#125;;\n\nvoid MyFastMutex::Init() &#123;\n    ExInitializeFastMutex(&amp;_mutex);\n&#125;\n\nvoid MyFastMutex::Lock() &#123;\n    ExAcquireFastMutex(&amp;_mutex);\n&#125;\n\nvoid MyFastMutex::Unlock() &#123;\n    ExReleaseFastMutex(&amp;_mutex);\n&#125;\n\n&#123;\n    &#x2F;&#x2F; init\n    MyFastMutex myFastMutex;\n    myFastMute.Init();\n    \n    &#x2F;&#x2F; auto lock and unlock\n    &#123;\n        AutoLock&lt;MyFastMutex&gt; autolock(myFastMutex);\n    &#125;\n&#125;\n\n\n\n6.6.5 Semaphore信号量的主要目标是限制某些东西，例如队列的长度\n当它的内部计数大于零时，信号量设为有信号 \nKeInitializeSemaphore();\nKeWaitForSingleObject(); &#x2F;&#x2F; Semaphore -1\nKeReleaseSemaphore(); &#x2F;&#x2F; Semaphore +\n\n\n\n6.6.6 Event一个事件封装了一个布尔值，表示是否有信号\n事件在初始化时可以设为手动或自动重置\n\n手动重置：当事件有信号，且被等待成功后，仍然有信号，所以等待线程都会被唤醒\n自动重置：当事件有信号，且被等待成功后，会变成无信号，只有一个等待线程会被唤醒\n\n通过在非页池中分配 KEVENT 来创建事件\n6.6.7 Executive Resource互斥锁本质上是并发杀手（原文），因为一次只能执行一个线程\n对于读写操作分开的情况，内核提供另一种原语，称为单写入器、多读取器\n这个对象是Executive Resource，这不是一个dispatcher对象\n通过在非页池中分配 ERESOURCE 并调用 ExInitializeResourceLite() 来初始化\n获取排他锁（写锁）ExAcquireResourceExclusiveLite()\n获取共享锁（读锁）ExAcquireResourceSharedLite()\n获取和释放锁都需要屏蔽 普通R0APC（Critical Region）\n示例：\nERESOURCE resource;\n\nvoid WriteData() &#123;\n    KeEnterCriticalRegion();\n    ExAcquireResourceExclusiveLite(&amp;resource, TRUE);\n    \n    &#x2F;&#x2F; write data\n    \n    ExReleaseResourceLite(&amp;resource);\n    KeLeaveCriticalRegion();\n&#125;\n\nvoid WriteData() &#123;\n    ExEnterCriticalRegionAndAcquireResourceExclusive(&amp;resource, TRUE);\n    \n    &#x2F;&#x2F; write data\n    \n    ExReleaseResourceAndLeaveCriticalRegion(&amp;resource);\n&#125;\n\n\n\n（练习）RAII包装示例：// todo\nclass MyResource &#123;\npublic:\n    void Init();\n    void ReadLock();\n    void WriteLock();\n    void Unlock();\n\t\nprivate:\n    ERESOURCE _resource;\n&#125;\n\nvoid MyResource::Init() &#123;\n    ExInitializeResourceLite(&amp;_resource);\n&#125;\n\nvoid MyResource::ReadLock() &#123;\n    ExEnterCriticalRegionAndAcquireSharedExclusive(&amp;_resource， TRUE);\n&#125;\n\nvoid MyResource::WriteLock() &#123;\n    ExEnterCriticalRegionAndAcquireResourceExclusive(&amp;_resource， TRUE);\n&#125;\n\nvoid MyResource::Unlock() &#123;\n    ExReleaseResourceAndLeaveCriticalRegion(&amp;_resource);\n&#125;\n\ntemplate&lt;typename TLock&gt;\nstruct AutoLockEx &#123;\n    AutuLock(TLock&amp; lock, BOOL isWrite) : _lock(lock) &#123;\n        if(isWrite)\n        \tlock.WriteLock();\n        else\n            lock.ReadLock();\n    &#125;\n    \n    ~AutoLock() &#123;\n        _lock.Unlock();\n    &#125;\n\nprivate:\n    TLock&amp; _lock;\n&#125;\n\n\n\n6.7 高IRQL下的同步当 IRQL&gt;=2（DISPATCH_LEVEL或更高）时线程不能等待，意味着不能用上面的东西来实现同步\n比如IRQL0的代码和DPC共用一个资源，或者两个cpu的DPC同时使用一个资源的时候\n前者在IRQL0的代码中临时提升IRQL到2可以避免DPC的干扰\n在多CPU系统中需要使用 Spin Lock\nSpin Lock\n自旋锁是内存中的一个简单位，它通过 API 提供原子测试和修改操作 \n创建自旋锁需要在非页池中分配 KSPIN_LOCK\n获取自旋锁有两步：提升IRQL到合适级别；获取自旋锁\n（合适级别指所有使用该资源的代码的最高级别）\n获取和释放自旋锁的API会执行上述两个步骤\n\n\n\nIRQL\n获取\n释放\n\n\n\n\n2\nKeAcquireSpinLock\nKeReleaseSpinLock\n\n\n\n2\nKeAcquireSpinLockAtDpcLevel\nKeReleaseSpinLockFromDpcLevel\n(1)\n\n\nDevice IRQL\nKeAcquireInterruptSpinLock\nKeReleaseInterruptSpinLock\n(2)\n\n\nHIGH_LEVEL\nExInterlockedXxx\n(none)\n(3)\n\n\n(1) 只可以在IRQL=2的时候调用（API只获取或释放锁，不修改IRQL）\n(2) 用于将 ISR 与任何其他功能同步。 具有中断源的基于硬件的驱动程序使用这些例程。参数是一个中断对象——自旋锁是它的一部分\n(3) 用于操作基于 LIST_ENTRY 的链表的 3 个函数。这些函数使用提供的自旋锁并将 IRQL 提升到 HIGH_LEVEL。由于高 IRQL，这些例程可以在任何情况下使用，且总是安全的\n\n\n\n\n\n\n\n\n\n确保自旋锁在同一个函数获取和释放，否则会造成死锁\n\n\n\n\n\n\n\n\n\nCancel 自旋锁是一个特例，由内核在调用驱动的取消例程之前获取，由驱动释放\n\n\n\n\n\n\n\n\n\n通常当多个CPU竞争一个自旋锁，电子速度快的CPU获胜。\n内核提供另一种队列自旋锁用于处理这种竞争\nKeAcquireInStackQueuedSpinLock\nKeReleaseInStackQueuedSpinLock\n6.8 Work Item内核提供了创建单独运行的线程的函数：PsCreateSystemThread、IoCreateSystemThread如果驱动程序需要在后台长时间运行代码，这些函数是合适的\n对于有时间限制的操作，最好使用内核提供的线程池，它将在某个系统工作线程上执行您的代码\n\n\n\n\n\n\n\n\n\n首选 IoCreateSystemThread，因为它允许将设备或驱动程序对象与线程相关联\n\n\n\n\n\n\n\n\n\n驱动程序创建的线程必须调用 PsTerminateSystemThread 来终止自身。 如果成功，此函数永远不会返回。 \nWork Item 描述的是一些在系统线程池队列中的函数\n看起来与DPC非常相似，主要区别是Work Item总是在IRQL 0这意味着当DPC需要执行IRQL2不能执行的操作时，可以使用 work item\n创建和初始化一个work item的两种方法：\n\n使用 IoAllocateWorkItem() 分配和初始化work item该函数返回 IO_WORKITEM 结构体的指针work item完成后必须使用 IoFreeWorkItem()\n根据 IoSizeofWorkItem() 动态分配一个 IO_WORKITEM然后调用 IoInitializeWorkItem()work item完成后必须使用 IoUninitializeWorkItem()\n\n使用 IoQueueWorkItem() 查询已有 work item：\nvoid IoQueueWorkItem(\n    _Inout_ PIO_WORKITEM IoWorkItem,         &#x2F;&#x2F; the work item\n    _In_ PIO_WORKITEM_ROUTINE WorkerRoutine, &#x2F;&#x2F; the function to be called\n    _In_ WORK_QUEUE_TYPE QueueType,          &#x2F;&#x2F; queue type\n    _In_opt_ PVOID Context);                 &#x2F;&#x2F; driver-defined value\n\n\n\nIO_WORKITEM_ROUTINE 回调函数：\nvoid WorkerRoutine(\n    _In_ PDEVICE_OBJECT DeviceObject,\n    _In_opt_ PVOID Context\n);\n\n\n\n系统线程池有多个队列，基于不同的线程优先级，WORK_QUEUE_TYPE 枚举：\ntypedef enum _WORK_QUEUE_TYPE &#123;\n    CriticalWorkQueue,      &#x2F;&#x2F; priority 13\n    DelayedWorkQueue,       &#x2F;&#x2F; priority 12\n    HyperCriticalWorkQueue, &#x2F;&#x2F; priority 15\n    NormalWorkQueue,        &#x2F;&#x2F; priority 8\n    BackgroundWorkQueue,    &#x2F;&#x2F; priority 7\n    RealTimeWorkQueue,      &#x2F;&#x2F; priority 18\n    SuperCriticalWorkQueue, &#x2F;&#x2F; priority 14\n    MaximumWorkQueue,\n    CustomPriorityWorkQueue &#x3D; 32\n&#125; WORK_QUEUE_TYPE;\n\n文档表明必须使用 DelayedWorkQueue，但实际上可以使用任意支持的级别\n7 IRP典型的驱动在 DriverEntry 中完成初始化后，其主要工作是处理请求\n这些请求被打包为半文档化的 I/O Request Packet（IRP）结构\n本章关于了解IRP，及驱动如何处理常见的IRP\n7.1 IRP简介IRP在非页池\nallocated by one of the “managers” in  the Executive(I/O Manager, Plug &amp; Play Manager, Power Manager) ，也可以由驱动分配，用于将请求传递给另外一个驱动\nIRP通常伴随着一个或多个 IO_STACK_LOCATION\n分配IRP时必须指定由多少个 IO_STACK_LOCATION\nIO_STACK_LOCATION 的数量 = 设备堆栈中设备对象的数量\n使用宏 IoGetCurrentIrpStackLocation  获取当前的 IO_STACK_LOCATION\n7.2 设备栈IO系统以设备为中心：\n\n可以命名设备对象并且可以打开设备对象的句柄CreateFile 函数接受指向设备对象名称的符号链接CreateFile 不能接受驱动程序的名称作为参数\n设备可以堆叠，发送到较低设备的请求将先到达最上层\n\n堆叠的一组设备称为设备栈（device stack）或设备节点（device node）\n设备栈例子：\n（上层）\nFiDO\nFiDO\nFDO\nFiDO\nFiDO\nPDO\n（底层）\n\nFiDO（Filter Device Object）：可选的过滤驱动创建的过滤设备\nFDO（Functional Device Object）：由“真正”的驱动创建的；这些驱动通常由硬件供应商提供\nPDO（Physical Device Object）：由总线驱动(bus driver，负责特定总线，例如PCI、USB)创建；该设备对象表示该总线上的插槽中存在某个设备\n例子：\nP&amp;P管理器（Plug &amp; Play manager）负责从底部开始加载驱动\n创建设备栈的事件序列总结如下：\n\nPCI总线驱动程序 (pci.sys) 识别出插槽中存在硬件，创建一个PDO (IoCreateDevice)\nPCI总线企业的程序 通知 P&amp;P管理器 它的总线发生了变化\nP&amp;P管理器 向 总线驱动 请求PDO链表，该链表包括新PDO\n准备找到并加载新PDO的正确的驱动程序，它将向 总线驱动 查询完整的硬件设备ID\nP&amp;P管理器 根据硬件ID，在注册表中查找HKLM\\System\\ CurrentControlSet\\Enum\\PCI\\(HardwareID)如果驱动已经加载，将注册并加载\n驱动加载并创建FDO，通过附加调用 IoAttachDeviceToDeviceStack 将自身附加到（通常是PDO）前一层\n\nIRP 流驱动在处理IRP时有如下几种选择：\n向下传递：\n如果驱动的设备不是设备栈的最底层，可以直接向下传递，跳过该请求\n跳过请求需要如下步骤：\n\n调用 IoSkipCurrentIrpStackLocation 确保下一个设备“看”到同样的 I/O stack location\n调用 IoCallDriver  传递低一层设备和IRP\n\n\n\n\n\n\n\n\n\n\n调用 IoSkipCurrentIrpStackLocation 是一种优化，它会减少当前 I/O stack location 指针，随后被IoCallDriver增加回来\n完全处理IRP：\n不向下传递请求，处理完IRP后直接调用 IoCompleteRequest\n处理并向下传递：\n处理完请求后再向下传递\n传递并接收通知：\n传递给底层设备，并在请求完成时接收通知\n通过在传递之前调用 IoSetCompletionRoutine 设置例程，该例程会在请求完成时被调用\n启动异步IRP处理：\n在处理过程比较长的一些情况，可以将IRP标记为pending\n需要调用IoMarkIrpPending和返回STATUS_PENDING\n7.3 IRP 和 IO_STACK_LOCATIONIRP重要字段：\n\n\nMdlAddress：MDL指针，与 Direct I/O 有关\nAssociatedIrp：union\nMasterIrp：指向主IRP\nIrpCount：对于 主IRP，指示与此 主IRP 关联的 关联IRP 数量\nSystemBuffer：指向系统分配的非页池，与 Buffered I/O 有关\n\n\nIoStatus：包括Status和Information；Information是ULONG_PTR，是多态的，定义取决于IRP的类型\nUserEvent：指向客户端提供的KEVENT，客户端可以在OVERLAPPED中提供该事件HANDLE，这是异步调用所必须的\nUserBuffer：包含指向用户缓冲区的原始缓冲区指针\nCancel Routine：指向取消例程，比如R3调用CancelIO时，软件驱动通常不需要\n\nIO_STACK_LOCATION重要字段：\n\n\nMajorFunction：IRP的 major function (如IRP_MJ_CREATE，IRP_MJ_READ)\nMinorFunction：IRP的 minor function (如 IRP_MJ_PNP，IRP_MJ_POWER)\nParameters：union，不同的操作对应不同的结构\nFileObject：该IRP关联的 FILE_OBJECT\nDeviceObject：该IRP关联的 设备对象\nCompletionRoutine：由上层设置（IoSetCompletionRoutine）\nContext：传递给 CompletionRoutine 的参数\n\n观察IRP信息[windbg]：!irpfind 查找或输出所有IRP\n[windbg]：!irp 对于特定的IRP，提供其内容的预览\n[windbg]：dt命令可以与_IRP类型一起使用来查看完整IRP结构\n7.4 调度例程所有调度例程是同一个函数原型\nNTSTATUS DRIVER_DISPATCH (\n    _In_ PDEVICE_OBJECT DeviceObject,\n    _Inout_ PIRP Irp\n);\n\n通常运行在发起请求的线程的上下文但位于该设备上层的过滤驱动可能在不同的上下文发送请求\n所有调度例程做以下事情：\n\n检查错误\n处理请求\n\n软件驱动常见调度例程：\n\nIRP_MJ_CREATE\nIRP_MJ_CLOSE\nIRP_MJ_READ\nIRP_MJ_WRITE\nIRP_MJ_DEVICE_CONTROL\nIRP_MJ_INTERNAL_DEVICE_CONTROL\n\n完成请求当驱动处理完IRP（不再向下传递），需要完成请求填写请求状态和其他信息后，调用IoCompleteRequest\nNTSTATUS MyDispatchRoutine(PDEVICE_OBJECT, PIRP Irp) &#123;\n    &#x2F;&#x2F; ...\n    \n    Irp-&gt;IoStatus.Status &#x3D; STATUS_XXX;\n    Irp-&gt;IoStatus.Information &#x3D; ; &#x2F;&#x2F; depends on request type\n    IoCompleteRequest(Irp, IO_NO_INCREMENT);\n    return STATUS_XXX;\n&#125;\n\n\n\n\n\n\n\n\n\n\n调度例程返回值和Irp-&gt;IoStatus.Status应该相同，但不能直接return Irp-&gt;IoStatus.Status\n当IRP完成后，使用IRP中的数据是危险的\n当发生错误，Information字段应该为0\nIoCompleteRequest的第二个参数为可选值，用于临时增加原始线程的优先级发起请求的线程）\n7.5 访问R3缓冲区调度例程首先接触到IRP\n当IRQL为0时，可以换页，所以指针在此上下文是有效的但有可能其他线程会释放掉R3客户端提供的缓冲区\n但当IRQL为2时，无法换页；而执行DPC的可能为任意线程，可以换页但无法保证在正确上下文\n所以提供了两种种方法用于访问原始的R3缓冲区：Buffered I/O 和 Direct I/O\n7.5.1 Bufferd I/O该方法最简单\n获取对于 Read 和 Write 操作的支持：\nDeviceObject-&gt;Flags |&#x3D; DO_BUFFERED_IO;\n\n\n\n原理（I/O管理器的工作）：\n\n管理器在非页池分配缓冲区，大小与R3缓冲区一致该非页池缓冲区指针存储在AssociatedIrp.SystemBuffer\n如果Write，管理器复制R3缓冲区的内容到非页池缓冲区\n调度例程被调用\n完成操作后，管理器将非页池缓冲区的内容复制到R3缓冲区（Write也是一样）复制的字节数取决于IoStatus.Information\n最后，管理器释放非页池缓冲区\n\n\n\n\n\n\n\n\n\n\nI/O管理器 将一个特殊的内核APC入队发出请求的线程中，完成复制回R3缓冲区的操作\nBuffer I/O的特点：\n\n易于使用\n总是涉及副本（适用于传递的缓冲区较小的情况）\n\n7.5.2 Direct I/O该方法的目的是允许在任何IRQL和任何线程上下文中访问R3缓冲区，而不要任何复制\n获取对于 Read 和 Write 操作的支持：\nDeviceObject-&gt;Flags |&#x3D; DO_DIRECT_IO;\n\n\n\n原理（I/O管理器的工作）：\n\n管理器首先确认R3缓冲区是合法的，然后放入物理内存中\n然后将缓冲区锁定在内存中（将不会被换出）\n管理器构建一个MDL（描述缓冲区如何映射到内存），该MDL地址存在 IRP 的 MdlAddress字段中\n调度例程被调用，要使用锁定在内存中的缓冲区，需要先将缓冲区映射到系统地址本质上，相对于将两个地址映射到同一个缓冲区（一个R3下特定上下文有效的地址，一个R0对所以上下文有效的地址）映射到系统地址的API是MmGetSystemAddressForMdlSafe\n驱动完成请求后，管理器将移除到系统地址的映射，释放MDL，解锁R3缓冲区\n\n7.5.3 IRP_MJ_DEVICE_CONTROL缓冲区的访问方式取决于控制代码（DeviceIoControl()第2个参数dwIoControlCode）\n下面是第四章给出的定义控制代码的宏\n#define CTL_CODE( DeviceType, Function, Method, Access ) ( \\\n((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method))\n\nMethod的决定了访问缓冲区的方式：\n\nMETHOD_NEITHER：管理器将不会提供任何帮助，完全由驱动处理缓冲区\nR3输入缓冲区指针将存储在当前I/O stack location的Paramaters.DeviceIoControl.Type3InputBuffer字段R3输出缓冲区指针将存储在IRP的UserBuffer字段\n\n\nMETHOD_BUFFERED：对于输入和输出都使用 Buffered I/O\nMETHOD_IN_DIRECT and METHOD_OUT_DIRECT：输入缓冲区用Buffered I/O，输出缓冲区用Direct I/O；区别是对于输出缓冲区，IN可读，OUT可写\n\n7.5.x 总结Buffred I/O 使用 IRP 的 AssociatedIrp.SystemBuffer\nDirected I/O 使用 IRP 的 MdlAddress\nDeviceIoControl 的 NEITHER：    Input：I/O stack location 的 Paramaters.DeviceIoControl.Type3InputBuffer    Ouput：IRP 的 UserBuffer\n\n\n\nMethod\nIn buf\nOut buf\n\n\n\nMETHOD_BUFFER\nBuffred\nBuffred\n\n\nMETHOD_IN_DIRECT\nBuffred\nDirect（只读）\n\n\nMETHOD_OUT_DIRECT\nBuffred\nDirect（只写）\n\n\n7.6 示例：Zero 驱动（S4）运用6、7章的内容，构建一个驱动：\n\nread操作：返回清零的缓冲区\nwrite操作：只是消耗提供的缓冲区，类似于经典的null设备\n\n使用Direct I/O\n（同样不需要INF文件，删除掉）\n7.6.1 技巧：使用预编译头预编译头文件是 Visual Studio 的一项功能，有助于缩短编译时间\n创建预编译头的步骤：\n\n添加头文件到项目，名为pch.h：\n&#x2F;&#x2F; pch.h\n#pragma once\n#include &lt;ntddk.h&gt;\n\n添加源文件，名为pch.cpp：\n&#x2F;&#x2F; pch.cpp\n#include &quot;pch.h&quot;\n\n接下来使编译器知道这是个预编译头打开项目属性，选择所有配置和所有平台打开C/C++ -&gt; 预编译头，设置为使用，设置文件名为pch.h\n\npch.cpp需要设置为预编译头的创建者右键该文件，打开C/C++ -&gt; 预编译头，设置为创建\n\n现在，项目中的每个文件都必须先包含pch.h，否则不会被编译\n\n\n\n\n\n\n\n\n\n\n\n注意，#include &quot;pch.h&quot;必须放在源文件最前面，这条包含语句之前的内容不会被编译\n7.6.2 DriverEntry 例程技巧：\ndo &#123;\n\tif(notSuccess)\n        break;\n&#125; while(false);\n\n\n\n创建设备后，需要添加开启Direct IO代码：\n&#x2F;&#x2F; IoCreateDevice()\nDeviceObject-&gt;Flags |&#x3D; DO_DIRECT_IO;\n\n\n\n7.6.3 Read 调度例程NTSTATUS ZeroRead(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp) &#123;\n\tUNREFERENCED_PARAMETER(DeviceObject);\n\n\tauto stack &#x3D; IoGetCurrentIrpStackLocation(Irp);\n\tauto status &#x3D; STATUS_SUCCESS;\n\tULONG infomation &#x3D; 0;\n\t\n\tdo &#123;\n\t\tauto len &#x3D; stack-&gt;Parameters.Read.Length;\n\t\tif (len &#x3D;&#x3D; 0)\n\t\t\tbreak;\n\t\t\n\t\t&#x2F;&#x2F; get buffer\n\n\t\tauto buffer &#x3D; MmGetSystemAddressForMdlSafe(Irp-&gt;MdlAddress, NormalPagePriority);\n\t\tif (!buffer) &#123;\n\t\t\tstatus &#x3D; STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; work\n\n\t\tmemset(buffer, 0, len);\n\t\tinfomation &#x3D; len;\n\n\t&#125; while (false);\n\t\n\tIrp-&gt;IoStatus.Status &#x3D; status;\n\tIrp-&gt;IoStatus.Information &#x3D; infomation;\n\tIoCompleteRequest(Irp, IO_NO_INCREMENT);\n\treturn status;\n&#125;\n\n\n\n7.6.4 Write 调度例程NTSTATUS ZeroWrite(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp) &#123;\n\tUNREFERENCED_PARAMETER(DeviceObject);\n\n\tauto stack &#x3D; IoGetCurrentIrpStackLocation(Irp);\n\tauto status &#x3D; STATUS_SUCCESS;\n\tULONG infomation &#x3D; 0;\n\tauto len &#x3D; stack-&gt;Parameters.Write.Length;\n\n    &#x2F;&#x2F; get buffer\n    \n\tauto buffer &#x3D; MmGetSystemAddressForMdlSafe(Irp-&gt;MdlAddress, NormalPagePriority);\n\tinfomation &#x3D; len;\n    \n    &#x2F;&#x2F; work\n    \n    &#x2F;&#x2F; ...\n\n\tIrp-&gt;IoStatus.Status &#x3D; status;\n\tIrp-&gt;IoStatus.Information &#x3D; infomation;\n\tIoCompleteRequest(Irp, IO_NO_INCREMENT);\n\treturn status;\n&#125;\n\n\n\n7.6.5 R3测试程序HANDLE hDevice &#x3D; CreateFile(L&quot;\\\\\\\\.\\\\S4Zero&quot;, GENERIC_READ | GENERIC_WRITE,\n                            0, nullptr, OPEN_EXISTING, 0, nullptr);\n\n&#x2F;&#x2F; read\nDWORD btr;\nReadFile(hDevice, buffer, sizeof(buffer), &amp;btr, nullptr);\n\n&#x2F;&#x2F; write\nDWORD btw;\nWriteFile(hDevice, buffer, sizeof(buffer), &amp;btw, nullptr);\n\n\n\n练习6.6.7 Executive Resource，p144，Create appropriate C++ RAII wrappers for executive resources（见文中）\n6.7 高IRQL下的同步，p149，Write a C++ wrapper for a DISPATCH_LEVEL spin lock that works with the AutoLock RAII class defined earlier in this chapter.（todo）\n7.6.6，p185（todo）\n勘误6p133 的Interlocked Operations的 IF 应改为 If\np150 代码的 viud 应该为 void\n7p167 AssociatedIrp-&gt;SystemBuffer 应改为 AssociatedIrp.SystemBuffer\n","slug":"wkp6-7","date":"2022-01-02T04:00:00.000Z","categories_index":"Windows","tags_index":"windows,note,kernel,wkp","author_index":"御史神风"},{"id":"5492b18e2fa4da93951bdc6ad9c6b6ae","title":"sctf21 BabyDriver 出题思路","content":"BabyDriver 出题思路这题是和0x太上一起出的，他提供了题目的框架和内核通信部分的代码，我负责其余的实现\n0xTalShang (0x太上) (github.com)\nSycloverTeam/SCTF2021: SCTF 2021 (github.com)\n有选手反馈R3部分出得不太好，确实没有很好的把驱动的考点和R3的加密结合在一起，下次加油吧\n题目摘要题目有一个R3的客户端babydriver.exe和一个驱动sctf.sys\n客户端会要求输入一个flag，并读取文件key.bin，然后对flag进行运算\n运算的结果会传给驱动\n驱动进行第二次运算，然后与目标值比较\n客户端再向驱动查询比较结果是否正确\nbabydriver.exe客户端会要求输入一个flag，并读取文件key.bin。\nflag的输入格式限制为只能用64个字符\n然后对flag进行一个类似base64解密的过程，把输入的20个字节的flag转换成15字节的数据\n这个过程按每两位的移动，拆分成了60个位移函数。一共有60*60共3600个函数用于移动。\n程序根据key.bin决定使用哪些位移函数（实际上就是3600取60）。\n每个位移函数会有一个费用，总费用必须为3100\n内核通信驱动程序会注册一个时间回调函数，客户端修改时间会触发该回调函数。\n整个通讯流程是客户端把要传输的数据写入PE文件头，然后修改时间触发回调进入内核。回调函数再从PE头文件中读写数据，并做处理。\nsctf.sys驱动要手动启动，该驱动负责实现和注册回调函数，并对传输给内核的数据做校验。\n驱动对传入数据的处理是将传入的15字节分成4组，每组进行一个模乘，比较结果是否为目标值\n陷阱babydriver.exe中利用VEH添加了一些call 0和除0语句，以触发异常其中除0异常用于跳转到位移函数\n驱动中在接收数据后，会对后3字节做一些处理，将后3字节左移一个字节，然后填充一个10h，模乘校验完后再还原回去\n解题思路key.bin位移函数格式如下（实际上是无参的）\nvoid name() &#123;\n    char x &#x3D; inBuf[iIdx] &gt;&gt; (iSh * 2);\n    x &#x3D; x &amp; 3;\n    x &#x3D; x &lt;&lt; (oSh * 2);\n    outBuf[oIdx] |&#x3D; x;\n    totalC -&#x3D; cost;\n&#125;\n\n首先需要提取3600个位移函数的参数\n已知约束是cost的和必须为3100\n根据题意得到隐含的约束条件是要选择其中的60个函数，每个函数会从输入中选2个位，复制到输出中，输入的偏移和输出的偏移不能相同\n然后用动态规划算法找出解\n和为3100且选择了60个的解有多个。但完全覆盖输入和输出所有位的解只有1个\n这里给出python版本的参考代码：\ndef ReadMM(name, n, w):\n    mm &#x3D; [[0 for j in range(w)] for i in range(n)]\n    with open(&#39;&#123;&#125;_&#123;&#125;_&#123;&#125;.txt&#39;.format(name, n, w), &#39;r&#39;) as f:\n        lines &#x3D; f.readlines()\n        i &#x3D; 0\n        for line in lines:\n            j &#x3D; 0\n            for w in line.split():\n                mm[i][j] &#x3D; int(w)\n                j +&#x3D; 1\n            i +&#x3D; 1\n                \n    return mm\n\n\ndef msOrd2wsOrd(ms_ord):\n\n    a &#x3D; ms[ms_ord][0]*3+ms[ms_ord][1]\n    b &#x3D; ms[ms_ord][2]*4+ms[ms_ord][3]\n    return a * 60 + b\n\n\ndef dp3(ii, ww):\n\n    if ww &lt; 0:\n        return 0\n\n    ans &#x3D; 0\n\n    if mm3[ii][ww] !&#x3D; -1:\n        return mm3[ii][ww]\n\n    # take ws[n]\n    if ii &#x3D;&#x3D; 59:\n        for n in range(ii*60, (ii+1)*60):\n            print(n)\n            new_w &#x3D; ww - ws[n]\n            ans +&#x3D; dp3(ii-1, new_w)\n    else:\n        for n in range(ii*60, (ii+1)*60):\n            new_w &#x3D; ww - ws[n]\n            ans +&#x3D; dp3(ii-1, new_w)\n\n    mm3[ii][ww] &#x3D; ans\n    return ans\n\n\nopos &#x3D; [0]*60\ncur_ans &#x3D; []\ndef findPath(ii, ww):\n\n    total_ans &#x3D; []\n\n    if ii &#x3D;&#x3D; 0:\n        for oo in range(60):\n            if ws[oo] &#x3D;&#x3D; ww:\n                total_ans &#x3D; [cur_ans[:] + [oo]]\n                break\n        return total_ans\n\n    n &#x3D; ii*60\n    for oo in range(60):\n        if opos[oo]:\n            n +&#x3D; 1\n            continue\n\n        new_w &#x3D; ww - ws[n]\n        if new_w &gt;&#x3D; 0 and mm3[ii-1][new_w] &gt; 0:\n            opos[oo] &#x3D; 1\n            cur_ans.append(n)\n\n            new_ans &#x3D; findPath(ii-1, new_w)\n\n            total_ans +&#x3D; new_ans\n\n            del cur_ans[-1]\n            opos[oo] &#x3D; 0\n\n        # continue\n        n +&#x3D; 1\n    \n    return total_ans\n\n\nw &#x3D; 3100\nms &#x3D; ReadMM(&#39;ms&#39;, 3600, 5)\n\nwsOrd2msOrd &#x3D; [0]*3600\nws &#x3D; [0]*3600\nfor msOrd in range(3600):\n    wsOrd &#x3D; msOrd2wsOrd(msOrd)\n    wsOrd2msOrd[wsOrd] &#x3D; msOrd\n    ws[wsOrd] &#x3D; ms[msOrd][4]\n\n# step 1 dp\n\nmm3 &#x3D; [[-1 for i in range(w+1)] for j in range(60)]\nfor ww in range(w+1):\n    mm3[0][ww] &#x3D; 0\nfor oo in range(60):\n    mm3[0][ws[oo]] &#x3D; 1\ndp3(59, w)\nprint(mm3[59][w])\n\n# step 2 dfs\n\nansWsOrds &#x3D; findPath(59, w)[0]\nansMsOrds &#x3D; [wsOrd2msOrd[ord] for ord in ansWsOrds]\nprint(ansMsOrds)\n\n# step 3 key\n\nans &#x3D; [0]*3600\nfor ord in ansMsOrds:\n    ans[ord] &#x3D; 1\n\ns &#x3D; &#39;&#39;\nfor x in ans:\n    s +&#x3D; str(x)\n\nwith open(&#39;.&#x2F;key.bin&#39;, &#39;wb&#39;) as f:\n    for i in range(0, 3600, 8):\n        f.write(int(s[i:i+8][::-1], 2).to_bytes(1, &#39;little&#39;))\n\n\n一元同余方程这个比较简单就不说了\n总结求出一元同余方程的解，得到变形base64的输出。然后求出key.bin得到base64的规则，逆推出输入。\n","slug":"sctf21-babydriver","date":"2021-12-26T04:00:00.000Z","categories_index":"CTF","tags_index":"ctf,re,wp","author_index":"御史神风"},{"id":"2cdcc6b2635425e63dc5ac736f5a68f9","title":"《Windows Kernel Programming》 笔记 1~5 内核开发入门","content":"Windows Kernel Programming 笔记 1~5 内核开发入门1 windows内部概况描述一些Windows内部工作中最重要、最基本的概念，部分概念将在后面的章节做更详细的研究\n1.1 进程进程不运行（Processes dont’t run - processes manage），线程才执行代码\n进程拥有以下内容：\n\n一个可执行程序（PE文件），包括代码和数据\n私有的虚拟内存空间\n主令牌（primary token），是一个对象，存储进程默认安全上下文\n对象（事件、信号、文件）句柄表\n一个或多个线程（没有线程的用户态进程一般情况下会被内核销毁）\n\n1.2 虚拟内存每个进程拥有自己的虚拟、私有、线性地址空间（该地址空间初始时几乎为空，然后pe、ntdll.dll开始被影射，接着是其他子系统dll）\n32位进程默认地址空间2GB，设置pe中的LARGEADDRESSAWARE标志可以增加到3GB（32位系统）或4GB（64位系统）\n64位进程默认地址空间128TB（win8之前是8TB）\n虚拟内存被映射到物理内存（RAM）或临时驻留在文件中（如page file）如果不在物理内存，则触发page fault异常，并或取数据到物理内存中\n页（page）是内存管理的单位，默认大小为4KB\n页状态虚拟内存中的页处于三种状态之一\n\nFree：未分配\nCommitted：已分配，通常映射到RAM或文件（例如page file）\nReserved：未分配，对cpu而言与Free相似，自动分配将不会使用该页一个例子是线程栈（thread stack）\n\n系统内存系统空间与进程无关\n系统空间就是内核\n1.3 线程实际执行代码的是线程\n线程拥有的最重要的内容：\n\n当前访问模式（用户或内核）\n执行上下文\n一个或两个栈（stack）\nThread Local Storage（TLS）\n基本优先级和当前（动态）优先级\n处理器关联信息\n\n线程最常处于的状态：\n\nRunning：在逻辑处理器运行中\nReady：等待运行（所有处理器在忙或不可用）\nWaiting：等待某个事件，事件触发就变成Ready\n\n括号中的数字是状态号：\nRunning(2) =&gt; Waiting(5) =&gt; Deferred Ready(7), Ready(1) =&gt; Running(2)\n1.3.1 线程栈线程至少有一个位于内核空间的栈（32位系统12KB，64位系统24KB）\n用户态的线程还有一个位于所属进程空间的栈（默认上限1MB）\n线程Running或Ready时，内核栈驻留在RAM\n栈初始时会尽可能少提交页（最少一页），剩下的页设置为Reserved，而最后一个Committed的页的下一页设置为PAGE_GUARD\n1.4 系统调用（又名系统服务）原标题：System Services (a.k.a. System Calls)\nR3代码通过系统调用完成一些只能在R0下完成的功能，如分配内存、打开文件、创建线程等\n大致流程是：调用subsystem dll（如kernel32.dll）中的文档化api（如CreateFile）进入NTDLL中的 Native Api（如NtCreateFile）进入内核中的系统服务分发函数进入Native Api对应的内核中的函数\nNative Api将调用号存入eax然后进入r0的系统服务分发函数，eax实际是SSDT（System Service Dispatch Table）的下标\n1.5 通用系统架构\n1.6 句柄和对象对象被引用计数，当计数为0时才会被释放\n句柄是进程的对象表的索引\n\n\n\n\n\n\n\n\n\n注意：返回值为句柄的函数，大多数失败时返回0。有些返回INVALID_HANDLE_VALUE (-1)，比如CreateFile\n句柄值是4的倍数，0不是有效句柄值\n1.6.1 对象名某些类型的对象可以有名称，可用于通过合适的 Open 函数按名称打开对象。 \n用户模式调用 Create 函数按名称创建对象，如果存在，则仅打开现有对象。\nwinObj中显示的名称有时不是对象的真实名称：\n\n进程和线程显示ID\n文件对象显示文件名（或设备名），因为共享的原因，无法通过文件名获得文件对象句柄\n（注册表）键对象与注册表的路径一起显示，原因同文件对象\n目录对象显示路径，目录不是文件系统对象，而是对象管理器目录，可通过Sysinternals WinObj查看\n令牌对象名称与存储在令牌中的用户名一起显示\n\n1.6.2 访问现有对象Process Explorer 的句柄视图中的访问列显示用于打开或创建句柄的访问掩码\nProcess Explorer中显示的引用数（References）不是实际引用数（outstanding references）\n[windbg]中用!trueref获取实际引用数（actual reference）\n2 内核开发入门本章主要是关于准备内核开发所需的环境，包括开发和调试的工具以及环境配置\n以及启动和运行内核驱动的知识\n然后写一个可以加载和卸载的驱动\n驱动开发准备工作首先按 2.1安装工具 完成安装，然后为驱动开发配置虚拟机（未包括内核调试的配置）\n安装无签名驱动\n如果驱动没有签名，安装驱动需要以该模式启动系统\nbcdedit &#x2F;set testsigning on\n\n\n\n显示内核调试信息\n在HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager添加一个名为Debug Print Filter的键在键中添加一个DWORD，名为DEFAULT，值为8\n虚拟机文件共享\n实际操作时，安装在虚拟机中（避免本机崩溃），需要共享项目的文件给虚拟机\n共享本机的 vs解决方案文件夹 给虚拟机，名称为MyDriver\n虚拟机中的debug输出路径为：\\\\vmware-host\\Shared Folders\\MyDriver\\x64\\Debug\n驱动调试工具\n安装完WDK后，把C:\\Program Files (x86)\\Windows Kits\\10\\Tools\\x64这个目录复制到虚拟机中，这个是x64下的驱动开发调试工具，比如用于查看内存池的poolmon\n2.1 安装工具需要vs2019、windows 10 sdk（vs2019中安装）、windows 10 driver kit（WDK）\n以及 Sysinternals，该工具包含debug view、process monitor等一系列有用的工具\n\n\n\n\n\n\n\n\n\n在实际编译中发现，新版本的vs驱动项目默认开启缓解Spectre 漏洞\n可以在c/c++、代码生成中关闭该项，或在vs installer中安装对应工具\n2.2 创建一个驱动工程vs2019中选择创建一个Empty WDM Driver，创建完成后有个inf后缀的文件，暂时不需要，删除掉\n2.3 DriverEntry 和 Unload RoutinesDriverEntry 是驱动的默认入口点\n系统线程以IRQL_PASSIVE_LEVEL(0)调用 DriverEntry\nDriverEntry函数原型：\nextern &quot;C&quot;\nNTSTATUS\nDriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath);\n\n\n\n一个简单的驱动（sample.cpp）：\n#include &lt;ntddk.h&gt;\n\nvoid SampleUnload(_In_ PDRIVER_OBJECT DriverObject) &#123;\n\tUNREFERENCED_PARAMETER(DriverObject);\n&#125;\n\nextern &quot;C&quot;\nNTSTATUS\nDriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) &#123;\n\tUNREFERENCED_PARAMETER(RegistryPath);\n    \n\tDriverObject-&gt;DriverUnload &#x3D; SampleUnload;\n    \n\treturn STATUS_SUCCESS;\n&#125;\n\n\n\n2.4 安装驱动安装驱动和安装用户态服务相似，需要调用Create Service API或使用工具\nsc.exe（系统自带）是著名工具之一\n安装驱动需要管理员权限\n创建服务项：\nsc create sample type&#x3D; kernel binPath&#x3D; &quot;\\\\vmware-host\\Shared Folders\\MyDriver\\x64\\Debug\\sample.sys&quot;\n\n随后就能在注册表（regedit.exe）的HKLM\\System\\CurrentControlSet\\Services\\Sample中看到该项\n\n\n\n\n\n\n\n\n\n注册表项位置：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Sample\n假设binPath= c:\\，注册表项ImagePath= \\??\\c:\\\n假设binPaht= &quot;\\\\vmware-hots\\&quot;，注册表项ImagePath= \\??\\UNC\\vmware-hots\\\n加载驱动（启动服务）：\nsc start sample\n\n在process explorer中，选择System进程，查看dll窗口，拉到最下面就能看到sample.sys\n卸载驱动（停止服务）：\nsc stop sample\n\n\n\n2.5 简单跟踪（S1）KdPrint 宏是DbgPrint API的包装\n通过在每个函数开头加入KdPrint((&quot;Debug messgae&quot;));可以观察函数调用的发生\n使用DebugView，选择capture Kernel可以看到内核调试信息\n2.6 练习：显示系统信息（E1）创建一个驱动用于显示系统版本信息，使用RtlGetVersion\ncode:\n&#x2F;&#x2F; Get Version\nRTL_OSVERSIONINFOW versionInfo &#x3D; &#123; 0, &#125;;\nversionInfo.dwOSVersionInfoSize &#x3D; sizeof(RTL_OSVERSIONINFOW);\nRtlGetVersion(&amp;versionInfo);\n\n&#x2F;&#x2F; Print\nDbgPrint(&quot;[E1] Major:%d\\n[E1] Minor:%d\\n[E1] Build:%d&quot;,\n\tversionInfo.dwMajorVersion,\n\tversionInfo.dwMinorVersion,\n\tversionInfo.dwBuildNumber);\n\nshell:\nsc create E1_OSVersion type&#x3D; kernel binPath&#x3D; &quot;\\\\vmware-host\\Shared Folders\\MyDriver\\x64\\Debug\\E1_OSVersion.sys&quot;\nsc start E1_OSVersion\nsc stop E1_OSVersion\n\n\n\n3 内核编程基础研究一些内核的API、结构和定义，以及一些驱动程序中的机制\n3.1 通用内核编程指南用户模式和内核模式调试的重要区别\n\n\n\n\n用户模式\n内核模式\n\n\n\n未处理异常\n进程崩溃\n系统崩溃\n\n\n终止\n当进程终止，所有内存和资源都会被自动释放\n当驱动卸载，如果没有手动释放，会造成泄露直到重启\n\n\n返回值\nAPI错误有时候会忽略\n应该不忽略任何错误\n\n\nIRQL\n总是 PASSIVE_LEVEL (0)\n可能为更高\n\n\n错误代码\n通常只会影响本进程\n影响整个系统\n\n\n测试和调试\n通常在开发机器上调试\n需要双机调试\n\n\n库（Lib）\n可以使用C/C++库（如STL、boost）\n大多数标准库无法使用\n\n\n异常处理\n可以使用C++异常或SEH\n只能使用SEH\n\n\nC++支持\n完全的C++支持\n不支持C++ runtime\n\n\n3.1.1 未处理异常未处理异常会导致蓝屏，原因是防止继续执行代码、对系统造成不可逆转的伤害\n内核代码不应该跳过任何细节或错误检查\n3.1.2 终止如果驱动程序卸载时仍保留分配的内存或打开的内核句柄，这些资源不会自动释放，只会在下次系统启动时释放\n原因是驱动程序可以分配一些缓冲区，然后将其传递给另一个与之合作的驱动程序\n3.1.3 函数返回值忽略内核API的返回值很危险，应该总是检查返回值\n3.1.4 IRQL中断请求级（Interrupt Request Level, IRQL）通常为0\n用户模式下始终为0，内核模式下大部分时间为0\n3.1.5 C++使用没有C++ runtime\n一些不支持的C++特性：\n\n不支持new和delete，这正常是在用户模式堆分配的\n不会调用具有非默认构造函数的全局变量\n避免在构造函数中使用代码，创建一些要显式调用的Init函数\n仅将指针分配为全局变量，动态创建实例\n\n\n不支持C++异常处理（try、catch、throw）\n不可使用标准C++库，如std::vector&lt;&gt;、std::wstring等\n\n一些支持的C++特性：\n\nnullptr关键字\nauto关键字\n模板将在有意义时使用\n重载new 和delete 运算符\n构造函数和析构函数，尤其是用于构建 RAII 类型\n\n3.1.6 测试和调试内核调试需要双机调试，一台作为调试者、另一台作为被调试者运行驱动程序\n3.2 Debug vs. Release 生成内核术语是 Checked（Debug）和 Free（Release）\nDebug意味着可以使用DBG符号\n3.3 内核API内核API常用前缀的意义：\n\nEx：一般执行函数\nKe：一般内核函数\nMm：内存管理\nRtl：一般运行时库\nFsRtl：文件系统运行时库\nFlt：文件系统迷你过滤库\nOb：对象管理\nIo：I/O管理\nSe：安全\nPs：进程结构\nPo：电源管理\nWmi：Windows管理工具\nZw：native API 包装\nHal：硬件抽象层\nCm：配置管理器（注册表）\n\nNt前缀的内核函数对应NtDll.Dll的函数，会根据 KTHREAD 结构的标记（调用者是否来自内核）对参数进行检查\nZw前缀的内核函数先将调用者模式设为KernelMode(0)，然后调用Nt前缀的内核函数\n3.4 函数和错误代码可以在ntstatus.h中找到NTSTATUS值的定义\n大多数代码并不关心错误具体是什么，仅测试最高位即可，可以使用NT_SUCCESS宏\n当返回到用户层时，会由STATUS_xxx转成ERROR_yyy，用户模式通过GetLastError可以得到这些错误\n通常遇到错误时，会返回相同的 NTSTATUS 到调用函数\n3.5 字符串内核使用UNICODE_STRING\ntypedef struct _UNICODE_STRING &#123;\nUSHORT Length;\nUSHORT MaximumLength;\nPWCH Buffer;\n&#125; UNICODE_STRING;\ntypedef UNICODE_STRING *PUNICODE_STRING;\ntypedef const UNICODE_STRING *PCUNICODE_STRING;\n\nLength是字符串的字节数（不包括\\x00\\x00结束符）\nMaximumLength是不需要重新分配内存的情况下、字符串字节数上限\n需要注意的是，UNICODE_STRING并不总是有\\x00\\x00结尾\n一些常用的字符串操作函数：\n\nRtlInitUnicodeString\nRtlCopyUnicodeString\nRtlCompareUnicodeString \nRtlEqualUnicodeString \nRtlAppendUnicodeStringToString\nRtlAppendUnicodeToString\n\n3.6 动态内存分配（S2）内核提供两种通用内存池（general memory pools）给驱动使用：\n\n页池（Paged pool）：可能会被换出（paged out）的内存池\n非页池（Non Paged Pool）：一直在RAM中的内存池\n\n枚举类型POOL_TYPE表示池类型，只有三种是可以用于驱动的：PagedPool、NonPagedPool、NonPagedPoolNx（non-page pool没有可执行权限）\n常用内存池函数：\n\nExAllocatePool（已过时，将被下面的函数取代）\nExAllocatePoolWithTag\nExAllocatePoolWithQuotaTag\nExFreePool\n\ntag是4字节的值\n可以在PoolMon（WDK的Windows Kits中）中观察到有tag的内存池（tag以大端序字符串显示）\n给ustring分配页池内存：\ncode:\nUNICODE_STRING strA;\nint length;\n&#x2F;&#x2F; allocate\nstrA.Buffer &#x3D; (WCHAR*)ExAllocatePoolWithTag(PagedPool,\n\tlength, &#39;dcba&#39;);\nif (strA.Buffer &#x3D;&#x3D; nullptr) &#123;\n    KdPrint((&quot;Failed to allocate memory\\n&quot;));\n    return STATUS_INSUFFICIENT_RESOURCES;\n&#125;\nstrA.MaximumLength &#x3D; length;\n\nshell:\nsc create S2_DynMemAlloc type&#x3D; kernel binPath&#x3D; &quot;\\\\vmware-host\\Shared Folders\\MyDriver\\x64\\Debug\\S2_DynMemAlloc.sys&quot;\nsc start S2_DynMemAlloc\nsc stop S2_DynMemAlloc\n\n\n\n3.7 链表内核使用循环双向链表：\ntypedef struct _LIST_ENTRY &#123;\n    struct _LIST_ENTRY *Flink;\n    struct _LIST_ENTRY *Blink;\n&#125; LIST_ENTRY, *PLIST_ENTRY;\n\n\n\nCONTAINING_RECORD宏执行适当的偏移计算并转换为实际数据类型CONTAINING_RECORD(pvoid, type, entry_member_name)\nstruct MyDataItem &#123;\n    &#x2F;&#x2F; some data members\n    LIST_ENTRY Link;\n    &#x2F;&#x2F; more data members\n&#125;;\n\nMyDataItem* GetItem(LIST_ENTRY* pEntry) &#123;\n\treturn CONTAINING_RECORD(pEntry, MyDataItem, Link);\n&#125;\n\n\n\n常用链表函数（时间复杂度都是常数）：\n\nInitializeListHead\nInsertHeadList\nInsertTailList\nIsListEmpty\nRemoveHeadList\nRemoveTailList\nRemoveEntryList\nExInterlockedInsertHeadList\nExInterlockedInsertTailList\nExInterlockedRemoveHeadList\n\n后三个关于自旋锁，在第6章详细讨论\n3.8 驱动对象（The Driver Object）常用major function代码：\n\nIRP_MJ_CREATE (0) \nIRP_MJ_CLOSE (2)\nIRP_MJ_READ (3) \nIRP_MJ_WRITE (4) \nIRP_MJ_DEVICE_CONTROL (14) \nIRP_MJ_INTERNAL_DEVICE_CONTROL (15)\nIRP_MJ_PNP (31) \nIRP_MJ_POWER (22)\n\nMajorFunction数组由内核初始化指向内核内部例程IopInvalidDeviceRequest，该例程直接返回失败，表示不支持该操作\n3.9 设备对象（Device Objects）驱动通过设备与r3代码通信，驱动应该至少创建一个设备对象并为其命名\nCreateFile可以打开设备，第一个参数为设备对象名称\n打开文件或设备的句柄会创建内核结构 FILE_OBJECT 的实例，这是个半文档化的结构。 \n更准确的说，CreteFile接受一个symbolic link（符号链接）\n对象管理器中名为??的目录下的符号链接都可被用户模式代码通过CreateFile或Createfile2调用\n可以通过WinObj查看（WinObj中目录名为Global??）\n使用符号链接的CreateFile的文件名（第一个参数），必须加上前缀\\\\.\\（c++中是&quot;\\\\\\\\.\\\\&quot;）\n如果创建了多个设备对象，将形成一个单向链表，添加设备时是头插法，所以第一个创建的设备在链表的最后\n4 驱动从头到尾（Driver from Start to Finish）（S3）将完成一个完整的驱动及客户端程序，利用驱动完成只能在内核模式下完成的功能（设置任意级别的线程优先级）\n4.1 绪论线程优先级 = 进程优先级 + 相对线程优先级\n用户模式下，设置进程优先级可以用SetPriorityClass，共有6个级别设置相对线程优先级可以用SetThreadPriority，共有7个级别\n下面是线程优先级合法值的表（通过windows api设置），据别的书说是个未文档化的东西，windows不建议开发时考虑线程优先级，该表的值随windows版本变化可能发生改变\n\n\n\n进程优先级\n-Sat\n-2\n-1\n0\n+1\n+2\n+sat\n\n\n\nIdle(low)\n1\n\n\n4\n\n\n15\n\n\nBelow Normal\n1\n\n\n6\n\n\n15\n\n\nNormal\n1\n\n\n8\n\n\n15\n\n\nAbove Normal\n1\n\n\n10\n\n\n15\n\n\nHigh\n1\n\n\n13\n\n\n15\n\n\nReal-time\n16\n\n\n24\n\n\n31\n\n\n进程优先级枚举：级别+_PRIORITY_CLASS\n线程优先级枚举：THREAD_PRIORITY_+级别\n4.2 驱动初始化大多数驱动需要在DriverEntry中做如下操作：\n\n设置Unload例程\n设置驱动支持的调度例程\n创建一个设备对象\n创建一个指向设备对象的符号链接\n\n所有驱动必须支持IRP_MJ_CREATE和IRP_MJ_CLOSE，不然无法打开一个驱动的设备的句柄，通常这两个调度例程是相同的\n调度例程的函数原型：NTSTATUS Function(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)\n4.2.1 将信息传给驱动用户模式客户端可用的三个基础函数：WriteFile、ReadFile、DeviceIoControl\n4.2.2 客户端/驱动程序通信协议必须使用CTL_CODE宏来构建控制代码\n#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \\\n    ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \\\n)\n\n\nDeviceType：设备类型标识，FILE_DEVICE_xxx，第三方应以0x8000开头\nFunction：指示特定操作的升序数字，第三方应该以0x800开头\nMethod：指示客户端提供的输入和输出缓冲区如何传递给驱动程序（将在第6章详细讨论）\nAccess：指示对驱动来说这个操作是什么？\n\n示例：\n#define MY_DEVICE 0x800\n#define IOCTL_MY_OP CTL_CODE(\\\nMY_DEVICE, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)\n\n\n\n4.2.3 创建一个设备对象创建设备名：\n在创建一个设备对象前，需要先创建一个UNICODE_STRING存储内部设备名称\n下面是两种初始化方式：\n&#x2F;&#x2F; plan A\nUNICODE_STRING devName &#x3D; RTL_CONSTANT_STRING(L&quot;\\\\Device\\\\YourName&quot;); \n\n&#x2F;&#x2F; plan B\nUNICODE_STRING devName;\nRtlInitUnicodeString(&amp;devName, L&quot;\\\\Device\\\\YourName&quot;);\n\n设备名称需要在设备对象管理器目录下\n（RtlInitUnicodeString函数内部字符串的长度，RTL_CONSTANT_STRING宏在编译时计算长度）\n创建设备对象：\n创建设备对象需要调用IoCreateDevice\nNTSTATUS IoCreateDevice(\n    _In_ PDRIVER_OBJECT DriverObject,\n    _In_ ULONG DeviceExtensionSize,\n    _In_opt_ PUNICODE_STRING DeviceName,\n    _In_ DEVICE_TYPE DeviceType,\n    _In_ ULONG DeviceCharacteristics,\n    _In_ BOOLEAN Exclusive,\n    _Outptr_ PDEVICE_OBJECT *DeviceObject);\n\n\n\n创建设备完整示例：\nUNICODE_STRING devName &#x3D; RTL_CONSTANT_STRING(L&quot;\\\\DEVICE\\\\devName&quot;);\nPDEVICE_OBJECT devObj;\nstatus &#x3D; IoCreateDevice(\n    DriverObject,        &#x2F;&#x2F; our driver object\n    0,                   &#x2F;&#x2F; no need for extra bytes\n    &amp;devName,            &#x2F;&#x2F; the device name\n    FILE_DEVICE_UNKNOWN, &#x2F;&#x2F; device type\n    0,                   &#x2F;&#x2F; characteristics flags\n    FALSE,               &#x2F;&#x2F; not exclusive\n    &amp;devObj              &#x2F;&#x2F; the resulting pointer\n);\nif (status &lt; 0) &#123;\n    KdPrint((&quot;[] Failed to create device object (0x%08X)\\n&quot;, status));\n    return status;\n&#125;\n\n\n\n创建符号链接：\n需要创建一个指向设备的符号链接，供r3调用\n同样需要先创建一个字符串作为符号链接对象名称\nUNICODE_STRING symLink &#x3D; RTL_CONSTANT_STRING(L&quot;\\\\??\\\\symLinkName&quot;);\nstatus &#x3D; IoCreateSymbolicLink(&amp;symLink, &amp;devName);\nif (status &lt; 0) &#123;\n\tKdPrint((&quot;[] Failed to create symbolic link (0x%08X)\\n&quot;, status));\n    return status;\n&#125;\n\n\n\n注意：资源释放\n上面创建的字符串会自动释放（好像在函数的栈中）？但对象不会，需要（在unload例程中）手动删除\nvoid Unload(_In_ PDRIVER_OBJECT DriverObject) &#123;\n    &#x2F;&#x2F; delete symbolic link\n    UNICODE_STRING symLink &#x3D; RTL_CONSTANT_STRING(L&quot;\\\\??\\\\symLinkName&quot;);\n    IoDeleteSymbolicLink(&amp;symLink);\n    &#x2F;&#x2F; delete device object\n    IoDeleteDevice(DriverObject-&gt;DeviceObject);\n&#125;\n\n\n\n4.3 客户端代码将用CTL_CODE构造的控制代码放到一个头文件中，供驱动代码和用户模式客户端代码同时使用\n通过符号链接获驱动的设备的句柄\n&#123;\n    HANDLE hDevice &#x3D; CreateFile(L&quot;\\\\\\\\.\\\\symLinkName&quot;, GENERIC_WRITE,\n        FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);\n    if (hDevice &#x3D;&#x3D; INVALID_HANDLE_VALUE)\n        return Error(&quot;Failed to open device&quot;);\n&#125;\n    \nint Error(const char* msg) &#123;\n    printf(&quot;%s (error&#x3D;%d)\\n&quot;, msg, GetLastError());\n    return 1;\n&#125;\n\n\n\n4.4 Create和Close调度例程该例程什么都不用做，直接返回成功即可\nNTSTATUS PriorityBoosterCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123;\n    UNREFERENCED_PARAMETER(DeviceObject);\n    \n    Irp-&gt;IoStatus.Status &#x3D; STATUS_SUCCESS;\n    Irp-&gt;IoStatus.Information &#x3D; 0;\n    IoCompleteRequest(Irp, IO_NO_INCREMENT);\n    return STATUS_SUCCESS;\n&#125;\n\n\n\nIRP是半文档化结构，通常来自运行中的管理器：I/O Manager, Plug &amp; Play Manager or Power Manager\n对驱动程序的每个请求总是包装在 IRP 中\nIRP中有一个或多个IO_STACK_LOCATION结构\n为了完成IRP，需要调用IoCompleteRequest，这个函数做很多东西，基本上理解为将IRP传播回创建者（通常是I/O管理器），然后由管理器通知客户端操作完成\n4.5 DeviceIoControl调度例程调用IoGetCurrentIrpStackLocation获取当前设备对应的IO_STACK_LOCATION\nIO_STACK_LOCATION中有控制代码、输入输出buffer指针等\n\n\n\n\n\n\n\n\n\n调度例程运行在调用该例程的用户模式进程的上下文中\nDWORD threadId;\nPETHREAD Thread;\nstatus &#x3D; PsLookupThreadByThreadId(ULongToHandle(threadId), &amp;Thread);\n\n使用ULongToHandle（这实际上只是个casting）将pid转换成HANDLE\n线程和进程存在一个全局私有内核句柄表，句柄的“值”实际上就是ID\n（HANDLE在64位系统是64位，线程ID始终是32位）\n4.6 安装和测试sc create S3_PriorityBooster type&#x3D; kernel binPath&#x3D; &quot;\\\\vmware-host\\Shared Folders\\MyDriver\\x64\\Debug\\S3_PriorityBooster.sys&quot;\nsc start S3_PriorityBooster\nsc stop S3_PriorityBooster\nsc delete S3_PriorityBooster\n\n\n\nstart后可以在WinObj中的Driver目录下看到驱动、GLOBAL??目录下看到符号链接\n可以在Process Explorer中查看进程的pid以及其线程的动态优先级\n5 调试关于使用WinDbg进行调试\n5.1 windows的调试工具四个调试器：\n\nCdb 和 Ntsd 是用户模式调试器，可以附加到进程上，是命令行界面，没有什么大的区别\nKd 是内核调试器，提供命令行界面，可以附加到本地内核或其他机器\nWinDbg 是有图形化界面的调试器，可以调试用户和内核模式\n\n\n\n\n\n\n\n\n\n\nWinDbg Preview是WinDbg的“最新版”，解决了一些WinDbg上的bug\n这些调试器都是基于DbgEng.Dll\n5.2 WinDbg简介虽然有GUI，实际上还是命令行，所有UI操作都会转成命令，显示在命令行窗口上\nWinDbg支持三种类型的命令：\n\n标准命令(Intrinsic)：内置在调试器中，在被调试的目标上运行\n元命令(Meta)：以.开头，作用于调试器(debugging process)本身，而不是直接作用于被调试目标\n拓展命令：以!开头，提供调试器大部分功能，都在拓展DLL中实现\n\n教程：用户模式调试基础符号信息：\n设置符号的方法1：.symfix\n设置符号的方法2：设置环境变量_NT_SYMBOL_PATH=SRV*c:\\Symbols*http://msdl.microsoft.com/download/symbols\nlm：显示进程加载的模块，以及各模块是否加载了符号\n.reload /f modulename.dll：强制加载模块的符号\n!sym noisy：记录符号加载尝试的详细信息\n线程：\n~：显示调试进程中所有线程的信息线程信息前的.表示当前线程，#表示触发中断的线程输入提示冒号右边的数字是当前线程的索引\n0  Id: 874c.18068 Suspend: 1 Teb: 00000001&#96;2229d000 Unfrozen\n[下标] Id: [PID].[TID] Suspend: [挂起计数] Teb: [TEB地址] [是否冻结]\n\n\n\n~ns：切换到索引为n的线程可以组合命令~nk，这样可以在不切换线程的情况下，在别的线程执行操作（这里是显示别的线程的调用堆栈）\nk：当前线程的调用堆栈（stack trace）\n!teb：查看TEB的部分信息，默认当前线程的\n进制转换：\n16转10：\n0:000&gt; ? 874c\nEvaluate expression: 34636 &#x3D; 0000874c\n\n10转16：\n0:000&gt; ? 0n34636\nEvaluate expression: 34636 &#x3D; 0000874c\n\n\n\n数据或结构的显示：\ndt [type]：显示数据结构的定义（如显示_TEB：dt ntdll!_teb）\ndt [type] [addr]：显示数据结构的数据（如显示某个_TEB： dt ntdll!_teb 000000`012229d000）\nr [reg]：读取寄存器（如读取rcx：r rcx）\nd&#123;a|b|c|d|D|f|p|q|u|w|W&#125;：以指定类型显示指定地址的数据a：ascii字符b,w,d,q：字节u：unicodef：单精浮点D：双精浮点\nu：显示反汇编，默认8句汇编指令\n!error [error_code]：显示错误信息\n断点和运行：\nbp [symbol]：设置断点（如CreateFile：bp kernel32!createfilew）\nbl：显示当前设置的断点\nbd：禁用断点，禁用所有断点：bd *\nbc：删除断点\ng(F5)：运行直到断点\np(F10)：步过\nt(F11)：步进\n5.3 内核调试（本地）本地内核调试修改启动项：bcdedit /debug on\n本地内核调试教程!process 0 0：显示所有进程的基本信息\nlkd&gt; !process 0 0\n**** NT ACTIVE PROCESS DUMP ****\nPROCESS ffff8d0e682a73c0\n    SessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000\n    DirBase: 001ad002 ObjectTable: ffffe20712204b80 HandleCount: 9542.\n    Image: System\n    \n(truncated)\n\n\nPROCESS旁边的地址：EPROCESS的地址\nSessionId：进程所处的对话\nCid：pid\nPeb：PEB地址（在用户模式地址空间）\nParentCid：父进程pid\nDirBase：进程主页目录的物理地址（x32是PDPT基址、x64是PML4基址）\nObjectTable：指向进程的私有句柄表的指针 \nHandleCount：进程中的句柄数\nImage：可执行文件名称，或与可执行文件无关的特殊进程名称 \n\n!process指令后第一个数字是筛选特定进程，0表示所有进程；第二个数字是细节掩码，0表示最少细节；第三个参数是筛选可执行文件\n.process /p [EPROCESS]：切换到指定进程\npeb在用户模式地址空间中，查看peb需要先设置正确的用户模式进程环境\n不切换的做法：.process /p ffff8d0e849df080; !peb e8a8c9c000\n调用堆栈中，nt前缀表示内核\n.reload /user：加载用户模式符号\n其余常用/有趣的内核模式调试指令：\n\n!pcr：显示指定为附加索引的处理器的进程控制区域 (PCR)（如果未指定索引，则默认显示处理器 0）\n!vm：显示系统和进程的内存统计信息\n!running：显示有关在系统上所有处理器上运行的线程的信息\n\n5.4 完全内核调试（双机）完全内核调试需要”双机“\n最好的连接方式是通过网络，这需要主机和被调试目标系统版最少为Win8\n另外一种方法是COM串口，大多数虚拟机支持虚拟串口而不需要真实（物理的）串口线\n详细配置方式略过\n配置目标机器bcdedit &#x2F;debug on\nbcdedit &#x2F;dbgsettings serial debugport:1 baudrate:115200\n\n\n\n配置主机调试器需要设置调试端口映射和命名管道，与虚拟机上的相同\n输入提示kd左边的数字是引起中断的处理器的索引\n5.5 内核驱动调试教程可以设置未来断点（在运行程序前设置断点）\n如设置驱动prioritybooster的入口点：bu prioritybooster!driverentry\n可以设置只在指定进程上中断：bp /p [EPROCESS] [symbol]如： bp /p ffffdd06042e4080 prioritybooster!priorityboosterdevicecontrol\n","slug":"wkp1-5","date":"2021-12-24T04:00:00.000Z","categories_index":"Windows","tags_index":"windows,note,kernel,wkp","author_index":"御史神风"},{"id":"b18e35184f4ae33a90ef7f51ea6e9e65","title":"《逆向工程实战》1.7练习 反编译windows内核例程","content":"《逆向工程实战》1.7 练习 反编译windows内核例程例程选取自win10 x64 21h1\n摘要每个例程反编译的知识点如下：\n\nKeInitializeDpc：结构体赋值，纯拷贝\n\nKeInitializeApc：结构体赋值，有条件拷贝\n\nObFastDereferenceObject：while循环，比较后交换的分析\n\nKeInitializeQueue：结构体赋值，有条件拷贝\n\nKxWaitForLockChainValid：do-while循环，if(a &amp;&amp; b &amp;&amp; c){}else{}结构\n\nKeReadyThread：嵌套的if(){}结构\n\nKiInitializeTSS（未找到）\n\nRtlValidateUnicodeString：if(a &amp;&amp; b || c){}else{}结构\n\n\n条件复杂的if(){}else{}KxWaitForLockChainValid和RtlValidateUnicodeString都有类似if(a &amp;&amp; b || c)的结构\n其多个的jmp结果一定会去到两个分支之一，然后回到主分支\n可以理解成析取或合取表达式的提取\n我对windows采用的编译器的理解是，对于或（||）通过多个jmp实现：\n&#x2F;&#x2F; c++\nif(a&#x3D;&#x3D;0 || b&#x3D;&#x3D;0 || c&#x3D;&#x3D;0)\n    BranchA();\nelse\n    BranchB();\n\n# asm\ntest a, a\njz loc_A\ntest b, b\njz loc_A\ntest c, c\njz loc_A\ncall BranchB\njmp loc_ed\nloc_A:\ncall BrancA\nloc_ed:\n\n对于（&amp;&amp;）会将后面的合取转成析取，然后生成一个chunk：\n&#x2F;&#x2F; c++ 1\nif(a&#x3D;&#x3D;0 &amp;&amp; b&#x3D;&#x3D;0 &amp;&amp; c&#x3D;&#x3D;0) &#x2F;&#x2F; &#x3D;&gt; if(a&#x3D;&#x3D;0 &amp;&amp; !(b!&#x3D;0 || c!&#x3D;0))\n    BranchA();\nelse\n    BranchB();\n\n&#x2F;&#x2F; c++ 2\nif(a&#x3D;&#x3D;0) &#123;\n    if(b!&#x3D;0 || c!&#x3D;0)\n         BranchB();\n    else\n        BranchA();\n&#125;\nelse &#123;\n    BranchB();\n&#125;\n\n# asm\ntest a, a\njz chunk_1\nloc_B:\ncall BranchB\nloc_ed:\n# ...\n\nchunk_1:\ntest b, b\njnz loc_B\ntest c, c\njnz loc_B\ncall BranchA\njmp loc_ed\n\nKeInitializeDpc前置信息&#x2F;&#x2F; MSDN\nvoid KeInitializeDpc(\n  [out]          __drv_aliasesMem PRKDPC Dpc,\n  [in]           PKDEFERRED_ROUTINE      DeferredRoutine,\n  [in, optional] __drv_aliasesMem PVOID  DeferredContext\n);\n\nKDPC的结构（该结构在win10 x64各版本中未发生过改变）：\nstruct _KDPC\n&#123;\n    union\n    &#123;\n        ULONG TargetInfoAsUlong;    &#x2F;&#x2F;0x0\n        struct\n        &#123;\n            UCHAR Type;             &#x2F;&#x2F;0x0\n            UCHAR Importance;       &#x2F;&#x2F;0x1\n            volatile USHORT Number; &#x2F;&#x2F;0x2\n        &#125;;\n    &#125;;\n    struct _SINGLE_LIST_ENTRY DpcListEntry; &#x2F;&#x2F;0x8\n    ULONGLONG ProcessorHistory;     &#x2F;&#x2F;0x10\n    VOID (*DeferredRoutine)(struct _KDPC* arg1, VOID* arg2, VOID* arg3, VOID* arg4); &#x2F;&#x2F;0x18\n    VOID* DeferredContext; &#x2F;&#x2F;0x20\n    VOID* SystemArgument1; &#x2F;&#x2F;0x28\n    VOID* SystemArgument2; &#x2F;&#x2F;0x30\n    VOID* DpcData;         &#x2F;&#x2F;0x38\n&#125;; \n\n汇编使用工具得到的反汇编如下：\n.text:00000001402E39E0 KeInitializeDpc proc near\n.text:00000001402E39E0                 xor     eax, eax\n.text:00000001402E39E2                 mov     dword ptr [rcx], 113h\n.text:00000001402E39E8                 mov     [rcx+38h], rax\n.text:00000001402E39EC                 mov     [rcx+10h], rax\n.text:00000001402E39F0                 mov     [rcx+18h], rdx\n.text:00000001402E39F4                 mov     [rcx+20h], r8\n.text:00000001402E39F8                 retn\n.text:00000001402E39F8 KeInitializeDpc endp\n\n反编译该初始化函数只是简单的赋值\n反编译结果如下：\nvoid KeInitializeDpc(\n    PRKDPC Dpc,\n    PKDEFERRED_ROUTINE DeferredRoutine,\n    PVOID DeferredContext)\n&#123;\n    Dpc-&gt;TargetInfoAsUlong &#x3D; 0x113; &#x2F;&#x2F; Type&#x3D;0x13, Importance&#x3D;0x1, Number&#x3D;0\n    Dpc-&gt;ProcessorHistory &#x3D; 0;\n    Dpc-&gt;DeferredRoutine &#x3D; DeferredRoutine;\n    Dpc-&gt;DeferredContext &#x3D; DeferredContext;\n    Dpc-&gt;DpcData &#x3D; 0;\n&#125;\n\nKeInitializeApc前置信息这是个未文档化的函数\n显然会用到KAPC结构（win10 x64 21H1）：\n&#x2F;&#x2F;0x58 bytes (sizeof)\nstruct _KAPC\n&#123;\n    UCHAR Type;                      &#x2F;&#x2F;0x0\n    UCHAR SpareByte0;                &#x2F;&#x2F;0x1\n    UCHAR Size;                      &#x2F;&#x2F;0x2\n    UCHAR SpareByte1;                &#x2F;&#x2F;0x3\n    ULONG SpareLong0;                &#x2F;&#x2F;0x4\n    struct _KTHREAD* Thread;         &#x2F;&#x2F;0x8\n    struct _LIST_ENTRY ApcListEntry; &#x2F;&#x2F;0x10\n    VOID* Reserved[3];               &#x2F;&#x2F;0x20\n    VOID* NormalContext;             &#x2F;&#x2F;0x38\n    VOID* SystemArgument1;           &#x2F;&#x2F;0x40\n    VOID* SystemArgument2;           &#x2F;&#x2F;0x48\n    CHAR ApcStateIndex;              &#x2F;&#x2F;0x50\n    CHAR ApcMode;                    &#x2F;&#x2F;0x51\n    UCHAR Inserted;                  &#x2F;&#x2F;0x52\n&#125;; \n\n在旧版本中（21H1之前），成员Reserved[3]被认为是union：\nunion\n   &#123;\n       struct\n       &#123;\n           VOID (*KernelRoutine)(struct _KAPC* arg1, VOID (**arg2)(VOID* arg1, VOID* arg2, VOID* arg3), VOID** arg3, VOID** arg4, VOID** arg5); &#x2F;&#x2F;0x20\n           VOID (*RundownRoutine)(struct _KAPC* arg1);                     &#x2F;&#x2F;0x28\n           VOID (*NormalRoutine)(VOID* arg1, VOID* arg2, VOID* arg3);      &#x2F;&#x2F;0x30\n       &#125;;\n       VOID* Reserved[3];                                                  &#x2F;&#x2F;0x20\n   &#125;;\n\n汇编使用工具得到的反汇编如下：\n.text:00000001402F93D0 KeInitializeApc proc near\n.text:00000001402F93D0 arg_20          &#x3D; qword ptr  28h ; RundownRoutine\n.text:00000001402F93D0 arg_28          &#x3D; qword ptr  30h ; NormalRoutine\n.text:00000001402F93D0 arg_30          &#x3D; byte ptr  38h  ; ApcMode\n.text:00000001402F93D0 arg_38          &#x3D; qword ptr  40h ; NormalContext\n.text:00000001402F93D0\n.text:00000001402F93D0                 mov     byte ptr [rcx], 12h   ; Apc-&gt;Type &#x3D; 0x12\n.text:00000001402F93D3                 mov     r10, rcx\n.text:00000001402F93D6                 mov     byte ptr [rcx+2], 58h ; Apc-&gt;Size &#x3D; 0x58\n.text:00000001402F93DA                 cmp     r8d, 2\n.text:00000001402F93DE                 jz      short loc_1402F9424\n.text:00000001402F93E0\n.text:00000001402F93E0 loc_1402F93E0:                          ; CODE XREF: KeInitializeApc+5B↓j\n.text:00000001402F93E0                 mov     rax, [rsp+arg_20]\n.text:00000001402F93E5                 mov     [rcx+50h], r8b ; Apc-&gt;ApcStateIndex &#x3D; ApcStateIndex\n.text:00000001402F93E9                 mov     [rcx+28h], rax ; Apc-&gt;RundownRoutine &#x3D; RundownRoutine\n.text:00000001402F93ED                 mov     [rcx+8], rdx   ; Apc-&gt;Thread &#x3D; Thread\n.text:00000001402F93F1                 mov     rdx, [rsp+arg_28]\n.text:00000001402F93F6                 mov     [rcx+30h], rdx ; Apc-&gt;NormalRoutine &#x3D; NormalRoutine\n.text:00000001402F93FA                 mov     rax, rdx\n.text:00000001402F93FD                 neg     rax\n.text:00000001402F9400                 mov     [rcx+20h], r9  ; Apc-&gt;KernelRoutine &#x3D; KernelRoutine\n.text:00000001402F9404                 sbb     rcx, rcx\n.text:00000001402F9407                 and     rcx, [rsp+arg_38]\n.text:00000001402F940C                 neg     rdx\n.text:00000001402F940F                 sbb     al, al\n.text:00000001402F9411                 and     al, [rsp+arg_30]\n.text:00000001402F9415                 mov     [r10+51h], al  ; Apc-&gt;ApcMode &#x3D; ApcMode\n.text:00000001402F9419                 mov     [r10+38h], rcx ; Apc-&gt;NormalContext &#x3D; NormalContext\n.text:00000001402F941D                 mov     byte ptr [r10+52h], 0 ; Apc-&gt;Inserted &#x3D; 0\n.text:00000001402F9422                 retn\n.text:00000001402F9422 ; ---------------------------------------------------------------------------\n.text:00000001402F9423                 align 4\n.text:00000001402F9424\n.text:00000001402F9424 loc_1402F9424:                          ; CODE XREF: KeInitializeApc+E↑j\n.text:00000001402F9424                 mov     r8b, [rdx+24Ah] ; ApcStateIndex &#x3D; Thread-&gt;ApcStateIndex\n.text:00000001402F942B                 jmp     short loc_1402F93E0\n.text:00000001402F942B KeInitializeApc endp\n\n反编译1402F93D6 mov byte ptr [rcx+2], 58h对照KAPC的结构，可以发现刚好成员size的偏移是+2，而sizeof(_KAPC) = 0x58由此判断rcx是KAPC*\n根据后面对Apc的赋值，能够还原参数的符号\n比较有意思的是下面这段汇编：\n.text:00000001402F93F1                 mov     rdx, [rsp+arg_28] ; rdx &#x3D; NormalRoutine\n; ...\n.text:00000001402F93FA                 mov     rax, rdx          ; rax &#x3D; NormalRoutine\n; ...\n.text:00000001402F940C                 neg     rdx               ; rdx &#x3D; -NormalRoutine\n.text:00000001402F940F                 sbb     al, al            ; al &#x3D; NormalRoutine !&#x3D; 0 ? -1 : 0\n.text:00000001402F9411                 and     al, [rsp+arg_30]  ; al &#x3D; NormalRoutine !&#x3D; 0 ? ApcMode : 0;\n.text:00000001402F9415                 mov     [r10+51h], al\n\n通过组合neg b; sbb a, a; and a, c实现的a = b != 0 ? c : 0 \n当b不等于0时，neg会置cf为1，sbb便会借位，于是a = a - a - 1 = -1；而b等于0时，neg会置cf为0，a = a - a = 0\n反编译代码如下：\nvoid KeInitializeApc(\n    _KAPC* Apc,\n    struct _KTHREAD* Thread,\n    CHAR ApcStateIndex,\n    void* KernelRoutine,  &#x2F;&#x2F; func\n    void* RundownRoutine, &#x2F;&#x2F; func\n    void* NormalRoutine,  &#x2F;&#x2F; func\n    CHAR ApcMode,\n    VOID* NormalContext\n)\n&#123;\n    Apc-&gt;Type &#x3D; 0x12;\n    Apc-&gt;Size &#x3D; 0x58;\n    if(ApcStateIndex &#x3D;&#x3D; 2)\n        ApcStateIndex &#x3D; Thread-&gt;ApcStateIndex;\n     Apc-&gt;Thread &#x3D; Thread;\n    Apc-&gt;ApcStateIndex &#x3D; ApcStateIndex;\n    Apc-&gt;KernelRoutine &#x3D; KernelRoutine;\n    Apc-&gt;RundownRoutine &#x3D; RundownRoutine;\n    Apc-&gt;NormalRoutine &#x3D; NormalRoutine;\n    Apc-&gt;ApcMode &#x3D; NormalRoutine !&#x3D; 0 ? ApcMode : 0;\n    Apc-&gt;NormalContext &#x3D; NormalContext;\n&#125;\n\nObFastDereferenceObject前置信息已知该函数在20h2和21h1中相同，且调用惯例应该是stdcall（被调用方清理栈），由于只有两个参数（通过寄存器传递），所以不需要清理\n查阅资料在win7中该函数的调用惯例应该也是stdcall\nMSDN原文:\nObDereferenceObject returns a value that is reserved for system use. Drivers must treat this value as VOID.\n&#x2F;&#x2F; MSDN\nvoid ObDereferenceObject(\n  [in]  a\n);\n\n汇编有一些比较陌生的汇编指令：\nprefectchw：不影响程序的行为。用于将数据提前装入缓存，减少延迟。\nlock cmpxchg r/m, r：x86上CAS被翻译成该指令。CAS是比较交换，无锁原子过程\ncmpxchg (r/m)a, (r)b：将al/ax/eax/rax与首操作数比较；若相等，等同于mov a, b且zf=1；否则等同于mov al/ax/eax/rax, a且zf=0\n使用工具得到的反汇编如下：\n.text:0000000140298F70 ObFastDereferenceObject proc near\n.text:0000000140298F70                 sub     rsp, 28h\n.text:0000000140298F74                 mov     r9, rdx         ; r9 &#x3D; a2\n.text:0000000140298F77                 prefetchw byte ptr [rcx]\n.text:0000000140298F7A                 mov     rax, [rcx]      ; rax &#x3D; *a1\n.text:0000000140298F7D                 mov     r8, rax\n.text:0000000140298F80                 xor     r8, rdx         ; r8 &#x3D; (*a1) ^ a2\n.text:0000000140298F83                 cmp     r8, 0Fh\n.text:0000000140298F87                 jnb     short b1_140298F9A ; jmp r8 &gt;&#x3D; 0xf\n.text:0000000140298F89\n.text:0000000140298F89 loopBody_140298F89:                     ; CODE XREF: ObFastDereferenceObject+3E↓j\n.text:0000000140298F89                 lea     r8, [rax+1]     ; r8 &#x3D; *a1 + 1\n.text:0000000140298F8D                 lock cmpxchg [rcx], r8\n.text:0000000140298F92                 jnz     short loopCheck_140298FA4\n.text:0000000140298F94\n.text:0000000140298F94 ret_140298F94:                          ; CODE XREF: ObFastDereferenceObject+32↓j\n.text:0000000140298F94                 add     rsp, 28h\n.text:0000000140298F98                 retn\n.text:0000000140298F98 ; ---------------------------------------------------------------------------\n.text:0000000140298F99                 align 2\n.text:0000000140298F9A\n.text:0000000140298F9A b1_140298F9A:                           ; CODE XREF: ObFastDereferenceObject+17↑j\n.text:0000000140298F9A                                         ; ObFastDereferenceObject+40↓j\n.text:0000000140298F9A                 mov     rcx, r9         ; DmaAdapter\n.text:0000000140298F9D                 call    HalPutDmaAdapter\n.text:0000000140298FA2                 jmp     short ret_140298F94\n.text:0000000140298FA4 ; ---------------------------------------------------------------------------\n.text:0000000140298FA4\n.text:0000000140298FA4 loopCheck_140298FA4:                    ; CODE XREF: ObFastDereferenceObject+22↑j\n.text:0000000140298FA4                 mov     rdx, rax\n.text:0000000140298FA7                 xor     rdx, r9         ; rdx &#x3D; rax ^ r9\n.text:0000000140298FAA                 cmp     rdx, 0Fh\n.text:0000000140298FAE                 jb      short loopBody_140298F89 ; r8 &#x3D; *a1 + 1\n.text:0000000140298FB0                 jmp     short b1_140298F9A ; break\n.text:0000000140298FB0 ObFastDereferenceObject endp\n\n反编译_InterlockedCompareExchange64(*Dst, Exc, Cmp)，Exc是新值，Cmp是比较值\n反编译代码如下：\nvoid ObDereferenceObject(UInt64* obj, const UInt64 a2)\n&#123;\n    &#x2F;&#x2F; begin:\n    _m_prefectchw(obj);\n    UInt64 v0 &#x3D; *obj; &#x2F;&#x2F; rax\n    UInt64 v1 &#x3D; v0 ^ a2;\n    \n    while(v1 &lt; 0xf) &#123;\n        &#x2F;&#x2F; loopBody:\n        UInt64 oldV0 &#x3D; v0;\n        v0 &#x3D; _InterlockedCompareExchange64(obj, v0 + 1, v0);\n        if(oldV0 &#x3D;&#x3D; v0) &#x2F;&#x2F; if v0 not change(obj &#x3D; v0 + 1)\n            return;\n        &#x2F;&#x2F; loopCheck:\n        v1 &#x3D; v0 ^ a2;\n    &#125;\n    \n    &#x2F;&#x2F; b1:\n    v0 &#x3D; HalPutDmaAdapter(a2);\n    \n    &#x2F;&#x2F; ret:\n    return;\n&#125;\n\n其中loopBody的四行代码相当于以下代码\nif(*obj &#x3D;&#x3D; v0) &#123;\n    *obj &#x3D; v0 + 1;\n    return;\n&#125;\nelse&#123;\n    v0 &#x3D; *obj;\n&#125;\n\nKeInitializeQueue前置信息&#x2F;&#x2F; MSDN\nvoid KeInitializeQueue(\n  [out] PRKQUEUE Queue,\n  [in]  ULONG    Count\n);\n\ntypedef struct _KQUEUE &#123;\n    DISPATCHER_HEADER Header;  &#x2F;&#x2F; +0h\n    LIST_ENTRY EntryListHead;  &#x2F;&#x2F; +18h\n    ULONG CurrentCount;        &#x2F;&#x2F; +28h\n    ULONG MaximumCount;        &#x2F;&#x2F; +2Ch\n    LIST_ENTRY ThreadListHead; &#x2F;&#x2F; +30h\n&#125; KQUEUE, *PKQUEUE, *RESTRICTED_POINTER PRKQUEUE;\n\nstruct _DISPATCHER_HEADER\n&#123;\n\tunion\n    &#123;\n        struct\n        &#123;\n            UCHAR QueueType;                           &#x2F;&#x2F;0x0\n            union\n            &#123;\n                UCHAR QueueControlFlags;               &#x2F;&#x2F;0x1\n                struct\n                &#123;\n                    UCHAR Abandoned:1;                 &#x2F;&#x2F;0x1\n                    UCHAR DisableIncrement:1;          &#x2F;&#x2F;0x1\n                    UCHAR QueueReservedControlFlags:6; &#x2F;&#x2F;0x1\n                &#125;;\n            &#125;;\n            UCHAR QueueSize;                           &#x2F;&#x2F;0x2\n            UCHAR QueueReserved;                       &#x2F;&#x2F;0x3\n        &#125;;\n    &#125;\n\n汇编.text:00000001402DE420 KeInitializeQueue proc near\n.text:00000001402DE420                 push    rbx\n.text:00000001402DE422                 sub     rsp, 20h\n.text:00000001402DE426                 mov     rbx, rcx        ; rbx &#x3D; Queue\n.text:00000001402DE429                 mov     byte ptr [rcx], 4 ; Queue-&gt;Header.QueueType &#x3D; 4\n.text:00000001402DE42C                 xor     ecx, ecx\n.text:00000001402DE42E                 mov     word ptr [rbx+1], 1000h ; *(WORD*)&amp;Queue-&gt;Header.QueueControlFlags &#x3D; 0x1000\n.text:00000001402DE434                 lea     rax, [rbx+8]    ; rax &#x3D; &amp;Queue-&gt;Header.WaitListHead\n.text:00000001402DE438                 mov     [rax+8], rax    ; Queue-&gt;Header.WaitListHead.Blink &#x3D; &amp;Queue-&gt;Header.WaitListHead\n.text:00000001402DE43C                 mov     [rax], rax      ; Queue-&gt;Header.WaitListHead.Flink &#x3D; &amp;Queue-&gt;Header.WaitListHead\n.text:00000001402DE43F                 lea     rax, [rbx+18h]  ; rax &#x3D; &amp;Queue-&gt;EntryListHead\n.text:00000001402DE443                 mov     [rax+8], rax    ; Queue-&gt;EntryListHead.Blink &#x3D; &amp;Queue-&gt;EntryListHead\n.text:00000001402DE447                 mov     [rax], rax      ; Queue-&gt;EntryListHead.Flink &#x3D; &amp;Queue-&gt;EntryListHead\n.text:00000001402DE44A                 lea     rax, [rbx+30h]  ; rax &#x3D; &amp;Queue-&gt;ThreadListHead\n.text:00000001402DE44E                 mov     [rax+8], rax    ; Queue-&gt;ThreadListHead.Blink &#x3D; &amp;Queue-&gt;ThreadListHead\n.text:00000001402DE452                 mov     [rax], rax      ; Queue-&gt;ThreadListHead.Flink &#x3D; &amp;Queue-&gt;ThreadListHead\n.text:00000001402DE455                 mov     [rbx+4], ecx    ; Queue-&gt;Header.SignalState &#x3D; 0\n.text:00000001402DE458                 mov     [rbx+28h], ecx  ; Queue-&gt;CurrentCount &#x3D; 0\n.text:00000001402DE45B                 test    edx, edx\n.text:00000001402DE45D                 jnz     short loc_1402DE46B ; jmp if edx\n.text:00000001402DE45F                 mov     ecx, 0FFFFh     ; GroupNumber\n.text:00000001402DE464                 call    KeQueryActiveProcessorCountEx\n.text:00000001402DE469                 mov     edx, eax\n.text:00000001402DE46B\n.text:00000001402DE46B loc_1402DE46B:                          ; CODE XREF: KeInitializeQueue+3D↑j\n.text:00000001402DE46B                 mov     [rbx+2Ch], edx  ; Queue-&gt;MaximumCount &#x3D; Count\n.text:00000001402DE46E                 add     rsp, 20h\n.text:00000001402DE472                 pop     rbx\n.text:00000001402DE473                 retn\n.text:00000001402DE473 ; ---------------------------------------------------------------------------\n.text:00000001402DE474                 db 0CCh\n.text:00000001402DE474 KeInitializeQueue endp\n\n反编译void KeInitializeQueue(PRKQUEUE Queue, ULONG Count)\n&#123;\n    Queue-&gt;Header.QueueType &#x3D; 4;\n    *(WORD*)&amp;Queue-&gt;Header.QueueControlFlags &#x3D; 0x1000;\n    Queue-&gt;Header.WaitListHead.Blink &#x3D; &amp;Queue-&gt;Header.WaitListHead;\n    Queue-&gt;Header.WaitListHead.Flink &#x3D; &amp;Queue-&gt;Header.WaitListHead;\n    Queue-&gt;EntryListHead.Blink &#x3D; &amp;Queue-&gt;EntryListHead;\n    Queue-&gt;EntryListHead.Flink &#x3D; &amp;Queue-&gt;EntryListHead;\n    Queue-&gt;ThreadListHead.Blink &#x3D; &amp;Queue-&gt;ThreadListHead;\n    Queue-&gt;ThreadListHead.Flink &#x3D; &amp;Queue-&gt;ThreadListHead;\n    Queue-&gt;Header.SignalState &#x3D; 0;\n    Queue-&gt;CurrentCount &#x3D; 0;\n    if ( !Count )\n    Count &#x3D; KeQueryActiveProcessorCountEx(0xFFFFu);\n    Queue-&gt;MaximumCount &#x3D; Count;\n&#125;\n\nKxWaitForLockChainValid汇编.text:0000000140279BD0 KxWaitForLockChainValid proc near\n.text:0000000140279BD0 arg_0           &#x3D; qword ptr  8\n.text:0000000140279BD0                 mov     [rsp+arg_0], rbx\n.text:0000000140279BD5                 push    rdi\n.text:0000000140279BD6                 sub     rsp, 20h\n.text:0000000140279BDA                 mov     rdi, rcx        ; rdi &#x3D; a1\n.text:0000000140279BDD                 xor     ebx, ebx        ; ebx &#x3D; 0\n.text:0000000140279BDF\n.text:0000000140279BDF loopStart_140279BDF:                    ; CODE XREF: KxWaitForLockChainValid+25↓j\n.text:0000000140279BDF                 inc     ebx             ; ebx++\n.text:0000000140279BE1                 test    cs:HvlLongSpinCountMask, ebx\n.text:0000000140279BE7                 jz      branch1_140437A78\n.text:0000000140279BED\n.text:0000000140279BED pause_140279BED:                        ; CODE XREF: KxWaitForLockChainValid+1BDEB0↓j\n.text:0000000140279BED                 pause\n.text:0000000140279BEF\n.text:0000000140279BEF loopCheck_140279BEF:                    ; CODE XREF: KxWaitForLockChainValid+1BDECB↓j\n.text:0000000140279BEF                 mov     rax, [rdi]      ; rax &#x3D; *a1\n.text:0000000140279BF2                 test    rax, rax\n.text:0000000140279BF5                 jz      short loopStart_140279BDF ; jmp if *a1 &#x3D;&#x3D; 0\n.text:0000000140279BF7                 mov     rbx, [rsp+28h+arg_0]\n.text:0000000140279BFC                 add     rsp, 20h\n.text:0000000140279C00                 pop     rdi\n.text:0000000140279C01                 retn\n.text:0000000140279C01 ; ---------------------------------------------------------------------------\n.text:0000000140279C02                 db 0CCh\n.text:0000000140279C02 KxWaitForLockChainValid endp\n\n\n.text:0000000140437A78 ; START OF FUNCTION CHUNK FOR KxWaitForLockChainValid\n.text:0000000140437A78\n.text:0000000140437A78 branch1_140437A78:                      ; CODE XREF: KxWaitForLockChainValid+17↑j\n.text:0000000140437A78                 mov     eax, cs:HvlEnlightenments\n.text:0000000140437A7E                 test    al, 40h\n.text:0000000140437A80                 jz      pause_140279BED\n.text:0000000140437A86                 call    KiCheckVpBackingLongSpinWaitHypercall\n.text:0000000140437A8B                 test    al, al\n.text:0000000140437A8D                 jz      pause_140279BED\n.text:0000000140437A93                 mov     ecx, ebx\n.text:0000000140437A95                 call    HvlNotifyLongSpinWait\n.text:0000000140437A9A                 nop\n.text:0000000140437A9B                 jmp     loopCheck_140279BEF ; rax &#x3D; *a1\n.text:0000000140437A9B ; END OF FUNCTION CHUNK FOR KxWaitForLockChainValid\n\n反编译branch1实际上就是一个if(a &amp; b &amp; c){}else{}的结构，各个jcc是顺序排序，只要触发一个就去到false分支，分析关键是抓住能走完全部jcc的路径\nunsigned long long KxWaitForLockChainValid(unsigned long long* a1)&#123;\n\tint i &#x3D; 0;\n    do&#123;\n        &#x2F;&#x2F; loopStart:\n        i++;\n        if((i &amp; HvlLongSpinCountMask) &#x3D;&#x3D; 0\n          &amp;&amp; (HvlEnlightenments &amp; 0x40) !&#x3D; 0\n          &amp;&amp; KiCheckVpBackingLongSpinWaitHypercall() !&#x3D; 0) &#123;\n            HvlNotifyLongSpinWait(i);\n        &#125;else&#123;\n            _mm_pause();\n        &#125;\n    &#125;while(!*a1);\n    return *a1;\n&#125;\n\nKeReadyThread嵌套的if{}，结构如下：\n&#123;\n    c0();\n    if() &#123;\n        c1();\n        if() c2();\n        c3();\n        if() ret();\n    &#125;\n    c4();\n    ret();\n&#125;\n\nKiInitializeTSS（未找到）21h1的ntoskrnl.exe中未找到\nRtlValidateUnicodeStringif((a &amp;&amp; b) || c)结构\nif(a || (!b &amp;&amp; (c || d || e || f)) || (g &amp;&amp; (h || !i))) &#123;\n    return 0xC000000D;\n&#125;else&#123;\n    return 0;\n&#125;\n\n","slug":"practicalre1-7","date":"2021-11-08T14:07:00.000Z","categories_index":"Windows","tags_index":"windows,note,practicalre,antiDebug","author_index":"御史神风"},{"id":"7081df1a25a0e63a8adb7b11423fb4be","title":"从0开始：某fpsgo简单透视制作","content":"从0开始：某fpsgo简易透视制作摘要\n\n\n\n\n\n\n\n\n前置知识：\n线性代数知识：矩阵的基本运算\n图形学知识：齐次坐标，仿射变换，MVP模型\n（可选）旋转、四元数与欧拉角（我也不懂）\n其他：CE的基本使用、C++、dll编写与注入、IMGUI\n\n\n\n\n\n\n\n\n\n一些资源：\nfrk1/hazedumper: up to date csgo offsets and hazedumper config (github.com)\ndanielkrupinski/Osiris: Free open-source game cheat for Counter-Strike: Global Offensive, written in modern C++. GUI powered by Dear ImGui. (github.com)\n\n\n\n\n\n\n\n\n\nhazedumper\n&gt;&#x2F;&#x2F; to client.dll\n&gt;constexpr DWORD myObjNodeOff &#x3D; dwEntityList;\n&gt;constexpr DWORD viewMatOff \n&gt;&#x2F;&#x2F; to OBJECT\n&gt;constexpr DWORD healthOff &#x3D; m_iHealth;\n&gt;constexpr DWORD positionOff&#x3D; m_vecOrigin;\nhazedumper中有所需要的偏移的地址，抱着学习的目的，就选择手动找了\n流程如下：\n\n1 找基址\n\n1.1 找object结构体地址\n1.2 找object链表基址\n1.3 分析结构体找出position偏移\n1.4 找vp变换矩阵基址\n\n\n2 世界到屏幕坐标转换\n\n读取vp矩阵、读取position\n视图变换\n标准立方体到屏幕\n\n\n3 绘制\n\n\n（以下地址和偏移均不是真实值）\n1 找基址\n\n\n\n\n\n\n\n\n神秘指令：\n// 已删除该部分\n1.1 找结构体地址猜测生命值是结构体的成员，先找生命值的地址\n用hurtme修改生命值，搜索精确数值，大概有22个结果\n根据访问情况排除：\n\n只有cmp指令\nserver.dll中的指令\n访问次数过少或没有\n没有偏移量的（如mov eax, [esi]）\n类型不符合（如搜整形遇到浮点指令）\n\n剩下如下可能性较大结果：\nh1 &#x3D; [0x0C704E00+0x1c]\n(client.dll)\nmov eax, [edi+0x1c]\ncmp eax, -1\n\nh2 &#x3D; [0x0C8345F0+0x18]\n(panorama.dll)\nmov ecx, [ecx+0x18]\ncmp ecx, [eax+0x18]\n\nh3 &#x3D; [0x41AA4248+0xd8]\n(client.dll)\ncall eax\n...\nmov [edi+0xd8], eax\n\nh4 &#x3D; [606F4D60+0x100]\n(client.dll)\nmov eax, [ecx+0x100]\nret\n(client.dll)\ncmp [ecx+0x100], 0\n\n综合来看h4的可能性比较大，即h4的基址可能是结构体地址，生命值的偏移为0x100\nOBJ\n+0x100: health int\n\n1.2 找链表地址搜到4个绿色的地址，保存着结构体地址\n只有一个具有链表的结构\n最终得到如下结构：\nclient.dll+666F75C OBJ_NODE\n+0: 6666BD60 OBJ*\n+4: 666      int\n+8:          OBJ_NODE*\n+C:          OBJ_NODE*\n\n也就是可以通过如下方式获取health：\nDWORD clientBase;\nDWORD pMyObjNode &#x3D; clientBase+0x6666888; &#x2F;&#x2F; OBJ_NODE*\nDWORD pMyObj &#x3D; *(DWORD*)(pobj_node);     &#x2F;&#x2F; OBJ*\nDWORD health &#x3D; *(DWORD*)(pobj+0x66);\n\n遍历链表可以发现，所以物品都在里面，生命值&gt;0的就是玩家或机器人，刚刚好有10个\n下面是遍历的代码：\ntypedef struct _OBJ_NODE &#123;\n    void* pObj;\n    int id;\n    void* prev, * next;\n&#125;OBJ_NODE, * POBJ_NODE;\nconstexpr DWORD myObjNodeOff &#x3D; 0x6666888;\nconstexpr DWORD healthOff &#x3D; 0x66;\n\nHANDLE hProc;                &#x2F;&#x2F; get it by yourself\nDWORD clientBase;            &#x2F;&#x2F; get it by yourself\nvoid* pMyObjNode, *pObjNode;\nOBJ_NODE myObjNode, objNode;\nint healthAddr, health;\n\n&#x2F;&#x2F; My Node\nint numHeal &#x3D; 1;\npMyObjNode &#x3D; (void*)(clientBase + myObjNodeOff);\nReadProcessMemory(hProc, (LPVOID)pMyObjNode, &amp;myObjNode, sizeof(OBJ_NODE), NULL);\nhealthAddr &#x3D; (DWORD)myObjNode.pObj + healthOff;\nReadProcessMemory(hProc, (LPVOID)healthAddr, &amp;health, 4, NULL);\n&#x2F;&#x2F; Prev\nfor (pObjNode &#x3D; myObjNode.prev; pObjNode; pObjNode &#x3D; objNode.prev) &#123;\n    ReadProcessMemory(hProc, (LPVOID)pObjNode, &amp;objNode, sizeof(OBJ_NODE), NULL);\n    healthAddr &#x3D; (DWORD)objNode.pObj + healthOff;\n    ReadProcessMemory(hProc, (LPVOID)healthAddr, &amp;health, 4, NULL);\n    if (health &gt; 0) numHeal++;\n&#125;\n&#x2F;&#x2F; Next\nfor (pObjNode &#x3D; myObjNode.next; pObjNode; pObjNode &#x3D; objNode.next) &#123;\n    ReadProcessMemory(hProc, (LPVOID)pObjNode, &amp;objNode, sizeof(OBJ_NODE), NULL);\n    healthAddr &#x3D; (DWORD)objNode.pObj + healthOff;\n    ReadProcessMemory(hProc, (LPVOID)healthAddr, &amp;health, 4, NULL);\n    if (health &gt; 0) numHeal++;\n&#125;\n\nprintf_s(&quot;\\nnumHeal:%d\\n&quot;, numHeal);\n&#x2F;&#x2F; &gt;numHeal:10\n\n1.3 找出position偏移查看结构体内存，显示类型选择单浮点，当跳的时候只有z轴是变的，根据此找坐标的位置\n观察内存数值的变化得到下面的信息\nOBJ\n+64  加速度 float[3]\n+60  坐标   float[3]\n+6C  坐标   float[3]\n+88 坐标   float[3]\n\n1.4 找vp变换矩阵基址搜索单精度浮点\n先移动视角，然后搜索变换的值，再移动位置，搜索未改变的值，重复以上步骤\n2 世界到屏幕坐标转换世界坐标系到屏幕坐标系的转换有2步，这里简述一下（具体实现根据引擎会有细微差别）（大量括号警告：CG有些名词中文翻译不一致，标上英语）：\n\n第一步是mvp转换：m（model trans.）指模型坐标转世界坐标v（view trans.）指世界坐标转摄像机（摄像机为原点）坐标p（projection trans.）指投影转换，分为正交投影（Orthographic proj.)和透视投影（Perspective proj.），且会将结果归一化（正交投影就是归一化、而透视投影是透视变换+归一化）前面我们得到的是世界坐标和vp矩阵，所以不存在模型坐标向世界坐标转换的步骤（opengl给的就是vp矩阵）\n\n第1.5步是归一化（规范化？）：\n（这一步opengl叫透视除法，perspective divide）上面说到投影转换最后会归一化，但在opengl的透视投影转换的透视转换这一过程中，没有维持w为1这一步就是除以那个w，因为用的是齐次坐标，点坐标的w应该为1\n\n第二步是视口变换（viewport mapping）：这一步的目标是将坐标转换成屏幕上的坐标需要注意处理原点误差的问题\n\n\nopengl中把第一步结果的坐标系称为裁剪坐标系（Clip space）第1.5步结果的坐标系称为规范化设备坐标系（NDC，Normalized Device Coord. space）第二步结果的坐标系称为屏幕坐标（Screen space）\nopengl中我认为易错的两点其一是第1.5步的维持点坐标w为1\n其二是第二步视口转换中要处理原点误差\n为了方便这里就不写矩阵了，对于x，原公式是screen.x = ndc.x * (w/2) + (w/2) + x ，那个x是屏幕原点坐标，应该为0。网上有些代码会写成screen.x = ndc.x * (w/2) + (w/2) + ndc.x因为归一化，ndc.x小于1，所以对结果没有太大影响，问题就被忽略了\n3 绘制这里我用的是外部绘制，用的imgui，最好是静态编译（需要先安装dx sdk，才有静态的dx.lib）\n内部绘制的话hook dx的api即可\n透明窗口的创建如下：\n&#123;\t\n\tint width &#x3D; 1920;\n    int height &#x3D; 1080;\n\n\tWNDCLASSEX wc &#x3D; &#123; sizeof(WNDCLASSEX), CS_CLASSDC, WndProc, 0L, 0L, GetModuleHandle(NULL), NULL, NULL, NULL, NULL, _T(&quot;Diana&quot;), NULL &#125;;\n    RegisterClassEx(&amp;wc);\n    HWND hwnd &#x3D; ::CreateWindow(wc.lpszClassName, _T(&quot;DianaLookAtYou&quot;), WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_CHILD | WS_POPUP | WS_POPUP | WS_EX_TOPMOST, 0, 0, width, height, NULL, NULL, wc.hInstance, NULL);\n    LONG nRet &#x3D; ::GetWindowLong(hwnd, GWL_EXSTYLE); nRet &#x3D; nRet | WS_EX_LAYERED; ::SetWindowLong(hwnd, GWL_EXSTYLE, nRet);\n    SetLayeredWindowAttributes(hwnd, RGB(255, 0, 255), (BYTE)200, LWA_ALPHA | LWA_COLORKEY);\n    SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE) | WS_EX_TRANSPARENT);\n    SetLayeredWindowAttributes(hwnd, RGB(0, 0, 0), 0, LWA_COLORKEY);\n    SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);\n&#125;\n\n","slug":"fpsgoPerspective","date":"2021-11-08T12:54:00.000Z","categories_index":"Hack","tags_index":"hack,fps","author_index":"御史神风"},{"id":"a1005445484098080c05958ea32d43c1","title":"《逆向工程实战》实例J","content":"《逆向工程实战》实例JDllMain 反编译尽量按汇编反编译结果（没有太多优化）：\nBOOL DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n&#123;\n    char[8] idtr;\n    unsigned int IDTBase;\n    PROCESSENTRY32 pe;\n    \n    &#x2F;&#x2F; Chunk 0:\n    \n    &#x2F;&#x2F; 10001C6A ~ 10001C6E\n    __sidt(&amp;idtr);\n    IDTBase &#x3D; *(unsigned int*)(idtr+2);\n    \n    &#x2F;&#x2F; 10001C71 ~ 10001C85\n    if((IDTBase &gt; 0x8003F400) &amp;&amp; (IDTBase &lt; 0x80047400)) &#123;\n        return 0;\n    &#125;\n    \n    &#x2F;&#x2F; Chunk 1:\n    \n    &#x2F;&#x2F; 10001C88 ~ 10001CA9\n    HANDLE hSnapshot &#x3D; CraeteToolhelp32Snapshot(2, 0); &#x2F;&#x2F; get thread message\n    memset(&amp;pe, 0, 0x128); &#x2F;&#x2F; 4+0x49*4\n    \n    &#x2F;&#x2F; 10001CAB ~ 10001CB6\n    if(hSnapshot &#x3D;&#x3D; -1) &#123;\n        &#x2F;&#x2F; invalid handle\n        return 0;\n    &#125;\n    \n    &#x2F;&#x2F; Chunk 2:\n    \n    &#x2F;&#x2F; 10001CB9 ~ 10001D22\n    pe.dwSize &#x3D; 0x128; &#x2F;&#x2F; &#x3D; sizeof(PROCESSENTRY32)\n    int flag &#x3D; Process32First(hSnapshot, &amp;pe);\n    while(flag) &#123;\n        if(stricmp(pe.szExeFile,&quot;explorer.exe&quot;) &#x3D;&#x3D; 0) &#123;\n        \t&#x2F;&#x2F; IsExplorer:\n            t1 &#x3D; pe.th32ParentProcessID;\n            t2 &#x3D; pe.th32ProcessID;\n            break;\n        &#125;\n        flag &#x3D; Process32Next(hSnapshot, &amp;pe);\n    &#125;\n    &#x2F;&#x2F; 10001D24 ~ 10001D27 (BreakWhileProc:)\n    int t1, t2;\n    if(flag &#x3D;&#x3D; 0) &#123;\n        t1 &#x3D; fdwReason;\n        t2 &#x3D; fdwReason;\n    &#125;\n    \n    &#x2F;&#x2F; 10001D2A ~ 10001D35 (CheckLoopResult:)\n    if(t1 &#x3D;&#x3D; t2)\n        return 0;\n    \n    &#x2F;&#x2F; Chunk3:\n    \n    &#x2F;&#x2F; 10001D38 ~ 10001D5C\n    if(fdwReason &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; DLL_PROCESS_ATTACH\n        CreateThread(0, 0, 0x100032D0, 0, 0, 0);\n    &#125;\n    return 1;\n&#125;\n\n__sidt对应汇编指令sidt，作用是读取idtr寄存器到指定地址idtr寄存器大小是6字节，高4字节是IDT基址\n开头检查IDT基址，每个处理器（核）的IDT都不同win xp中只有0核的IDT基址是0x8003F400，后续版本IDT每次重启都会变所以作用是检查是否运行在xp的0核中\nChunk1到Chunk2：检查explorer.exe是否在运行，不在运行就退出\nChunk3：创建一个线程\nDllMain栈帧以下偏移是相对DllMain栈帧的ebp\na开头是参数、v开头是局部变量\n\n\n\noffset(base16)\nname\nsize(base16)\n\n\n\n-130\nv_pe\n128\n\n\n-8\nv_idtr\n6/8\n\n\n+0\nlast_ebp\n4\n\n\n+4\nret_addr\n4\n\n\n+8\na0_hinstDLL\n4\n\n\n+C\na1_fdwReason\n4\n\n\n+10\na2_lpvReserved\n4\n\n\n","slug":"practicalreJ","date":"2021-10-22T04:00:00.000Z","categories_index":"Windows","tags_index":"windows,note,practicalre","author_index":"御史神风"},{"id":"2b002dec449ce21e3d8b7af026d74ae7","title":"逆向工程核心原理 R3静态反调试 笔记","content":"逆向工程核心原理 R3静态反调试 笔记摘要主要是R3层面的静态反调试手段\n参考逆向工程核心原理51章静态反调试\n涉及的API：\n\nIsDebuggerPresent()\n\nNtQueryInformationProcess()\n\nNtQuerySystemInformation()\n\nNtQueryObject()\n\nZwSetInformationThread()\n\nDebugActiveProcessStop()\n\n\n51.2 涉及peb的检查方式\n\n\n偏移\n名称\n类型\n\n\n\n0x2\nBeingDebugged\nUChar\n\n\n0xc\nLdr\nPtr32 _PEB_LDR_DATA\n\n\n0x18\nProcessHesap\nPtr32 Void\n\n\n0x68\nNtGlobalFlag\nUint48\n\n\nBeingDebugged 标志位 \n处于调试状态，BeingDebugged被设置为1。IsDebuggerPresent()检查 BeingDebugged。\nLdr 堆内存检查\n调试进程未使用堆内存填充0xFEEEFEEE(x32)。该方法只在xp中有效，且附加不存在该特征：PEB_LDR_DATA结构体在堆内存中创建，扫描该区域是否存在上述特征。\nProcessHeap 标志\nprocessheap结构//todo该方法只在xp中有效，且附加不存在该特征：正常情况Heap.Flags=2，Heap.ForceFlags=0\nNtGlobalFlag Bitmap\n该方法通过附加无效调试状态PEB.NtGlobalFlag |= 0x70由以下位组成FLG_HEAP_ENABLE_TAIL_CHECK (0x10)FLG_HEAP_ENABLE_FREE_CHECK (0x20)FLG_HEAP_VALIDATE_PARAMETERS (0x40)\n51.3 NtQueryInformationProcess()该函数用于查询进程信息。\ntypedef enum PROCESSINFOCLASS &#123;\n\tProcessDebugPort &#x3D; 0x7,\n\tProcessDebugObjectHandle &#x3D; 0x1e,\n\tProcessDebugFlags &#x3D; 0x1f\n&#125;;\n\n&#x2F;&#x2F; MSDN\n__kernel_entry NTSTATUS NtQueryInformationProcess(\n  HANDLE           ProcessHandle,\n  PROCESSINFOCLASS ProcessInformationClass,\n  PVOID            ProcessInformation,\n  ULONG            ProcessInformationLength,\n  PULONG           ReturnLength\n);\n\n第二个参数指定查询的信息。\n非调试情况第三个参数指向地址被填充的值：ProcessDebugPort 填充为0ProcessDebugObjectHandle 填充为0ProcessDebugFlags 填充为1\nbool CheckNtQfP_API()\n&#123;\n\t&#x2F;&#x2F; get api\n\n\tHMODULE hNtdll &#x3D; GetModuleHandleW(L&quot;NtDll.dll&quot;);\n\tauto pNtQueryInformationProcess &#x3D; (PNtQueryInformationProcess)GetProcAddress(hNtdll, &quot;NtQueryInformationProcess&quot;);\n\n\t&#x2F;&#x2F; temp values\n\n\tHANDLE hCurProc &#x3D; GetCurrentProcess();\n\tbool beingDebug &#x3D; false;\n\n\t&#x2F;&#x2F; Process Debug Port (0x7)\n\n\tDWORD dwDebugPort;\n\tpNtQueryInformationProcess(hCurProc, ProcessDebugPort, &amp;dwDebugPort, sizeof(dwDebugPort), NULL);\n    \n\tif (dwDebugPort) beingDebug &#x3D; true;\n\n\t&#x2F;&#x2F; Process Debug Object Handle (0x1E)\n\n\tHANDLE hDebugObject &#x3D; NULL;\n\tpNtQueryInformationProcess(hCurProc, ProcessDebugObjectHandle, &amp;hDebugObject, sizeof(hDebugObject), NULL);\n\n\tif (hDebugObject) beingDebug &#x3D; true;\n\n\t&#x2F;&#x2F; Process Debug Flags (0x1F)\n\n\tBOOL bDebugFlag &#x3D; true;\n\tpNtQueryInformationProcess(hCurProc, ProcessDebugFlags, &amp;bDebugFlag, sizeof(bDebugFlag), NULL);\n\n\tif (bDebugFlag &#x3D;&#x3D; 0) beingDebug &#x3D; true;\n\n    &#x2F;&#x2F; return\n    \n\treturn beingDebug;\n&#125;\n\n51.4 NtQuerySystemInformation()该函数用于查询系统信息，可以检测系统是否在调试模式下运行。\ntypedef enum SYSTEM_INFORMATION_CLASS &#123;\n\tSystemKernelDebuggerInformation &#x3D; 0x23\n&#125;;\ntypedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION &#123;\n\tBOOLEAN DebuggerEnabled;\n\tBOOLEAN DebuggerNotPresent;\n&#125;SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;\n\n&#x2F;&#x2F; MSDN\n__kernel_entry NTSTATUS NtQuerySystemInformation(\n  SYSTEM_INFORMATION_CLASS SystemInformationClass,\n  PVOID                    SystemInformation,\n  ULONG                    SystemInformationLength,\n  PULONG                   ReturnLength\n);\n\n非调试情况，debuggerInfo.DebuggerEnabled = 0\nbool CheckNtQSI_API()\n&#123;\n\t&#x2F;&#x2F; get api\n\n\tHMODULE hNtdll &#x3D; GetModuleHandleW(L&quot;NtDll.dll&quot;);\n\tauto pNtQuerySystemInformation &#x3D; (PNtQuerySystemInformation)GetProcAddress(hNtdll, &quot;NtQuerySystemInformation&quot;);\n\n\t&#x2F;&#x2F; SystemKernelDebuggerInformation(0x23)\n\n\tSYSTEM_KERNEL_DEBUGGER_INFORMATION debuggerInfo &#x3D; &#123; 0, &#125;;\n\tpNtQuerySystemInformation(SystemKernelDebuggerInformation, &amp;debuggerInfo, sizeof(debuggerInfo), 0);\n\n\treturn debuggerInfo.DebuggerEnabled;\n&#125;\n\n应对\nxp中修改boot.ini，删除/debugport=coml /baudrate=115200 /Debug\nwin7 cmd中执行bcdedit /debug off\n51.5 NtQueryObject()该函数用于查询内核对象，可以用于检测是否存在调试对象类型的内核对象。\ntypedef enum _OBJECT_INFORMATION_CLASS &#123;\n\tObjectAllTypesInformation &#x3D; 3\n&#125; OBJECT_INFORMATION_CLASS;\ntypedef struct _UNICODE_STRING &#123; &#x2F;&#x2F; sizeof &#x3D; 8\n\tUSHORT Length;\n\tUSHORT MaximumLength;\n\tPWSTR Buffer;\n&#125; UNICODE_STRING, * PUNICODE_STRING;\ntypedef struct _OBJECT_TYPE_INFORMATION &#123; &#x2F;&#x2F; sizeof &#x3D; 16\n\tUNICODE_STRING TypeName;\n\tULONG TotalNumberOfHandles;\n\tULONG TotalNumberOfObjects;\n&#125; OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;\ntypedef struct _OBJECT_ALL_INFORMATION &#123;\n\tULONG NumberOfObjectsTypes;\n\tOBJECT_TYPE_INFORMATION ObjectTypeInformation[1];\n&#125; OBJECT_ALL_INFORMATION, *POBJECT_ALL_INFORMATION;\n\n&#x2F;&#x2F; MSDN\n__kernel_entry NTSYSCALLAPI NTSTATUS NtQueryObject(\n  HANDLE                   Handle,\n  OBJECT_INFORMATION_CLASS ObjectInformationClass,\n  PVOID                    ObjectInformation,\n  ULONG                    ObjectInformationLength,\n  PULONG                   ReturnLength\n);\n\n分析返回的OBJECT_ALL_INFORMATIONObjectInformation中会填充OBJECT_ALL_INFORMATION，需要遍历这个结构，我在一次调试中记录下了一些地址用于分析该结构下面是返回的ObjectInformation指向的buf的数据内容：\n0x750000: OBJECT_ALL_INFORMATION\n  +0h : NumberOfObjectsTypes(ULONG)&#x3D; 67\n  +4h : ObjectTypeInformation(STRUCT)\n\n0x750004: (OBJECT_TYPE_INFORMATION)\n  +0h : ObjectTypeInformation[0].TypeName.Length(USHORT)&#x3D; 8\n  +2h : ObjectTypeInformation[0].TypeName.LengthMaximumLength(USHORT)&#x3D; 10\n  +4h : ObjectTypeInformation[0].TypeName.Buffer(wchar_t*)&#x3D; 0x750064\n  +8h : ObjectTypeInformation[0].TotalNumberOfHandles(ULONG)&#x3D; 67\n  +ch: ObjectTypeInformation[0].TotalNumberOfObjects(ULONG)&#x3D; 0\n\n0x750014: (BYTE[80]) &#x2F;&#x2F; unknown\n\n0x750064: (wchar[5]) &#x3D; L&quot;Type&quot;\n\n0x75006E: (BYTE[2]) &#x3D; \\x00\\x00\n\n0x750070: (OBJECT_TYPE_INFORMATION)\n  +0h : ObjectTypeInformation[1].TypeName.Length(USHORT)&#x3D; 18\n  +2h : ObjectTypeInformation[1].TypeName.LengthMaximumLength(USHORT)&#x3D; 20\n  +4h : ObjectTypeInformation[1].TypeName.Buffer(wchar_t*)&#x3D; 0x7500D0\n  ...\n\n0x750080: (BYTE[80]) &#x2F;&#x2F; unknown\n\n0x7500D0: (wchar[10]) &#x3D; L&quot;Directory&quot;\n\n0x7500E4: (OBJECT_TYPE_INFORMATION)\n  +0h : ObjectTypeInformation[2].TypeName.Length(USHORT)&#x3D; 24\n  +2h : ObjectTypeInformation[2].TypeName.LengthMaximumLength(USHORT)&#x3D; 26\n  +4h : ObjectTypeInformation[2].TypeName.Buffer(wchar_t*)&#x3D; 0x750144\n  ...\n\n0x7500F4: (BYTE[80]) &#x2F;&#x2F; unknown\n\n0x750144: (wchar[13]) &#x3D; L&quot;SymbolicLink&quot;\n\n...\n\n可以看到内存布局可简化为：\nNumberOfObjectsTypes\nObjectTypeInformation[0]\n80bytes undocument date\nwchar[]\nObjectTypeInformation[1]\n80bytes undocument date\nwchar[]\nObjectTypeInformation[2]\n80bytes undocument date\nwchar[]\n\n我的理解是OBJECT_ALL_INFORMATION中的OBJECT_TYPE_INFORMATION[]是个元素长度可变的”数组”\nOBJECT_TYPE_INFORMATION[]“数组”每个元素由已知的OBJECT_TYPE_INFORMATION（16bytes）+ 未文档化数据（80bytes）+ wchar[]（长度不定）组成\n同时根据书中代码的&amp;0xfffffffc可知是4字节对齐，也就是元素起始地址为4的倍数\n示例代码这里着重分析next那部分代码。\n书中的做法是：首先是找到最后一个字符地址（wchar字符串以\\x00\\x00结尾）然后清楚低两位（实现4字节对齐）然后加上4\n不考虑对齐，最后一个字符地址+2=下一个元素地址（wchar字符串以\\x00\\x00结尾）\n如果最后一个字符地址已经对齐，那么下一个元素地址就不对齐，偏移原本为+2，为了对齐变成+4\n如果最后一个字符地址不对其，那么下一个元素地址就对齐，偏移原本为+2，但字符地址清楚了低两位，所以变成+4\n所以最后不管是否对齐都是+4\n也可以先猜测下一个元素地址，然后再判断是否对齐，不对齐就+2，但这样更费劲\nbool CheckNtQO_API()\n&#123;\n\tbool beingDebug &#x3D; false;\n\n\t&#x2F;&#x2F; get api\n\n\tHMODULE hNtdll &#x3D; GetModuleHandleW(L&quot;NtDll.dll&quot;);\n\tauto pNtQueryObject &#x3D; (PNtQueryObject)GetProcAddress(hNtdll, &quot;NtQueryObject&quot;);\n\n\t&#x2F;&#x2F; ObjectAllTypesInformation(0x3)\n\n\t&#x2F;&#x2F; get size\n\tULONG lSize &#x3D; 0;\n\tpNtQueryObject(0, ObjectAllTypesInformation, &amp;lSize, sizeof(lSize), &amp;lSize);\n\t&#x2F;&#x2F; alloc memory\n\tchar* buf &#x3D; 0;\n\tbuf &#x3D; (char*)VirtualAlloc(NULL, lSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n\t&#x2F;&#x2F; get info\n\tNTSTATUS sta;\n\tsta &#x3D; pNtQueryObject((HANDLE)0xFFFFFFFF, ObjectAllTypesInformation, buf, lSize, NULL);\n\tauto pObjAllInfo &#x3D; (POBJECT_ALL_INFORMATION)buf;\n\t&#x2F;&#x2F; check\n\tULONG objNum &#x3D; pObjAllInfo-&gt;NumberOfObjectsTypes;\n\tauto pObjTypeInfo &#x3D; pObjAllInfo-&gt;ObjectTypeInformation;\n\tfor (ULONG i &#x3D; 0; i &lt; objNum; i++) &#123;\n\t\tif (wcscmp(L&quot;DebugObject&quot;, pObjTypeInfo-&gt;TypeName.Buffer) &#x3D;&#x3D; 0) &#123;\n\t\t\tbeingDebug &#x3D; true;\n\t\t\tbreak;\n\t\t&#125;\n\t\t&#x2F;&#x2F; next\n        &#x2F;&#x2F; go to last wchar\n\t\tpObjTypeInfo &#x3D; (POBJECT_TYPE_INFORMATION)((ULONG)pObjTypeInfo-&gt;TypeName.Buffer + pObjTypeInfo-&gt;TypeName.Length);\n        &#x2F;&#x2F; alignment\n\t\tpObjTypeInfo &#x3D; (POBJECT_TYPE_INFORMATION)(((ULONG)pObjTypeInfo) &amp; 0xFFFFFFFC);\n        &#x2F;&#x2F; alignment offset\n\t\tpObjTypeInfo &#x3D; (POBJECT_TYPE_INFORMATION)((ULONG)pObjTypeInfo + sizeof(DWORD));\n\t&#125;\n\n\tif (buf)\n\t\tVirtualFree(buf, 0, MEM_RELEASE);\n\n\treturn beingDebug;\n&#125;\n\n51.6 ZwSetInformationThread()该函数用于设置线程信息，可将线程隐藏起来，使调试器收不到消息\nDebugActiveProcessStop()则可以分离调试器和被调试线程\ntypedef enum _THREADINFOCLASS &#123;\n\tThreadHideFromDebugger &#x3D; 0x11\n&#125; THREADINFOCLASS;\n\n&#x2F;&#x2F; MSDN\nNTSYSAPI NTSTATUS ZwSetInformationThread(\n  HANDLE          ThreadHandle,\n  THREADINFOCLASS ThreadInformationClass,\n  PVOID           ThreadInformation,\n  ULONG           ThreadInformationLength\n);\n\n用法示例：\nvoid Detach()\n&#123;\n\t&#x2F;&#x2F; get api\n\n\tHMODULE hNtdll &#x3D; GetModuleHandleW(L&quot;NtDll.dll&quot;);\n\tauto pZwSetInformationThread &#x3D; (PZwSetInformationThread)GetProcAddress(hNtdll, &quot;ZwSetInformationThread&quot;);\n\n\t&#x2F;&#x2F; detach\n\tpZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0);·\n&#125;\n\nvoid Stop()\n&#123;\n    &#x2F;&#x2F; #include &lt;windows.h&gt;\n    DebugActiveProcessStop(GetCurrentProcessId());\n&#125;\n\n51.7 TLStls回调函数会在ep之前执行（实际上是在创建终止进程时都会执行）\n示例：\n#pragma comment(linker, &quot;&#x2F;INCLUDE:__tls_used&quot;)\n\nvoid NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved);\n\n#pragma data_seg(&quot;.CRT$XLX&quot;)\nPIMAGE_TLS_CALLBACK pTLS_callbacks[] &#x3D; &#123; TLS_CALLBACK1, TLS_CALLBACK2 &#125;;\n#pragma data_seg()\n\nint main()\n&#123;\n    return 0;\n&#125;\n\nvoid NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)\n&#123;\n\tswitch (Reason) &#123;\n\tcase DLL_PROCESS_ATTACH:\n\t\tcout &lt;&lt; &quot;tls:process attach\\n\\n&quot;;\n        &#x2F;&#x2F; YourAntiDebug();\n\t\tbreak;\n\tcase DLL_THREAD_ATTACH:\n\t\tcout &lt;&lt; &quot;tls:thread attach\\n\\n&quot;;\n\t\tbreak;\n\tcase DLL_THREAD_DETACH:\n\t\tcout &lt;&lt; &quot;tls:thread detach\\n\\n&quot;;\n\t\tbreak;\n\tcase DLL_PROCESS_DETACH:\n\t\tcout &lt;&lt; &quot;tls:process detach\\n\\n&quot;;\n\t\tbreak;\n\t&#125;\n&#125;\n\n51.8 ETC检测窗口 FindWindow()\n检测进程 CreateToolhelp32Snapshot()\n检测计算机名\n检测运行路径\n检测虚拟机\n","slug":"recoreR3StaAntiDebug","date":"2021-10-16T04:00:00.000Z","categories_index":"Windows","tags_index":"windows,note,reversecore,antiDebug","author_index":"御史神风"},{"id":"37d6e393a967114c82f7d8a550ead81e","title":"pbctf21 btree wp","content":"PBCTF21 RE BinaryTree Beaengine+dijkstra解法思路代码是动态解密的，简单的xor，解密一块执行一块。每一块结尾会设置rbx，rbx决定下一块被解密的代码。\n实际上每一块代码相当于一个节点，里面有一个根据输入的jz，决定下一个rbx以及一个cost，所以相当于一颗二叉树。\n每次经过一个节点都会累加cost。\n根节点对应的代码块会判断cost是否小于等于某个值，然后输出成功信息。\n如果只有唯一解那么显然是找最短路。\n解题思路是beaengine解析代码生成图，用dijkstra算法求最短路并输出路径。事实上只有一条最短路，刚刚等于那个值。\nbeaengine提取图#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;windows.h&gt;\n#include &lt;queue&gt;\n#include &lt;set&gt;\n#define BEA_ENGINE_STATIC\n#include &quot;BeaEngine.h&quot;\n#pragma comment(lib,&quot;legacy_stdio_definitions.lib&quot;)\n#pragma comment(lib, &quot;BeaEngine.lib&quot;)\n\nusing namespace std;\n\ntypedef struct Block &#123;\n\tint index;\n\tchar buf[32];\n&#125;;\n\nint path[25503][4] &#x3D; &#123; 0, &#125;; &#x2F;&#x2F; 0(path&#x2F;rbx,cost) 1(path&#x2F;rbx,cost)\n\nqueue&lt;pair&lt;int, Block*&gt;&gt; rbxs; &#x2F;&#x2F; rbx(xor offset), lastBlock\nint sa &#x3D; 0x176;\nBYTE* firstBlock;\nint blockNum &#x3D; 0;\nset&lt;int&gt; dised;\nBlock xorBlock &#x3D; &#123;\n\t0,\n\t0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x48,\n\t0xc7, 0xc7, 0x01, 0x00, 0x00, 0x00, 0x48, 0xc7,\n\t0xc2, 0x05, 0x00, 0x00, 0x00, 0x49, 0x81, 0xf9,\n\t0xda, 0x49, 0x00, 0x00, 0x7f, 0x07, 0x4c, 0x89\n&#125;;\n\nBlock* Xor(char* firstBlock, UInt64 offset, Block &amp;oldBlock)\n&#123;\n\tBlock* pB &#x3D; new Block();\n\tpB-&gt;index &#x3D; offset &gt;&gt; 5;\n\tblockNum++;\n\tchar* xorBuf &#x3D; firstBlock + offset;\n\tfor (int i &#x3D; 0; i &lt; 32; i++) &#123;\n\t\tpB-&gt;buf[i] &#x3D; xorBuf[i] ^ oldBlock.buf[i];\n\t&#125;\n\treturn pB;\n&#125;\n\nvoid Jmp(DISASM&amp; infos)\n&#123;\n\tUINT64 nextVA &#x3D; infos.Instruction.AddrValue;\n\tUINT64 curVA &#x3D; infos.VirtualAddr;\n\n\t&#x2F;&#x2F; jmp\n\tinfos.EIP +&#x3D; nextVA - curVA;\n\tinfos.VirtualAddr &#x3D; nextVA;\n&#125;\n\nvoid DisasmCode(char* stBuf, UINT64 stVA, Block* curBlock, int rbx, int branch)\n&#123;\n\tDISASM infos;\n\tsize_t len;\n\n\t&#x2F;&#x2F; init\n\tmemset(&amp;infos, 0, sizeof(DISASM));\n\tinfos.EIP &#x3D; (UINT64)stBuf;\n\tinfos.VirtualAddr &#x3D; (UINT64)stVA;\n\n\twhile (infos.Error &#x3D;&#x3D; 0) &#123;\n\t\t&#x2F;&#x2F; limit\n\t\tUInt64 offset &#x3D; infos.EIP - (UINT64)curBlock-&gt;buf;\n\t\tif (offset &lt; 0 || offset &gt;&#x3D; 32) &#123;\n\t\t\tbreak;\n\t\t&#125;\n\t\tif (infos.VirtualAddr &#x3D;&#x3D; 0x400080) &#123;&#x2F;&#x2F; xor\n\t\t\trbxs.push(make_pair(rbx, curBlock));\n\t\t\tbreak;\n\t\t&#125;\n\t\t\t\n\n\t\t&#x2F;&#x2F;disasm\n\t\tlen &#x3D; Disasm(&amp;infos);\n\t\tcout &lt;&lt; hex &lt;&lt; infos.VirtualAddr &lt;&lt; &quot; &quot; &lt;&lt; infos.CompleteInstr &lt;&lt; endl;\n\n\t\t&#x2F;&#x2F; jmp\n\t\tif (infos.Instruction.BranchType &#x3D;&#x3D; JmpType) &#123;\n\t\t\tif (infos.Instruction.AddrValue &#x3D;&#x3D; 0x400080) &#123; &#x2F;&#x2F; xor\n\t\t\t\trbxs.push(make_pair(rbx, curBlock));\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\t\n\t\t\tJmp(infos);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; jmp\n\t\tif (infos.Instruction.BranchType) &#123;\n\t\t\t&#x2F;&#x2F; false branch\n\t\t\tDisasmCode((char*)(infos.EIP + len), infos.VirtualAddr + len, curBlock, rbx, 0);\n\t\t\t&#x2F;&#x2F; true branch\n\t\t\tbranch &#x3D; 1;\n\t\t\tJmp(infos);\n\t\t\tcontinue;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; if modified rbx (0x8)\n\t\tif (((infos.Operand1.AccessMode &#x3D;&#x3D; WRITE) &amp;&amp; (infos.Operand1.Registers.gpr &amp; REG3))) &#123;\n\t\t\trbx +&#x3D; infos.Operand2.Memory.Displacement;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; if add r9 (0x200)\n\t\tif ((infos.Operand1.AccessMode &#x3D;&#x3D; 3) &amp;&amp; (infos.Operand1.Registers.gpr &amp; 0x200)) &#123;\n\t\t\tif (branch &gt;&#x3D; 0) &#123;\n\t\t\t\tpath[curBlock-&gt;index][branch * 2] &#x3D; rbx &gt;&gt; 5;\n\t\t\t\tpath[curBlock-&gt;index][branch * 2 + 1] &#x3D; infos.Instruction.Immediat;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; go on\n\t\tinfos.EIP +&#x3D; len;\n\t\tinfos.VirtualAddr +&#x3D; len;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tifstream fin;\n\tofstream fout;\n\tBYTE* fileBuf;\n\tBlock* lastBlock;\n\tBlock* pB;\n\n\t&#x2F;&#x2F; read file\n\n\tfin.open(&quot;E:\\\\works\\\\ctf\\\\21pbctf\\\\re_BinaryTree\\\\main.elf&quot;, ios::in | ios::binary);\n\n\tfin.seekg(0, ios::end);\n\tsize_t fileSize &#x3D; fin.tellg();\n\tfin.seekg(0, ios::beg);\n\tfileBuf &#x3D; (BYTE*)malloc(fileSize);\n\tfin.read((char*)fileBuf, fileSize);\n\n\tcout &lt;&lt; &quot;fileSize:&quot; &lt;&lt; dec &lt;&lt; fileSize &lt;&lt; endl;\n\tfin.close();\n\n\t&#x2F;&#x2F; disasm\n\n\tfirstBlock &#x3D; fileBuf + sa;\n\n\tcout &lt;&lt; &quot;rbx:0&quot; &lt;&lt; endl;\n\tpB &#x3D; Xor((char*)firstBlock, 0, xorBlock);\n\tdised.insert(0);\n\tDisasmCode(pB-&gt;buf, 0x4000AD, pB, 0, 0);\n\twhile (!rbxs.empty()) &#123;\n\t\tpair&lt;int, Block*&gt; t &#x3D; rbxs.front();\n\t\trbxs.pop();\n\n\t\tlastBlock &#x3D; t.second;\n\n\t\tcout &lt;&lt; &quot;num:&quot; &lt;&lt; dec &lt;&lt; blockNum &lt;&lt; endl; &#x2F;&#x2F; 0x639f * 2\n\t\t\n\t\tif (dised.insert(t.first).second) &#123;\n\t\t\t&#x2F;&#x2F; not disasm\n\t\t\tpB &#x3D; Xor((char*)firstBlock, t.first, *lastBlock);\n\t\t\t&#x2F;&#x2F; disasm\n\t\t\tDisasmCode(pB-&gt;buf, 0x4000AD, pB, 0, -1);\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; write file\n\n\tfout.open(&quot;E:\\\\works\\\\ctf\\\\21pbctf\\\\re_BinaryTree\\\\main_.elf&quot;, ios::out | ios::binary);\n\tfout.write((char*)fileBuf, fileSize);\n\tfout.close();\n\n\t&#x2F;&#x2F; write file\n\n\tfout.open(&quot;E:\\\\works\\\\ctf\\\\21pbctf\\\\re_BinaryTree\\\\path.txt&quot;, ios::out);\n\tfor (int i &#x3D; 0; i &lt; blockNum; i++) &#123;\n\t\tfout &lt;&lt; path[i][0] &lt;&lt; &quot; &quot; &lt;&lt; path[i][1] &lt;&lt; &quot; &quot; &lt;&lt; path[i][2] &lt;&lt; &quot; &quot; &lt;&lt; path[i][3] &lt;&lt; endl;\n\t&#125;\n\tfout.close();\n\n\tfout.open(&quot;E:\\\\works\\\\ctf\\\\21pbctf\\\\re_BinaryTree\\\\pathDij.txt&quot;, ios::out);\n\tint E &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; blockNum; i++) &#123;\n\t\tif (path[i][1]) &#123;\n\t\t\tfout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; path[i][0] &lt;&lt; &quot; &quot; &lt;&lt; path[i][1] &lt;&lt; endl;\n\t\t\tfout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; path[i][2] &lt;&lt; &quot; &quot; &lt;&lt; path[i][3] &lt;&lt; endl;\n\t\t\tE +&#x3D; 2;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tcout &lt;&lt; i &lt;&lt; &quot;,&quot;;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; endl;\n\tfout.close();\n\n\tcout &lt;&lt; &quot;N E\\n&quot;;\n\tcout &lt;&lt; dec &lt;&lt; blockNum &lt;&lt; &quot; &quot; &lt;&lt; E &lt;&lt; endl;\n\t&#x2F;&#x2F; 25503 50942 0\n\n\treturn 0;\n&#125;\n\n\ndijkstra算法自己打oi时留下的板子，忘记有没有加优化了，不过这个版本比较方便记录path\n&#x2F;*\n* 有向+无向，不能用于负权图\n*&#x2F;\n\n#pragma warning(disable:4996)\n\n#include &lt;stdio.h&gt;\n#include &lt;list&gt;\n#include &lt;set&gt;\n#include &lt;utility&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; TR;\nstruct Edge &#123;\n\tint v;\n\tint w;\n&#125;;\n\nint roots[] &#x3D; &#123; 1225,1226,1891,1892,3929,3930,4929,4930,6295,6296,9313,9314,9813,9814,15465,15466,15713,15714,17301,17302,18767,18768,18841,18842,19145,19146,19279,19280,19927,19928,22501,22502 &#125;;\nint path[50943];\nint path1[50943];\n\ninline bool min(int a, int b)\n&#123;\n\tif (a !&#x3D; -1 &amp;&amp; (a &lt; b || b &#x3D;&#x3D; -1))\n\t\treturn true;\n\telse\n\t\treturn false;\n&#125;\n\nint main()\n&#123;\n\tFILE* r &#x3D; freopen(&quot;E:\\\\works\\\\ctf\\\\21pbctf\\\\re_BinaryTree\\\\pathDij.txt&quot;, &quot;r&quot;, stdin);\n\n\tint i, j, u, v, w;\n\tEdge edge;\n\tlist&lt;Edge&gt;::iterator it;\n\tTR tr;\n\n\tint N, E, start, iMin, nMin;\n\tint* flag;\n\tset&lt;TR&gt; ds;\n\tint* d;\n\tlist&lt;Edge&gt;* es;\n\n\tscanf(&quot;%d %d&quot;, &amp;N, &amp;E);\n\tscanf(&quot;%d&quot;, &amp;start);\n\n\t&#x2F;&#x2F; 初始化\n\tflag &#x3D; new int[N];\n\td &#x3D; new int[N];\n\tfor (i &#x3D; 0; i &lt; N; i++) &#123;\n\t\tflag[i] &#x3D; 0;\n\t\td[i] &#x3D; -1;\n\t\tpath[i] &#x3D; -1;\n\t&#125;\n\tds.insert(make_pair(0, start));\n\td[start] &#x3D; 0;\n\n\t&#x2F;&#x2F; 读图\n\tes &#x3D; new list&lt;Edge&gt;[N];\n\tint boo &#x3D; 1;\n\tfor (i &#x3D; 0; i &lt; E; i++) &#123;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w);\n\t\tedge.v &#x3D; v;\n\t\tedge.w &#x3D; w;\n\t\tes[u].push_back(edge);\n\t\tif (boo) &#123;\n\t\t\tboo &#x3D; 0;\n\t\t\tpath1[u] &#x3D; v;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tboo &#x3D; 1;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; dij\n\twhile (!ds.empty()) &#123;\n\t\t&#x2F;&#x2F; 找最小未完成节点（确保d[iMin] !&#x3D; -1）\n\t\tiMin &#x3D; ds.begin()-&gt;second;\n\t\tnMin &#x3D; ds.begin()-&gt;first;\n\t\tds.erase(ds.begin());\n\n\t\t&#x2F;&#x2F; 标记完成\n\t\tu &#x3D; iMin;\n\t\tflag[u] &#x3D; 1;\n\n\t\t&#x2F;&#x2F; 依次松弛\n\t\tfor (it &#x3D; es[u].begin(); it !&#x3D; es[u].end(); it++) &#123;\n\t\t\tv &#x3D; it-&gt;v;\n\t\t\tw &#x3D; d[iMin] + it-&gt;w;\n\t\t\tif (w &#x3D;&#x3D; d[v])\n\t\t\t\tpath[v] &#x3D; u;\n\t\t\tif (min(w, d[v])) &#123;\n\t\t\t\td[v] &#x3D; w;\n\t\t\t\t&#x2F;&#x2F; 加入set\n\t\t\t\ttr &#x3D; make_pair(w, v);\n\t\t\t\tif (ds.find(tr) !&#x3D; ds.end()) ds.erase(tr);\n\t\t\t\tds.insert(tr);\n\t\t\t\tpath[v] &#x3D; u;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 输出结果\n\t&#x2F;&#x2F; for (i &#x3D; 0; i &lt; N; i++)\n\t&#x2F;&#x2F;\tprintf(&quot;%d:%d\\n&quot;, i, d[i]);\n\t&#x2F;&#x2F; putchar(10);\n\n\tcout &lt;&lt; &quot;\\nans:\\n&quot;;\n\tfor (i &#x3D; 0; i &lt; 32; i++) &#123;\n\t\tcout &lt;&lt; d[roots[i]] &lt;&lt; &quot; &quot;;\n\t&#125;\n\n\tcout &lt;&lt; &quot;\\nshortest:\\n&quot;;\n\tfor (i &#x3D; 0; i &lt; 32; i++) &#123;\n\t\tif (d[roots[i]] &lt;&#x3D; 0x49DA) &#123;\n\t\t\tcout &lt;&lt; roots[i] &lt;&lt; &quot;:&quot; &lt;&lt; d[roots[i]] &lt;&lt; &quot; &quot; &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n\n\tcout &lt;&lt; &quot;\\npath\\n&quot;;\n\ti &#x3D; 19279;\n\tdo &#123;\n\t\ti &#x3D; path[i];\n\t\tcout &lt;&lt; i &lt;&lt; &quot; &quot;;\n\t&#125; while (i);\n\n\tcout &lt;&lt; &quot;\\npath\\n&quot;;\n\ti &#x3D; 19279;\n\tdo &#123;\n\t\t&#x2F;&#x2F; path[i] -&gt; i\n\t\tif (path1[path[i]] &#x3D;&#x3D; i)\n\t\t\tcout &lt;&lt; 1;\n\t\telse\n\t\t\tcout &lt;&lt; 0;\n\t\ti &#x3D; path[i];\n\t&#125; while (i);\n\n\ti &#x3D; 0;\n\tj &#x3D; 0;\n\twhile (!es[i].empty()) &#123;\n\t\ti &#x3D; es[i].begin()-&gt;v;\n\t\tj++;\n\t&#125;\n\tcout &lt;&lt; &quot;\\nl:&quot; &lt;&lt; j &lt;&lt; endl;\n\n\t&#x2F;&#x2F; 释放内存\n\tdelete[] flag;\n\tdelete[] es;\n\n\treturn 0;\n&#125;\n\n\nlong2bytesfrom Crypto.Util.number import long_to_bytes\n\nans &#x3D; &#39;01111101001101110110010101100101011001100110001001100001001110000011000000110110001100100110001000110001011001100011011100110001001100000011100101100011001100110011000100110101011000110110000100111000001101110011010001100001001100100011001001100010011000100011000000110011011001010011000000110011011000110011010000110111011001010101111100100001001000010110010101100100011011110110001101011111011001110110111001101001011110010110011001101001011001000110111101101101001011010110011001101100011001010111001101011111011011100110100101011111011010000111010001100001011100000101111101110100011100110110010101110100011100100110111101101000011100110101111101100101011010000111010001011111011001110110111001101001011001000110111001101001011001100010000100100001011110110110011001110100011000110110001001110000&#39;\nans &#x3D; int(ans, 2)\nprint(long_to_bytes(ans)[::-1])\n\n参考[原创]PBCTF21 RE BinaryTree Beaengine+dijkstra解法-bbs.pediy.com\n","slug":"pbctf21-btree-Wp","date":"2021-10-09T04:00:00.000Z","categories_index":"CTF","tags_index":"ctf,re,wp","author_index":"御史神风"},{"id":"796d9083672966112e1391db00c01e6d","title":"vmp2 (3) handler类型总结","content":"VMP2（3）handler类型总结摘要详细分析push、pop、计算类handler以及粗略分析其余handler后对handler进行分类并做一些总结。\n字节码vm字节码结构有三种：\n\nopcode(1B)\nopcode(1B) + Imm(1~8B)\nopcode(1B) + VmRegOffset(1B)\n\n所有字节码都是经过加密的，解析时需要根据rbx动态解密。\nvm字节码各部分是倒序排列的，也就是说后一条指令在前面，Imm、VmRegOffset在opcode前面。\nvm虚拟栈与虚拟寄存器通过分析涉及vm栈的handler（如push、pop、add等），得出vm栈是2字节对齐的。vm寄存器实质可以理解为一个全局数组，也是2字节对齐的。\npush类push类指令push数据到栈上。分为三种：\n\npush 立即数\npush vm寄存器\npush 真实寄存器\n\n立即数即指令的Imm部分，push到vm寄存器时则根据VmRegOffset部分。\npush压栈元素的大小不小于被压栈数据的长度。比如push 4字节的立即数有两条指令：一条是压入4字节(VmRsp-=4)；一条是压入8字节(VmRsp-=8)，其中被压入的立即数在栈顶的低4字节([VmRsp] = ImmD)。\npop类pop类指令从vm栈上pop数据。分为两种：\n\npop到vm寄存器中\npop到真实寄存器中（包括popfq）。\n\n显然pop到vm寄存器的指令长度为2字节，第二个字节指示了vm寄存器的偏移。\n计算类计算类指令有七种：\n\nnor\nadd\ndiv\nshl\nshld\nshr\nshrd\n\n逻辑运算由nor组合实现，减法可以通过逻辑运算和加法实现，乘法可以由位移和加法组合实现。\n各种指令的操作数也是分长度的。\n计算类指令基于栈实现，可以等价成以下4步：\n\n所有操作数出栈\n计算结果\n入栈结果\n入栈RFLAGS\n\n也就是计算以后操作数将清除，栈顶为RFLAGS(8Byte)、栈顶第二项为结果(长度由指令决定)\nIndirection类该类指令用于解除应用。伪代码如下：\ntop &#x3D; *top\n\n等价于以下3步：\n\n出栈（8字节指针）\n解除引用\n入栈结果\n\nsubscript类该类指令用于给内存地址赋值。伪代码如下：\n*top &#x3D; top2\n\n等价于以下3步：\n\n出栈左值（8字节指针）\n出栈右值\n往指针指向地址赋值\n\n其他还有初始化虚拟机、call、ret、修改rbx、修改bp、基于vm栈的cpuid等指令。\n","slug":"vmp2-p3","date":"2021-09-28T04:00:00.000Z","categories_index":"Re","tags_index":"re,vmp2","author_index":"御史神风"},{"id":"14f57ee55d88ddbbbcf4ab3554ca49cd","title":"BeaEngine","content":"BeaEngine摘要一个反汇编引擎，支持c++、python等。\n具体使用参照官方github的example，非常详细。\n常用char buf;\nUINT64 va;\n\nDISASM infos;\nint len;\n\n&#x2F;&#x2F; init\nmemset(&amp;infos, 0, sizeof(DISASM));\ninfos.EIP &#x3D; buf;\ninfos.VirtualAddr &#x3D; va;\n\n&#x2F;&#x2F; disasm\nlen &#x3D; Disasm(&amp;infos);\n\n&#x2F;&#x2F; Branch type\nif (infos.Instruction.BranchType &#x3D;&#x3D; JmpType); &#x2F;&#x2F; RetType, CallType\n\n&#x2F;&#x2F; Operater\ninfos.Instruction.Mnemonic; &#x2F;&#x2F; &quot;add&quot;\n\n&#x2F;&#x2F; Reg\ninfos.Operand1.OpMnemonic; &#x2F;&#x2F; &quot;rax&quot;\ninfos.Operand1.Registers.gpr;\n\n&#x2F;&#x2F; Continue\ninfos.EIP +&#x3D; len;\ninfos.VirtualAddr +&#x3D; len;\n\n&#x2F;&#x2F; Jmp\nUINT64 nextVA &#x3D; infos.Instruction.AddrValue;\nUINT64 curVA &#x3D; infos.VirtualAddr;\ninfos.EIP +&#x3D; nextVA - curVA;\ninfos.VirtualAddr &#x3D; nextVA;\n\nvs2019 &amp; static lib配置项目属性页 -&gt; C/C++ -&gt; 常规 -&gt; 附加包含目录 添加beaengine的headers目录\n项目属性页 -&gt; C/C++ -&gt; 代码生成 -&gt; 运行库 /MD /MDd改成/MT /MTd\n项目属性页 -&gt; 链接器 -&gt; 输入 -&gt; 忽略特定默认库 添加crt64.lib\n然后在代码开头添加以下语句。\n#define BEA_ENGINE_STATIC\n#include &quot;BeaEngine.h&quot;\n#pragma comment(lib,&quot;legacy_stdio_definitions.lib&quot;)\n#pragma comment(lib, &quot;D:\\\\beaengine-5.3.0\\\\lib_static_x64\\\\BeaEngine.lib&quot;)\n\n重点是：第一行在include”BeaEngine.h”前指明是静态，修改运行库、忽略crt64.lib以及第三行链接兼容库。\n可能的错误无法解析的外部符号如果缺少第一行，报错如下：\nerror LNK2019: 无法解析的外部符号 __imp_Disasm\n使用静lib库时必须在include前通过define指明使用静态库\n无法打开crt64.lib 或 sprintf无效引用如果没有忽略crt64.lib或者没有修改运行库，报错如下：\nLINK : fatal error LNK1104: 无法打开文件“crt64.lib”\n这时尝试在配置链接器中忽略掉crt64.lib这个库，就会报_sprintf无效引用\n这时需要链接兼容库legacy_stdio_definitions.lib\n","slug":"BeaEngine","date":"2021-09-20T04:00:00.000Z","categories_index":"Programing","tags_index":"Programing,BeaEngine","author_index":"御史神风"},{"id":"ff3b8559df1c08290e25585b94350c6d","title":"neo4j与CQL","content":"ne04j与CQL摘要neo4j是个nosql数据库，通过docker安装可以启动一个本地服务器，在浏览器中访问。能画出数据的关系图。通过CQL语言进行操作。\n主要用途是构建社会关系、知识图谱这种类型的数据库。自带图形化展示数据的功能。\n通过docker安装首先安装docker，win10需要先装wsl2，可以通过下载离线安装包的方z式，安装某个wsl2子系统到指定位置，具体不在絮述。\n官网查询最新版本，比如是4.3.3，在wsl2的shell中执行以下命令拉取neo4j的docker。\ndocker pull neo4j:4.3.3-community\n\n执行以下命令运行。其中NEO4J_AUTH后跟着的是初始 账号/密码。\ndocker run -d --name container_name -p 7474:7474 -p 7687:7687 -v &#x2F;home&#x2F;neo4j&#x2F;data:&#x2F;data -v &#x2F;home&#x2F;neo4j&#x2F;logs:&#x2F;logs -v &#x2F;home&#x2F;neo4j&#x2F;conf:&#x2F;var&#x2F;lib&#x2F;neo4j&#x2F;conf -v &#x2F;home&#x2F;neo4j&#x2F;import:&#x2F;var&#x2F;lib&#x2F;neo4j&#x2F;import --env NEO4J_AUTH&#x3D;neo4j&#x2F;password neo4j:4.3.3-community\n\nCQL\n\n\n\n\n\n\n\n\n1、Neo4j数据库服务器使用此&lt;node-name&gt;将此节点详细信息存储在Database.As中作为Neo4j DBA或Developer，我们不能使用它来访问节点详细信息。———为何不能呢？\n2、Neo4j数据库服务器创建一个&lt;label-name&gt;作为内部节点名称的别名。作为Neo4j DBA或Developer，我们应该使用此标签名称来访问节点详细信息。\n创建节点CREATE (&lt;node-name&gt;:&lt;label-name&gt;)\nnode-name可以理解成编程语言里的变量名，是一条数据的别名、句柄，用于操作这一条数据。可以当成是一个临时变量。（可以参照下面第三、四个示例理解）可以省略。\nlabel-name是数据的标签，或者说类型，有人把它类比成sql中的表名。\n示例如下：\n&#x2F;&#x2F; 创建一个标签为person，没有其他属性、关系的节点。\n&#x2F;&#x2F; 写法1\nCREATE (a:person)\n&#x2F;&#x2F; 写法2，省略节点名\nCREATE (:person)\n\n&#x2F;&#x2F; 创建一个带有name、phone两个属性的节点。\nCREATE (a:person&#123;name:&#39;abc&#39;, phone:114514&#125;)\n\n&#x2F;&#x2F; 创建两个节点，并添加关系\n&#x2F;&#x2F; 写法1，创建时添加关系\nCREATE (p1:person) CREATE (p2:person)-[r:&#39;friend&#39;]-&gt;(p2)\n&#x2F;&#x2F; 写法2，创建后添加关系\nCREATE (p1:person) CREATE (p2:person) CREATE (p1)-[r:&#39;friend&#39;]-&gt;(p2)\n\n&#x2F;&#x2F; 创建一个节点，并在图中显示该节点\nCREATE (a:person) RETURN a\n\n搜索节点&#x2F;&#x2F; 显示所有的节点及其关系\nMATCH (n) RETURN n\n\n&#x2F;&#x2F; 显示所有标签为person的节点及其关系\nMATCH (n:person) RETURN n\n\n&#x2F;&#x2F; 显示所有标签为person，属性id&#x3D;1的节点及其关系\nMATCH (n:person&#123;id:1&#125;) RETURN n\n\n&#x2F;&#x2F; 显示所有关系为friend的节点\nMATCH p&#x3D;()-[r:&#39;friend&#39;]-&gt;() RETURN p\n\n添加属性、关系需要配合MATCH使用。\n&#x2F;&#x2F; 添加修改属性\nMATCH (n:person&#123;id:1&#125;) SET n.name&#x3D;&#39;abc&#39;\n\n&#x2F;&#x2F; 添加关系\nMATCH (p:person&#123;id:1&#125;) MATCH (n:person&#123;id:1&#125;) CREATE (p)-[r:&#39;friend&#39;]-&gt;(n)\n\n删除节点需要配合MATCH使用。\nMATCH (p:person&#123;id:1&#125;) DELETE p\n\nMATCH (p:person&#123;id:1&#125;)-[r]-(n:person&#123;id:2&#125;) DELETE p,r,n\n\n删除属性、关系MATCH (p:person&#123;id:1&#125;) REMOVE n.name\n\n读取文件csv文件内容：\nid, name1, aaa2, bbb\n\n读取并创建节点：\nLOAD CSV FROM &#39;pathname&#39; AS line FILEDTERMINATOR &#39;,&#39; CREATE (:p&#123;id:toInterger(line[0]), name:line[1]&#125;)\n\n","slug":"neo4j-CQL","date":"2021-09-20T04:00:00.000Z","categories_index":"Database","tags_index":"Database,neo4j,CQL","author_index":"御史神风"},{"id":"74105a35f31797dc18272c05740bf85c","title":"vmp2 (2) 初步分析handler(BeaEngine)","content":"VMP2（2）初步分析handler(BeaEngine)摘要基于手动初步分析的基础，了解了vmp2的结构以及handler表及解密方式。现在写些工具用于辅助分析。\n流程为：\n\n获取handler RVA\n分析跳转并dump handler\n\n由subs1(*top = top2)这类涉及栈的一字节操作handler可知vmp栈是两字节对齐。\ndump handler的目的是为了方便分析，具体原因见“条件与无条件jmp”。\n有一个handler存在循环，在自动分析中导致了栈溢出，无法dump出来（需要检查是否重复解析同一地址才能正确dump）。\n获取handler的RVA获取handler表根据手动调试的结果，可以得到handler表的va，计算出rva，再转换成fa即可通过读取文件获取handler表。\nrva转fa解析pe头的section header即可，这里不做絮述。\n解码UINT64 handlers[256];\nUINT64 imageBase &#x3D; 0x140000000;\nfor (int i &#x3D; 0; i &lt; 256; i++) &#123;\n    &#x2F;&#x2F; ror 5\n    handlers[i] &#x3D; (handlers[i] &gt;&gt; 5) | ((handlers[i] &amp; 31) &lt;&lt; 59);\n    &#x2F;&#x2F; get rva\n    handlers[i] -&#x3D; imageBase;\n&#125;\n\nvmp2默认 Image Base 是0x140000000。\nBeaEngineBeaEngine是一个反汇编引擎，可以辅助分析。\n这里给出一个大概的框架，用于辅助分析handler中的跳转，以及折叠jmp和部分意义不大的jmp。具体可以查看官网文档。\n通过下述代码可以遍历handler，然后可以输出为文本（infos.VirtualAddr,infos.CompleteInstr），借助vsc、md等文本工具分析汇编代码。其中vsc有一个提供asm高亮的插件x86 and x86_64 Assembly。\nvoid DisasmCode(char* stBuf, UINT64 stVA, UINT64 edVA)\n&#123;\n    DISASM infos;\n\tPDISASM prevInfos &#x3D; new DISASM();\n\tPDISASM prev2Infos &#x3D; new DISASM();\n\tPDISASM tpInfos;\n\tint len;\n\tUINT64 curVA, nextVA;\n\tint isJmp; &#x2F;&#x2F; -1: undefine, 0: false, 1: true\n    \n    BYTE cmp_rbp_rax[3] &#x3D; &#123; 0x48, 0x39, 0xC5 &#125;;\n    \n    while (infos.Error &#x3D;&#x3D; 0) &#123;\n\t\tcurVA &#x3D; infos.VirtualAddr;\n\t\tif (curVA &#x3D;&#x3D; edVA) break;\n\t\t&#x2F;&#x2F; disasm\n\t\tlen &#x3D; Disasm(&amp;infos);\n\t\tcout &lt;&lt; curVA &lt;&lt; &quot; &quot; &lt;&lt; infos.CompleteInstr &lt;&lt; endl;\n\n\t\t&#x2F;&#x2F; jmp\n\t\tif (infos.Instruction.BranchType &#x3D;&#x3D; JmpType) &#123;\n\t\t\tJmp(infos);\n\t\t\tcontinue;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; ret\n\t\tif (infos.Instruction.BranchType &#x3D;&#x3D; RetType) &#123;\n\t\t\tbreak;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; call\n\t\tif (infos.Instruction.BranchType &#x3D;&#x3D; CallType) &#123;\n\t\t\t&#x2F;&#x2F; next\n\t\t\tinfos.EIP +&#x3D; len;\n\t\t\tinfos.VirtualAddr +&#x3D; len;\n\t\t\tcontinue;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Not branch instruction\n\t\tif (infos.Instruction.BranchType &#x3D;&#x3D; 0) &#123;\n\t\t\t&#x2F;&#x2F; save\n\t\t\ttpInfos &#x3D; prevInfos;\n\t\t\tprevInfos &#x3D; prev2Infos;\n\t\t\tprev2Infos &#x3D; tpInfos;\n\t\t\tmemcpy(prevInfos, &amp;infos, sizeof(DISASM));\n\n\t\t\t&#x2F;&#x2F; next\n\t\t\tinfos.EIP +&#x3D; len;\n\t\t\tinfos.VirtualAddr +&#x3D; len;\n\n\t\t\tcontinue;\n\t\t&#125;\n\t\t\n\t\tisJmp &#x3D; -1;\n\t\tif(infos.Instruction.BranchType &#x3D;&#x3D; JA)&#123;\n            &#x2F;&#x2F; 此处下断点即可检查所有JA语句\n\t\t\tif (memcmp((void*)prevInfos-&gt;EIP, cmp_rbp_rax, 3) &#x3D;&#x3D; 0) &#123;\n\t\t\t\t&#x2F;&#x2F; cmp rbp, rax : 48 39 c5\n\t\t\t\t&#x2F;&#x2F; 48: REX.W\n\t\t\t\t&#x2F;&#x2F; 39: cmp Ev, Gv\n\t\t\t\t&#x2F;&#x2F; c5: Ev &#x3D; bp, Gv &#x3D; ax\n\t\t\t\tisJmp &#x3D; 1;\n\t\t\t&#125;\n\t\t&#125;else&#123;\n            &#x2F;&#x2F; 此处下断点即可检查漏掉的跳转语句\n        &#125;\n\n\t\tif (isJmp &#x3D;&#x3D; 1) &#123;\n\t\t\tJmp(infos);\n\t\t&#125;\n\t\telse if(isJmp &#x3D;&#x3D; 0)&#123;\n\t\t\t&#x2F;&#x2F; next\n\t\t\tinfos.EIP +&#x3D; len;\n\t\t\tinfos.VirtualAddr +&#x3D; len;\n\t\t&#125;\n\t\telse &#123;\n\t\t\t&#x2F;&#x2F; false branch\n\t\t\tDisasmCode((char*)(infos.EIP+len), infos.VirtualAddr+len, edVA);\n\t\t\t&#x2F;&#x2F; true branch\n\t\t\tJmp(infos);\n\t\t&#125;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n    unsigned char* fileBuf; &#x2F;&#x2F; 指向被加壳文件的拷贝\n    &#x2F;&#x2F; 读取被加壳文件，此处略过\n    \n    &#x2F;&#x2F; 去重\n    for (int i &#x3D; 0; i &lt; 256; i++) &#123;\n        rva &#x3D; handlers[i];\n        fa &#x3D; RVA2FA(rva); &#x2F;&#x2F; rva-&gt;fa函数略过\n\t\thandler_Rva_Fa[rva] &#x3D; fa;\n\t&#125;\n    \n    unsigned long long getHandlerRVA &#x3D; 0x190438; &#x2F;&#x2F; 这个是获取字节码的那段shellcode\n    unsigned long long enVA +&#x3D; 0x140000000;\n    \n    map&lt;unsigned int, unsigned int&gt;::iterator iter;\n\tfor (iter &#x3D; handler_Rva_Fa.begin(); iter !&#x3D; handler_Rva_Fa.end(); iter++) &#123;\n\t\tchar* buf &#x3D; (char*)((UINT64)fileBuf + (UINT64)iter-&gt;second);\n\t\tunsigned long long va &#x3D; imageBase + (UINT64)iter-&gt;first;\n\n\t\tcout &lt;&lt; &quot;Dis(rva):0x&quot; &lt;&lt; hex &lt;&lt; iter-&gt;first &lt;&lt; endl;\n\t\tif (iter-&gt;first &#x3D;&#x3D; 0x18e53b) &#123; &#x2F;&#x2F; 这个handler有点奇怪的问题，会造成栈溢出，解析不了\n\t\t\tcontinue;\n\t\t&#125;\n\t\tDisasmCode(buf, va, edVA);\n\t&#125;\n&#125;\n\n条件与无条件jmphandler中大量的jmp和有条件跳转，严重影响分析handler的效率。所以需要折叠jmp和一些意义不大的条件jmp，再dump出来方便分析。\nja的所有情况概述跳转标志位：CF==0 &amp;&amp; ZF==0\n跳转意义：\n\n无符号&gt;\n加法无进位（CF=0）\n\nstc设置cf = 1\nxor设置cf = 0\n运算结果为0 zf = 0\nvm栈溢出 检查lea rax, [rdi+0xE0]\ncmp rbp, rax\njmp ImageBase+0x18F29A\nja ImageBase+0x190438 # Jmp if no vmp&#39;s StackOverflow\n\n在push中会有上述代码，没有栈溢出时满足ja，直接跟踪true分支即可。\n分析时检查到前一条非jmp指令为cmp rbp, rax即可直接ja。\nvm栈指针 无条件加法 检查add rbp, 0x10\nja ImageBase+0x18cc56 # Jmp if no add overflow\n\n参照概述，直接跟踪true分支即可。\n分析时检查到前一条非jmp指令为add rbp 即可直接ja。\nshlshl ax, cl\nja ImageBase+0x18ebef\n\n两条分支一样，可以不做处理。\nxor eax, eaxje # true\nstc # cf &#x3D; 1\nxor eax, eax # cf &#x3D; 0\nja ImageBase+0x18f460\n\nxor eax, eax的结果为0，所以zf=1，所以这个ja为false，直接忽略。\n其他（未知）lea rdx, [8682618a + rax*2]\nja\n\n前面有个xor是的cf=0，没有找到影响zf的语句，直接忽略。\njl的所有情况概述跳转标志位：SF != OF\n跳转意义：\n\n有符号&lt;\n\nsigned: bh &lt; 0xf9（可疑）cmp bh, 0xf9\nstc # cf &#x3D; 1\njl\n\n这个jl就是 if(bh &lt; -7) 或者说 0x7f &lt; bh &lt; 0xf9，不知道想干嘛，在调试中发现bh一般为f4，这里当成true。\nNORand rax, rdxjl\n\n经观察这是个NOR handle，jl以后的代码和没有jl的是一样的，所以当成什么都无所谓。\nAdd rbpadd rbp, 0xajl\n\n这个add最高位是0+0=0，相同，of=0；sf=结果最高位=0。\n所以jl是false。\nSub rbpsub rbp, 4jl\n\n同add rbp，这个jl也是false。\n部分其余的条件跳转JCadd dword ptr [rpb+8], eaxjc\n\n两条分支一样，可以不做处理。\nJEpushfqje\n\n两条分支一样，可以不做处理。\nJGcmp bp, sijg\n\n两条分支一样，可以不做处理。\nJNOinc clmov cl, byte ptr [rbp+8]jno\n\n可能循环相关，跟踪两条分支。\n","slug":"vmp2-p2","date":"2021-09-15T04:00:00.000Z","categories_index":"Re","tags_index":"re,vmp2,BeaEngine","author_index":"御史神风"},{"id":"168fbfd9ad872dd1d16955f2d30e829c","title":"vmp2 (1) 初步分析","content":"VMP2（1）初步分析摘要初步分析VMProtect Ultimate v 2.13.5加密后的程序，得出vmp基本结构的总结。\n基本信息\n\n\n\n\n\n\n\n\n版本：VMProtect Ultimate v 2.13.5\nvmp代码在tls中。\n下面是分析出的一些寄存器在vmp中的作用：\n\n\n\n寄存器\n描述\n\n\n\nRSI\n字节码数组（逆序）\n\n\nR12\nHandler表\n\n\nR13\nHandler基址\n\n\nRBP\nVMP栈顶指针（栈从高到低）\n\n\nRDI\nVMP寄存器指针\n\n\nRBX\n解码密钥（动态）\n\n\nrsi指向当前字节码，rsi-1指向下一条字节码。\nHandler14019065C~140190E54（256个x8byte）\nHandler分析POP_Q\n从vmp栈pop8字节数据到指定vmp寄存器。\n2字节命令，后1字节解密后为VMP寄存器偏移（rdi）。\n&#x2F;&#x2F; 获取pop8目标vmp寄存器的偏移\nunsigned char GetPOP8Offset()\n&#123;\n    unsigned char al, bl;\n    \n    al &#x3D; stack[--_rsi];\n    bl &#x3D; _rbx &amp; 0xff;\n    \n    al -&#x3D; bl;\n    al ^&#x3D; 0x2f;\n    al++;\n    al ^&#x3D; 0xf1;\n    _rbx &#x3D; _rbx - bl + (bl - al); &#x2F;&#x2F; bl -&#x3D; al\n    return al;\n&#125;\n\nPUSH_Q_ID\n从字节码push4字节数据到vmp栈。\n5字节命令，后4字节解密后为数据。\nsub rbp, 8：push的数据为4字节，而VMP栈指针减8。\n在最后有如下一段代码\nlea rax, qword ptr ds:[rdi+0xE0] # 108\ncmp rbp, rax                   # 10D\nja &lt;VmGetHandle&gt;               # 10F\n\n当rbp&gt;rax时跳转到正常代码，rbp是vmp栈顶，可知rbp&gt;rdi+0xE0。\n由此得知虚拟寄存器在低地址、虚拟栈在高地址。\n&#x2F;&#x2F; 获取push4的数据\nunsigned int GetPUSH4Data()\n&#123;\n    unsigned int eax, ebx;\n    unsigned char _bl;\n    \n    _rsi -&#x3D; 4;\n    eax &#x3D; *(unsigned int*)(stack+_rsi);\n    ebx &#x3D; _rbx &amp; 0xffffffff;\n    \n    bswap(eax);\n    eax ^&#x3D; ebx;\n    eax -&#x3D; 0xcc3ff88a;\n    eax ^&#x3D; 0x9b616bfd;\n    eax &#x3D; !eax;\n    bl &#x3D; _rbx &amp; 0xff;\n    _rbx &#x3D; _rbx - bl + 0xfa; &#x2F;&#x2F; bl &#x3D; 0xfb; bx--;\n    cdqe;\n    return eax;\n&#125;\n\nADD_Q_Q\n基于栈的二元加法。实现的功能为top2 = top2+top1，top1 = RFLAGS。\n","slug":"vmp2-p1","date":"2021-09-13T04:00:00.000Z","categories_index":"Re","tags_index":"re,vmp2","author_index":"御史神风"},{"id":"25dfe92efe3817312d385cfe3a16b7f2","title":"MEMZ彩虹猫分析","content":"MEMZ彩虹猫分析流程\nvoid start()\n&#123;\n\t&#x2F;&#x2F; 紫色部分\n\tif(arbc &gt; 1)\n\t&#123;\n\t\tif(!lstrcmpW(argv[1], L&quot;&#x2F;watchdog&quot;))\n        &#123;\n            &#x2F;&#x2F; 红色部分\n        &#125;\n        &#x2F;&#x2F; 绿色部分\n\t&#125;\n    &#x2F;&#x2F; 蓝色部分\n&#125;\n\n根据命令行参数不同，实际上会有三种效果。\n第一种（蓝色部分）是不带参数，会弹两次警告窗口，然后带参数的打开自身。\n第二种（绿色部分）是带参数且argv[1] != “/watchdog”。会往硬盘写入恶意代码，修改mbr；然后打开一个notepad；接着是捣乱十阶段：依次创建十个线程分别搞破坏。\n第三种（红色部分）是argv[1] != “/watchdog”，会创建一个线程用于检测除彩虹猫以外的进程数量，如果有减少，会触发蓝屏与重启。主线程会创建一个消息循环，接收到关闭消息也会触发蓝屏与重启。\n细节分析struct&#123;\n    LPVOID pFunc;\n    unsigned int sleepTime;\n&#125;struc_1;\n\n无参数部分代码\n这部分代码比较普通，api都有符号，直接查MSDN即可。\n非/watchdog部分代码运行这部分的进程优先级会被设为高。\n这部分代码的结尾有个死循环sleep，所以不会运行无参数部分的代码。\n修改MBR，写入恶意代码\n\n比较有意思的是文件名为\\\\.PhysicalDrive0可以打开磁盘0，并覆写MBR\nhFile &#x3D; CreateFileA(&quot;\\\\\\\\.\\\\PhysicalDrive0&quot;, 0xC0000000, 3u, 0, 3u, 0, 0);&#x2F;&#x2F; 打开物理驱动器0\n\n写入的shellcode没有分析。\n打开记事本嘲讽\n\n然后写入记事本并打开。\n捣乱十连\n\n随后有个捣乱十阶段，间隔一定时间，创建十个线程，分别执行十个函数，下面是我稍微整理了下的代码。\nfor(i &#x3D; 0; i &lt; 10; i++)\n&#123;\n    Sleep(messFuncs[i].sleepTime);\n    CreateThread(0, 0, LoopCallMess, &amp;messFuncs[i], 0, 0);\n&#125;\n\n其中messFuncs是一个结构体数组，猜测定义如下。\ntypedef struct _struc_1&#123;\n    LPVOID pFunc;\n    unsigned int sleepTime;\n&#125;struc_1;\nstruc_1 messFuncs[10];\n\n执行的那十个函数的分析见下面的捣乱十阶段。\n/watchdog部分代码创建一个线程，然后创建一个消息循环。\n创建的线程\n创建的线程会不断的创建快照，然后统计除MEMZ以外的进程数，如果有减少就执行一个导致蓝屏与重启的函数。\n判断是否是MEMZ的方法是检测进程路径。\n消息循环\n消息循环函数在接收到关闭信息也会执行导致蓝屏与重启的函数。\n蓝屏与重启\n先循环创建20个线程执行一个函数。\n然后直接获取ntdll的api，然后调用触发蓝屏的函数。随后重启。\n那20个线程执行的函数，会SetWindowsHook，hook函数会在窗口创建时随机随机修改窗口位置，随后调用MessageBoxA创建一个窗口，随机弹出嘲讽信息，由于设置了钩子，这个窗口位置是随机的。最后撤销钩子。\n捣乱十阶段阶段一：乱开网页和窗口从46条字符串里随机挑一条作为ShellExecuteA的参数，相当于在运行一个shell，字符串是shell的输入。如果字符串是网页链接，就会打开网页。还可以是calc，notepad等，将打开对应的程序。\n阶段二：乱动鼠标获取鼠标坐标，然后加上随机数，最后再修改鼠标坐标，达到让鼠标乱抖的效果。\n阶段三：乱按键盘调用SendInput api。\n阶段四：乱放系统声音调用PlaySoundA api。\n阶段五：反转桌面窗口颜色获取窗口句柄，然后用BitBlt()反转颜色。\n阶段六：嘲讽弹窗创建一个线程，该线程做的东西和前面StartAddresss那个函数差不多，也是通过SetWindowsHook实现随机位置弹出MessageBox，显示嘲讽信息。\n阶段七：错误图标获取鼠标坐标，然后在鼠标旁边画图标。\n阶段八：反转文字通过EnumChildWindows给全部窗口设一个回调函数，这个回调函数通过SendMessageTimeoutW发送信号给窗口，获取窗口的文字，然后把文字顺序反转，再发送信号给窗口更改文字。\n阶段九：无限桌面有点类似阶段五，不过这次不是反转颜色，可以理解为把桌面截图，然后向右和向下各平移50像素后覆盖到原来桌面。\n阶段十：混乱桌面类似阶段九，不过这次是随机覆盖。\n","slug":"memz","date":"2021-08-13T04:00:00.000Z","categories_index":"Virus","tags_index":"windows,virus","author_index":"御史神风"},{"id":"0655b50c19b52b6b171bbab9b69a5ecc","title":"简易压缩壳笔记","content":"简易压缩壳笔记流程加壳器：\n读取被加壳文件\n加载壳代码\n复制壳代码的section header\n修改ep并保存oep\n加密\n压缩\n清空import、iat directory，保存import directory\n清空tls directoru，保存directory的AddressOfCallBacks\n重定位壳代码\n复制壳代码重定位表，并修改reloc directory\n修复壳代码重定位表\n写入文件\n\n壳代码：\n遍历ldr获取ntdll中的函数\n获取用于解壳的函数的地址\n解压\n解密\n修复并加密iat\n重定位\ntls\n反调试\n跳转到oep\n\n细节替换reloc等section时，只需要修改data directory即可。\n增加section可以只增加header，写入文件时再追加写入。\n通过dll形式写壳代码可以比较方便生成重定位表、iat等。\n关于导入表关于加密iat，常见的做法对每一个api申请一块可执行内存作为跳转函数，然后把iat中api地址换成跳转函数地址。此做法需要判断导入表中导入的是函数还是变量。如果是变量显然会出错。我采取的做法是判断地址是否位于dll的text段。\n关于import_descriptor。该结构有OriginalFirstThunk和FirstThunk两个结构体数组的指针。理论上文件中时两个结构体应该都指向同一个地址，加载为image后FT指向IAT的RVA。有时可能会出现OFT为0，只有FT的情况。\n","slug":"SimplePack","date":"2021-08-04T04:00:00.000Z","categories_index":"Windows","tags_index":"windows,pack","author_index":"御史神风"},{"id":"b4fc70e59f23576dbde3f95657ed4ffe","title":"WX数据库自动解密（已失效）","content":"微信 PC端 数据库 自动解密摘要\n\n\n\n\n\n\n\n\n环境:\nwin10家庭中文版 10.0.19043 x64（本机）\n微信 3.3.0.115\nopenssl-1.0.2r\nPC密码为32字节。\n手动流程获取密码打开微信（不点登录）。\n打开Odb附加WeChat.exe。\n查找-&gt;可执行模块-&gt;WeChatWin。\n用插件找ASCII字符串（我打了中文搜索补丁，直接用中文搜索的搜索ASCII字符串）。\n然后搜索字符串DBFactory::encryptDB，跳转到第一次出现该字符串的位置。这里旧版本可能是第二个字符串的位置。3.3版本我找到了两个，都跳转过去看看，其中一个push语句下面有一个TEST，另一个只有一个call就return了。要找的是有TEST那个。\n该TEST语句就是比较密码的地方，双击设置断点。然后运行并登录。\n停在断点时，选择edx在数据窗口中跟随。\n然后把从edx开始的32字节的数据dump出来，该32字节的数据就是密码。\n从源码安装openssl需要用到openssl，据说sqlcipher用的是最低版本的openssl。这里使用1.0.2u。\n首先安装perl。（http://www.activestate.com/activeperl/downloads/）\n然后运行 x86 Native Tools Command Prompt for VS 2019 这个shell。\n激活perl环境\nstate activate\ncd &#x2F;d D:\\openssl-1.0.2u\\\n\n编译\nperl Configure VC-WIN64A no-asm -prefix&#x3D;D:\\Program Files\\openssl102u\nms\\do_ms.bat\nnmake -f ms\\ntdll.mak\n\n检查\nnmake -f ms\\ntdll.mak test\n\n安装\nnmake -f ms\\ntdll.mak install\n\n奇怪的是最后还是安装到了E:\\usr\\local\\ssl\\这个目录下\n解密这里分享vs2019解密的过程。\n在项目的属性页 -&gt; C/C++ -&gt; 常规 -&gt; 附加包含目录 中添加openssl的include目录。\n在项目的属性页 -&gt; 链接器 -&gt; 常规 -&gt; 附加库目录 中添加openssl的include目录。\n在项目的属性页 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项 中添加libeay32.lib和ssleay32.lib。\n然后编译运行看雪文章中的代码。（链接见参考）\n然后把E:\\usr\\local\\ssl\\bin\\中的两个dll复制exe的根目录，exe才能正常运行。\n接着把exe和两个dll复制到微信缓存文件的目录/对应用户目录/Msg/里，微信缓存目录名为WeChat Files，可以在微信设置中查到。\n复制过去后运行exe即可。\n自动获取（代码修改api hook）流程代码参考附件。\n总流程如下：\n复制dll到wx根目录\n打开微信\n注入dll\n微信登录\ndll把密钥dump出来\n复制聊天记录文件\n解密\n\n其中dll所做的是修改目标函数的起始字节为jmp，跳转到hook函数中，然后读取原函数的参数，把密钥写到文件里，再unhook并跳回原来的位置继续运行。\n因为比较懒，自动化代码没有写卸载dll的东西。另外有时会出现dump出密码后，微信直接闪退的情况。\ndll通过注入dll实现修改代码的hook来dump出密钥。\n通过GetModuleHandle获取WeChatWin.dll的基址，然后加上目标api的偏移得到api的地址。\nhApi &#x3D; GetModuleHandleW(L&quot;WeChatWin&quot;) + apiOffset;\nhook_by_5b_code(hApi, (PROC)HookFunc);\n\n然后查看api的代码可以推算出密钥首地址为*(*(esp - 4 + 0x10))，减4是因为有个push ebp。然后剩下的照抄test edx, edx前的代码得到。\n当然也可以直接在test edx, edx的地方跳转，这样直接读edx就行。\n__declspec(naked) void HookFunc()\n&#123;\n    &#123;\n        DWORD _esp &#x3D; 0;\n \n        __asm &#123;\n            mov _esp, esp;\n            pusha;\n        &#125;\n \n        DWORD addr &#x3D; *(DWORD*)(*(DWORD*)(_esp + 0xc));\n        HANDLE hFile &#x3D; CreateFileW(L&quot;.&#x2F;pw.bin&quot;, GENERIC_WRITE, 0, 0, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);\n        WriteFile(hFile, (LPCVOID)addr, 32, NULL, NULL);\n        CloseHandle(hFile);\n        unhook_by_5b_code(hApi);\n \n        __asm &#123;\n            popa;\n            mov ecx, 0x53677E70;\n            jmp ecx;\n        &#125;\n    &#125;\n&#125;\n\n食用指南GetPwHookCodeDll.cpp是dll的代码。AllInOne.cpp是自动解密的代码。需要提供wx根目录位置和微信用户文件的位置。\nwx用户文件的位置：在wx的缓存文件（该目录在wx设置中有）中，有一个叫wxid_xxxxxxx的文件夹，xxxxx是你的初始wx id，这个就是对应wx账户的本地文件。\n假设wx根目录是D:\\WeChat，用户目录是D:\\WeChat Files\\wxid_bravetroops。方法一：在自动程序根目录中打开shell，输入AllInOne.exe D:\\WeChat D:\\WeChat Files\\wxid_bravetroops即可。方法二：在程序根目录中有个aio_cf.txt，第一行输入wx根目录，第二行输入用户目录即可。\n最后会在根目录生成一个dec_ChatMsg.db的文件，就是解密后的聊天记录。\n参考[原创]PC版微信数据库解密详细教程|bbs.pediy.com\nwindow10 安装 OpenSSL_sun-CSDN博客\n","slug":"WeChatDBDecrypt","date":"2021-07-22T04:00:00.000Z","categories_index":"Windows","tags_index":"WX,Database","author_index":"御史神风"},{"id":"9a514a805495433f4105a5ad7faec5ce","title":"HammingCode","content":"Hamming Code思路多次奇偶校验，下标为2n的位作为奇偶校验位，校验对象为所有位中小标第n位为1的位，显然包括了一半的数据。\n第0位一般弃置，或者作为奇偶校验位的奇偶校验位，这样就可以判断是否存在多个错误。\n每一个奇偶校验位都校验了一半的数据，通过检测哪些校验位是错的即可找到哪一位数据出错。\n小结三种理解思路：一是多组奇偶校验；二是异或；三是线性代数。\n只能纠错一个位，以及判断是否有多个错误，校验结果即为错误位。\n若奇偶校验位的个数为n：\n汉明码的位数：2n = 1 &lt;&lt; n\n数据位的位数：2n-n-1 = (1&lt;&lt;n)-n-1\n校验位按下标排序，错误的置一，其余置零，若结果不为0，得到的就是错误位的下标。\n实现该算法目前已经不常用。实际使用通常配合其他通信技巧使用。下面是我分别用python和c++实现的代码。实现方式为把原始数据分块再编码成汉明码。\nAlgorithm/HammingCode at master · windgodm/Algorithm (github.com)\n参考https://www.bilibili.com/video/BV1WK411N7kz\nhttps://www.bilibili.com/video/BV1pV411y7E8\n","slug":"HammingCode","date":"2021-07-14T04:00:00.000Z","categories_index":"Algorithm","tags_index":"note,Error_Correction","author_index":"御史神风"},{"id":"5e05a9de597a39befc3bd53d02dc7c56","title":"APIHook DLL注入实现代码钩取 笔记","content":"APIHook - DLL注入实现代码钩取 笔记摘要\n\n\n\n\n\n\n\n\n技术摘要：\n动态修改进程内存中的代码。利用DLL注入修改代码开头跳转到补丁代码。\n起源是逆向工程核心原理里面以任务管理器ZwQuerySystemInformation()API钩取为例讲解利用dll注入修改api的起始代码为jmp实现api钩取。该例子目标是隐藏某个进程。\n大概流程如下\n调用者:\n1: call api\napi:\n2: jmp patch\npatch:\n3: unhook\n4: call api（正常执行api功能）\n5: hook\n6: patch\n7: retn 到调用者\n\n细节有一些未公开的函数或者枚举类型一定要找尽可能正确的。可能因为资料的不正确导致钩取失败或没有效果。如果出现问题，要对比正常流程看钩取后传递的参数是否符合预期，一些标志位的设置是否正确。\n不可避免的一个问题是会出现漏网之鱼，也就unhook期间原api被调用会暴露隐藏进程。我在测试时遇到过隐藏进程突然在任务管理器中闪出来几下的情况。\n隐藏进程实际上是修改了ZwQuerySystemInformation返回的一个包含进程信息的链表，如果要隐藏的进程在链表中排第一个的话会出错，原因详见 实例 中。而实际中似乎链表的第一个一定是System(进程号为4)，随后是Registry和svchost。所以只有不隐藏System这个进程就不会有问题。\n实例：隐藏进程ZwQuerySystemInformation()（x64）该例子对象是任何直接或间接使用了ZwQuerySystemInformation查询进程信息的64位程序，比如任务管理器。\n下面的步骤按运行时的执行顺序来写。\n1 dll注入第一步是把后面编写好的dll注入到目标程序中，关于dll注入的内容在此略过。\n2 dll#pragma comment(linker, &quot;&#x2F;SECTION:.SHARE,RWS&quot;)\n#pragma data_seg(&quot;.SHARE&quot;)\nwchar_t g_wszProcName[MAX_PATH] &#x3D; &#123; 0, &#125;;\n#pragma data_seg()\n\nvoid SetProcName(LPCTSTR wszProcName)\n&#123;\n    wcscpy_s(g_wszProcName, wszProcName);\n&#125;\n\nBOOL APIENTRY DllMain(HMODULE hModule,\n    DWORD  ul_reason_for_call,\n    LPVOID lpReserved\n)\n&#123;\n    char pszCurProc[MAX_PATH] &#x3D; &#123; 0, &#125;;\n    char* p &#x3D; NULL;\n\n    &#x2F;&#x2F; check\n    GetModuleFileNameA(NULL, pszCurProc, MAX_PATH);\n    p &#x3D; strrchr(pszCurProc, &#39;\\\\&#39;);\n    if ((p !&#x3D; NULL) &amp;&amp; !_stricmp(p + 1, &quot;remote_inject_x64.exe&quot;))\n        return TRUE;\n\n    switch (ul_reason_for_call) &#123;\n    case DLL_PROCESS_ATTACH:\n        &#x2F;&#x2F; set\n        SetProcName(L&quot;notepad.exe&quot;);\n        &#x2F;&#x2F; get api\n        hApi &#x3D; GetProcAddress(GetModuleHandleW(pwszDllName), &quot;ZwQuerySystemInformation&quot;);\n        &#x2F;&#x2F; hook\n        hook_by_5b_code(pszDllName, hApi, (PROC)MyZwQuerySystemInformation);\n        break;\n    case DLL_PROCESS_DETACH:\n        &#x2F;&#x2F;unhook\n        unhook_by_5b_code(pszDllName, hApi);\n        break;\n    &#125;\n    return TRUE;\n&#125;\n\n这里就是普通的dll，加载时钩取、卸载时脱钩。在加载时还会获取目标api的地址，以及设置要隐藏的dll名称。设置隐藏dll名称这一步可以换到别的地方设置。因为保存隐藏dll名称的变量是个共享变量，所以完全可以再写一个程序复制管理这个共享变量。只需要在管理程序中主动加载该dll，然后调用导出的SetProcName()即可，可以实现动态改变隐藏目标。当然也可以拓展代码实现隐藏多个不同名进程或按pid隐藏等。（这里SetProcName定义在dll的头文件中）\n3 hook by 5bytes codehook_by_5b_code函数修改api开头的5字节内容，改成jmp指令。32和64的jmp都是e9+4字节的相对偏移，这个相对偏移是以jmp下一条指令的地址作为起始地址来计算的，具体见下面的代码。\nbool hook_by_5b_code(char* pszDllName, HANDLE api, PROC newApi)\n&#123;\n    DWORD dwOldProtect;\n    byte pNewBytes[5] &#x3D; &#123; 0xE9, 0, &#125;;\n    DWORD jmpOffset;\n\n    VirtualProtect(api, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\n    if (((PBYTE)api)[0] &#x3D;&#x3D; 0xE9)\n        return false;\n\n    &#x2F;&#x2F; bak origin byte\n    memcpy(pOriginBytes, api, 5);\n\n    &#x2F;&#x2F; count jmp offset\n    jmpOffset &#x3D; (DWORD)((size_t)newApi - (size_t)api - 5);\n\n    &#x2F;&#x2F; e9 offset(4bytes)\n    memcpy(&amp;pNewBytes[1], &amp;jmpOffset, 4);\n\n    &#x2F;&#x2F; hook\n    memcpy(api, pNewBytes, 5);\n\n    VirtualProtect(api, 9, dwOldProtect, &amp;dwOldProtect);\n\n    return true;\n&#125;\n\nunhook就是恢复api原始字节即可。\nbool unhook_by_5b_code(char* pszDllName, HANDLE api)\n&#123;\n    DWORD dwOldProtect;\n\n    VirtualProtect(api, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\n    if (((PBYTE)api)[0] !&#x3D; 0xE9)\n        return false;\n\n    &#x2F;&#x2F; unhook\n    memcpy(api, pOriginBytes, 5);\n\n    VirtualProtect(api, 5, dwOldProtect, &amp;dwOldProtect);\n\n    return true;\n&#125;\n\n新api（补丁代码 ZwQuerySystemInformation）1~4对应摘要中的3~6，具体看代码及注释。在执行patch之前会检测返回值判断调用原api是否成功，以及判断此次调用是否为查询进程信息。\nPSYSTEM_PROCESS_INFORMATION结构是一个链表，具体遍历方式参考代码即可。\nSYSTEM_INFORMATION_CLASS是一个枚举类型，说明函数SystemInformation这个参数的类似是什么。如果 SystemInformationClass == SystemProcessorInformation(5) 即代表SystemInformation类型为PSYSTEM_PROCESS_INFORMATION。\n可以看到代码中没有对链表第一个元素做特殊处理，这里算是一个不会产生太大影响的bug。如果要隐藏的进程在链表的第一个位置，此时prev和cur指向的都是第一个元素，执行操作以后会错误修改第一个元素的next偏移，导致无法正确找到第二个元素，同时也没有隐藏第一个。实际中第一个元素好像一般为System进程，只要不隐藏这个一般不会触发问题。\ntypedef struct _SYSTEM_PROCESS_INFORMATION &#123;\n\tULONG NextEntryOffset;\n\tULONG NumberOfThreads;\n\tBYTE Reserved1[48];\n\tPVOID Reserved2[3];\n\tHANDLE UniqueProcessId;\n\tPVOID Reserved3;\n\tULONG HandleCount;\n\tBYTE Reserved4[4];\n\tPVOID Reserved5[11];\n\tSIZE_T PeakPagefileUsage;\n\tSIZE_T PrivatePageCount;\n\tLARGE_INTEGER Reserved6[6];\n&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;\n\nNTSTATUS WINAPI MyZwQuerySystemInformation(\n    _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,\n    _Inout_   PVOID                    SystemInformation,\n    _In_      ULONG                    SystemInformationLength,\n    _Out_opt_ PULONG                   ReturnLength\n)\n&#123;\n    NTSTATUS nts;\n\n    &#x2F;&#x2F; 1: unhook\n    unhook_by_5b_code(pszDllName, hApi);\n\n    &#x2F;&#x2F; 2: call origin api\n    nts &#x3D; ((ZwQuerySystemInformation)hApi)(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);\n\n    &#x2F;&#x2F; 3: hook\n    hook_by_5b_code(pszDllName, hApi, (PROC)MyZwQuerySystemInformation);\n\n    &#x2F;&#x2F; SystemProcessorInformation(5)\n    if ((nts !&#x3D; CMC_STATUS_SUCCESS) || SystemInformationClass !&#x3D; 5) &#123;\n        return nts;\n    &#125;\n\n    &#x2F;&#x2F; 4: patch: hide\n    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;\n    pCur &#x3D; (PSYSTEM_PROCESS_INFORMATION)SystemInformation;\n    pPrev &#x3D; pCur; &#x2F;&#x2F; warning\n    while (1) &#123;\n        &#x2F;&#x2F; hide\n        if (pCur-&gt;Reserved2[1] !&#x3D; NULL) &#123;\n            if (_wcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_wszProcName) &#x3D;&#x3D; 0) &#123;\n                if (pCur-&gt;NextEntryOffset &#x3D;&#x3D; 0)\n                    pPrev-&gt;NextEntryOffset &#x3D; 0;\n                else\n                    pPrev-&gt;NextEntryOffset +&#x3D; pCur-&gt;NextEntryOffset;\n            &#125;\n            else &#123;\n                pPrev &#x3D; pCur;\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; break\n        if (pCur-&gt;NextEntryOffset &#x3D;&#x3D; 0)\n            break;\n\n        &#x2F;&#x2F; next\n        pCur &#x3D; (PSYSTEM_PROCESS_INFORMATION)((size_t)pCur + (size_t)pCur-&gt;NextEntryOffset);\n    &#125;\n    \n    return nts;\n&#125;\n\n参考逆向工程核心原理：part4-API钩取：第33章-隐藏进程\n","slug":"APIHookDllCodeHideProc","date":"2021-06-24T06:44:00.000Z","categories_index":"Windows","tags_index":"windows,note,api_hook,reversecore","author_index":"御史神风"},{"id":"cc4abc1dfb3fac0a8ab6b7033be4ca99","title":"APIHook DLL注入实现IAT钩取 笔记","content":"APIHook - DLL注入实现IAT钩取 笔记摘要\n\n\n\n\n\n\n\n\n技术摘要：\n动态修改进程内存中的IAT。利用DLL注入修改API的IAT。\n起源是逆向工程核心原理里面以计算器SetWindowText()API钩取为例讲解利用dll注入修改api的iat来实现钩取。该例子目标是把显示的阿拉伯数字改成中文数字。\n细节补丁函数（新api）要申明为WINAPI，即stdcall。c++默认的是cdecl，由调用者处理栈。而api使用的stdcall是由被调用者处理的。如果不声明为stdcall，调用钩取api结束时本应该清理栈，而实际上不会清理。同样钩取api中调用原api时，原api结束时清理了一次栈，而我们的钩取api又会再处理一次栈。这时esp指向的不是旧ebp，pop ebp时就会触发错误。实际上由于win32 api为stdcall，使得我们的新函数对栈不需要做特殊操作。\n实例：计算器SetWindowTextW()（x32）该例子对象是xp的x32的calc.exe，运行环境是在win10中。（我把xp虚拟机里的计算机复制出来了）在win10的计算机中尝试失败了，还没找到原因。\n下面的步骤按运行时的执行顺序来写。\n1 dll注入第一步是把后面编写好的dll注入到目标程序中，关于dll注入的内容在此略过。\n2 dll当 dll第一次加载进进程(DLL_PROCESS_ATTACH) 时先记录原本api的地址，如何再hook。\n当 卸载dll(DLL_PROCESS_DETACH) 时unhook。\n因为hook实际上就是把iat中被钩取api的地址换成补丁函数的地址，而unhook的过程则反过来把iat中补丁函数地址换回原本地址，所以可以统一写成一个函数hook_iat()。该函数会将oldFunc替换成newFunc。\nbool hook_iat(char* pszDllName, HANDLE oldFunc, HANDLE newFunc);\nBOOL WINAPI MySetWindowTextW(\n    HWND    hWnd,\n    LPCWSTR lpString\n);\n\nBOOL APIENTRY DllMain(HMODULE hModule,\n    DWORD  ul_reason_for_call,\n    LPVOID lpReserved\n)\n&#123;\n    switch (ul_reason_for_call) &#123;\n    case DLL_PROCESS_ATTACH:\n        &#x2F;&#x2F; save origin api\n        pOriginFunc &#x3D; GetProcAddress(GetModuleHandleW(L&quot;user32.dll&quot;), &quot;SetWindowTextW&quot;);\n        &#x2F;&#x2F; hook\n        hook_iat(&quot;user32.dll&quot;, pOriginFunc, MySetWindowTextW);\n        break;\n    case DLL_PROCESS_DETACH:\n        &#x2F;&#x2F;unhook\n        hook_iat(&quot;user32.dll&quot;, MySetWindowTextW, pOriginFunc);\n        break;\n    &#125;\n    return TRUE;\n&#125;\n\n3 改写iat（hook_iat()）这个函数用于把iat中名为 pszDllName 的 library 中的 oldFunc 换成 newFunc。本质上整段代码就是在解析pe文件以及遍历iat。这里不做详细解析，详见反射注入文章[2]中 处理导入表 部分内容。\n其中用到了size_t，这是个与机器有关的unsigned类型。说人话就是按32位编译时是32位；按64位编译时是64位。\nbool hook_iat(char* pszDllName, HANDLE oldFunc, HANDLE newFunc)\n&#123;\n    &#x2F;&#x2F; pe\n    PIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)GetModuleHandleW(NULL);\n    PIMAGE_NT_HEADERS32 pNtHeader &#x3D; (PIMAGE_NT_HEADERS32)padd(pDosHeader, pDosHeader-&gt;e_lfanew);\n    PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)padd(pDosHeader, pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\n\n    &#x2F;&#x2F; find dll\n    LPCSTR pszLibName;\n    for (; pImportDescriptor-&gt;Name; pImportDescriptor++) &#123;\n        pszLibName &#x3D; (LPCSTR)padd(pDosHeader, pImportDescriptor-&gt;Name);\n        if (_stricmp(pszLibName, pszDllName) &#x3D;&#x3D; 0) &#123;\n            &#x2F;&#x2F; find old func\n            PIMAGE_THUNK_DATA32 pThunk &#x3D; (PIMAGE_THUNK_DATA32)padd(pDosHeader, pImportDescriptor-&gt;FirstThunk);\n            for (; pThunk-&gt;u1.Function; pThunk++) &#123;\n                if (pThunk-&gt;u1.Function &#x3D;&#x3D; (size_t)oldFunc) &#123;\n                    &#x2F;&#x2F; replace\n                    DWORD dwOldProt;\n                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, 4, PAGE_EXECUTE_READWRITE, &amp;dwOldProt);\n                    pThunk-&gt;u1.Function &#x3D; (size_t)newFunc;\n                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, 4, dwOldProt, &amp;dwOldProt);\n\n                    return true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n\n4 新api（补丁代码 MySetWindowTextW()）这部分代码参考逆向工程核心原理[1]，这个函数用于将unicode的数字转换成中文数字。temp数组的目的是构造一个0结尾的字符串，用于_wtoi。\ntypedef BOOL(WINAPI *SETWINDOWTEXTW)(HWND, LPCWSTR);\n\nBOOL WINAPI MySetWindowTextW(\n    HWND    hWnd,\n    LPCWSTR lpString\n)\n&#123;\n    wchar_t pNumTab[] &#x3D; L&quot;零一二三四五六七八九&quot;;\n    wchar_t temp[2] &#x3D; &#123; 0, &#125;; &#x2F;&#x2F; for wtoi\n    size_t i, nLen, nIndex;\n\n    nLen &#x3D; wcslen(lpString);\n    for (i &#x3D; 0; i &lt; nLen; i++) &#123;\n        &#x2F;&#x2F; translate\n        if (L&#39;0&#39; &lt;&#x3D; lpString[i] &amp;&amp; lpString[i] &lt;&#x3D; L&#39;9&#39;) &#123;\n            temp[0] &#x3D; lpString[i];\n            nIndex &#x3D; _wtoi(temp);\n            ((wchar_t*)lpString)[i] &#x3D; pNumTab[nIndex];\n        &#125;\n    &#125;\n\n    return ((SETWINDOWTEXTW)pOriginFunc)(hWnd, lpString);\n&#125;\n\n参考[1] 逆向工程核心原理：part4-API钩取：第32章-计算器显示中文数字\n[2] 反射注入 看雪文章链接 博客文章链接\n","slug":"APIHookDllIATCalc","date":"2021-06-19T06:22:00.000Z","categories_index":"Windows","tags_index":"windows,note,api_hook,reversecore","author_index":"御史神风"},{"id":"647fdfb1f4686f6ba30a2feb4f787ced","title":"APIHook 调试技术 笔记","content":"APIHook-调试技术 笔记摘要\n\n\n\n\n\n\n\n\n技术摘要：\n动态修改进程内存中的代码。利用调试技术附加到目标进程钩取API。\n\n\n\n\n\n\n\n\n\n术语：\ndebuger：调试器debugee：被调试者\n起源是逆向工程核心原理里面以记事本WriteFile()API钩取为例讲解利用调试来实现API钩取。该例子目标是在文件保存时把小写转成大写。\n概括来说就是实现一个调试器，给对应api下断点。\n以记事本WriteFile()API为例，大概流程是作为调试器附加到notepad上，然后给WriteFile()的起始地址下个int 3断点，这样控制流就能回到调试器，就可以读取栈获得api参数了。\n大概流程如下\n1: 作为调试器附加\n2: 进入调试循环\n\n判断是否为int3断点，且断点位置为目标api起始地址\nOnException:\n  1: unhook\n  2: get thread context\n  3: your patch\n  4: change ctx(eip&#x2F;rip)\n  5: continue debugee\n  Sleep(0)\n  6: hook\n\n对于其他异常，交回给debugee的seh处理\n\n细节首先是要注意32和64位的问题，然后可能需要获取Debug权限。\n实例：记事本WriteFile()API（x32）该例子对象是win10的x32的notepad.exe。\n1 作为调试器附加代码如下只有一行：\nDebugActiveProcess(dwPID);\n\n附加失败会返回0，通过GetLastError()可以获取错误代码，x32的debuger附加x64的debugee会失败并得到0x32这个错误代码。\n成功后会发送一个CREATE_PROCESS_DEBUG_EVENT事件，可以被WaitForDebugEvent()获取。\n还有另外一种方法是用CreateProcess()来创建并附加一个进程。\n2 调试循环附加成功后就要进入调试循环：\nDEBUG_EVENT de;\nDWORD dwDECode;\nDWORD dwContinueStatus;\n\n&#x2F;&#x2F; wait for debug event\nwhile (WaitForDebugEvent(&amp;de, INFINITE)) &#123;\n    dwContinueStatus &#x3D; DBG_EXCEPTION_NOT_HANDLED;\n    dwDECode &#x3D; de.dwDebugEventCode;\n    &#x2F;&#x2F; exception\n    if (dwDECode &#x3D;&#x3D; EXCEPTION_DEBUG_EVENT) &#123;\n        if (OnException(&amp;de))\n            continue;\n    &#125;\n    &#x2F;&#x2F; on create or attach debug event\n    else if (dwDECode &#x3D;&#x3D; CREATE_PROCESS_DEBUG_EVENT) &#123;\n        OnCreate(&amp;de);\n        dwContinueStatus &#x3D; DBG_CONTINUE;\n    &#125;\n    &#x2F;&#x2F; debuggee exit\n    else if (dwDECode &#x3D;&#x3D; EXIT_PROCESS_DEBUG_EVENT) &#123;\n        break;\n    &#125;\n    &#x2F;&#x2F; continue to run debuggee\n    ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus);\n&#125;\n\nWaitForDebugEvent()用于等待调试事件。第一个参数用于接收调试信息；第二个为等待时间(ms)，如果等待时间为INFINITE(0xFFFFFFFF)则会一直等待直到有调试时间再返回，这时debugee会被挂起。\n3 处理调试事件&#x2F;&#x2F; minwinbase.h\ntypedef struct _DEBUG_EVENT &#123;\n    DWORD dwDebugEventCode;\n    DWORD dwProcessId;\n    DWORD dwThreadId;\n    union &#123;\n        EXCEPTION_DEBUG_INFO Exception;\n        CREATE_THREAD_DEBUG_INFO CreateThread;\n        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;\n        EXIT_THREAD_DEBUG_INFO ExitThread;\n        EXIT_PROCESS_DEBUG_INFO ExitProcess;\n        LOAD_DLL_DEBUG_INFO LoadDll;\n        UNLOAD_DLL_DEBUG_INFO UnloadDll;\n        OUTPUT_DEBUG_STRING_INFO DebugString;\n        RIP_INFO RipInfo;\n    &#125; u;\n&#125; DEBUG_EVENT, *LPDEBUG_EVENT;\n\nEXCEPTION_DEBUG_EVENT(u.Exception = EXCEPTION_DEBUG_INFO)为异常调试事件，int 3中断时会触发该事件，这时我们需要执行自己的代码，具体见“6 异常调试事件”。\n&#x2F;&#x2F; minwinbase.h\ntypedef struct _EXCEPTION_DEBUG_INFO &#123;\n    EXCEPTION_RECORD ExceptionRecord;\n    DWORD dwFirstChance;\n&#125; EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;\n&#x2F;&#x2F; winnt.h\ntypedef struct _EXCEPTION_RECORD &#123;\n    DWORD    ExceptionCode;\n    DWORD ExceptionFlags;\n    struct _EXCEPTION_RECORD *ExceptionRecord;\n    PVOID ExceptionAddress;\n    DWORD NumberParameters;\n    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];\n&#125; EXCEPTION_RECORD;\n\nCREATE_PROCESS_DEBUG_EVENT(u.CreateProcessInfo = CREATE_PROCESS_DEBUG_INFO)在刚附加到debugee时会触发，这时需要完成hook，具体见“5 首次hook”。\n&#x2F;&#x2F; minwinbase.h\ntypedef struct _CREATE_PROCESS_DEBUG_INFO &#123;\n    HANDLE hFile;\n    HANDLE hProcess;\n    HANDLE hThread;\n    LPVOID lpBaseOfImage;\n    DWORD dwDebugInfoFileOffset;\n    DWORD nDebugInfoSize;\n    LPVOID lpThreadLocalBase;\n    LPTHREAD_START_ROUTINE lpStartAddress;\n    LPVOID lpImageName;\n    WORD fUnicode;\n&#125; CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;\n\nEXIT_PROCESS_DEBUG_EVENT(u.ExitProcess = EXIT_PROCESS_DEBUG_INFO)在debugee退出时触发。\n4 继续运行debugee处理完调试事件后，调用ContinueDebugEvent()以继续运行debugee。\nContinueDebugEvent第三个参数比较特殊，如果处理成功设置为DBG_CONTINUE即可，如果不能处理设置成DBG_EXCEPTION_NOT_HANDLED让seh来处理。\n5 首次hook该事件在刚附加时触发一次，这时我们需要完成对API的hook：\nbool OnCreate(DEBUG_EVENT* pde)\n&#123;\n    &#x2F;&#x2F; get api address\n\n    hKernel32 &#x3D; GetModuleHandleW(L&quot;kernel32.dll&quot;);\n    if (hKernel32 &#x3D;&#x3D; 0) &#123; cout &lt;&lt; &quot;Get kernel32.dll failed.\\n&quot;; return false; &#125;\n    pWriteFile &#x3D; GetProcAddress(hKernel32, &quot;WriteFile&quot;);\n    if (pWriteFile &#x3D;&#x3D; 0) &#123; cout &lt;&lt; &quot;Get WriteFile() failed.\\n&quot;; return false; &#125;\n\n    &#x2F;&#x2F; hook\n\n    memcpy(&amp;cpdi, &amp;pde-&gt;u.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_INFO));\n    ReadProcessMemory(cpdi.hProcess, pWriteFile, &amp;chOrigin, 1, NULL);\n    WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chINT3, 1, NULL);\n\n    return true;\n&#125;\n\nkernel32在不同进程中加载到同样位置，直接在本进程GetModuleHandleW就行。\n需要注意的是把CreateProcessInfo保存下来，其中有一些信息比如debugee的进程、线程id我们在接下来的再次hook时也需要使用。\n6 异常调试事件（补丁代码）发生异常调试事件时触发，如果为int3且断点为目标api地址就执行我们的补丁，这里我们的补丁是把文本的小写字母转换成大写：\nbool OnException(DEBUG_EVENT* pde)\n&#123;\n    CONTEXT ctx;\n    PEXCEPTION_RECORD per &#x3D; &amp;pde-&gt;u.Exception.ExceptionRecord;\n    DWORD dwBuffer, dwNum; &#x2F;&#x2F; WriteFile() param 2, 3\n    PBYTE lpBuffer &#x3D; NULL;\n\n    int i;\n\n    &#x2F;&#x2F; int 3\n    if (per-&gt;ExceptionCode &#x3D;&#x3D; EXCEPTION_BREAKPOINT) &#123;\n        &#x2F;&#x2F; breakpoint address\n        if (per-&gt;ExceptionAddress &#x3D;&#x3D; pWriteFile) &#123;\n            &#x2F;&#x2F; 1: unhook\n            WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chOrigin, 1, NULL);\n\n            &#x2F;&#x2F; 2: get thread context\n            ctx.ContextFlags &#x3D; CONTEXT_CONTROL;\n            GetThreadContext(cpdi.hThread, &amp;ctx);\n\n            &#x2F;&#x2F; 3.1: get WriteFile() param 2, 3\n            ReadProcessMemory(cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;dwBuffer, 4, NULL);\n            ReadProcessMemory(cpdi.hProcess, (LPVOID)(ctx.Esp + 0xC), &amp;dwNum, 4, NULL);\n\n            &#x2F;&#x2F; 3.2: malloc buffer\n            lpBuffer &#x3D; (PBYTE)malloc(dwNum + 1);\n            memset(lpBuffer, 0, dwNum + 1);\n\n            &#x2F;&#x2F; 3.3: copy to buffer\n            ReadProcessMemory(cpdi.hProcess, (LPVOID)dwBuffer, lpBuffer, dwNum, NULL);\n            cout &lt;&lt; &quot;\\nOrigin:\\n&quot; &lt;&lt; lpBuffer &lt;&lt; endl;\n\n            &#x2F;&#x2F; 3.4: Convert\n            for (i &#x3D; 0; i &lt; dwNum; i++) &#123;\n                if (&#39;a&#39; &lt;&#x3D; lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;&#x3D; &#39;z&#39;)\n                    lpBuffer[i] -&#x3D; 0x20;\n            &#125;\n            cout &lt;&lt; &quot;\\nConverted:\\n&quot; &lt;&lt; lpBuffer &lt;&lt; endl;\n\n            &#x2F;&#x2F; 3.5: copy back\n            WriteProcessMemory(cpdi.hProcess, (LPVOID)dwBuffer, lpBuffer, dwNum, NULL);\n            free(lpBuffer);\n\n            &#x2F;&#x2F; 4: change ctx(eip)\n            ctx.Eip &#x3D; (DWORD)pWriteFile;\n            SetThreadContext(cpdi.hThread, &amp;ctx);\n\n            &#x2F;&#x2F; 5: run\n            ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE);\n\n            Sleep(0);\n\n            &#x2F;&#x2F; 6: hook\n            WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chINT3, 1, NULL);\n\n            return true;\n        &#125;\n    &#125;\n\n    return false;\n&#125;\n\n流程是unhook -&gt; 获取上下文 -&gt; 补丁 -&gt; 恢复eip/rip -&gt; 继续运行debugee -&gt; 恢复hook\n在继续运行debugee之后需要Sleep(0)再恢复hook，是因为hook会修改内存中的代码，此时debugee也在运行同一段内存的代码，可能会发生内存访问异常。Sleep(0)可以释放当前线程的剩余时间，让cpu先去执行其他线程，然后再回来恢复hook。\n其中需要用到api的参数，这里简单分析下此时的栈。此时刚刚进入函数，还未push ebp，所以esp指向旧的栈顶，也就是函数放回地址。32位以寄存器传参，第n的参数此时在esp+4*n的位置。\n参考逆向工程核心原理：part4-API钩取：第30章-记事本WriteFile()API钩取\n","slug":"APIHookDebugNotebook","date":"2021-06-17T14:10:00.000Z","categories_index":"Windows","tags_index":"windows,note,api_hook,reversecore","author_index":"御史神风"},{"id":"546d298359e46b393eada3f4824c48b0","title":"21KctfSpring","content":"21 kctf 春2 南冥神功分析main函数\n1 char 2 intchars_table &#x3D; &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;\nwhile(v24 !&#x3D; ++v23)\n&#123;\n\tif(chars_table[v23] &#x3D;&#x3D; input_i)\n        goto LABEL_11;\n&#125;\n\n上面代码中input_i是输入的第i个字符，goto执行时，v23 = int(input_i)。\n2 找出二维数组有一句 &amp;aS_1[10*row+col]可以判断出是二维数组。该句上面是一个switch，对row和col操作，然后判断越界，然后才到v13 = &amp;aS_1。紧接着又有一个if(*v13) break猜测是走二维数组地图的题。且1为墙，0为空。\n3 主要循环switch外面套了个for，然后还有一些向前的goto，构成了主要循环。下面是该循环的部分代码。\nx2 &#x3D; (i + int_inputs[i] &#x2F; 6) % 6;\nx &#x3D; 5 - (i + int_inputs[i]) % 6;\n\nfor (j &#x3D; 0 ;; j &#x3D; 1) &#123; &#x2F;&#x2F; 一共循环两次\n    \n    switch(x) &#123;&#125; &#x2F;&#x2F; 移动\n    \n    &#x2F;&#x2F; 越界撞墙判断\n    if (col &gt; 9) break;\n    if (row &gt; 8) break;\n    v13 &#x3D; &amp;aS_1[10 * row + col];\n    if ( *v13 ) break;\n    *v13 &#x3D; 1; &#x2F;&#x2F; 走过的位置填充\n    \n    if (j &#x3D;&#x3D; 1) &#123;\n        if (input[++i])\n        \tgoto LABEL_4; &#x2F;&#x2F; 去把inputs[i]转换成数字\n        else\n            goto LABEL_19; &#x2F;&#x2F; 到了输入结尾，去判断有没有全部被填充\n    &#125;\n    \n    x &#x3D; x2; &#x2F;&#x2F; x &#x3D; x2 再循环一次\n&#125;\n\n可以看到实际上这个for循环执行了两次，也就是每个inputs[i]对应两次移动。\n其中LABEL_19对应的代码会检测aS_1是否全为1，全为1就输出”Good job!”\n4 switch接着分析switch，即移动的方式。这里直接给结论。实际上可以不分析，直接复制这个switch去写暴力解码脚本。\ncase 1：col += 1\ncase 2：!(row&amp;1) 时col += 1，然后 row += 1\ncase 3：row&amp;1 时col -= 1，然后 row += 1\ncase 4：col -= 1\ncase 5：row&amp;1 时col -= 1，然后 row -= 1\ncase 0：!(row&amp;1) 时col += 1，然后 row -= 1\n5 接下来就可以爆破了刚刚打完acm不想写爆破了。要不是每一个字符对应两次位移，可以建一个图来跑。\n4 英雄救美分析main函数\nscanf_s(&quot;%s&quot;, pszIn, 81);\nnLen &#x3D; strlen(pszIn);\nif (nLen &lt;&#x3D; 64 &amp;&amp; fun2(nLen, pszIn, v10) &#x3D;&#x3D; 1 &amp;&amp; fun1(v10, nLen - 9) &#x3D;&#x3D; 1)&#123;\n    &#x2F;&#x2F; pass\n&#125;\n\n可以看到有三个判定。fun2有三个参数，但我的ida在main中只识别出两个。通过看汇编把缺的参数补全了。\n1 fun2下面给出数据和重构的代码。\nchar v60[16] &#x3D; &#123;0x46, 0x53, 0x4c, 0x52, 0x41, 0x3b, 0x2e, 0x6c, 0x3d, 0x43, 0x45, 0x6b, 0x76, 0x4b, 0x2d, 0x28&#125;;\nchar v70[16] &#x3D; &#123;0x6a, 0x69, 0x63, 0x30, 0x21, 0x68, 0x64, 0x79, 0x7b, 0x6f, 0x5a, 0x7a, 0x2d, 0x40, 0x6e, 0x2b&#125;;\nchar v80[16] &#x3D; &#123;0x24, 0x42, 0x50, 0x56, 0x3a, 0x75, 0x62, 0x66, 0x59, 0x70, 0x7d, 0x5d, 0x44, 0x74, 0x4e, 0x3e&#125;;\nchar v90[16] &#x3D; &#123;0x3f, 0x26, 0x25, 0x73, 0x5f, 0x2f, 0x67, 0x3c, 0x65, 0x5b, 0x57, 0x29, 0x58, 0x55, 0x78, 0x52&#125;;\nchar vA0[16] &#x3D; &#123;0x61, 0x54, 0x5e, 0x4d, 0x47, 0x6d, 0x4a, 0x51, 0x23, 0x2a, 0x48, 0x72, 0x60, 0x4f, 0x27, 0x77&#125;\n&#x2F;&#x2F; psTable &#x3D; v80+vA0+v70+v90+v60+0x71\nchar psTable[82] &#x3D; &quot;$BPV:ubfYp&#125;]DtN&gt;aT^MGmJQ#*Hr&#96;O&#39;wjic0!hdy&#123;oZz-@n+?&amp;%s_&#x2F;g&lt;e[W)XUxRFSLRA;.l&#x3D;CEkvK-(q&quot;;\n\ni &#x3D; 0;\nj &#x3D; 0;\nv5 &#x3D; 0;\n&#x2F;&#x2F; psTable[81]\nwhile (1) &#123;\n    if(pszIn[i] &gt; &#39;0&#39; &amp;&amp; pszIn[i] &lt;&#x3D; &#39;9&#39;)&#123;\n        if(j + pszIn[i] &#x3D;&#x3D; &#39;9&#39;)&#123;\n            j &#x3D; 0;\n            v5 +&#x3D; 9;\n        &#125;\n        else&#123;\n            return -1;\n        &#125;\n    &#125;\n    else&#123;\n        v7 &#x3D; v5;\n        if(v5 &gt;&#x3D; 81)\n            return 0;\n        \n        &#x2F;&#x2F; v7 &#x3D; pszIn[i]对应psTable[]中相同字符的下标\n        while(pszIn[i] !&#x3D; *(psTable+v7)) &#123;\n            if(++v7 &gt;&#x3D; 81)\n                return 0;\n        &#125;\n        \n        v9 &#x3D; v7 % 9 + 1;\n        if( v9 &#x3D;&#x3D; -1)\n            return 0;\n        *pcV10 &#x3D; v9; &#x2F;&#x2F; 重构输入\n        j++;\n        pcV10++;\n    &#125;\n    \n    if(++i &gt;&#x3D; nLen)\n        return 1;\n&#125;\n\n搞了一大堆，其中一个退出条件是，如果输入全都是9，就能return 1，但显然答案不是这个。\n相反，只要输入中没有1-9，v5就一直为0，这样就会根据输入字符在psTable中的相同字符的下标重构一个pcV10。\n比如 pszIn = &quot;$$V:$V&quot;，pcV10 = &#123;1, 1, 4, 5, 1, 4&#125;\n2 算flagfun1实际上就是检测是否符合数独情况。\n解出数独答案来，然后推出输出。\ntable &#x3D; [0x24, 0x42, 0x50, 0x56, 0x3A, 0x75, 0x62, 0x66, 0x59, 0x70, 0x7D, 0x5D, 0x44, 0x74, 0x4E, 0x3E, 0x61, 0x54, 0x5E, 0x4D, 0x47, 0x6D, 0x4A, 0x51, 0x23, 0x2A, 0x48, 0x72, 0x60, 0x4F, 0x27, 0x77, 0x6A, 0x69, 0x63, 0x30, 0x21, 0x68, 0x64, 0x79, 0x7B, 0x6F, 0x5A, 0x7A, 0x2D, 0x40, 0x6E, 0x2B, 0x3F, 0x26, 0x25, 0x73, 0x5F, 0x2F, 0x67, 0x3C, 0x65, 0x5B, 0x57, 0x29, 0x58, 0x55, 0x78, 0x52, 0x46, 0x53, 0x4C, 0x52, 0x41, 0x3B, 0x2E, 0x6C, 0x3D, 0x43, 0x45, 0x6B, 0x76, 0x4B, 0x2D, 0x28, 0x71]\n\no &#x3D; [[0, 4, 0, 7, 0, 0, 0, 0, 0],\n [9, 2, 0, 0, 0, 0, 6, 0, 7],\n [8, 3, 0, 0, 0, 5, 4, 0, 0],\n [0, 1, 0, 0, 0, 3, 0, 0, 0],\n [0, 0, 0, 2, 0, 1, 0, 0, 0],\n [0, 0, 0, 5, 0, 0, 0, 4, 0],\n [0, 0, 4, 9, 0, 0, 0, 7, 1],\n [3, 0, 5, 0, 0, 0, 0, 9, 4],\n [0, 0, 0, 0, 0, 8, 0, 6, 0]]\n\nr &#x3D; [[5, 4, 6, 7, 1, 9, 2, 3, 8],\n [9, 2, 1, 8, 3, 4, 6, 5, 7],\n [8, 3, 7, 6, 2, 5, 4, 1, 9],\n [7, 1, 8, 4, 6, 3, 9, 2, 5],\n [4, 5, 3, 2, 9, 1, 7, 8, 6],\n [6, 9, 2, 5, 8, 7, 1, 4, 3],\n [2, 8, 4, 9, 5, 6, 3, 7, 1],\n [3, 6, 5, 1, 7, 2, 8, 9, 4],\n [1, 7, 9, 3, 4, 8, 5, 6, 2]]\n\n# 1\nprint(&#39;#1&#39;)\nflag &#x3D; &#39;&#39;\nfor y in range(9):\n    j &#x3D; 0\n    for x in range(9):\n        if o[y][x] &#x3D;&#x3D; 0:\n            j +&#x3D; 1\n            flag +&#x3D; chr(table[r[y][x] - 1 + y * 9])\n    flag +&#x3D; chr(ord(&#39;9&#39;) - j)\nprint(flag)\n\n# 2\nprint(&#39;#2&#39;)\nflag &#x3D; &#39;&#39;\nj &#x3D; 0\nn9 &#x3D; 0\nfor y in range(9):\n    for x in range(9):\n        if o[y][x] &#x3D;&#x3D; 0:\n            j +&#x3D; 1\n            flag +&#x3D; chr(table[r[y][x] - 1 + n9 * 9])\n        if j &gt;&#x3D; 8:\n            flag +&#x3D; &#39;1&#39;\n            j &#x3D; 0\n            n9 +&#x3D; 1\nwhile n9 &lt; 9:\n    flag +&#x3D; chr(ord(&#39;9&#39;) - j)\n    j &#x3D; 0\n    n9 +&#x3D; 1\nprint(flag)\n\n第一个flag是正确的，第二个只能过输入转换fun2和数独检测fun1，而不能弹出窗口。\n:u$YBPf2pa]Dt4#QM^H4ic&#39;j0&#96;w2y&#123;d-Zzo2%&#x2F;n_s@+2&lt;UW)e4AR;F.4&#x3D;-qEkvC2\n:u$YBPf$1a]Dt&gt;N&#125;p1H#*mQHMJ1&#39;wO0icjj1-hzZ!dhz1&amp;%+%@sn_1gXxe[W&lt;299\n\n在VA之前有几个函数，这个函数会检测转换前的原始输入。如果原始输入不符合要求，将不能正确弹窗，（弹窗的代码依赖于正确的输入来生成，但前面的if检查并不严格，错误的原始输入产生了错误的代码）会报错0xc0000096然后崩溃。\n","slug":"21KctfSpring","date":"2021-06-02T12:43:07.000Z","categories_index":"CTF","tags_index":"ctf,re,wp","author_index":"御史神风"},{"id":"f95e71ca907bcbbc367beb658acddc27","title":"games101笔记","content":"games101-5\ngames 101 note\n","slug":"games101Note","date":"2021-05-24T14:12:26.000Z","categories_index":"ComputerGraphics","tags_index":"note,ComputerGraphics,持续更新","author_index":"御史神风"},{"id":"76983b1b7b5d8ab212f2ed6fe2f81e66","title":"CPP编写类库给其他语言使用的总结","content":"CPP编写类库给其他语言使用主要是使用vs2019作为ide，cpp为语言编写类库，然后编译成dll，供其他cpp、c#、python等语言的工程调用类库。目的是一次编写与编译某个类库，然后给多语言使用。\n这里是个傻瓜式操作总结贴（我总是忘记细节emm），总结网上及书里提供的一些方法，尽量用简单的方式实现目的。\n用cpp写类库（VS2019）类库项目配置直接新建空白项目，然后在项目属性页中进行如下配置：\n\n\n\n\n\n\n\n\n\n常规-常规属性-配置类型：动态库(.dll)\n代码框架下面给出项目的框架。直接编译就可以得到MyDll.dll\n&#x2F;*\n* 项目（MyDll）：头文件：MyDll.h\n*&#x2F;\n#pragma once\n#ifndef MYDLL_H\n#define MYDLL_H\n\n&#x2F;&#x2F; 这里是输出的函数\n_declspec(dllexport) int Add(int a, int b);\n\n&#x2F;&#x2F; 这里是输出的类\nclass _declspec(dllexport) MyClass\n&#123;\nprivate:\n    int a[2];\npublic:\n    MyClass();\n    ~MyClass();\n    int Set(int index, int x);\n&#125;\n\n#endif &#x2F;&#x2F; !MYDLL_H\n\n&#x2F;*\n* 项目（MyDll）：源文件：MyDll.cpp\n*&#x2F;\n#include &quot;MyDll.h&quot;\n\n&#x2F;&#x2F; 实现头文件中的函数\nint Add(int a, int b)\n&#123;\n    return a + b;\n&#125;\n\n&#x2F;&#x2F; 实现头文件中类的函数\nMyClass::MyClass()\n&#123;\n    a[0] &#x3D; 1;\n    a[1] &#x3D; 0;\n&#125;\n\nMyClass::~MyClass()\n&#123;\n&#125;\n\nint MyClass::Set(int index, int x)\n&#123;\n    a[index] &#x3D; x;\n    return a[0] + a[1];\n&#125;\n\n添加类库对应的共享项目这一步的目的主要是为了解决调用类库项目和类库项目 不在同一个解决方案的情况。\n在同一个解决方案中，新建一个共享项目项目，然后在解决方案资源管理器-共享项目上右键添加-添加现有项，找到MyDll.h、MyDll.cpp添加进去。\ncpp项目 调用 cpp写的类库（VS2019）方案一：隐式链接\n添加引用：在解决方案资源管理器中你的cpp项目的引用处右键选择添加引用\n\ncpp项目和dll项目在同一个解决方案：然后在弹出窗口的左侧菜单选择项目-解决方案，然后找到刚刚写好的dll项目，点击勾选框。\n两者不在同一个解决方案：先参考cpp写类库-配置共享项目配置好，然后在弹出窗口的左侧菜单选择共享的项目-解决方方案，找到dll项目对应的共享项目，点击勾选框。\n\n\n包含头文件：通过相对或绝对路径引用dll项目的头文件。\n\n\n方案二：显示链接没有需求，所以还没有测试这种方案这么处理比较方便。// todo\nC#（WPF）项目 调用 cpp写的类库（vs2019）我的情况是涉及一个大量使用指针的类。通过一个托管类把类的函数都暴露出来，实际上就是在托管类中做一个跳转，有时候还需要在这个跳转的函数中做c#和c++间的类型转换。\n流程大概是先写个托管类，然后再在wpf项目中导入。\n需要注意的是，Debug调试时，应该把 MyDll.dll 放到WPF的 /bin/Debug 目录中，原因是 MyDllCSWrapper.dll 需要导入 MyDll.dll。所以需要把 MyDll.dll 放到项目的可执行文件的根目录（当然系统目录啥的好像也行）。至于MyDllCSWrapper.dll放哪里都行，c#中ImportDll的路径填对就行。\n托管类首先参考“用cpp写类库”新建一个项目写托管。\n这里直接给出托管类代码框架，原型类参考前面“用cpp写类库”。\n这里MyDll.h中的Add不是类中的函数，我没有这个需求没有去研究，不确定该如何暴露，欢迎补充。// todo\n&#x2F;*\n* 项目（MyDllCSWrapper）：头文件：MyDllCSWrapper.h\n*&#x2F;\n#pragma once\n\n&#x2F;&#x2F; 这里通过相对或绝对路径引用MyDll的头文件\n#include &quot;..&#x2F;MyDll&#x2F;MyDll.h&quot;\n\nnamespace MyDllCSWrapper\n&#123;\n\textern &quot;C&quot; __declspec(dllexport) int Set(int index, int x);\n&#125;\n\n&#x2F;*\n* 项目（MyDllCSWrapper）：源文件：MyDllCSWrapper.cpp\n*&#x2F;\n#include &quot;MyDllCSWrapper.h&quot;\n\nnamespace MyDllCSWrapper\n&#123;\n\tMyClass* pmc &#x3D; new MyClass();\n\n\tint Set(int index, int x)\n\t&#123;\n\t\treturn ppe-&gt;Set(index, x);\n\t&#125;\n&#125;\n\n类型转换c++中的类型与c#不是完全对应的。int、double、float啥的好像是一一对应的，但指针就不一定了，要小心处理。\n我遇到的一个特殊情况就是我需要传递一个数组过去，c#中使用类型 char[]、ref char[] 只能传递第一个元素过去。需要使用 byte[] 才行。\n下面是我遇到一些的情况。\n\n\n\n\n\n\n\n\n\nc++类型 —- c# 类型\nunsigned int、unsigned long、DWORD —- uint\nchar*（数组）—- byte[]\nPython暂时没有需求，没有了解，可能下个星期就会需要。// todo\n","slug":"CppDllForOthers","date":"2021-04-22T17:05:59.000Z","categories_index":"Programing","tags_index":"dll,Programing,cpp","author_index":"御史神风"},{"id":"60af909abdc466137935eaab74c3cdbb","title":"21虎符CTF-RE-wp","content":"虎符 2021 REre1mips架构什么的，完全不了解，溜了\ngocrypt是个go语言程序\n里面有个encodeing_hex_Decode，作用是string转hex（”b0a0” =&gt; [0xa0, 0xb0]）第7个参数是dest第10个参数是source第11个参数是source的长度\n有个runtime_check会检查格式，推出格式是flag{hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh}\nmain_myCipher_Encrypt中有(a+(a&gt;&gt;5)&amp;(16*a))猜出加密方式是xtea\n解密脚本就不贴了，实际上异或的另一边是密钥，利用异或的可逆很快就能推出解密脚本\n在打极客时就有个想法，这种简单的re题核心都是推导加密函数的逆函数，不知道能不能写个逻辑分析程序一把梭。\nCrackMe运行什么提示都没，但还是搜字符串试试，rva=2A90，2AB0的两个函数似乎有点重要。\nmain里面有两次输入，判定两次。sub_1360这个函数ida似乎识别出了问题，不知道是不是bug。\n第一次输入后有两个循环，会把17个输入分成前7个和后10个\n第二次输入后有几个循环\n第一个循环是在求dx = 0.001，[0,100]，sub_1360(x, (v94/12379) + 1)*dx的积分 a\n然后int(2a+3) == 0x13AFA + 9 == 0x13B03 (sub_13A0中v7044+=9)\n第二个循环同样求和第一个差不多的积分 b，不过第二个参数变成了(v94%12379 + 1)\n然后int(2b+3) == 0x59D + 5 == 0x5A2 (sub_13A0中v7048+=5)\n爆破脚本\n#include&lt;math.h&gt;\n#include&lt;iostream&gt;\n#include&lt;stdio.h&gt;\nusing namespace std;\ninline double f(double a, double b)\n&#123;\n\tdouble tmp &#x3D; pow(a, b - 1.0);\n\tdouble ret &#x3D; tmp &#x2F; exp(a);\n\treturn ret;\n&#125;\n\nint main() &#123;\n\tdouble s &#x3D; 0.0;\n\tdouble x &#x3D; 0.0;\n\tint i;\n\n\tfor (i &#x3D; 0; i &lt; 12379; ++i) &#123;\n\t\tx &#x3D; 0.0;\n\t\ts &#x3D; 0.0;\n\t\tdo &#123;\n\t\t\ts +&#x3D; f(x, (double)i) * 0.001;\n\t\t\tx +&#x3D; + 0.001;\n\t\t&#125; while (x &lt;&#x3D; 100.0);\n\t\tint ans &#x3D; (int)(s + s + 3.0);\n\t\tif (ans &#x3D;&#x3D; 0x5a2) &#123; &#x2F;&#x2F; 0x59D + 5\n\t\t\tprintf(&quot;i &#x3D; %d, v95 &#x3D; %d\\n&quot;, i, i-1); &#x2F;&#x2F; i &#x3D; 7, v95 &#x3D; 6\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\tfor (i &#x3D; i - 1; ; i +&#x3D; 12379) &#123;\n\t\tx &#x3D; 0.0;\n\t\ts &#x3D; 0.0;\n\t\tdouble b &#x3D; (double)((int)i &#x2F; 12379) + 1.0;\n\t\tdo &#123;\n\t\t\ts +&#x3D; f(x, (double)b) * 0.001;\n\t\t\tx +&#x3D; +0.001;\n\t\t&#125; while (x &lt;&#x3D; 100.0);\n\t\tint ans &#x3D; (int)(s + s + 3);\n\t\tif (ans &#x3D;&#x3D; 0x13B03) &#123; &#x2F;&#x2F; 0x13AFA + 9\n\t\t\tprintf(&quot;v95 &#x3D; %d\\n&quot;, i); &#x2F;&#x2F; v95 &#x3D; 99038\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\n最后与第一次输入的内容处理后，得到flag\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main() &#123;\n\tint i;\n\n\tchar a[8] &#x3D; &quot;9903819&quot;;\n\tshort s1[7] &#x3D; &#123;0x8, 0x4d, 0x59, 0x06, 0x73, 0x02, 0x40&#125;;\n\tchar c[20] &#x3D; &#123; 0 &#125;;\n\tfor (i &#x3D; 0; i &lt; 7; i++)\n\t\tc[i] &#x3D; a[i] ^ s1[i];\n\n\tchar s2[10] &#x3D; &#123; 0xb2, 0xd6, 0x8e, 0x3f, 0xaa, 0x14, 0x53, 0x54, 0xc6, 0x06 &#125;;\n\tchar key[10] &#x3D; &#123; 0xe0, 0x95, 0xba, 0x60, 0xc9, 0x66, 0x2a, 0x24, 0xb2, 0x36 &#125;;\n\n\tfor (i &#x3D; 0; i &lt; 10; i++)\n\t\tc[i + 7] &#x3D; s2[i] ^ key[i];\n\n\tcout &lt;&lt; c &lt;&lt; endl;\n\n\treturn 0;\n&#125;\n\n","slug":"HufuCtfReWp","date":"2021-04-15T14:04:21.000Z","categories_index":"CTF","tags_index":"ctf,re,wp","author_index":"御史神风"},{"id":"672d33a00ecfe140728287608f94a579","title":"反射式dll注入源码笔记","content":"从反射注入学习pe文件加载前言？后记与总结这是我写完代码后写的总结。重新梳理一下反射注入到底想干什么、以及怎么干。以及从中学到了什么。\n收获？目标？反射注入是什么首先是学习反射注入的收获，当然也可以作为学习的目标，同时也是反射注入实际做的东西。\n我的理解是反射注入实际上就是手工加载模块。通过LoadLibrary加载dll会在peb中留下记录，通过手工实现加载过程，我们的dll能像正常dll那样工作，且不再peb中留下痕迹。\n也就是说，通过学习反射注入，可以了解到windows系统加载一个pe文件的流程。其中涉及到了部分的peb以及大量的pe结构。\n我们主要需要peb中的ldr结构，这个结构中保存了该进程已经加载了的dll。\n既然我们的主要工作是手工加载pe文件，自然要对pe文件格式有一定了解。但笔记中不会多提pe文件结构，实际上只要大概了解pe文件格是是个什么，然后在写代码时多去看pe结构的定义，就可以对pe文件结构有一个更深的理解。\n参考在学习过程中参考了许多资料，最主要的就是msf的反射注入payload的源码。其他如有不懂通过百度也可以找到详细的解释。相关文章比较多，dddd，就不一一列举了。\n关于这篇东西这篇东西由我阅读源码，查资料时做的笔记发展而来。国内虽然少但也有一些优秀的反射注入的文章，看雪中也有类似文章，但阅读门槛稍微有点高。因为是由笔记发展而来，这更像是一个零基础初学者的学习笔记（实际上在开始学反射注入之前，只知道pe文件格是是什么东西，几乎完全不了解。对windows的机制也完全不了解），希望能帮助到初学者，这项技术对我学习windows有很大帮助，虽然我只是一个初学者，但这项实践使我之后对书本、资料上的内容有了更深的了解。可能会有错误，希望发现错误的dalao可以帮帮我这个初学者纠正。\n前置要求va、fa、rva这几个概念搞清楚好像就行。实际上就是对pe文件如何从文件映射到内存有一个大体的认识。我们的工作就是具体完成这个过程。可以参考下图。\n\npe文件的格式网上有比较多的图片，这里就不贴了。\n流程(前置条件序号) 序号 流程内容\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n注入器：\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n(0)   1 打开dll文件(CreateFile)，获取dll长度(GetFileSize)\n(1)   2 分配内存(HealAlloc)，读取文件(ReadFile)\n(0)   3 打开目标进程(OpenProcess)\n(2,3) 4 调用反射注入函数(LoadLibraryR.c&gt;LoadRemoteLibraryR)\n(2)   5 获取反射加载函数的文件偏移(LoadLibraryR.c&gt;GetReflectiveLoaderOffset)\n(2,3) 6 在目标进程中分配空间(VirtualAllocEx)，写入dll(WriteProcessMemory)\n(6)   7 修改目标进程中的空间为可执行(VirtualProtectEx)\n(5,7) 8 创建远程线程，执行反射加载函数(CreateRemoteThread)\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n反射加载函数（运行在被注入进程的新建线程中）：\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n1 获取基地址\n2 获取需要的kernel32.dll及ntdll.dll的函数的va\n3 分配空间作为映像空间，并复制pe头到新的位置\n4 复制所有段到映像的对应位置\n5 处理导入表，填写iat\n6 重定位\n7 跳转到ep（_DllMainCRTStartup）\n8 返回entry point地址\n\n注入器主要流程首先打开dll文件，获取长度，并在堆中分配空间读取文件。\nhFile &#x3D; CreateFileW(dllPathname, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\ndwDllLen &#x3D; GetFileSize(hFile, 0);\nlpDll &#x3D; HeapAlloc(GetProcessHeap(), 0, dwDllLen);\n\n然后找到dll中ReflectiveLoader的入口点。\n最后以RW申请空间，写入dll后改成RX，然后以ReflectiveLoader作为线程函数创建远程线程。\n计算faLoadLibraryR中有个函数Rva2Offset用于获取rva对应的fa。\n原理是遍历区块获取区块的section_rva和section_fa，然后比较rva和section_rva找到rva所在的section，最后计算出fa。再用fa+baseAddr得到内存中的位置。\nDWORD Rva2Fa(DWORD rva, PIMAGE_SECTION_HEADER sections, int sectionNum)\n&#123;\n    for (int i &#x3D; 0; i &lt; sectionNum; i++) &#123;\n        int sectionVa &#x3D; sections[i].VirtualAddress;\n        if ((rva &gt;&#x3D; sectionVa) &amp;&amp; ((sectionVa + sections[i].SizeOfRawData) &gt; rva))\n            return rva - (sectionVa - sections[i].PointerToRawData);\n    &#125;\n\n    return 0;\n&#125;\n\n获取ReflectivelLoader位置（输出表）通过nt头，计算出sections的fa，以及通过nt头的optionalheader获取输出表的rva。\n然后遍历section找到输出表的fa，接着遍历输出表的函数名字rva表，计算出rva对应fa得到导出函数名字，与需要的导出函数做对比，确定要找的函数在函数名表中的下标。用此下标在序号表中找到序号，最后再用序号去地址表找到地址。\n反射加载函数1. 获取基址首先获取代码的位置，然后再往前找dos头。\n_ReturnAddress()返回当前调用函数的返回地址。所以在loader中调用一个函数，该函数再调用_ReturnAddress()，返回调用函数的返回地址，即loader中调用函数的下一条语句的地址。其中 __declspec(noinline) 用于防止编译器优化该函数成内联函数，否则返回的就是loader的返回地址。\n使用_ReturnAddress需要intrin.h，并使用#pragma intrinsic防止内联优化。\n#include&lt;intrin.h&gt;\n#pragma intrinsic(_ReturnAddress)\n__declspec(noinline) PVOID NextAddr()\n&#123;\n\treturn (PVOID)_ReturnAddress();\n&#125;\n\n根据pe格式可知，dos头(IMAGE_DOS_HEADER)中有有一个e_magic标志，值是0x5A4D(MZ)。所以向前遍历内存，直到找到MZ标志，再检查pe头的PE标志，这样就找到dos头了。需要注意的是，检查PE标志时要检查pe头偏移是否正确，防止错误的内存访问。\nwhile (TRUE) &#123;\n    if (dosHeadAddr-&gt;e_magic &#x3D;&#x3D; 0x5A4D) &#123;\n        LONG e_lfanew &#x3D; dosHeadAddr-&gt;e_lfanew;\n        if (e_lfanew &gt;&#x3D; sizeof(IMAGE_DOS_HEADER) &amp;&amp; e_lfanew &lt; 1024) &#123;\n            ntHeadAddr &#x3D; (PIMAGE_NT_HEADERS)((PVOID)dosHeadAddr + (PVOID)e_lfanew);\n            if (ntHeadAddr-&gt;Signature &#x3D;&#x3D; 0x4550)\n                break;\n        &#125;\n    &#125;\n    dosHeadAddr--;\n&#125;\n\n这里也可以取巧，远程线程是可以传递一个参数的，对于我们这个简单的dll，imagebase实际上就是分配空间的首地址，可以作为参数传入。\n2. 获取需要的内核导出函数的va目标接下来的步骤中需要用到一些ntdll.dll，kernel32.dll中的导出函数，所以需要先找到这些函数的va。这些系统模块都是已经加载了的，可以在peb中找到其加载的位置。\n这里利用hash避免直接比较字符串。\n我们需要LoadLibraryA、GetProcAddress加载导入表中的dll的对应的函数。\n需要VirtualAlloc分配内存给我们把pe文件加载到其中。\n需要NtFlushInstructionCache刷新指令缓存。\nLDR_DATA_TABLE_ENTRYInMemoryOrderModuleList对应的链表是一个环形双向链表，且有一个头节点（或者说哨兵节点）。InMemoryOrderModuleList的Flink指向链表的第一个节点，Blink指向链表最后一个节点。头节点的Flink是第一个节点，可以以此为跳出条件遍历该链表。\n\n思路首先从peb中找到ldr，然后遍历InMemoryOrderModuleList，通过hash(BaseName)找到kernel32.dll和ntdll.dll对应的LDR_DATA_TABLE_ENTRY结构。\n找到dll对应的LDR_DATA_TABLE_ENTRY后，获取其imagebase，然后解析pe头，计算出导出表位置。同样利用hash比较字符串找到所需的导出函数，并计算出va。\n实现代码&#x2F;&#x2F; 找pLdrDataTableEnrty\nDWORD pPeb &#x3D; __readfsdword(0x30);\nDWORD pLdr &#x3D; *(DWORD*)(pPeb + 0xc);\nDWORD pInMemoryOrderModuleList &#x3D; pLdr + 0x14; &#x2F;&#x2F; 第一个节点的二级指针\nDWORD pLdrDataTableEnrty &#x3D; *(DWORD*)(pInMemoryOrderModuleList + 0);\n&#x2F;&#x2F; 遍历LdrDataTableEnrty\ndo&#123;\n\tWCHAR* name &#x3D; (WCHAR*)*(DWORD*)(pLdrDataTableEnrty + 0x24 + 0x4);\n\thash &#x3D; YourHashFun(name); &#x2F;&#x2F; 使用你自己的函数计算hash值\n\tif(hash &#x3D;&#x3D; DLLHASH) &#123; &#x2F;&#x2F; DLLHASH由你自己的函数计算得出\n\t\tDWORD baseAddr &#x3D; *(DWORD*)(pLdrDataTableEnrty + 0x10);\n\t\t&#x2F;&#x2F; 解析pe头过程省略\n\t\tfor(int i &#x3D; 0; i &lt; funcNum; i++) &#123; &#x2F;&#x2F; funcNum是导出函数的个数\n\t\t\tchar* name &#x3D; (char*)(baseAddr + ((DWORD*)nameRvas)[i]);\n\t\t\tDWORD hash &#x3D; YourHashFun(name);\n\t\t\tif (hash &#x3D;&#x3D; FUNCHASH) &#123;\n\t\t\t\tpFunc &#x3D; (FUNC)(baseAddr + ((DWORD*)funcRvas)[((WORD*)ordRvas)[i]]);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;while(*(DWORD*)(pLdrDataTableEnrty) !&#x3D; *(DWORD*)(pInMemoryOrderModuleList))\n\n3. 给映像分配空间，并加载pe头新分配大小等于sizeOfImga的内存作为映像加载的空间，然后把pe头复制到新内存里，这里我只更新了新nt头的imagebase地址。太简单就不贴代码了。\n4. 加载段遍历section_header获取fa和rva，计算出section在旧内存中的va和新内存中的va。然后复制section到新内存中的对应位置。\noldVA &#x3D; oldImageBase + sections[i].PointerToRawData;\nnewVA &#x3D; newImageBase + sections[i].VirtualAddress; \n\n5. 处理导入表目标找到导入表，然后遍历导入表，依次加载对应的dll，及需要的dll的导出函数，并填写对应iat。\n导入表结构&#x2F;&#x2F; winnt.h\ntypedef struct _IMAGE_THUNK_DATA32 &#123;\n    union &#123;\n        DWORD ForwarderString;      &#x2F;&#x2F; PBYTE \n        DWORD Function;             &#x2F;&#x2F; PDWORD\n        DWORD Ordinal;\n        DWORD AddressOfData;        &#x2F;&#x2F; PIMAGE_IMPORT_BY_NAME (补充一下，这是个rva)\n    &#125; u1;\n&#125; IMAGE_THUNK_DATA32;\ntypedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;\n\ntypedef struct _IMAGE_IMPORT_BY_NAME &#123;\n    WORD    Hint;\n    CHAR   Name[1];\n&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;\n\n和导出表不同，导入表是一个结构体数组。它不提供结构体数量，最后一个结构体仅作为结束标志，不包含导入信息，其成员Characteristics为0，这可以作为遍历的退出条件。\n对于每个导入表，在文件中时OriginalFirstThunk和FirstThunk都是RVA，指向同一个IMAGE_THUNK_DATA结构体数组。当加载到内存时，FirstThunk改为函数的VA，即iat。\n文件中时，OriginalFirstThunk和FirstThunk指向的结构体数组中，每一个IMAGE_THUNK_DATA的成员u1都被解释为Ordinal，若该函数应该通过序号导入，则Ordinal的最高位会被置为1。\n思路见实现代码注释。\n实现代码PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pNewDosHeader + pNewNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\n\nfor (; pImportDescriptor-&gt;Characteristics; pImportDes++) &#123;\n    &#x2F;&#x2F; 加载dll\n    HMODULE libraryAddress &#x3D; pLoadLibraryA((LPCSTR)((DWORD)pNewDosHeader + pImportDes-&gt;Name));\n    if (!libraryAddress)\n            continue;\n    \n    &#x2F;&#x2F; parsing pe structure\n    PIMAGE_THUNK_DATA32 pOriginalThunk &#x3D; (PIMAGE_THUNK_DATA32)((DWORD)pNewDosHeader + pImportDes-&gt;OriginalFirstThunk);\n    PIMAGE_THUNK_DATA32 pThunk &#x3D; (PIMAGE_THUNK_DATA32)((DWORD)pNewDosHeader + pImportDes-&gt;FirstThunk);\n    PIMAGE_NT_HEADERS32 pLibNtHeader &#x3D; (PIMAGE_NT_HEADERS32)((DWORD)libraryAddress + ((PIMAGE_DOS_HEADER)libraryAddress)-&gt;e_lfanew);\n    PIMAGE_EXPORT_DIRECTORY pExportDir &#x3D; (PIMAGE_EXPORT_DIRECTORY)((DWORD)libraryAddress + pLibNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n    PDWORD funcRvas &#x3D; (PDWORD)((DWORD)libraryAddress + pExportDir-&gt;AddressOfFunctions);\n\t\n    while (*(DWORD*)pThunk) &#123;\n        if (pOriginalThunk &amp;&amp; pOriginalThunk-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG) &#123;\n            &#x2F;&#x2F; import by ord\n            WORD ord &#x3D; pOriginalThunk-&gt;u1.Ordinal - pExportDir-&gt;Base;\n            *(DWORD*)pThunk &#x3D; ((DWORD)libraryAddress + funcRvas[ord]);\n        &#125;\n        else &#123;\n            &#x2F;&#x2F; import by name (this is a rva)\n            *(DWORD*)pThunk &#x3D; (DWORD)pGetProcAddress(libraryAddress, ((PIMAGE_IMPORT_BY_NAME)((DWORD)pNewDosHeader + pThunk-&gt;u1.AddressOfData))-&gt;Name);\n        &#125;\n\n        pThunk++;\n        if (pOriginalThunk)\n            pOriginalThunk++;\n    &#125;\n&#125;\n\n6. 重定位目标完成重定位过程。\n重定位表结构重定位表是一个结构体数组，DataDirectory中的重定位表项保存着第一个重定位表的rva，遍历每一个重定位表，并遍历重定位表中的表项，根据其重定位类型，执行重定位操作。\ntypedef struct &#123;\n    WORD offset : 12;\n    WORD type : 4;\n&#125; RELOC;\ntypedef struct &#123;\n\tDWORD VA;\n\tDWORD size;\n\t&#x2F;&#x2F; RELOC reloc[];\n&#125; IMAGE_BASE_RELOCATION;\n\n其中每一个重定位表保存着一个rva，重定位实际上就是遍历IMAGE_BASE_RELOCATION的成员reloc，然后执行*(rva+baseAddr+reloc[i].offset) += baseAddr - ImageBase。\n思路两层循环，遍历重定位表，再遍历每个表的 RELOC reloc[]。然后根据重定位类型进行重定位。\n实现代码&#x2F;&#x2F; 解析pe，并计算offset\nPIMAGE_DATA_DIRECTORY pDDBaseReloc &#x3D; &amp;pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];\nPIMAGE_BASE_RELOCATION pBaseRelocation;\nULONG_PTR offset &#x3D; (ULONG_PTR)pNewDosHeader - (ULONG_PTR)pNtHeaders-&gt;OptionalHeader.ImageBase;\n\nif (pDDBaseReloc-&gt;Size) &#123;\n    DWORD size &#x3D; pDDBaseReloc-&gt;Size;\n    pBaseRelocation &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pNewDosHeader + pDDBaseReloc-&gt;VirtualAddress);\n\t\n    &#x2F;&#x2F; 遍历重定位表结构体\n    while (size &amp;&amp; pBaseRelocation-&gt;SizeOfBlock) &#123;\n\n        DWORD va &#x3D; (DWORD)pNewDosHeader + pBaseRelocation-&gt;VirtualAddress;\n        DWORD num &#x3D; (pBaseRelocation-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) &#x2F; sizeof(IMAGE_RELOC); &#x2F;&#x2F; 计算reloc[]大小\n        PIMAGE_RELOC reloc &#x3D; (PIMAGE_RELOC)((DWORD)pBaseRelocation + sizeof(IMAGE_BASE_RELOCATION));\n\t\t\n        &#x2F;&#x2F; 遍历reloc[]，根据重定位类型重定位\n        while (num--) &#123;\n            DWORD type &#x3D; reloc-&gt;type;\n            if (type &#x3D;&#x3D; IMAGE_REL_BASED_HIGH) &#123;\n                *(WORD*)(va + reloc-&gt;offset) +&#x3D; HIWORD(offset);\n            &#125;\n            else if (type &#x3D;&#x3D; IMAGE_REL_BASED_LOW) &#123;\n                *(WORD*)(va + reloc-&gt;offset) +&#x3D; LOWORD(offset);\n            &#125;\n            else if (type &#x3D;&#x3D; IMAGE_REL_BASED_HIGHLOW) &#123;\n                *(DWORD*)(va + reloc-&gt;offset) +&#x3D; (DWORD)offset;\n            &#125;\n\n            reloc++;\n        &#125;\n\n        size -&#x3D; pBaseRelocation-&gt;SizeOfBlock;\n        pBaseRelocation &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pBaseRelocation + pBaseRelocation-&gt;SizeOfBlock);\n    &#125;\n&#125;\n\n7. 跳转到ep跳转到dll的ep。实际上就是执行dll原本的_DllMainCRTStartup函数。该函数会完成一些初始化工作并转到dllMain，让我们的dllMain像正常dllmain那样运行，但又不在peb中留下dll加载的痕迹。\ntypedef BOOL(WINAPI* DLLMAIN)(HINSTANCE, DWORD, LPVOID);\n\nPVOID entryPoint &#x3D; (PVOID)((DWORD)pNewDosHeader + pNewNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);\n\npNtFlushInstructionCache((HANDLE)-1, NULL, 0);\n\n((DLLMAIN)entryPoint)((HMODULE)pNewDosHeader, DLL_PROCESS_ATTACH, lpParameter);\n\n8. 返回最后返回entrypoint。\n参考本文看雪链接：https://bbs.pediy.com/thread-266929.htm\nmsf反射注入源码：https://github.com/rapid7/ReflectiveDLLInjection\n","slug":"reflectiveDllInjection","date":"2021-04-11T10:31:55.000Z","categories_index":"Windows","tags_index":"windows,dll,note","author_index":"御史神风"},{"id":"bc0ff34ebb27f27dad44c564d61b2fb3","title":"hgame21","content":"web week1智商检测鸡（150）我用的python requests+beautifulsoup。\n这题是通过cookie当作账号，做出一题就会给出下一个cookie。\nimport requests\nfrom bs4 import BeautifulSoup\nimport requests\n\ngetQ &#x3D; &#39;http:&#x2F;&#x2F;r4u.top:5000&#x2F;api&#x2F;getQuestion&#39;\ngetS &#x3D; &#39;http:&#x2F;&#x2F;r4u.top:5000&#x2F;api&#x2F;getStatus&#39;\nsubmit &#x3D; &#39;http:&#x2F;&#x2F;r4u.top:5000&#x2F;api&#x2F;verify&#39;\ngetF &#x3D; &#39;http:&#x2F;&#x2F;r4u.top:5000&#x2F;api&#x2F;getFlag&#39;\n\nres &#x3D; requests.get(url&#x3D;getQ)\nheader &#x3D; &#123;&#39;Cookie&#39;: res.headers[&#39;Set-Cookie&#39;]&#125;\n\ndef f(x):\n    return c&#x2F;2*x*x + d*x\n\nfor i in range(100):\n    # 获取\n    res &#x3D; requests.get(url&#x3D;getQ, headers&#x3D;header)\n    bs &#x3D; BeautifulSoup(res.text, &#39;html.parser&#39;)\n    a &#x3D; int(bs.msubsup.contents[1].mn.text)\n    if(bs.msubsup.contents[1].mo !&#x3D; None):\n        if(bs.msubsup.contents[1].mo.text &#x3D;&#x3D; &#39;-&#39;):\n            a &#x3D; -a\n    b &#x3D; int(bs.msubsup.contents[2].mn.text)\n    if(bs.msubsup.contents[2].mo !&#x3D; None):\n        if(bs.msubsup.contents[2].mo.text &#x3D;&#x3D; &#39;-&#39;):\n            b &#x3D; -b\n    c &#x3D; int(bs.mrow.contents[2].text)\n    d &#x3D; int(bs.mrow.contents[5].text)\n    # 计算\n    ans &#x3D; round(f(b)-f(a), 2)\n    # 返回\n    res2 &#x3D; requests.post(url&#x3D;submit, headers&#x3D;header, json&#x3D;&#123;&#39;answer&#39;:ans&#125;)\n    print(res2.headers[&#39;Set-Cookie&#39;])\n    header &#x3D; &#123;&#39;Cookie&#39;: res2.headers[&#39;Set-Cookie&#39;]&#125;\n    # 检查\n    res &#x3D; requests.get(url&#x3D;getS, headers&#x3D;header)\n    print(res.text)\n\nres &#x3D; requests.get(url&#x3D;getF, headers&#x3D;header)\nprint(res.text)\n\nmisc week1Base全家福（50）base64+base32+base16\npwn week1whitegive（50）if(num == “paSsw0rd”)\nida中找到if语句中的字符串地址即可。\nre week1apacha（150）一个比较复杂的推理。需要注意的是，变量要用unsigned int。\nunsigned int new_a1[35] &#x3D; &#123;&#125;; &#x2F;&#x2F; dump\nfor (i &#x3D; 6; i &gt;&#x3D; 0; i--) &#123;\n    unsigned int l, r;\n\n    v6 &#x3D; v6s[i];\n    v7 &#x3D; v6 &gt;&gt; 2;\n\n    &#x2F;&#x2F; 最后一个\n    v5 &#x3D; new_a1[a2 - 2];\n    result &#x3D; (v5 * 16) ^ (new_a1[0] &gt;&gt; 3);\n    l &#x3D; (a3[((a2 - 1) ^ (unsigned __int8)v7) &amp; 3] ^ v5) + (new_a1[0] ^ v6);\n    r &#x3D; ((4 * new_a1[0]) ^ (v5 &gt;&gt; 5)) + result;\n    old_a1[a2 - 1] &#x3D; new_a1[a2 - 1] - (l ^ r);\n\n    for (j &#x3D; a2 - 2; j &gt;&#x3D; 0; j--) &#123; &#x2F;&#x2F; j &#x3D; v8\n\n        if (j &gt; 0) &#123;\n            v5 &#x3D; new_a1[j - 1];\n        &#125;\n        else &#123;\n            v5 &#x3D; old_a1[a2 - 1];\n        &#125;\n\n        l &#x3D; ((v5 &gt;&gt; 5) ^ (4 * old_a1[j + 1])) + ((16 * v5) ^ (old_a1[j + 1] &gt;&gt; 3));\n        r &#x3D; (a3[(((unsigned __int8)j ^ (unsigned __int8)v7) &amp; 3)] ^ v5) + ((old_a1[j + 1]) ^ (v6));\n        f &#x3D; l ^ r;\n        old_a1[j] &#x3D; new_a1[j] - f;\n    &#125;\n    for (j &#x3D; 0; j &lt; 35; j++)\n        new_a1[j] &#x3D; old_a1[j];\n\nhellowRe（150）一个异或。\na &#x3D; [0x97, 0x99, 0x9C, 0x91, 0x9E, 0x81, 0x91, 0x9D, 0x9B, 0x9A, 0x9A,0xAB, 0x81, 0x97, 0x0AE, 0x80, 0x83, 0x8F, 0x94, 0x89, 0x99,0x97, 0x0, 0x0]\n\nb &#x3D; 0xff\nc &#x3D; []\nfor i in range(24):\n    c.append(a[i] ^ b)\n    b -&#x3D; 1\n\npypy（150）python字节码转python代码。一个交换和异或。\nfrom Crypto.Util.number import long_to_bytes\n\nflag &#x3D; 0x30466633346f59213b4139794520572b45514d61583151576638643a\ncipher &#x3D; long_to_bytes(flag)\nlength &#x3D; len(cipher)\n\ndef f(x):\n    cipher &#x3D; list(x)\n    for i in range(length&#x2F;&#x2F;2):\n        cipher[i*2], cipher[2*i+1] &#x3D; cipher[i*2+1], cipher[2*i]\n\n    res &#x3D; []\n    for i in range(length):\n        res.append(cipher[i] ^ i)\n    return bytes(res)\n\ndef re(cipher):\n    res &#x3D; list(cipher)\n    for i in range(length):\n        res[i] ^&#x3D; i\n\n    for i in range(length&#x2F;&#x2F;2):\n        res[i*2], res[2*i+1] &#x3D; res[i*2+1], res[2*i]\n    \n    return bytes(res)\n\nprint(re(flag))\n\nre week2ezApk找到位置后，看不太懂，是aes cbc加密。\nhelloRe2sse2指令sse2指令集是个扩展指令集。cpp中需要include &lt;emmintrin.h&gt;。\n_mm_load_si128：加载128bits值，vs中试了以下相当于把字符串直接转数字。\n_mm_cmpeq_epi8：判断是否相等\n_mm_movemask_epi8：没查\nflag1cmp(load(flag1), flag)\nida中flag = 0x981b02a3a6e5c0b2\n所以flag1(input)是”2b0c5e6a3a20b189”\nflag2flag1正确后会异或一次然后重启程序，接着进入输入flag2的分支。\nBCrypt解密没看懂。后面补了AES的CBC和ECB才看懂。\n复现主函数及BCrypt.h的使用要先include windows.h再include BCrypt.h\nhttps://docs.microsoft.com/en-us/windows/win32/seccng/cng-algorithm-identifiers\nNTSTATUS BCryptGenerateSymmetricKey(\n  BCRYPT_ALG_HANDLE hAlgorithm,  &#x2F;&#x2F; handle of algorithm\n  BCRYPT_KEY_HANDLE *phKey,      &#x2F;&#x2F; recive handle of key\n  PUCHAR            pbKeyObject, &#x2F;&#x2F; recive key object\n  ULONG             cbKeyObject, &#x2F;&#x2F; sizeof(pbKeyObject)\n  PUCHAR            pbSecret,    &#x2F;&#x2F; pt a key witch to creat key\n  ULONG             cbSecret,    &#x2F;&#x2F; sizeof(pbSecret)\n  ULONG             dwFlags\n);\n\n找到关键的参数如下。c实际上有32位，这里只得到16位，上网找脚本破解。\ns &#x3D; [0x32, 0x63, 0x32, 0x60, 0x31, 0x60, 0x30, 0x66, 0x3b, 0x68, 0x38, 0x3b, 0x6e, 0x3c, 0x36, 0x36]\n# 32633260316030663b68383b6e3c3636\niv &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd ,0xe ,0xf]\n# 000102030405060708090a0b0c0d0e0f\nc &#x3D; [0xB7, 0xFE, 0xFE, 0xD9, 7, 0x76, 0x79, 0x65, 0x3F, 0x4E, 0x5F, 0x62, 0xD5, 2, 0xF6, 0x7E]\n# b7fefed9077679653f4e5f62d502f67e\nm &#x3D; &#39;7a4ad6c5671fb313&#39;\nflag &#x3D; &#39;hgame&#123;2b0c5e6a3a20b189\n_7a4ad6c5671fb313&#125;&#39;\n\n复现了一下他的代码。这里解密失败了，不知道是什么原因。\nBCRYPT_HANDLE name;\nDWORD objLen &#x3D; 0, blockLength &#x3D; 0;\nunsigned long btw &#x3D; 0, nts &#x3D; 0;\nwchar_t mode[16] &#x3D; L&quot;ChainingModeCBC&quot;;\nBCRYPT_KEY_HANDLE hKey;\nUCHAR pKey[618] &#x3D; &#123; 0 &#125;, pbSecret[16] &#x3D; &#123; 0x32, 0x63, 0x32, 0x60, 0x31, 0x60, 0x30, 0x66, 0x3b, 0x68, 0x38, 0x3b, 0x6e, 0x3c, 0x36, 0x36 &#125;, pKeyBLOB[560] &#x3D; &#123; 0 &#125;;\nUCHAR pIV[16] &#x3D; &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf &#125;;\n\nname &#x3D; 0;\n\n__try &#123;\n    &#x2F;&#x2F; 初始化\n    nts &#x3D; BCryptOpenAlgorithmProvider(&amp;name, L&quot;AES&quot;, 0, 0);\n    if ((nts &lt; 0) || name &#x3D;&#x3D; 0) &#123;\n        cout &lt;&lt; nts &lt;&lt; endl;\n        __leave;\n    &#125;\n\n    &#x2F;&#x2F; 获取属性值\n    nts &#x3D; BCryptGetProperty(name, L&quot;ObjectLength&quot;, (PUCHAR)&amp;objLen, 4, &amp;btw, 0);\n    cout &lt;&lt; &quot;ObjectLength(&quot; &lt;&lt; btw &lt;&lt; &quot;): &quot; &lt;&lt; objLen &lt;&lt; endl; &#x2F;&#x2F; 618\n\n    nts &#x3D; BCryptGetProperty(name, L&quot;BlockLength&quot;, (PUCHAR)&amp;blockLength, 4, &amp;btw, 0);\n    cout &lt;&lt; &quot;BlockLength(&quot; &lt;&lt; btw &lt;&lt; &quot;): &quot; &lt;&lt; blockLength &lt;&lt; endl; &#x2F;&#x2F; 16\n\n    if (blockLength &lt;&#x3D; 16) &#123;\n        &#x2F;&#x2F; 设置模式为CBC\n        nts &#x3D; BCryptSetProperty(name, L&quot;ChainingMode&quot;, (PUCHAR)mode, 0x20, 0);\n\n        &#x2F;&#x2F; 生成密钥对象\n        nts &#x3D; BCryptGenerateSymmetricKey(name, &amp;hKey, pKey, objLen, pbSecret, 16, 0);\n\n        &#x2F;&#x2F; 获取key BLOB长度\n        &#x2F;nts &#x3D; BCryptExportKey(hKey, 0, L&quot;OpaqueKeyBlob&quot;, 0, 0, &amp;btw, 0);\n        cout &lt;&lt; &quot;keyBLOBLen: &quot; &lt;&lt; btw &lt;&lt; endl; &#x2F;&#x2F; 560\n        &#x2F;&#x2F; 接收key BLOB\n        nts &#x3D; BCryptExportKey(hKey, 0, L&quot;OpaqueKeyBlob&quot;, pKeyBLOB, 560, &amp;btw, 0);\n\n        &#x2F;&#x2F; 获取密文长度\n        nts &#x3D; BCryptEncrypt(hKey, inputs, 16, 0, pIV, 16, 0, 0, &amp;btw, BCRYPT_BLOCK_PADDING);\n        cout &lt;&lt; &quot;ciphertextLen: &quot; &lt;&lt; btw &lt;&lt; endl; &#x2F;&#x2F; 32\n        &#x2F;&#x2F; 加密\n        nts &#x3D; BCryptEncrypt(hKey, inputs, 16, 0, pIV, 16, c, 32, &amp;btw, BCRYPT_BLOCK_PADDING);\n\n        &#x2F;&#x2F; 解密\n        nts &#x3D; BCryptDecrypt(hKey, c, 32, 0, pIV, 16, m, 16, &amp;btw, BCRYPT_BLOCK_PADDING);\n        cout &lt;&lt; btw &lt;&lt; endl;\n        cout &lt;&lt; m &lt;&lt; endl;\n    &#125;\n&#125;\n__finally &#123;\n\n&#125;\n\n","slug":"hgame21","date":"2021-03-17T12:51:25.000Z","categories_index":"CTF","tags_index":"ctf,re,pwn,misc,wp,web","author_index":"御史神风"},{"id":"7b6a6ddcdac946174aca4612b4f02cc3","title":"vnctf21ReWp","content":"notsudoku这题是python打包的exe\n首先用pyinstxtractor解包\n.\\pyinstxtractor.py:86: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module&#39;s documentation for alternative uses\n  import imp\n[*] Processing .\\notsudoku.exe\n[*] Pyinstaller version: 2.1+\n[*] Python version: 37\n[*] Length of package: 5560832 bytes\n[*] Found 60 files in CArchive\n[*] Beginning extraction...please standby\n[+] Possible entry point: pyiboot01_bootstrap\n[+] Possible entry point: 2\n[*] Found 133 files in PYZ archive\n[*] Successfully extracted pyinstaller archive: .\\notsudoku.exe\n\nYou can now use a python decompiler on the pyc files within the extracted directory\n\n得到主要代码在文件 2 ，把这个文件改名为2.pyc，并复制struct文件的E3前面的内容，然后粘贴到2.pyc的E3前面。接着用uncompyle6反编译成py文件。\n最后改一下变量名，得到的是要解一个五阶幻方。本来有多组解，因为有个校验所以只有唯一解。\nimport time, sys, hashlib\n\nnum &#x3D; 65\n\n# 124 126\nprint(&#39;welcome baby~ input your flag~:&#39;, end&#x3D;&#39;&#39;)\n\n# 128\nstr1 &#x3D; input()\n\n# 130 132\nprint(&#39;your input is:&#39;, end&#x3D;&#39;&#39;)\nprint(str1)\n\n# 134\nprint(&quot;let&#39;s check......&quot;, end&#x3D;&#39;&#39;)\n\n# 136\ntime.sleep(0.5)\n\n# 138 ~ 146\nlist2 &#x3D; []\nlist2 +&#x3D; [[0 for i in range(5)]]\nlist2 +&#x3D; [[0 for i in range(5)]]\nlist2 +&#x3D; [[0 for i in range(5)]]\nlist2 +&#x3D; [[0 for i in range(5)]]\nlist2 +&#x3D; [[0 for i in range(5)]]\n\n# 148\nif len(str1) % 2 !&#x3D; 0:\n    sys.exit()\nfor i in str1:\n    if ord(i) &gt; 52 or ord(i) &lt; 48: # [0, 4]\n        sys.exit()\n\nx &#x3D; str(hashlib.new(&#39;md5&#39;, bytes((str1), encoding&#x3D;&#39;utf8&#39;)).hexdigest())\nif x[:6] !&#x3D; &#39;e3a912&#39;:\n    sys.exit()\nflag &#x3D; x\n\n# 150\nj &#x3D; 0\na &#x3D; 0\nb &#x3D; 0\nfor i in range(0, len(str1), 2):\n    j +&#x3D; 1\n    a &#x3D; int(str1[i])\n    b &#x3D; int(str1[(i + 1)])\n    list2[a][b] &#x3D; j\n\n# 152\nif list2[0][1] !&#x3D; 24 or list2[4][3] !&#x3D; 2:\n    sys.exit()\nif list2[0][2] !&#x3D; 1 or list2[2][3] !&#x3D; 20:\n    sys.exit()\nif list2[1][0] !&#x3D; 23 or list2[3][4] !&#x3D; 3:\n    sys.exit()\n\n# 154 ~ 162\nfor a in range(0, 5):\n    tnum &#x3D; 0\n    a &#x3D; 0\n    for i in range(5):\n        tnum +&#x3D; cla.list2[a][i]\n\n    if tnum !&#x3D; num:\n        sys.exit()\n\n# 164 ~ 172\nfor b in range(0, 5):\n    tnum &#x3D; 0\n    for i in range(5):\n        tnum +&#x3D; list2[i][b]\n\n    if tnum !&#x3D; num:\n        sys.exit()\n\n# 174 ~ 180\nprint(&#39;Goodjob!&#39;, end&#x3D;&#39;&#39;)\nprint(&#39;The flag is vnctf&#123;&#39;, end&#x3D;&#39;&#39;)\nprint(flag, end&#x3D;&#39;&#39;)\nprint(&#39;&#125;&#39;, end&#x3D;&#39;&#39;)\n\n#182\nsys.exit()\n\nFlipGameida中看到主函数中，有一个16x16的位数组，先是把16进制转10进制，然后翻转上下左右中间。\n解法是暴力搜索第一行的情况，接着对于第i+1行，如果第i行对应位置为0，就在第i+1行的那一位执行翻转操作。这样就能得到解。\n代码的话搜索poj 3279即可，是个noip题目。\n","slug":"vnctf21ReWp","date":"2021-03-17T11:03:13.000Z","categories_index":"CTF","tags_index":"ctf,re,wp","author_index":"御史神风"},{"id":"8974ac6b1252ccb40492ca6fb37e2ab1","title":"远程线程注入逆向","content":"远程线程注入逆向资料MSDN中的函数定义OpenProcess (processthreadsapi.h)\n\n\n\n\n\n\n\n\nSyntaxHANDLE OpenProcess (    DWORD dwDesiredAccess,    BOOL bInheritHandle,    DWORD dwProcessId);\nRequirementsDLL：Kernel32.dll\nNtOpenProcess (ntddk.h)\n\n\n\n\n\n\n\n\nSyntax__kernel_entry NTSYSCALLAPI NTSTATUS NtOpenProcess (   PHANDLE ProcessHandle,   ACCESS_MASK DesiredAccess,   POBJECT_ATTRIBUTES ObjectAttributes,   PCLIENT_ID ClientId);\nRequirementsHeader：ntddk.h (include Ntddk.h, Ntifs.h)\nNtAllocateVirtualMemory (ntifs.h)\n\n\n\n\n\n\n\n\nSyntax__kernel_entry NTSYSCALLAPI NTSTATUS NtAllocateVirtualMemory(   HANDLE ProcessHandle,   PVOID *BaseAddress,   ULONG_PTR ZeroBits,   PSIZE_T RegionSize,   ULONG AllocationType,   ULONG Protect);\n第三方网站中的函数定义NtWriteVirtualMemory\n\n\n\n\n\n\n\n\n__kernel_entry NTSYSCALLAPI NTSTATUS NtQueryVirtualMemory(   HANDLE ProcessHandle,   PVOID BaseAddress,   MEMORY_INFORMATION_CLASS MemoryInformationClass,   PVOID MemoryInformation,   SIZE_T MemoryInformationLength,   PSIZE_T ReturnLength );\n结构体定义UNICODE_STRING (ntdef.h)似乎是一种安全的unicode字符串类型，下面是ntdef源码。\n&#x2F;&#x2F;\n&#x2F;&#x2F; Unicode strings are counted 16-bit character strings. If they are\n&#x2F;&#x2F; NULL terminated, Length does not include trailing NULL.\n&#x2F;&#x2F;\n\ntypedef struct _UNICODE_STRING &#123;\n    USHORT Length;\n    USHORT MaximumLength;\n#ifdef MIDL_PASS\n    [size_is(MaximumLength &#x2F; 2), length_is((Length) &#x2F; 2) ] USHORT * Buffer;\n#else &#x2F;&#x2F; MIDL_PASS\n    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH   Buffer;\n#endif &#x2F;&#x2F; MIDL_PASS\n&#125; UNICODE_STRING;\ntypedef UNICODE_STRING *PUNICODE_STRING;\ntypedef const UNICODE_STRING *PCUNICODE_STRING;\n&#x2F;&#x2F; end_sdfwdm\n&#x2F;&#x2F; end_wudfwdm\n\nOBJECT_ATTRIBUTES (ntdef.h)下面是ntdef源码。\ntypedef struct _OBJECT_ATTRIBUTES &#123;\n    ULONG Length;\n    HANDLE RootDirectory;\n    PUNICODE_STRING ObjectName;\n    ULONG Attributes;\n    PVOID SecurityDescriptor;        &#x2F;&#x2F; Points to type SECURITY_DESCRIPTOR\n    PVOID SecurityQualityOfService;  &#x2F;&#x2F; Points to type SECURITY_QUALITY_OF_SERVICE\n&#125; OBJECT_ATTRIBUTES;\ntypedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;\ntypedef CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;\n\nCLIENT_ID (MSDN)MSDN的解释是包括进程和线程的id，下面是MSDN中的定义。\ntypedef struct _CLIENT_ID &#123;\n\tHANDLE UniqueProcess;\n\tHANDLE UniqueThread;\n&#125; CLIENT_ID;\n\n文件地址\n\n\n\n\n\n\n\n\nC:\\Windows\\System32\\kernel32.dllC:\\Windows\\System32\\KernelBase.dllC:\\Windows\\SysWOW64\\kernel32.dllC:\\Windows\\SysWOW64\\KernelBase.dllC:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\um\\windows.hC:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\shared\\ntdef.h\n逆向重写OpenProcess（NtOpenProcess）在dll中寻找OpenProcess在本机的System32\\kernel32.dll里没有找到，只找到OpenProcessStub()，这个函数会直接调用OpenProcess。在System32\\KernelBase.dll里找到了OpenProcess，然后用ida f5，改了以下符号名是下面这个样子。\n其中ObjectAttributes.Length这个参数有问题，64位是48，32位是24，msdn里是sizeof(OBJECT_ATTRIBUTES)。\n如果有dalao看到这里肯定发现，system32目录下的是64位的dll，但我原本是想找32位的，很尴尬。\nKernelBaseMSDN上找到一份关于win7的资料[5]，大概意思是把部分kernel32和advapi32的函数移到了kernelbase里，并称kernelbase为low-level binaries，应该是低权限的意思。目的是为了以后的网络工程开发和减少攻击面。\nOpenProcess调用过程（x32）在重写OpenProcess改用NtOpenProcess后（详细见下面重新OpenProcess），我重新跟踪了下调用OpenProcess的过程。\n\n首先main函数call OpenProcess，跳转到kernel.dll；然后jmp到kernelbase.dll；在kernelbase.dll里才是OpenProcess的主要代码，其中会调用ntdll的NtOpenProcess；而NtOpenProcess会调用系统调用。\nOpenProcess调用过程（x64）64位和32差不多，先是main call OpenProcess跳转到kernel.dll；然后jmp到kernelbase.dll；kernelbase.dll里是主要代码，不同点是ObjectAttributes.Length的值，以及32位调用的NtOpenProcess，在64中改成了ntdll的ZwOpenProcess；而ZwOpenProcess同样调用了系统调用。\n\n重写OpenProcess（NtOpenProcess）直接引用ntdef.h会引发下面的错误：\nerror C2338: Windows headers require the default packing option. Changing this can lead to memory corruption. This diagnostic can be disabled by building with WINDOWS_IGNORE_PACKING_MISMATCH defined.\n最终代替OpenProcess的代码如下：\ntypedef struct _UNICODE_STRING &#123;\n\tUSHORT Length;\n\tUSHORT MaximumLength;\n\tPWSTR  Buffer;\n&#125;UNICODE_STRING, *PUNICODE_STRING;\n\ntypedef struct _OBJECT_ATTRIBUTES &#123;\n\tULONG Length;\n\tHANDLE RootDirectory;\n\tPUNICODE_STRING ObjectName;\n\tULONG Attributes;\n\tPVOID SecurityDescriptor;\n\tPVOID SecurityQualityOfService;\n&#125;OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;\n\ntypedef struct _CLIENT_ID &#123;\n\tHANDLE UniqueProcess;\n\tHANDLE UniqueThread;\n&#125;CLIENT_ID, *PCLIENT_ID;\n\ntypedef long (WINAPI* PNtOpenProcess) (\n\tPHANDLE ProcessHandle,\n\tACCESS_MASK DesiredAccess,\n\tPOBJECT_ATTRIBUTES ObjectAttributes,\n\tPCLIENT_ID ClientId\n);\n\n&#x2F;&#x2F; hTarget &#x3D; OpenProcess((PROCESS_CREATE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION), false, pid);\nHMODULE mdNT &#x3D; GetModuleHandleW(L&quot;ntdll.dll&quot;);\nPNtOpenProcess NtOpenProcess &#x3D; (PNtOpenProcess)GetProcAddress(mdNT, &quot;NtOpenProcess&quot;);\nOBJECT_ATTRIBUTES ObjectAttributes &#x3D; &#123; sizeof(OBJECT_ATTRIBUTES) &#125;; &#x2F;&#x2F; 0x18\nCLIENT_ID ClientId &#x3D; &#123; (HANDLE)pid, 0 &#125;;\nDWORD nts &#x3D; NtOpenProcess(&amp;hTarget, (PROCESS_CREATE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION), &amp;ObjectAttributes, &amp;ClientId);\n\n其中ObjectAttributes.Length我一开始照抄48（后面才发现，照抄的是64位版本的openprocess。），然后NtOpenProcess给我返回了0xC000000D，MSDN中的说明是传入非法参数，再仔细看Members条目，发现这个参数应该为sizeof(OBJECT_ATTRIBUTES)，vs中调试发现这个结构体的长度为24，修改后就能正常用了。原因是32和64的OBJECT_ATTRIBUTES结构长度不一样。\nR0和R3通信后面查资料才知道，windwos程序运行在r3（用户态）层；驱动在r1，r2；系统代码在r0（内核态）层。r0权限最高。\nntdll提供api使得r3层面的程序能够执行r0层的代码。而ntdll的native api都是成对出现的，分别以Nt和Zw开头。\n逆向重写VirtualAllocEx（NtAllocateVirtualMemory）KernelBase.dll中的VirtualAllocExVirtualAllocEx会直接调用VirtualAllocExNuma；然后VirtualAllocExNuma调用NtAllocateVirtualMemory。\n重写typedef long (WINAPI* PNtAllocateVirtualMemory) (\n\tHANDLE ProcessHandle,\n\tPVOID* BaseAddress,\n\tULONG_PTR ZeroBits,\n\tPSIZE_T RegionSize,\n\tULONG AllocationType,\n\tULONG Protect\n);\n\n&#x2F;&#x2F; pszPathname &#x3D; (PWSTR)VirtualAllocEx(hTarget, NULL, pathnameLen, MEM_COMMIT, PAGE_READWRITE);\nPNtAllocateVirtualMemory NtAllocateVirtualMemory &#x3D; (PNtAllocateVirtualMemory)GetProcAddress(mdNT, &quot;NtAllocateVirtualMemory&quot;);\nnts &#x3D; NtAllocateVirtualMemory(hTarget, (PVOID*)&amp;pszPathname, 0, (SIZE_T*)&amp;pathnameLen, MEM_COMMIT &amp; 0xFFFFFFC0, PAGE_READWRITE);\n\n逆向重写WriteProcessMemory（NtWriteVirtualMemory）KernelBase.dll中的WriteProcessMemoryWriteProcessMemory中调用了NtQueryVirtualMemory，NtProtectVirtualMemory，NtWriteVirtualMemory，NtFlushInstructionCache。后三个在MSDN中似乎都没有资料。\n其中 NtQueryVirtualMemory 用于获取虚拟内存的属性。\n在第三方网站查询得到 NtProtectVirtualMemory[7] 用于改变虚拟内存区域的保护状态。\n关于 NtFlushInstructionCache 的资料没有找到多少，说是用于刷新指令缓存，不知道具体有什么用。\n同样在第三方网站查询得到 NtWriteVirtualMemory[8] 用于写入内存。所以只需要直接调用这个即可。\n重写typedef long(WINAPI* PNtWriteVirtualMemory) (\n\tHANDLE ProcessHandle,\n\tPVOID BaseAddress,\n\tPVOID Buffer,\n\tULONG BufferSize,\n\tPULONG NumberOfBytesWritten\n);\n\n&#x2F;&#x2F; WriteProcessMemory(hTarget, (LPVOID)memoryAddr, buf, bufSize, &amp;byw);\nPNtWriteVirtualMemory NtWriteVirtualMemory &#x3D; (PNtWriteVirtualMemory)GetProcAddress(mdNT, &quot;NtWriteVirtualMemory&quot;);\nNtWriteVirtualMemory(hTarget, memoryAddr, buf, bufSize, &amp;byw);\n\n逆向重写LoadLibraryExW（LdrLoadDll）32位下调用过程如下，不管调用哪个版本，最终都会去到LoadLibraryExW。\nLoadLibraryA -&gt; LoadLibraryExA -&gt;LoadLibraryExW，LoadLibraryW -&gt; LoadLibraryExW\nKernelBase.dll中的LoadLibraryExW首先通过传入的dwFlags参数确认传入的dll名称是不是unicode编码，不是就设置错误代码为0xC000000D（传入参数非法）。\n然后转换成UNICODE_STRING（RtlInitUnicodeString）。\n转换后会进行检查，去掉unicode字符串末尾的空格。如果全是空格同样会设置错误代码为0xC000000D。\n接着有一段代码会调用 LdrGetDllPath，这段代码如果调用 LoadLibraryW 进入的 LoadLibraryExW 不会触发。\n然后又有一系列从 LoadLibraryW 进入不会触发的if语句。\n最后调用 LdrLoadDll。\n需要注意的是，要选择Release模式，debug模式会出问题，不能正确获得ShellCode地址。\n重写void __declspec(naked) ShellCode(PVOID addr)\n&#123;\n    &#x2F;&#x2F; para 3 UNICODE_STRING pathname\n    &#x2F;&#x2F; [addr+0x0] 2:  USHORT  Length\n    &#x2F;&#x2F; [addr+0x2] 2:  USHORT  MaximumLength\n    &#x2F;&#x2F; [addr+0x4] 4:  PWSTR   Buffer        &#x3D; addr+8\n\n    &#x2F;&#x2F; [addr+0x8] 0x14: wchar_t dllPathname\n\n    &#x2F;&#x2F; para 2\n    &#x2F;&#x2F; [addr+0x98] 4: ULONG LoadFlags &#x3D; 0\n\n    &#x2F;&#x2F; para 4\n    &#x2F;&#x2F; [addr+0x9C] 4: PVOID BaseAddress &#x3D; 0\n\n    &#x2F;&#x2F; [addr+0x100] 4: PVOID LdrLoadDll\n\n    &#x2F;&#x2F; [addr+0x200] : shellcode\n\t__asm &#123;\n\t\tpushad;\n\t\tmov eax, addr;\n\t\t&#x2F;&#x2F; para 4\n\t\tmov ebx, eax;\n\t\tadd ebx, 0x9c;\n\t\tpush ebx;\n\t\t&#x2F;&#x2F; para 3\n\t\tmov ebx, eax;\n\t\tpush ebx;\n\t\t&#x2F;&#x2F; para 2\n\t\tmov ebx, eax;\n\t\tadd ebx, 0x98;\n\t\tpush ebx;\n\t\t&#x2F;&#x2F; para 1\n\t\tmov ebx, 1;\n\t\tpush ebx;\n\t\t&#x2F;&#x2F; call LdrLoadDll\n\t\tadd eax, 0x100;\n\t\tmov edx, [eax];\n\t\tcall edx;\n\t\tpopad;\n\t\tmov eax, addr;\n\t\tadd eax, 0x9C;\n\t\tmov eax, [eax];\n\t\tret;\n\t&#125;\n&#125;\n\n写入参数及shellcode这里需要用NtWriteVirtualMemory写入参数及shellcode。\n第三个参数 UNICODE_STRING pathname 我直接选择自己构建，MaximumLength就是dll路径字符串的字节数（包括末尾的零），而Length必须是字符串不包括末尾\\x0\\x0的字节数，否则会LdrLoadDll会找不到dll并返回0xC0000135。\n逆向重写CreateRemoteThreadEx（NtCreateThreadEx）KernelBase.dll中的CreateRemoteThreadExCreateRemoteThread会直接调用CreateRemoteThreadEx\n然后CreateRemoteThreadEx会搞一堆奇奇怪怪的检测，并调用NtCreateThreadEx。\n在网上找到定义[9]，照着定义和ida写了下。其中调用了个BaseFormatObjectAttributes，但传了两个零进去发现其实什么也没干。\n重写typedef long(WINAPI* PNtCreateThreadEx) (\n\tPHANDLE hThread,\n\tACCESS_MASK DesiredAccess,\n\tLPVOID ObjectAttributes,\n\tHANDLE ProcessHandle,\n\tLPTHREAD_START_ROUTINE lpStartAddress,\n\tLPVOID lpParameter,\n\tBOOL CreateSuspended,\n\tULONG StackZeroBits,\n\tULONG SizeOfStackCommit,\n\tULONG SizeOfStackReserve,\n\tLPVOID lpBytesBuffer\n);\n\nPNtCreateThreadEx NtCreateThreadEx &#x3D; (PNtCreateThreadEx)GetProcAddress(mdNT, &quot;NtCreateThreadEx&quot;);\nnts &#x3D; NtCreateThreadEx(\n    &amp;hDll,\n    0x1FFFFF,\n    0,\n    hTarget,\n    (LPTHREAD_START_ROUTINE)(pVirtualMemory + 0x200),\n    (PVOID)pVirtualMemory,\n    0,\n    0,\n    0,\n    0,\n    0);\n\n用RtlCreateUserThread代替CreateRemoteThread据说RtlCreateUserThread是NtCreateThread的一个小型封装。抄了一下Metasploit的代码[11]。\nMetasploit会先用CraeteRemoteThread，没有足够空间时再使用RtlCreateUserThread。\ntypedef long(WINAPI* PRtlCreateUserThread) (\n\tHANDLE ProcessHandle,\n\tPSECURITY_DESCRIPTOR SecurityDescriptor,\n\tBOOLEAN CreateSuspended,\n\tULONG StackZeroBits,\n\tPULONG StackReserved,\n\tPULONG StackCommit,\n\tPVOID StartAddress,\n\tPVOID StartParameter,\n\tPHANDLE ThreadHandle,\n\tPCLIENT_ID ClientID\n);\n\nPRtlCreateUserThread RtlCreateUserThread &#x3D; (PRtlCreateUserThread)GetProcAddress(mdNT, &quot;RtlCreateUserThread&quot;);\nnts &#x3D; RtlCreateUserThread(\n    hTarget,\n    0,\n    0,\n    0,\n    0,\n    0,\n    (LPTHREAD_START_ROUTINE)(pVirtualMemory + 0x200),\n    (PVOID)pVirtualMemory,\n    &amp;hDll,\n    0);\n\n参考[1] UNICODE_STRING ：https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_unicode_string\n[2] OBJECT_ATTRIBUTES：https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_object_attributes\n[3] CLIENT_ID：https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tsts/a11e7129-685b-4535-8d37-21d4596ac057\n[4] NtOpenProcess：https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-ntopenprocess\n[5] New Low-Level Binaries（win7）：https://docs.microsoft.com/en-us/windows/win32/win7appqual/new-low-level-binaries\n[6] r0和r3之间的通信：https://blog.csdn.net/qq_33526144/article/details/103503011\n[7] NtQueryVirtualMemory：http://www.codewarrior.cn/ntdoc/winnt/mm/NtProtectVirtualMemory.htm\n[8] NtWriteProcessMemory：http://www.codewarrior.cn/ntdoc/winnt/mm/NtWriteVirtualMemory.htm\n[9] NtCreateThread：https://securityxploded.com/ntcreatethreadex.php\n[10] RtlCreateUserThread：https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FExecutable%20Images%2FRtlCreateUserThread.html\n[11] RtlCreateUserThread Metasploit例子：https://github.com/rapid7/meterpreter/blob/6d43284689240f4261cae44a47f0fb557c1dde27/source/common/arch/win/remote_thread.c#L77\n[12] RtlCreateUserThread mimikatz例子：https://github.com/gentilkiwi/mimikatz/blob/d5676aa66cb3f01afc373b0a2f8fcc1a2822fd27/modules/kull_m_remotelib.c#L59\n","slug":"dllRemoteInject","date":"2021-03-16T09:08:49.000Z","categories_index":"Windows","tags_index":"windows,dll,note","author_index":"御史神风"},{"id":"c3979005c513d3a7ab25692f156963bc","title":"windows核心编程 dll笔记","content":"windows核心编程 dll笔记构建及使用dll以下是核心编程的示例：\n&#x2F;* .\\Mylib\\MyLib.h *&#x2F;\n#ifndef MYLIB\n#define MYLIB extern &quot;C&quot; __declspec(dllimport)\n#endif\n\nMYLIB int num;\n\nMYLIB int DllFun();\n\n&#x2F;* .\\Mylib\\MyLib1.cpp *&#x2F;\n#include &lt;windows.h&gt;\n#define MYLIB extern &quot;C&quot; __declspec(dllexport)\n#include &quot;MyLib.h&quot;\n\nint dll_num;\n\nint DllFun() &#123;\n    return dll_num;\n&#125;\n\n&#x2F;* .\\MyExe.cpp *&#x2F;\n#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n#include &quot;MyLib\\MyLib.h&quot;\n\nint main()\n&#123;\n    dll_num &#x3D; 10;\n    std::cout &lt;&lt; DllFun();\n    return 0;\n&#125;\n\nextern “C”修饰符用于指明使用C++。\n载入dll模块显式载入将dll映射到进程的地址空间\nHMODULE LoadLibrary(PCTSTR pszDLLPathName);\nHMODULE LoadLibraryEx(PCTSTR pszDLLPathName,\n                      HANDLE hFile,\n                      DWORD dwFlags);\n\n返回值是被映射到的虚拟内存地址。（此处HMODULE等价于HINSTANCE）\n通过GetLastError确定是否成功载入。\n显式链接到导出符号FARPROC GetProcAddress(HMODULE hInstDll, PCSTR pszSymbolName);\n\n显式卸载BOOL FreeLibrary(HMODULE hInstDll);\nVOID FreeLivraryAndExitThread(HMODULE hInstDll, DWORD dwExitCode);\n\ndll搜索顺序\n当前目录\nwindows系统目录\n16位windows系统目录（windows目录下的system子目录）\nwindows目录\npath环境变量中的目录\n\nDllMainfdwReasonDLL_PROCESS_ATTACH：第一次将DLL映射到进程中时，会调用DllMain并传入该信号。通常此时应该通过HeapCreate创建需要的堆。返回值用于表示是否初始化成功。\nDLL_THREAD_ATTACH：进程创建一个线程时触发。\nDLL_THREAD_DETACH：ExitThread触发。\nDLL_PROCESS_DETACH：撤销映射时传入该信号。通常执行HeapDestroy销毁初始化时创建的堆。\n模块的基地址重定位重定位段(relocation section)包含一个字节偏移量的列表，记录机器指令的内存地址，用于需要重定位时遍历修改内存映像中的地址。\nRemoteInject（CreateRemoteThread）大致流程\n获取目标进程pid，并打开目标进程。\n\n在目标进程中申请空间，写入注入dll的路径。\n\n获取LoadLibrary在Kernel32.dll的真实地址。\n\n通过远程创建线程，在目标进程中创建一个线程，执行LoadLibrary(dllPathname)。\n\n释放申请的空间，并关闭句柄。\n\n\n细节因为是在目标进程中执行LoadLibrary(dllPathname)的，所以需要先把dll路径写入目标进程中，并作为LoadLibrary的参数。\n直接调用LoadLibrary时，链接器会生成一个调用，调用导入段中的一个转换函数。即先跳转到转换函数，再跳转到实际函数。而转换函数在不同进程中是会变的，但Kernel32.dll在所有进程中映射的地址是一样的，所以需要获取LoadLibrary在Kernel32.dll中的地址。\n具体代码&#x2F;*\nRemoteInject.cpp\n*&#x2F;\n\n#include &lt;iostream&gt;\n#include &lt;windows.h&gt;\n#include &lt;TlHelp32.h&gt;\n\nusing std::cout;\nusing std::endl;\n\nDWORD GetPidByName(WCHAR* name);\n\nint main()\n&#123;\n\twchar_t targetName[20] &#x3D; L&quot;Target.exe&quot;;\n\twchar_t dllPathname[] &#x3D; L&quot;E:\\\\MyDll.dll&quot;;\n\tint pathnameLen &#x3D; (1 + lstrlenW(dllPathname)) * sizeof(wchar_t);\n\tDWORD pid &#x3D; 0, byw &#x3D; 0;\n\tHANDLE hTarget &#x3D; 0, hDll &#x3D; 0;\n\tPWSTR pszPathname &#x3D; 0;\n\tPTHREAD_START_ROUTINE realAddr &#x3D; 0;\n\n\t__try &#123;\n\t\t&#x2F;&#x2F; 1 get pid\n\t\tpid &#x3D; GetPidByName(targetName);\n\t\tif (pid &#x3D;&#x3D; 0) &#123;\n\t\t\tcout &lt;&lt; &quot;e:Get pid failed\\n&quot;;\n\t\t\t__leave;\n\t\t&#125;\n\t\tcout &lt;&lt; &quot;pid:&quot; &lt;&lt; pid &lt;&lt; endl;\n\n\t\t&#x2F;&#x2F; 2 open process\n\t\thTarget &#x3D; OpenProcess((PROCESS_CREATE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION), false, pid);\n\t\tif (hTarget &#x3D;&#x3D; NULL) &#123;\n\t\t\tcout &lt;&lt; &quot;e:Open process failed\\n&quot;;\n\t\t\t__leave;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 3 alloc memory for dll pathname\n\t\tpszPathname &#x3D; (PWSTR)VirtualAllocEx(hTarget, NULL, pathnameLen, MEM_COMMIT, PAGE_READWRITE);\n\t\tif (pszPathname &#x3D;&#x3D; NULL) &#123;\n\t\t\tcout &lt;&lt; &quot;e:Alloc memory failed\\n&quot;;\n\t\t\t__leave;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tcout &lt;&lt; &quot;pathname addr: &quot; &lt;&lt; pszPathname &lt;&lt; endl;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 4 write dll pathname\n\t\tWriteProcessMemory(hTarget, (LPVOID)pszPathname, dllPathname, pathnameLen, &amp;byw);\n\t\tcout &lt;&lt; &quot;dll pathname(len, write len): &quot; &lt;&lt; pathnameLen &lt;&lt; &quot; &quot; &lt;&lt; byw &lt;&lt; std::endl;\n\n\t\t&#x2F;&#x2F; 5 get the real address of LoadLibraryW in Kernel32.dll\n\t\tHMODULE mh &#x3D; GetModuleHandleW(L&quot;Kernel32.dll&quot;);\n\t\tif (mh &#x3D;&#x3D; NULL) &#123;\n\t\t\tcout &lt;&lt; &quot;e:kernel\\n&quot;;\n\t\t\t__leave;\n\t\t&#125;\n\t\trealAddr &#x3D; (PTHREAD_START_ROUTINE)GetProcAddress(mh, &quot;LoadLibraryW&quot;);\n\n\t\t&#x2F;&#x2F; 6 create a remote thread to call LoadLibraryW(dllPathname)\n\t\thDll &#x3D; CreateRemoteThread(hTarget, NULL, 0, realAddr, pszPathname, 0, NULL);\n\t\tif (hDll &#x3D;&#x3D; NULL) &#123;\n\t\t\tcout &lt;&lt; &quot;e:create remote thread failed\\n&quot;;\n\t\t\t__leave;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tcout &lt;&lt; &quot;hDll: &quot; &lt;&lt; hDll &lt;&lt; endl;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; wait\n\t\tWaitForSingleObject(hDll, INFINITE);\n\t&#125;\n\t__finally &#123;\n\t\t&#x2F;&#x2F; clean\n\t\tif (hDll !&#x3D; NULL) &#123;\n\t\t\tCloseHandle(hDll);\n\t\t&#125;\n\n\t\tif (hTarget !&#x3D; NULL) &#123;\n\t\t\tif (pszPathname !&#x3D; NULL)\n\t\t\t\tVirtualFreeEx(hTarget, pszPathname, 0, MEM_RELEASE);\n\n\t\t\tCloseHandle(hTarget);\n\t\t&#125;\n\t&#125;\n&#125;\n\nDWORD GetPidByName(WCHAR* name)\n&#123;\n\tHANDLE hsnapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\tif (hsnapshot &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;\n\t\tprintf_s(&quot;CreateToolhelp32Snapshot error!\\n&quot;);\n\t\treturn 0;\n\t&#125;\n\n\tPROCESSENTRY32 pe&#123;&#125;;\n\tpe.dwSize &#x3D; sizeof(PROCESSENTRY32);\n\n\tint flag &#x3D; Process32First(hsnapshot, &amp;pe);\n\n\twhile (flag !&#x3D; 0) &#123;\n\t\tif (wcscmp(pe.szExeFile, name) &#x3D;&#x3D; 0) &#123;\n\t\t\treturn pe.th32ProcessID;\n\t\t&#125;\n\t\tflag &#x3D; Process32Next(hsnapshot, &amp;pe);\n\t&#125;\n\n\tCloseHandle(hsnapshot);\n\n\treturn 0;\n&#125;\n\nImageWalk遍历内存区块查询对应的信息\nMEMORY_BASIC_INFORMATIONAllocationBase：内存单元起始地址\nBaseAddress：模块基地址\nRegionSize：模块所以页面的大小\nC6262 堆栈溢出警告C6262：函数使用了堆栈的“26300”个字节: 超过了 /analyze:stacksize ‘16384’。 请考虑将某些数据移到堆中。\n其中有一个变量为 char szBuf[260 * 100]，260是路径长度最大值，100是个数，这里减少下个数避免这个警告。\n其他解决方式如malloc或new就不再深究了。\n小笔记__try和try：据说Release模式下，如果没有throw模块，vc会优化掉try catch\n线性地址：逻辑地址（偏移）+ 基地址\nHMODULE：模块句柄，win32下通常是被载入模块的线性地址\nMAX_PATH：宏常量，通常为260，代表编译器支持的最长路径长度\nsz：string zero，表示以零结尾的字符串，即c字符串\n参考C6262：https://blog.csdn.net/mxclxp/article/details/7991127\n随书代码下载页面：https://www.wintellect.com/windows-via-cc-by-jeffrey-richter-and-christopher-nasarre/\n随书代码下载地址：https://www.wintellect.com/wp-content/uploads/2017/11/Windows-via-C-Code-January-29-2008.zip\n","slug":"winViaC-dll","date":"2021-03-16T08:52:35.000Z","categories_index":"Windows","tags_index":"windows,dll,note,windows_via_c","author_index":"御史神风"},{"id":"27d41187f35ffd274258f367e076131e","title":"geek20","content":"geek challenge 20th\n","slug":"geek20","date":"2020-12-08T09:48:04.000Z","categories_index":"CTF","tags_index":"ctf,geek_challenge,re,pwn,crypt,misc,wp","author_index":"御史神风"}]