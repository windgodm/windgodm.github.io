{"title":"《逆向工程实战》实例D","uid":"59b8a2ac42b98d74611bef705cd30176","slug":"practicalreD","date":"2022-03-11T04:00:00.000Z","updated":"2022-04-13T13:58:55.515Z","comments":true,"path":"api/articles/practicalreD.json","keywords":null,"cover":null,"content":"<h1 id=\"《逆向工程实战》实例D\"><a href=\"#《逆向工程实战》实例D\" class=\"headerlink\" title=\"《逆向工程实战》实例D\"></a>《逆向工程实战》实例D</h1><h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p><strong>基本信息</strong></p>\n<p>x86</p>\n<p>Device Name：<code>\\Device\\ProcPanama</code></p>\n<p>SymbolLink Name：<code>\\DosDevices\\ProcPanama</code></p>\n<p>IRP：Create、Close、DeviceIoCtrl</p>\n<p>回调：进程</p>\n<p><strong>函数分析结果</strong></p>\n<ul>\n<li><p>sub_10001019：进程通知回调</p>\n</li>\n<li><p>sub_10001277：Memcpy</p>\n</li>\n<li><p>sub_100012B0：修改cr0</p>\n</li>\n<li><p>sub_100012BC：修改cr0</p>\n</li>\n<li><p>sub_100012C8*：DeviceIoCtrl</p>\n</li>\n</ul>\n<p><strong>功能摘要</strong></p>\n<p>提供接口修改ssdt（CR0关WP）、写入shellcode、触发中断</p>\n<p>功能与shellcode密切相关，没有R3的样本，不知道shellcode是什么</p>\n<h2 id=\"结构分析\"><a href=\"#结构分析\" class=\"headerlink\" title=\"结构分析\"></a>结构分析</h2><p>IOCTL_0_803 input buffer</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; size &gt;&#x3D; 0x20\n+  0  ssdtIdx        4\n+  4  aShellCode     char[0xa]\n+  E  unknown        2\n+ 10  hProc          HANDLE\n+ 14  desiredAccess  4\n+ 18  pid            4\n+ 1C  newBase        void*</code></pre>\n\n<p>IOCTL_1_804 input buffer</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; size &#x3D; 0xC\n+ 0  ssdtIdx  4\n+ 4  newBase  void*\n+ 8  oldBase  void*</code></pre>\n\n\n\n<h2 id=\"Memcpy\"><a href=\"#Memcpy\" class=\"headerlink\" title=\"Memcpy\"></a>Memcpy</h2><p>这个函数的功能就是memcpy</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void Memcpy(char* Dst_, char* Src_, unsigned int size);</code></pre>\n\n\n\n<p>书中问到第二个参数从何而来，是否有意义，不太确定是什么意思。<br>我猜测是优化使得对第二个参数的使用变得有点奇怪，比较不直观，详见下面的分析。</p>\n<p>首先检查传入的第一个和第二个参数是否是合法地址</p>\n<p>然后执行了memcpy的操作，有一些优化，所以比较难识别</p>\n<p>反汇编：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">; unsigned int i   (esi)\n; char*        dst (eax)\nmov     esi, [ebp+size]    ; i &#x3D; size\ntest    esi, esi\njbe     short L_end ; jmp if i &#x3D;&#x3D; 0:\nmov     eax, [ebp+Dst_]    ; eax &#x3D; Dst_\nmov     ecx, [ebp+Src_]\nsub     ecx, eax           ; const ecx &#x3D; Src_ - Dst_\nL_continue:\nmov     dl, [ecx+eax]\nmov     [eax], dl          ; *dst &#x3D; *(Src_-Dst_+dst)\ninc     eax                ; dst++\ndec     esi                ; i--\njnz     short L_continue\nL_end:\npop     esi\npop     ebp\nretn    0Ch</code></pre>\n\n<p>反编译：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">unsigned int i &#x3D; size;\nif(i)&#123;\n\tchar* dst &#x3D; Dst_;\n\tdo &#123;\n        *dst &#x3D; *(dst + Src_ - Dst_); &#x2F;&#x2F; Dst_[size-i] &#x3D; Src_[size-i]\n        ++dst;\n        --i;\n    &#125; while( i );\n&#125;</code></pre>\n\n\n\n<h2 id=\"修改cr0\"><a href=\"#修改cr0\" class=\"headerlink\" title=\"修改cr0\"></a>修改cr0</h2><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">EnableCR0WP proc near\nmov     eax, cr0\nor      eax, 10000h ; cr0 bit[16] &#x3D; 1\nmov     cr0, eax\nretn\nsub_100012B0 endp\n\nDisableCR0WP proc near\nmov     eax, cr0\nand     eax, 0FFFEFFFFh ; cr0 bit[16] &#x3D; 0\nmov     cr0, eax\nretn\nsub_100012BC endp</code></pre>\n\n\n\n<h2 id=\"DeviceIoCtrl\"><a href=\"#DeviceIoCtrl\" class=\"headerlink\" title=\"DeviceIoCtrl\"></a>DeviceIoCtrl</h2><p>5个控制码</p>\n<p>都是METHOD_BUFFERED，有一个用了UserBuffer输出，有点迷惑</p>\n<p>METHOD_NEITHER 用的是（In）Type3InputBuffer、（Out）UserBuffer</p>\n<p>Read/Write的Buffer IO用的都是SystemBuffer</p>\n<h3 id=\"IOCTL-0-803\"><a href=\"#IOCTL-0-803\" class=\"headerlink\" title=\"IOCTL_0_803\"></a><strong>IOCTL_0_803</strong></h3><p>修改了ssdt表项，然后又修改了新的服务例程前10个字节，然后调用打开进程句柄</p>\n<p>最后恢复上面修改的两个东西</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Code 22E00C\nDeviceType 0x22 FILE_DEVICE_UNKNOWN\nFunction 0x803\nMethod 0x0 METHOD_BUFFERED\nAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS  </code></pre>\n\n\n\n<p>部分反编译：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">if( MmIsAddressValid(inBuf-&gt;newBase) ) &#123;\n    pSSDT_i &#x3D; (PVOID *)(KeServiceDescriptorTable[0] + 4 * inBuf-&gt;ssdtIdx);\n    if( MmIsAddressValid(pSSDT_i) ) &#123;\n        oldBase &#x3D; *pSSDT_i; &#x2F;&#x2F; save ssdt[i]\n        DisableCR0WP();\n        *pSSDT_i &#x3D; inBuf-&gt;newBase; &#x2F;&#x2F; change ssdt[i]\n        Memcpy(tempBuf, (char *)inBuf-&gt;newBase, 0xAu);&#x2F;&#x2F; save shellcode 0xA bytes\n        Memcpy((char *)inBuf-&gt;newBase, inBuf-&gt;aShellcode, 0xAu);&#x2F;&#x2F; change shellcode 0xA bytes\n        status &#x3D; ZwOpenProcess(&amp;inBuf-&gt;hProc, inBuf-&gt;desiredAccess, &amp;ObjectAttributes, &amp;ClientId);\n        Memcpy((char *)inBuf-&gt;newBase, tempBuf, 0xAu);&#x2F;&#x2F; re change shellcode 0xA bytes\n        *pSSDT_i &#x3D; oldBase; &#x2F;&#x2F; re change ssdt[i]\n        EnableCR0WP();\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"IOCTL-1-804-set-ssdt\"><a href=\"#IOCTL-1-804-set-ssdt\" class=\"headerlink\" title=\"IOCTL_1_804 set ssdt\"></a><strong>IOCTL_1_804 set ssdt</strong></h3><p>设置ssdt表项，并保存旧的ssdt表项</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Code 22E010\nDeviceType 0x22 FILE_DEVICE_UNKNOWN\nFunction 0x804\nMethod 0x0 METHOD_BUFFERED\nAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS  </code></pre>\n\n\n\n<p>部分反编译：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">inBuf_1-&gt;oldBase &#x3D; *(PVOID *)(KeServiceDescriptorTable[0] + 4 * inBuf_1-&gt;ssdtIdx); &#x2F;&#x2F; save old ssdt[i]\nDisableCR0WP();\n*pSSDT_i &#x3D; inBuf_1-&gt;newBase; &#x2F;&#x2F; set ssdt[i]\nEnableCR0WP();</code></pre>\n\n\n\n<h3 id=\"IOCTL-2-805-write-g-buffer\"><a href=\"#IOCTL-2-805-write-g-buffer\" class=\"headerlink\" title=\"IOCTL_2_805 write g_buffer\"></a>IOCTL_2_805 write g_buffer</h3><p>往一个全局指针分配页池内存，然后往该全局buffer里写入数据，然后对该全局buffer做了一些看不懂的操作</p>\n<p>另外使用了UserBuffer</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Code 22E014\nDeviceType 0x22 FILE_DEVICE_UNKNOWN\nFunction 0x805\nMethod 0x0 METHOD_BUFFERED\nAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS  </code></pre>\n\n\n\n<h3 id=\"IOCTL-3-806\"><a href=\"#IOCTL-3-806\" class=\"headerlink\" title=\"IOCTL_3_806\"></a>IOCTL_3_806</h3><p>对g_buffer进行了一些操作</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Code 22E018\nDeviceType 0x22 FILE_DEVICE_UNKNOWN\nFunction 0x806\nMMethod 0x0 METHOD_BUFFERED\nAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS</code></pre>\n\n\n\n<h3 id=\"IOCTL-4-807-add-pid\"><a href=\"#IOCTL-4-807-add-pid\" class=\"headerlink\" title=\"IOCTL_4_807 add pid\"></a>IOCTL_4_807 add pid</h3><p>往<code>ULONG g_pids[0x10]</code>插入</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Code 22E01C\nDeviceType 0x22 FILE_DEVICE_UNKNOWN\nFunction 0x807\nMethod 0x0 METHOD_BUFFERED\nAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS</code></pre>\n\n\n\n<p>反汇编：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">i &#x3D; Stack-&gt;Parameters.DeviceIoControl.IoControlCode - 0x22E01C;&#x2F;&#x2F; i&#x3D;0\nif ( Stack-&gt;Parameters.DeviceIoControl.IoControlCode &#x3D;&#x3D; 0x22E01C\n&amp;&amp; Stack-&gt;Parameters.DeviceIoControl.OutputBufferLength &#x3D;&#x3D; 4 ) &#123;&#x2F;&#x2F; !!!\n    while ( g_pids[i] ) &#123;\n        if ( (unsigned int)++i &gt;&#x3D; 0x10 )\n        \tbreak;                    &#x2F;&#x2F; g_pids is full\n    &#125;\n    g_pids[i] &#x3D; *(HANDLE *)Irp-&gt;AssociatedIrp.SystemBuffer;\n&#125;</code></pre>\n\n\n\n<h2 id=\"进程通知回调\"><a href=\"#进程通知回调\" class=\"headerlink\" title=\"进程通知回调\"></a>进程通知回调</h2><p>只有g_buffer不为空时才执行功能</p>\n<p>进程注销则将g_pids[]中对应元素清零</p>\n<p>进程创建则大量的<code>int 2E</code>中断</p>\n<p>进程创建分支的结构：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; void __stdcall OnProcessNotify(\n&#x2F;&#x2F;   PEPROCESS Process,\n&#x2F;&#x2F;   HANDLE ProcessId,\n&#x2F;&#x2F;   PS_CREATE_NOTIFY_INFO *Create)\n\ni &#x3D; 0;\nwhile(g_pids[i] !&#x3D; Process) &#123;\n    i +&#x3D; 4;\n    if(i &lt; 0x40) &#123;\n        continue;\n    &#125;else &#123;\n        if(ObOpenObjectByPointer()) &#123;\n            &#x2F;&#x2F; ...\n        &#125;\n        return;\n    &#125;\n&#125;</code></pre>\n\n","text":"《逆向工程实战》实例D摘要基本信息 x86 Device Name：\\Device\\ProcPanama SymbolLink Name：\\DosDevices\\ProcPanama IRP：Create、Close、DeviceIoCtrl 回调：进程 函数分析结果 sub_1...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"Windows","slug":"Windows","count":21,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":21,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"practicalre","slug":"practicalre","count":5,"path":"api/tags/practicalre.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E5%AE%9E%E4%BE%8BD\"><span class=\"toc-text\">《逆向工程实战》实例D</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%91%98%E8%A6%81\"><span class=\"toc-text\">摘要</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90\"><span class=\"toc-text\">结构分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Memcpy\"><span class=\"toc-text\">Memcpy</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9cr0\"><span class=\"toc-text\">修改cr0</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DeviceIoCtrl\"><span class=\"toc-text\">DeviceIoCtrl</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IOCTL-0-803\"><span class=\"toc-text\">IOCTL_0_803</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IOCTL-1-804-set-ssdt\"><span class=\"toc-text\">IOCTL_1_804 set ssdt</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IOCTL-2-805-write-g-buffer\"><span class=\"toc-text\">IOCTL_2_805 write g_buffer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IOCTL-3-806\"><span class=\"toc-text\">IOCTL_3_806</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IOCTL-4-807-add-pid\"><span class=\"toc-text\">IOCTL_4_807 add pid</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%80%9A%E7%9F%A5%E5%9B%9E%E8%B0%83\"><span class=\"toc-text\">进程通知回调</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"SFU Compilers class 笔记2","uid":"b8be4bf58b4cb3abe70be3d848e17901","slug":"SFU-Compilers-2","date":"2022-03-15T04:00:00.000Z","updated":"2022-07-10T14:24:40.269Z","comments":true,"path":"api/articles/SFU-Compilers-2.json","keywords":null,"cover":[],"text":"SFU Compilers 笔记2 词法分析week2 wee3 p-lex hw1 Week 2 Lexical Analysis 1LEX1 Intro to Regexps词法分析 将字符串转成tokens Token Attributes 具有属性的例子：T_IDENT ...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"CS","slug":"CS","count":6,"path":"api/categories/CS.json"}],"tags":[{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"cs","slug":"cs","count":6,"path":"api/tags/cs.json"},{"name":"compiler","slug":"compiler","count":6,"path":"api/tags/compiler.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"《逆向工程实战》实例B","uid":"49cfcba348975accba6443ccf555c536","slug":"practicalreB","date":"2022-03-08T04:00:00.000Z","updated":"2022-04-13T13:58:06.965Z","comments":true,"path":"api/articles/practicalreB.json","keywords":null,"cover":null,"text":"《逆向工程实战》实例B（练习部分）参照书上对实例BOnProcessNotify(sub_4045F8)、sub_4038F0的分析对实例B进行的一些分析记录 一个x64的驱动后门 进程创建回调、sub_4038F0部分是根据书本分析过程复现的记录 结构体还原在40A590有一个...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"Windows","slug":"Windows","count":21,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":21,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"practicalre","slug":"practicalre","count":5,"path":"api/tags/practicalre.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}