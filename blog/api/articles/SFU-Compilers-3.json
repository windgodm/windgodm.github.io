{"title":"SFU Compilers class 笔记3","uid":"a1035c3663b3c14e4c1a5b534fff7e3d","slug":"SFU-Compilers-3","date":"2022-05-09T04:00:00.000Z","updated":"2022-09-26T10:29:39.462Z","comments":true,"path":"api/articles/SFU-Compilers-3.json","keywords":null,"cover":[],"content":"<h1 id=\"SFU-Compilers-笔记-3-语法分析1\"><a href=\"#SFU-Compilers-笔记-3-语法分析1\" class=\"headerlink\" title=\"SFU Compilers 笔记 3 语法分析1\"></a>SFU Compilers 笔记 3 语法分析1</h1><p>w4 p:yacc w5 w6</p>\n<h2 id=\"Week-4-Context-Free-Grammars（lost）\"><a href=\"#Week-4-Context-Free-Grammars（lost）\" class=\"headerlink\" title=\"Week 4 Context-Free Grammars（lost）\"></a>Week 4 Context-Free Grammars（lost）</h2><h3 id=\"CFG1-Intro-to-CFGs\"><a href=\"#CFG1-Intro-to-CFGs\" class=\"headerlink\" title=\"CFG1 Intro to CFGs\"></a>CFG1 Intro to CFGs</h3><p>一个CFG包括：</p>\n<ul>\n<li>终止符集合：T（输入符号）</li>\n<li>非终止符集合：N</li>\n<li>开始符号：S ∈ N</li>\n<li>规则集合</li>\n</ul>\n<p>应用规则：将规则左侧替换为规则右侧</p>\n<p>以开始符号S作为起始，对非终止符应用规则进行拓展，直到没有非终止符</p>\n<p>拓展过程可以化成一颗语法树，语法左侧为父节点</p>\n<p><strong>最右和最左推导</strong></p>\n<p>最右推导每次把最右边的非终止符应用规则拓展</p>\n<p>两者生成相同的语法树</p>\n<h3 id=\"CGF2-Ambiguity\"><a href=\"#CGF2-Ambiguity\" class=\"headerlink\" title=\"CGF2 Ambiguity\"></a>CGF2 Ambiguity</h3><p><strong>歧义</strong></p>\n<ul>\n<li>相同句子具有不同的语法树</li>\n<li>编程语言不能接受该歧义<ul>\n<li>无法确定给定的CFG是否有歧义</li>\n<li>一些CFG本质上是具有歧义的（不存在无歧义的CFG）</li>\n</ul>\n</li>\n</ul>\n<p><strong>处理歧义</strong></p>\n<ul>\n<li>重写语法</li>\n<li>使用优先级和关联性</li>\n</ul>\n<p><strong>关联性</strong></p>\n<p>对于以下语法：</p>\n<p>E -&gt; E + E<br>E -&gt; T<br>T -&gt; T * T<br>T -&gt; int</p>\n<p>通过左或右递归消除歧义：</p>\n<p>E -&gt; E + T<br>E -&gt; T<br>T -&gt; T * F<br>T -&gt; int</p>\n<p>（tips：考虑T+T+T的情况，使用前者会有歧义，后者没有（歧义指语法树不同））</p>\n<p><strong>yacc关联性定义</strong></p>\n<p>yacc中的关联性定义（不需要重新定义语法）</p>\n<p>对于：<code>E -&gt; E - E | int</code></p>\n<p>只需增加关联性定义<code>%left -</code></p>\n<p>等价于上面的<code>E -&gt; E + int E -&gt; int</code></p>\n<p><strong>yacc优先级定义</strong></p>\n<p>对于上面的语法，yacc中可以这样写：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">%left -\n%left &#x2F;\n\nE -&gt; E - E | E &#x2F; E | int</code></pre>\n\n<p>写在后面的关联性定义具有更高的优先级（在语法树的更底层）</p>\n<h3 id=\"CFG3-Push-down-Automata\"><a href=\"#CFG3-Push-down-Automata\" class=\"headerlink\" title=\"CFG3 Push-down Automata\"></a>CFG3 Push-down Automata</h3><p>对于每种regular语言有一个等效的FSA</p>\n<p>对一个CFG语言有一个等效的pushdown automaton(pda)</p>\n<p><strong>Push-down Automata</strong></p>\n<p>包含：</p>\n<ul>\n<li>字母表（终止符）</li>\n<li>栈符号（非终止符和终止符）</li>\n<li>一个fsa</li>\n<li>栈</li>\n</ul>\n<h2 id=\"Practice-Yacc（lost）\"><a href=\"#Practice-Yacc（lost）\" class=\"headerlink\" title=\"Practice Yacc（lost）\"></a>Practice Yacc（lost）</h2><p>蓝屏，笔记没了，不想补了</p>\n<h2 id=\"Week-5-Parsing-1\"><a href=\"#Week-5-Parsing-1\" class=\"headerlink\" title=\"Week 5 Parsing 1\"></a>Week 5 Parsing 1</h2><h3 id=\"LR1-Shift-Reduce-Parsing\"><a href=\"#LR1-Shift-Reduce-Parsing\" class=\"headerlink\" title=\"LR1 Shift-Reduce Parsing\"></a>LR1 Shift-Reduce Parsing</h3><p><strong>自顶向下 与 自底向上</strong></p>\n<p>自顶向下：按语法规则拓展</p>\n<p>自底向上：语法规则反向reduce</p>\n<p><strong>自底向上</strong></p>\n<p>reduce最右边的非终止符，即rightmost推导</p>\n<p><strong>Shift-Reduce</strong></p>\n<p>自底向上的过程，只有两种操作：shift、reduce</p>\n<p>shift对应于将待处理符号（输入的符号）入栈</p>\n<p>reduce按规则（语法右边）出栈，并入栈新的符号（语法左边）</p>\n<p><strong>冲突</strong></p>\n<p>过程中某一步可能会出现允许多种可能操作的情况（不考虑最终结果）</p>\n<ul>\n<li>同时允许shift、reduce：<ul>\n<li>可以修复（优先级、关联性）</li>\n</ul>\n</li>\n<li>同于允许不同的reduce：<ul>\n<li>可能语法本身具有歧义</li>\n<li>通过前瞻修复</li>\n</ul>\n</li>\n</ul>\n<p><strong>可行前缀 和 Handle</strong></p>\n<p>直觉：只执行能使我们到达起始符号的reduce</p>\n<p>（不太懂）</p>\n<p>handle总是在栈顶</p>\n<p><strong>自底向上 Shift-Reduce 语法分析算法</strong></p>\n<p>按算法可以处理的cfg语法集从大到小排序（上面的包含下面的）：</p>\n<ul>\n<li>LR(k)<ul>\n<li>L：从左到右扫描输入</li>\n<li>R：最右推导</li>\n<li>k：前瞻token数</li>\n</ul>\n</li>\n<li>LALR(k)</li>\n<li>SLR(k)：simple LR，类似LR(0)，但使用Follow sets</li>\n<li>LR(0)：0前瞻token</li>\n</ul>\n<h3 id=\"LR2-LR-0-Parsing\"><a href=\"#LR2-LR-0-Parsing\" class=\"headerlink\" title=\"LR2 LR(0) Parsing\"></a>LR2 LR(0) Parsing</h3><p><strong>LR 语法分析 概览</strong></p>\n<ul>\n<li>从终止符开始，寻找到起始符的路径</li>\n<li>应用 shift 和 reduce 操作（尽可能延迟决定）</li>\n<li>LR语法分析：<ul>\n<li>L：从左到右分析</li>\n<li>R：最右推导（自底向上）</li>\n</ul>\n</li>\n<li>LR(0) -&gt; SLR(1) -&gt; LR(1) -&gt; LALR(1)</li>\n</ul>\n<p><strong>操作</strong></p>\n<ul>\n<li>Shift<ul>\n<li>添加终止符到栈中</li>\n</ul>\n</li>\n<li>Reduce<ul>\n<li>如果栈顶是个可行前缀，则reduce</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"基于表的Shift-Reduce语法分析\"><a href=\"#基于表的Shift-Reduce语法分析\" class=\"headerlink\" title=\"基于表的Shift Reduce语法分析\"></a>基于表的Shift Reduce语法分析</h4><p><img src=\"E:\\documents\\note\\md\\src\\LR-table.jpg\"></p>\n<p>行号：状态</p>\n<p>列号：终止符 或 非终止符</p>\n<p>左边（终止符的列）是action表<br>右边（非终止符的列）是goto表</p>\n<p>一个栈存储状态</p>\n<p>表的使用：</p>\n<ol>\n<li>从输入读取一个字符（终止符）</li>\n<li>跟据栈顶状态<code>s</code>、读取的字符<code>t</code>查 <code>action[s, t]</code></li>\n</ol>\n<p>如果<code>action[s, t]</code> = S5（5是一个状态，图中红色例子）：</p>\n<ol start=\"3\">\n<li>将 5 入栈</li>\n</ol>\n<p>如果<code>action[s, t]</code> = R4（4是一条规则，图中浅蓝、深蓝例子）：</p>\n<ol start=\"3\">\n<li>查找规则 4 为 <code>F -&gt; (T)</code></li>\n<li>规则右边有3个符号，所以pop3次</li>\n<li>根据栈顶状态<code>s=0</code>、规则左边非终止符<code>n=&#39;F&#39;</code>，查<code>goto[s, n]=1</code></li>\n<li>将 <code>goto[s, n]=1</code> 入栈</li>\n</ol>\n<p>图中的表没有符号的格子代表语法错误</p>\n<p>图中的表<code>action[2, &#39;$&#39;]=A</code>代表到达起始符号，即语法解析成功</p>\n<h4 id=\"构建Action-Goto表的算法\"><a href=\"#构建Action-Goto表的算法\" class=\"headerlink\" title=\"构建Action/Goto表的算法\"></a>构建Action/Goto表的算法</h4><p><strong>配置集(Configuration/ item set)</strong></p>\n<ul>\n<li>每个集是一个语法状态</li>\n<li>使用点规则<ul>\n<li><code>T -&gt; T * • F</code></li>\n</ul>\n</li>\n<li>点在F之前，预测所有F在左边的规则<ul>\n<li><code>T -&gt; T * • F</code></li>\n<li><code>F -&gt; • ( T )</code></li>\n<li><code>F -&gt; • id</code></li>\n</ul>\n</li>\n<li>这创建了一个配置集（就是求<code>T -&gt; T * • F</code>的闭包）</li>\n</ul>\n<p><strong>起始配置集</strong></p>\n<ul>\n<li>用<code>S&#39;</code>扩充语法，添加一条规则<code>S&#39; -&gt; S</code></li>\n<li>求<code>closure(S&#39; -&gt; •  S)</code></li>\n</ul>\n<p>比如上述例子起始配置集<code>closure(S&#39; -&gt; • T)</code></p>\n<p><strong>后继 Successor(I, X)</strong></p>\n<p>意义：按符号X移动</p>\n<ol>\n<li>对于<code>I</code>中所有点后面为<code>X</code>的规则，点向右移动一位</li>\n<li>删除其余规则（没有移动的规则）</li>\n<li>计算（移动后的规则的）闭包</li>\n</ol>\n<p>得到的就是该后继配置集</p>\n<p><strong>实例</strong></p>\n<p><img src=\"E:\\documents\\note\\md\\src\\LR-table-2.jpg\"></p>\n<p>每个集合对应一个表中的状态（一行）<br>如果是终止符得到的后继（左边的列），则<code>action[I, t] = Successor(I, n) </code><br>如果是非终止符得到的后继（右边的列），则<code>goto[I, n] = Successor(I, t) </code></p>\n<p>其中有些集合有没有后继（点右边没有符号）的规则，则<code>action[I, 空着的t] = R</code><br>比如<code>action[1, 空着的t] = R1</code>、<code>action[4, 空着的t] = R2 </code><br>而集合2比较特殊，代表了成功结束，<code>action[2, &#39;$&#39;] = $Accept</code></p>\n<p>以计算集合3的后继为例，<code>Successor(I3, &#39;(&#39;)</code>：</p>\n<ol>\n<li>集合3中点后面为<code>(</code>的只有一条规则（集合3中红色标记）</li>\n<li>移动规则的点（集合5中红色标记的第一条规则）</li>\n<li>计算闭包<ol>\n<li>现在只有一条<code>F -&gt; ( • T )</code>，添加<code>T</code>在左边的规则到集合中（橙色左括号）</li>\n<li>现在新增了<code>F</code>和<code>T</code>，<code>T</code>已经找过，添加<code>F</code>在左边的规则（黄色括号）</li>\n<li>现在新增了<code>id</code>、<code>(</code>，没有这两者在左边的规则</li>\n<li>计算闭包完毕</li>\n</ol>\n</li>\n<li>该闭包即是<code>I5 = Successor(I3, &#39;(&#39;)</code></li>\n</ol>\n<p>集合5的后继有<code>T</code>、<code>F</code>、<code>id</code>、<code>(</code></p>\n<p>假设按深度优先，接着计算<code>Successor(I5, &#39;T&#39;)</code>，和上面的步骤一样：</p>\n<ol>\n<li>选择集合5中点后面为<code>T</code>的所有规则，移动点构成新集合</li>\n<li>得到<code>&#123;F -&gt; ( T • ), T -&gt; T • * F&#125;</code></li>\n<li>计算该集合的闭包<ol>\n<li>点后面有<code>)</code>、<code>*</code>，分别找出规则左边为这两符号的规则</li>\n<li>刚好都没有，计算闭包完毕</li>\n</ol>\n</li>\n<li>该闭包即是<code>I6 = Successor(I5, &#39;T&#39;) </code></li>\n</ol>\n<p>构建表的伪代码（广度优先）：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function items(G’)\n    C &#x3D; &#123; closure(&#123;S’ -&gt; • S&#125;) &#125;; &#x2F;&#x2F; C &#x3D; &#123;起始配置集&#125;\n    do foreach I ∈ C do &#x2F;&#x2F; 遍历C中新添加的配置集\n        foreach X ∈ (N ∪ T) do &#x2F;&#x2F; 遍历集的所有后继\n        \tC &#x3D; C ∪ &#123; Successor(I, X) &#125;; &#x2F;&#x2F; 添加后继配置集到C中（去重）\n    while C changes;</code></pre>\n\n\n\n<p><strong>冲突</strong></p>\n<p>R/N（不构成冲突）：</p>\n<p>集合中有点右边为非终止符的规则（对应非终止符后继），也有点右边什么都没有的规则（对应reduce）</p>\n<p>reduce规则一定是前者求闭包得到的（reduce求闭包就是reduce本身）</p>\n<p>action表（终止符后继）填充reduce，goto表（非终止符后继）填充对应后继</p>\n<p>R/R 冲突：</p>\n<p>集合中有一个以上的点右边什么都没有的规则（对应多个reduce）</p>\n<p>R/T（未定义的行为）：</p>\n<p>（这解决方式不在LR(0)的定义中）对于action表（终止符列），有后继的填后继，没有后继的，填充R</p>\n<h2 id=\"Week-6-Parsing-2\"><a href=\"#Week-6-Parsing-2\" class=\"headerlink\" title=\"Week 6 Parsing 2\"></a>Week 6 Parsing 2</h2><h3 id=\"LR3-SLR-1-Parsing\"><a href=\"#LR3-SLR-1-Parsing\" class=\"headerlink\" title=\"LR3 SLR(1) Parsing\"></a>LR3 SLR(1) Parsing</h3><p>LR(0)：action[s, 空着t] = R</p>\n<p>SLR(1)：action[s, follow(L)] = R，（L是规则的左边）解决部分冲突</p>\n<p><strong>终止符集合：</strong></p>\n<ul>\n<li><p>First(N)：非终止符拓展的序列中，第一个的可能取值</p>\n</li>\n<li><p>Follow(N)：非终止符下一个可能的取值</p>\n<ul>\n<li>S是起始符，$ ∈ FOLLOW(S)</li>\n<li>X -&gt; …Aa…，Follow(A)包括a</li>\n<li>X -&gt; …AB…，Follow(A)包括First(B)</li>\n<li>X -&gt; …A，Follow(A)包括Follow(X)</li>\n</ul>\n</li>\n</ul>\n<p>​    </p>\n<p><strong>SLR(1)</strong></p>\n<p>增加了检测follow的约束，只有满足follow的才会reduce，否则shift</p>\n<h3 id=\"LR4-LR-1-Parsing\"><a href=\"#LR4-LR-1-Parsing\" class=\"headerlink\" title=\"LR4 LR(1) Parsing\"></a>LR4 LR(1) Parsing</h3><p>LR(1)解决R/T，R/R冲突</p>\n<p>SLR(1)中可能存在follow(L)（Reduce）和shift（T）重合的情况</p>\n<p>也可能存在两个不同L的follow相同的情况（RR冲突）</p>\n<p>解决办法改变Follow的计算方法，同一个L，在不同闭包中的Follow是独立的</p>\n<p>计算闭包时，把新L在旧R中后一个符号作为Follow(L)，并记录下来</p>\n<p>例子1：</p>\n<p>S -&gt; • Aa, $<br>A -&gt; • e, a</p>\n<p>第二条从第一条拓展而来，第一条中A的后一个符号是a，则Follow(A)=a</p>\n<p>例子2：</p>\n<p>S -&gt; • A, =/$<br>A -&gt; • e, =/$</p>\n<p>第二条从第一条拓展而来，第一条中A是规则右边的最后一个符号，则Follow(A) = Follow(S) = {=, $}</p>\n<p><img src=\"E:\\documents\\note\\md\\src\\LR1-table.png\"></p>\n<p>图中闭包0，标1的红色箭头就是按例子1的方式计算的follow<br>标2的绿色和橙色箭头就是按例子2的方式继承自前一条规则的follow</p>\n<h3 id=\"LR5-Precedence-and-Associativity\"><a href=\"#LR5-Precedence-and-Associativity\" class=\"headerlink\" title=\"LR5 Precedence and Associativity\"></a>LR5 Precedence and Associativity</h3><p>优先级高的先reduce</p>\n<p>比如<code>*</code>优先级高于<code>+</code>，当前栈中为<code>E+E</code>，预览下一个符号，如果为优先级更高的<code>*</code>则shift，如果下一个符号优先级更低就reduce</p>\n<p>yacc/bison中使用%left、%right的列表来处理优先级（列表中的先后）和关联性（left还是right）</p>\n","text":"SFU Compilers 笔记 3 语法分析1w4 p:yacc w5 w6 Week 4 Context-Free Grammars（lost）CFG1 Intro to CFGs一个CFG包括： 终止符集合：T（输入符号） 非终止符集合：N 开始符号：S ∈ N 规则集合 ...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"CS","slug":"CS","count":4,"path":"api/categories/CS.json"}],"tags":[{"name":"note","slug":"note","count":23,"path":"api/tags/note.json"},{"name":"cs","slug":"cs","count":4,"path":"api/tags/cs.json"},{"name":"compiler","slug":"compiler","count":4,"path":"api/tags/compiler.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SFU-Compilers-%E7%AC%94%E8%AE%B0-3-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%901\"><span class=\"toc-text\">SFU Compilers 笔记 3 语法分析1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Week-4-Context-Free-Grammars%EF%BC%88lost%EF%BC%89\"><span class=\"toc-text\">Week 4 Context-Free Grammars（lost）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CFG1-Intro-to-CFGs\"><span class=\"toc-text\">CFG1 Intro to CFGs</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CGF2-Ambiguity\"><span class=\"toc-text\">CGF2 Ambiguity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CFG3-Push-down-Automata\"><span class=\"toc-text\">CFG3 Push-down Automata</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Practice-Yacc%EF%BC%88lost%EF%BC%89\"><span class=\"toc-text\">Practice Yacc（lost）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Week-5-Parsing-1\"><span class=\"toc-text\">Week 5 Parsing 1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LR1-Shift-Reduce-Parsing\"><span class=\"toc-text\">LR1 Shift-Reduce Parsing</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LR2-LR-0-Parsing\"><span class=\"toc-text\">LR2 LR(0) Parsing</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E%E8%A1%A8%E7%9A%84Shift-Reduce%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90\"><span class=\"toc-text\">基于表的Shift Reduce语法分析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BAAction-Goto%E8%A1%A8%E7%9A%84%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">构建Action&#x2F;Goto表的算法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Week-6-Parsing-2\"><span class=\"toc-text\">Week 6 Parsing 2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LR3-SLR-1-Parsing\"><span class=\"toc-text\">LR3 SLR(1) Parsing</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LR4-LR-1-Parsing\"><span class=\"toc-text\">LR4 LR(1) Parsing</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LR5-Precedence-and-Associativity\"><span class=\"toc-text\">LR5 Precedence and Associativity</span></a></li></ol></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"B站x64内核笔记1","uid":"368d5d02963b1ddd739fe7288ce34859","slug":"zh-x64krnl","date":"2022-05-17T04:00:00.000Z","updated":"2022-09-26T10:26:34.355Z","comments":true,"path":"api/articles/zh-x64krnl.json","keywords":null,"cover":null,"text":"IA_32eExtended Feature Enable Register（IA32_EFER，MSR[0xC0000080]） vol-3a p69 2.2.1 Extended Feature Enable Register ![](E:\\documents\\note\\md...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"Windows","slug":"Windows","count":19,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":19,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":23,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":5,"path":"api/tags/kernel.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"SFU Compilers class 笔记2","uid":"b8be4bf58b4cb3abe70be3d848e17901","slug":"SFU-Compilers-2","date":"2022-03-15T04:00:00.000Z","updated":"2022-07-10T14:24:40.269Z","comments":true,"path":"api/articles/SFU-Compilers-2.json","keywords":null,"cover":[],"text":"SFU Compilers 笔记2 词法分析week2 wee3 p-lex hw1 Week 2 Lexical Analysis 1LEX1 Intro to Regexps词法分析 将字符串转成tokens Token Attributes 具有属性的例子：T_IDENT ...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"CS","slug":"CS","count":4,"path":"api/categories/CS.json"}],"tags":[{"name":"note","slug":"note","count":23,"path":"api/tags/note.json"},{"name":"cs","slug":"cs","count":4,"path":"api/tags/cs.json"},{"name":"compiler","slug":"compiler","count":4,"path":"api/tags/compiler.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}