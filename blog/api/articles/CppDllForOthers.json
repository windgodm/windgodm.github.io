{"title":"CPP编写类库给其他语言使用的总结","uid":"76983b1b7b5d8ab212f2ed6fe2f81e66","slug":"CppDllForOthers","date":"2021-04-22T17:05:59.000Z","updated":"2021-06-19T07:20:55.468Z","comments":true,"path":"api/articles/CppDllForOthers.json","keywords":null,"cover":null,"content":"<h1 id=\"CPP编写类库给其他语言使用\"><a href=\"#CPP编写类库给其他语言使用\" class=\"headerlink\" title=\"CPP编写类库给其他语言使用\"></a>CPP编写类库给其他语言使用</h1><p>主要是使用vs2019作为ide，cpp为语言编写类库，然后编译成dll，供其他cpp、c#、python等语言的工程调用类库。目的是一次编写与编译某个类库，然后给多语言使用。</p>\n<p>这里是个傻瓜式操作总结贴（我总是忘记细节emm），总结网上及书里提供的一些方法，尽量用简单的方式实现目的。</p>\n<h2 id=\"用cpp写类库（VS2019）\"><a href=\"#用cpp写类库（VS2019）\" class=\"headerlink\" title=\"用cpp写类库（VS2019）\"></a>用cpp写类库（VS2019）</h2><h3 id=\"类库项目\"><a href=\"#类库项目\" class=\"headerlink\" title=\"类库项目\"></a>类库项目</h3><h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>直接新建空白项目，然后在项目属性页中进行如下配置：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>常规-常规属性-配置类型：动态库(.dll)</p></blockquote>\n<h4 id=\"代码框架\"><a href=\"#代码框架\" class=\"headerlink\" title=\"代码框架\"></a>代码框架</h4><p>下面给出项目的框架。直接编译就可以得到MyDll.dll</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n* 项目（MyDll）：头文件：MyDll.h\n*&#x2F;\n#pragma once\n#ifndef MYDLL_H\n#define MYDLL_H\n\n&#x2F;&#x2F; 这里是输出的函数\n_declspec(dllexport) int Add(int a, int b);\n\n&#x2F;&#x2F; 这里是输出的类\nclass _declspec(dllexport) MyClass\n&#123;\nprivate:\n    int a[2];\npublic:\n    MyClass();\n    ~MyClass();\n    int Set(int index, int x);\n&#125;\n\n#endif &#x2F;&#x2F; !MYDLL_H</code></pre>\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n* 项目（MyDll）：源文件：MyDll.cpp\n*&#x2F;\n#include &quot;MyDll.h&quot;\n\n&#x2F;&#x2F; 实现头文件中的函数\nint Add(int a, int b)\n&#123;\n    return a + b;\n&#125;\n\n&#x2F;&#x2F; 实现头文件中类的函数\nMyClass::MyClass()\n&#123;\n    a[0] &#x3D; 1;\n    a[1] &#x3D; 0;\n&#125;\n\nMyClass::~MyClass()\n&#123;\n&#125;\n\nint MyClass::Set(int index, int x)\n&#123;\n    a[index] &#x3D; x;\n    return a[0] + a[1];\n&#125;</code></pre>\n\n<h3 id=\"添加类库对应的共享项目\"><a href=\"#添加类库对应的共享项目\" class=\"headerlink\" title=\"添加类库对应的共享项目\"></a>添加类库对应的共享项目</h3><p>这一步的目的主要是为了解决<strong>调用类库项目</strong>和<strong>类库项目</strong> <strong>不在同一个解决方案</strong>的情况。</p>\n<p>在同一个解决方案中，新建一个<strong>共享项目</strong>项目，然后在<strong>解决方案资源管理器</strong>-<strong>共享项目</strong>上右键<strong>添加</strong>-<strong>添加现有项</strong>，找到MyDll.h、MyDll.cpp添加进去。</p>\n<h2 id=\"cpp项目-调用-cpp写的类库（VS2019）\"><a href=\"#cpp项目-调用-cpp写的类库（VS2019）\" class=\"headerlink\" title=\"cpp项目 调用 cpp写的类库（VS2019）\"></a>cpp项目 调用 cpp写的类库（VS2019）</h2><h3 id=\"方案一：隐式链接\"><a href=\"#方案一：隐式链接\" class=\"headerlink\" title=\"方案一：隐式链接\"></a>方案一：隐式链接</h3><ul>\n<li><p><strong>添加引用：</strong><br>在<strong>解决方案资源管理器</strong>中<strong>你的cpp项目</strong>的<strong>引用</strong>处右键选择<strong>添加引用</strong></p>\n<ul>\n<li>cpp项目和dll项目在<strong>同一个解决方案</strong>：<br>然后在弹出窗口的左侧菜单选择<strong>项目</strong>-<strong>解决方案</strong>，然后找到刚刚写好的<strong>dll项目</strong>，点击勾选框。</li>\n<li>两者不在同一个解决方案：<br>先参考<strong>cpp写类库</strong>-<strong>配置共享项目</strong>配置好，然后在弹出窗口的左侧菜单选择<strong>共享的项目</strong>-<strong>解决方方案</strong>，找到<strong>dll项目对应的共享项目</strong>，点击勾选框。</li>\n</ul>\n</li>\n<li><p><strong>包含头文件</strong>：通过相对或绝对<strong>路径引用</strong>dll项目的头文件。</p>\n</li>\n</ul>\n<h3 id=\"方案二：显示链接\"><a href=\"#方案二：显示链接\" class=\"headerlink\" title=\"方案二：显示链接\"></a>方案二：显示链接</h3><p>没有需求，所以还没有测试这种方案这么处理比较方便。// todo</p>\n<h2 id=\"C-（WPF）项目-调用-cpp写的类库（vs2019）\"><a href=\"#C-（WPF）项目-调用-cpp写的类库（vs2019）\" class=\"headerlink\" title=\"C#（WPF）项目 调用 cpp写的类库（vs2019）\"></a>C#（WPF）项目 调用 cpp写的类库（vs2019）</h2><p>我的情况是涉及一个大量使用指针的类。通过一个托管类把类的函数都暴露出来，实际上就是在托管类中做一个跳转，有时候还需要在这个跳转的函数中做c#和c++间的类型转换。</p>\n<p>流程大概是先写个托管类，然后再在wpf项目中导入。</p>\n<p>需要<strong>注意</strong>的是，Debug调试时，应该把 MyDll.dll 放到WPF的 /bin/Debug 目录中，原因是 MyDllCSWrapper.dll 需要导入 MyDll.dll。所以需要把 <strong>MyDll.dll</strong> 放到项目的<strong>可执行文件的根目录</strong>（当然系统目录啥的好像也行）。<br>至于MyDllCSWrapper.dll放哪里都行，c#中ImportDll的路径填对就行。</p>\n<h3 id=\"托管类\"><a href=\"#托管类\" class=\"headerlink\" title=\"托管类\"></a>托管类</h3><p>首先参考“用cpp写类库”新建一个项目写托管。</p>\n<p>这里直接给出托管类代码框架，原型类参考前面“用cpp写类库”。</p>\n<p>这里MyDll.h中的Add不是类中的函数，我没有这个需求没有去研究，不确定该如何暴露，欢迎补充。// todo</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n* 项目（MyDllCSWrapper）：头文件：MyDllCSWrapper.h\n*&#x2F;\n#pragma once\n\n&#x2F;&#x2F; 这里通过相对或绝对路径引用MyDll的头文件\n#include &quot;..&#x2F;MyDll&#x2F;MyDll.h&quot;\n\nnamespace MyDllCSWrapper\n&#123;\n\textern &quot;C&quot; __declspec(dllexport) int Set(int index, int x);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\n* 项目（MyDllCSWrapper）：源文件：MyDllCSWrapper.cpp\n*&#x2F;\n#include &quot;MyDllCSWrapper.h&quot;\n\nnamespace MyDllCSWrapper\n&#123;\n\tMyClass* pmc &#x3D; new MyClass();\n\n\tint Set(int index, int x)\n\t&#123;\n\t\treturn ppe-&gt;Set(index, x);\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>c++中的类型与c#不是完全对应的。int、double、float啥的好像是一一对应的，但指针就不一定了，要小心处理。</p>\n<p>我遇到的一个特殊情况就是我需要传递一个数组过去，c#中使用类型 char[]、ref char[] 只能传递第一个元素过去。需要使用 byte[] 才行。</p>\n<p>下面是我遇到一些的情况。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>c++类型 —- c# 类型</p>\n<p>unsigned int、unsigned long、DWORD —- uint</p>\n<p>char*（数组）—- byte[]</p></blockquote>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><p>暂时没有需求，没有了解，可能下个星期就会需要。// todo</p>\n","text":"CPP编写类库给其他语言使用主要是使用vs2019作为ide，cpp为语言编写类库，然后编译成dll，供其他cpp、c#、python等语言的工程调用类库。目的是一次编写与编译某个类库，然后给多语言使用。 这里是个傻瓜式操作总结贴（我总是忘记细节emm），总结网上及书里提供的一些...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"Programing","slug":"Programing","count":2,"path":"api/categories/Programing.json"}],"tags":[{"name":"dll","slug":"dll","count":4,"path":"api/tags/dll.json"},{"name":"Programing","slug":"Programing","count":2,"path":"api/tags/Programing.json"},{"name":"cpp","slug":"cpp","count":1,"path":"api/tags/cpp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CPP%E7%BC%96%E5%86%99%E7%B1%BB%E5%BA%93%E7%BB%99%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">CPP编写类库给其他语言使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8cpp%E5%86%99%E7%B1%BB%E5%BA%93%EF%BC%88VS2019%EF%BC%89\"><span class=\"toc-text\">用cpp写类库（VS2019）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%BA%93%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">类库项目</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">配置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">代码框架</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%BA%93%E5%AF%B9%E5%BA%94%E7%9A%84%E5%85%B1%E4%BA%AB%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">添加类库对应的共享项目</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cpp%E9%A1%B9%E7%9B%AE-%E8%B0%83%E7%94%A8-cpp%E5%86%99%E7%9A%84%E7%B1%BB%E5%BA%93%EF%BC%88VS2019%EF%BC%89\"><span class=\"toc-text\">cpp项目 调用 cpp写的类库（VS2019）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">方案一：隐式链接</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E6%98%BE%E7%A4%BA%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">方案二：显示链接</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-%EF%BC%88WPF%EF%BC%89%E9%A1%B9%E7%9B%AE-%E8%B0%83%E7%94%A8-cpp%E5%86%99%E7%9A%84%E7%B1%BB%E5%BA%93%EF%BC%88vs2019%EF%BC%89\"><span class=\"toc-text\">C#（WPF）项目 调用 cpp写的类库（vs2019）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%98%E7%AE%A1%E7%B1%BB\"><span class=\"toc-text\">托管类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">类型转换</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Python\"><span class=\"toc-text\">Python</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"games101笔记","uid":"f95e71ca907bcbbc367beb658acddc27","slug":"games101Note","date":"2021-05-24T14:12:26.000Z","updated":"2021-08-11T08:58:54.949Z","comments":true,"path":"api/articles/games101Note.json","keywords":null,"cover":null,"text":"games101-5 games 101 note ","link":"","photos":[],"count_time":{"symbolsCount":26,"symbolsTime":"1 mins."},"categories":[{"name":"ComputerGraphics","slug":"ComputerGraphics","count":1,"path":"api/categories/ComputerGraphics.json"}],"tags":[{"name":"note","slug":"note","count":19,"path":"api/tags/note.json"},{"name":"ComputerGraphics","slug":"ComputerGraphics","count":1,"path":"api/tags/ComputerGraphics.json"},{"name":"持续更新","slug":"持续更新","count":1,"path":"api/tags/持续更新.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"21虎符CTF-RE-wp","uid":"60af909abdc466137935eaab74c3cdbb","slug":"HufuCtfReWp","date":"2021-04-15T14:04:21.000Z","updated":"2021-09-28T10:21:59.923Z","comments":true,"path":"api/articles/HufuCtfReWp.json","keywords":null,"cover":null,"text":"虎符 2021 REre1mips架构什么的，完全不了解，溜了 gocrypt是个go语言程序 里面有个encodeing_hex_Decode，作用是string转hex（”b0a0” =&gt; [0xa0, 0xb0]）第7个参数是dest第10个参数是source第11个...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"CTF","slug":"CTF","count":7,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":7,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":10,"path":"api/tags/re.json"},{"name":"wp","slug":"wp","count":7,"path":"api/tags/wp.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}