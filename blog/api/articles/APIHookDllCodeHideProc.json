{"title":"APIHook DLL注入实现代码钩取 笔记","uid":"5e05a9de597a39befc3bd53d02dc7c56","slug":"APIHookDllCodeHideProc","date":"2021-06-24T06:44:00.000Z","updated":"2021-09-28T10:22:14.123Z","comments":true,"path":"api/articles/APIHookDllCodeHideProc.json","keywords":null,"cover":null,"content":"<h1 id=\"APIHook-DLL注入实现代码钩取-笔记\"><a href=\"#APIHook-DLL注入实现代码钩取-笔记\" class=\"headerlink\" title=\"APIHook - DLL注入实现代码钩取 笔记\"></a>APIHook - DLL注入实现代码钩取 笔记</h1><h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>技术摘要：</p>\n<p><strong>动态</strong>修改<strong>进程内存</strong>中的<strong>代码</strong>。利用<strong>DLL注入</strong>修改代码开头跳转到补丁代码。</p></blockquote>\n<p>起源是逆向工程核心原理里面以任务管理器ZwQuerySystemInformation()API钩取为例讲解利用dll注入修改api的起始代码为jmp实现api钩取。<br>该例子目标是隐藏某个进程。</p>\n<p>大概流程如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">调用者:\n1: call api\napi:\n2: jmp patch\npatch:\n3: unhook\n4: call api（正常执行api功能）\n5: hook\n6: patch\n7: retn 到调用者</code></pre>\n\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><p>有一些未公开的函数或者枚举类型一定要找尽可能正确的。可能因为资料的不正确导致钩取失败或没有效果。如果出现问题，要对比正常流程看钩取后传递的参数是否符合预期，一些标志位的设置是否正确。</p>\n<p>不可避免的一个问题是会出现<strong>漏网之鱼</strong>，也就unhook期间原api被调用会暴露隐藏进程。我在测试时遇到过隐藏进程突然在任务管理器中闪出来几下的情况。</p>\n<p>隐藏进程实际上是修改了ZwQuerySystemInformation返回的一个包含进程信息的链表，如果要隐藏的进程在链表中排第一个的话会出错，原因详见 实例 中。而实际中似乎链表的第一个一定是System(进程号为4)，随后是Registry和svchost。所以只有不隐藏System这个进程就不会有问题。</p>\n<h2 id=\"实例：隐藏进程ZwQuerySystemInformation-（x64）\"><a href=\"#实例：隐藏进程ZwQuerySystemInformation-（x64）\" class=\"headerlink\" title=\"实例：隐藏进程ZwQuerySystemInformation()（x64）\"></a>实例：隐藏进程ZwQuerySystemInformation()（x64）</h2><p>该例子对象是任何直接或间接使用了ZwQuerySystemInformation查询进程信息的64位程序，比如任务管理器。</p>\n<p>下面的步骤按运行时的执行顺序来写。</p>\n<h3 id=\"1-dll注入\"><a href=\"#1-dll注入\" class=\"headerlink\" title=\"1 dll注入\"></a>1 dll注入</h3><p>第一步是把后面编写好的dll注入到目标程序中，关于dll注入的内容在此略过。</p>\n<h3 id=\"2-dll\"><a href=\"#2-dll\" class=\"headerlink\" title=\"2 dll\"></a>2 dll</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#pragma comment(linker, &quot;&#x2F;SECTION:.SHARE,RWS&quot;)\n#pragma data_seg(&quot;.SHARE&quot;)\nwchar_t g_wszProcName[MAX_PATH] &#x3D; &#123; 0, &#125;;\n#pragma data_seg()\n\nvoid SetProcName(LPCTSTR wszProcName)\n&#123;\n    wcscpy_s(g_wszProcName, wszProcName);\n&#125;\n\nBOOL APIENTRY DllMain(HMODULE hModule,\n    DWORD  ul_reason_for_call,\n    LPVOID lpReserved\n)\n&#123;\n    char pszCurProc[MAX_PATH] &#x3D; &#123; 0, &#125;;\n    char* p &#x3D; NULL;\n\n    &#x2F;&#x2F; check\n    GetModuleFileNameA(NULL, pszCurProc, MAX_PATH);\n    p &#x3D; strrchr(pszCurProc, &#39;\\\\&#39;);\n    if ((p !&#x3D; NULL) &amp;&amp; !_stricmp(p + 1, &quot;remote_inject_x64.exe&quot;))\n        return TRUE;\n\n    switch (ul_reason_for_call) &#123;\n    case DLL_PROCESS_ATTACH:\n        &#x2F;&#x2F; set\n        SetProcName(L&quot;notepad.exe&quot;);\n        &#x2F;&#x2F; get api\n        hApi &#x3D; GetProcAddress(GetModuleHandleW(pwszDllName), &quot;ZwQuerySystemInformation&quot;);\n        &#x2F;&#x2F; hook\n        hook_by_5b_code(pszDllName, hApi, (PROC)MyZwQuerySystemInformation);\n        break;\n    case DLL_PROCESS_DETACH:\n        &#x2F;&#x2F;unhook\n        unhook_by_5b_code(pszDllName, hApi);\n        break;\n    &#125;\n    return TRUE;\n&#125;</code></pre>\n\n<p>这里就是普通的dll，加载时钩取、卸载时脱钩。在加载时还会获取目标api的地址，以及设置要隐藏的dll名称。设置隐藏dll名称这一步可以换到别的地方设置。因为保存隐藏dll名称的变量是个共享变量，所以完全可以再写一个程序复制管理这个共享变量。只需要在管理程序中主动加载该dll，然后调用导出的SetProcName()即可，可以实现动态改变隐藏目标。当然也可以拓展代码实现隐藏多个不同名进程或按pid隐藏等。（这里SetProcName定义在dll的头文件中）</p>\n<h3 id=\"3-hook-by-5bytes-code\"><a href=\"#3-hook-by-5bytes-code\" class=\"headerlink\" title=\"3 hook by 5bytes code\"></a>3 hook by 5bytes code</h3><p>hook_by_5b_code函数修改api开头的5字节内容，改成jmp指令。32和64的jmp都是e9+4字节的相对偏移，这个相对偏移是以jmp下一条指令的地址作为起始地址来计算的，具体见下面的代码。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bool hook_by_5b_code(char* pszDllName, HANDLE api, PROC newApi)\n&#123;\n    DWORD dwOldProtect;\n    byte pNewBytes[5] &#x3D; &#123; 0xE9, 0, &#125;;\n    DWORD jmpOffset;\n\n    VirtualProtect(api, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\n    if (((PBYTE)api)[0] &#x3D;&#x3D; 0xE9)\n        return false;\n\n    &#x2F;&#x2F; bak origin byte\n    memcpy(pOriginBytes, api, 5);\n\n    &#x2F;&#x2F; count jmp offset\n    jmpOffset &#x3D; (DWORD)((size_t)newApi - (size_t)api - 5);\n\n    &#x2F;&#x2F; e9 offset(4bytes)\n    memcpy(&amp;pNewBytes[1], &amp;jmpOffset, 4);\n\n    &#x2F;&#x2F; hook\n    memcpy(api, pNewBytes, 5);\n\n    VirtualProtect(api, 9, dwOldProtect, &amp;dwOldProtect);\n\n    return true;\n&#125;</code></pre>\n\n<p>unhook就是恢复api原始字节即可。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bool unhook_by_5b_code(char* pszDllName, HANDLE api)\n&#123;\n    DWORD dwOldProtect;\n\n    VirtualProtect(api, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\n    if (((PBYTE)api)[0] !&#x3D; 0xE9)\n        return false;\n\n    &#x2F;&#x2F; unhook\n    memcpy(api, pOriginBytes, 5);\n\n    VirtualProtect(api, 5, dwOldProtect, &amp;dwOldProtect);\n\n    return true;\n&#125;</code></pre>\n\n<h3 id=\"新api（补丁代码-ZwQuerySystemInformation）\"><a href=\"#新api（补丁代码-ZwQuerySystemInformation）\" class=\"headerlink\" title=\"新api（补丁代码 ZwQuerySystemInformation）\"></a>新api（补丁代码 ZwQuerySystemInformation）</h3><p>1~4对应摘要中的3~6，具体看代码及注释。在执行patch之前会检测返回值判断调用原api是否成功，以及判断此次调用是否为查询进程信息。</p>\n<p>PSYSTEM_PROCESS_INFORMATION结构是一个链表，具体遍历方式参考代码即可。</p>\n<p>SYSTEM_INFORMATION_CLASS是一个枚举类型，说明函数SystemInformation这个参数的类似是什么。如果 SystemInformationClass == SystemProcessorInformation(5) 即代表SystemInformation类型为PSYSTEM_PROCESS_INFORMATION。</p>\n<p>可以看到代码中没有对链表第一个元素做特殊处理，这里算是一个不会产生太大影响的bug。如果要隐藏的进程在链表的第一个位置，此时prev和cur指向的都是第一个元素，执行操作以后会错误修改第一个元素的next偏移，导致无法正确找到第二个元素，同时也没有隐藏第一个。实际中第一个元素好像一般为System进程，只要不隐藏这个一般不会触发问题。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">typedef struct _SYSTEM_PROCESS_INFORMATION &#123;\n\tULONG NextEntryOffset;\n\tULONG NumberOfThreads;\n\tBYTE Reserved1[48];\n\tPVOID Reserved2[3];\n\tHANDLE UniqueProcessId;\n\tPVOID Reserved3;\n\tULONG HandleCount;\n\tBYTE Reserved4[4];\n\tPVOID Reserved5[11];\n\tSIZE_T PeakPagefileUsage;\n\tSIZE_T PrivatePageCount;\n\tLARGE_INTEGER Reserved6[6];\n&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;\n\nNTSTATUS WINAPI MyZwQuerySystemInformation(\n    _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,\n    _Inout_   PVOID                    SystemInformation,\n    _In_      ULONG                    SystemInformationLength,\n    _Out_opt_ PULONG                   ReturnLength\n)\n&#123;\n    NTSTATUS nts;\n\n    &#x2F;&#x2F; 1: unhook\n    unhook_by_5b_code(pszDllName, hApi);\n\n    &#x2F;&#x2F; 2: call origin api\n    nts &#x3D; ((ZwQuerySystemInformation)hApi)(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);\n\n    &#x2F;&#x2F; 3: hook\n    hook_by_5b_code(pszDllName, hApi, (PROC)MyZwQuerySystemInformation);\n\n    &#x2F;&#x2F; SystemProcessorInformation(5)\n    if ((nts !&#x3D; CMC_STATUS_SUCCESS) || SystemInformationClass !&#x3D; 5) &#123;\n        return nts;\n    &#125;\n\n    &#x2F;&#x2F; 4: patch: hide\n    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;\n    pCur &#x3D; (PSYSTEM_PROCESS_INFORMATION)SystemInformation;\n    pPrev &#x3D; pCur; &#x2F;&#x2F; warning\n    while (1) &#123;\n        &#x2F;&#x2F; hide\n        if (pCur-&gt;Reserved2[1] !&#x3D; NULL) &#123;\n            if (_wcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_wszProcName) &#x3D;&#x3D; 0) &#123;\n                if (pCur-&gt;NextEntryOffset &#x3D;&#x3D; 0)\n                    pPrev-&gt;NextEntryOffset &#x3D; 0;\n                else\n                    pPrev-&gt;NextEntryOffset +&#x3D; pCur-&gt;NextEntryOffset;\n            &#125;\n            else &#123;\n                pPrev &#x3D; pCur;\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; break\n        if (pCur-&gt;NextEntryOffset &#x3D;&#x3D; 0)\n            break;\n\n        &#x2F;&#x2F; next\n        pCur &#x3D; (PSYSTEM_PROCESS_INFORMATION)((size_t)pCur + (size_t)pCur-&gt;NextEntryOffset);\n    &#125;\n    \n    return nts;\n&#125;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>逆向工程核心原理：part4-API钩取：第33章-隐藏进程</p>\n","text":"APIHook - DLL注入实现代码钩取 笔记摘要 技术摘要： 动态修改进程内存中的代码。利用DLL注入修改代码开头跳转到补丁代码。 起源是逆向工程核心原理里面以任务管理器ZwQuerySystemInformation()API钩取为例讲解利用dll注入修改api的起始代码为...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"Windows","slug":"Windows","count":13,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":13,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":13,"path":"api/tags/note.json"},{"name":"api_hook","slug":"api-hook","count":3,"path":"api/tags/api-hook.json"},{"name":"reversecore","slug":"reversecore","count":4,"path":"api/tags/reversecore.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#APIHook-DLL%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%92%A9%E5%8F%96-%E7%AC%94%E8%AE%B0\"><span class=\"toc-text\">APIHook - DLL注入实现代码钩取 笔记</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%91%98%E8%A6%81\"><span class=\"toc-text\">摘要</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">细节</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8BZwQuerySystemInformation-%EF%BC%88x64%EF%BC%89\"><span class=\"toc-text\">实例：隐藏进程ZwQuerySystemInformation()（x64）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-dll%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">1 dll注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-dll\"><span class=\"toc-text\">2 dll</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-hook-by-5bytes-code\"><span class=\"toc-text\">3 hook by 5bytes code</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B0api%EF%BC%88%E8%A1%A5%E4%B8%81%E4%BB%A3%E7%A0%81-ZwQuerySystemInformation%EF%BC%89\"><span class=\"toc-text\">新api（补丁代码 ZwQuerySystemInformation）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"HammingCode","uid":"9a514a805495433f4105a5ad7faec5ce","slug":"HammingCode","date":"2021-07-14T04:00:00.000Z","updated":"2021-08-11T08:56:20.570Z","comments":true,"path":"api/articles/HammingCode.json","keywords":null,"cover":null,"text":"Hamming Code思路多次奇偶校验，下标为2n的位作为奇偶校验位，校验对象为所有位中小标第n位为1的位，显然包括了一半的数据。 第0位一般弃置，或者作为奇偶校验位的奇偶校验位，这样就可以判断是否存在多个错误。 每一个奇偶校验位都校验了一半的数据，通过检测哪些校验位是错的即可...","link":"","photos":[],"count_time":{"symbolsCount":554,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":1,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"note","slug":"note","count":13,"path":"api/tags/note.json"},{"name":"Error_Correction","slug":"Error-Correction","count":1,"path":"api/tags/Error-Correction.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"APIHook DLL注入实现IAT钩取 笔记","uid":"cc4abc1dfb3fac0a8ab6b7033be4ca99","slug":"APIHookDllIATCalc","date":"2021-06-19T06:22:00.000Z","updated":"2021-09-28T10:22:11.422Z","comments":true,"path":"api/articles/APIHookDllIATCalc.json","keywords":null,"cover":null,"text":"APIHook - DLL注入实现IAT钩取 笔记摘要 技术摘要： 动态修改进程内存中的IAT。利用DLL注入修改API的IAT。 起源是逆向工程核心原理里面以计算器SetWindowText()API钩取为例讲解利用dll注入修改api的iat来实现钩取。该例子目标是把显示的阿...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"Windows","slug":"Windows","count":13,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":13,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":13,"path":"api/tags/note.json"},{"name":"api_hook","slug":"api-hook","count":3,"path":"api/tags/api-hook.json"},{"name":"reversecore","slug":"reversecore","count":4,"path":"api/tags/reversecore.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}