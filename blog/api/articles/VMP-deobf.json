{"title":"VMP还原思路","uid":"a0e830c45ad93252cf7ca59a00282739","slug":"VMP-deobf","date":"2023-01-11T04:00:00.000Z","updated":"2024-01-17T10:29:52.502Z","comments":true,"path":"api/articles/VMP-deobf.json","keywords":null,"cover":[],"content":"<h1 id=\"1-摘要\"><a href=\"#1-摘要\" class=\"headerlink\" title=\"1 摘要\"></a>1 摘要</h1><h2 id=\"1-1-关于代码优化与还原\"><a href=\"#1-1-关于代码优化与还原\" class=\"headerlink\" title=\"1.1 关于代码优化与还原\"></a>1.1 关于代码优化与还原</h2><p>关于还原，我认为难点是工作量大，需要自动化提升效率</p>\n<p>还原和混淆是一对反义词，相同点是保证代码<strong>功能相近</strong>，不同是一个是使代码更<strong>易读</strong>，后者则相反</p>\n<p>而代码优化非常类似，也要保证代码<strong>功能相近</strong>，不同是减少代码的<strong>体积</strong>或<strong>运行速度</strong></p>\n<p>所以我感觉还原和代码优化有很多共通点</p>\n<p>然后尝试了一下从编译的角度去做自动化还原，这里分享一下思路，算是画一个不太完美的句号吧</p>\n<h2 id=\"1-2-还原流程\"><a href=\"#1-2-还原流程\" class=\"headerlink\" title=\"1.2 还原流程\"></a>1.2 还原流程</h2><p>我的还原流程简单来说就三步：</p>\n<ol>\n<li>识别汇编对应的语义（翻译虚拟机字节码）</li>\n<li>虚拟指令转换成C</li>\n<li>二次编译，利用编译器优化</li>\n</ol>\n<p>第三步可以针对性的实现一些优化，因为vmp是一个基于栈的虚拟机，编译器的优化效果有限</p>\n<p>第一步是我做的比较多的一部分，在后面的实现过程会说具体思路</p>\n<h1 id=\"2-实现过程\"><a href=\"#2-实现过程\" class=\"headerlink\" title=\"2 实现过程\"></a>2 实现过程</h1><h2 id=\"2-1-Handler语义识别\"><a href=\"#2-1-Handler语义识别\" class=\"headerlink\" title=\"2.1 Handler语义识别\"></a>2.1 Handler语义识别</h2><p>这一步说的是怎么判断Handler对应的虚拟机指令</p>\n<h3 id=\"2-1-1-浅谈VMP的CFG\"><a href=\"#2-1-1-浅谈VMP的CFG\" class=\"headerlink\" title=\"2.1.1 浅谈VMP的CFG\"></a>2.1.1 浅谈VMP的CFG</h3><p>Handler识别首先绕不开一个问题，怎么找到Handler在哪</p>\n<p>关于VMP 3.X的架构这里简单说一下</p>\n<p>在VMP2中会有一个分发器，所有Handler的地址都存在一个数组中，很容易就能把所有Handler找出来；但到了3，分发方式变成从字节码中解码出下一条指令的地址</p>\n<h3 id=\"2-1-2-模拟执行输出虚拟指令\"><a href=\"#2-1-2-模拟执行输出虚拟指令\" class=\"headerlink\" title=\"2.1.2 模拟执行输出虚拟指令\"></a>2.1.2 模拟执行输出虚拟指令</h3><p>目前分析到两种跳转方式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">mov reg&#96;&#96;jmp reg</code></pre>\n\n<p>或</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">push reg&#96;&#96;ret</code></pre>\n\n<p>我的思路是模拟执行，遇到<code>jmp reg</code>或者<code>push ; ret</code>时就代表一条Handler已经结束，reg中的是下一条Handler的地址</p>\n<p>所以可以构建一个<code>Handler 虚拟地址</code>到<code>虚拟指令</code>的映射</p>\n<p>模拟执行还有一个好处，对于不同的虚拟指令，在Handler中下断，让Handler自己解密字节码中的内容，然后提取出来</p>\n<h3 id=\"2-1-3-Handler识别\"><a href=\"#2-1-3-Handler识别\" class=\"headerlink\" title=\"2.1.3 Handler识别\"></a>2.1.3 Handler识别</h3><p>关于Handler的语义是什么就省略了</p>\n<p>根据<code>jmp reg</code>或<code>push ; ret</code>把Handler提取出来后，现在就需要识别其对应的虚拟机指令</p>\n<p>两种思路：</p>\n<ul>\n<li>正则表达式匹配（速度块）</li>\n<li>DAG或者数据流图匹配</li>\n</ul>\n<h4 id=\"2-1-3-1-正则匹配\"><a href=\"#2-1-3-1-正则匹配\" class=\"headerlink\" title=\"2.1.3.1 正则匹配\"></a>2.1.3.1 正则匹配</h4><p>这是我目前正在用的方案，对汇编代码使用正则表达式匹配</p>\n<p>矛盾点是正则规则越严格，漏判越严重，规则越宽松，误判越严重</p>\n<p>缓解方案是对汇编代码先进行一次优化，参考编译原理中的死代码消除，对寄存器的使用进行分析</p>\n<p>以一个加法的Handler为例：</p>\n<p>比如优化前的Handler：</p>\n<p><img src=\"https://bbs.kanxue.com/upload/attach/202301/907036_G2YS7TP4CDYY2AD.png\" alt=\"handler_add_asm\"></p>\n<p>其中4、5、10、11行连续对rdi寄存器进行了写入，显然前三条写入是无效的</p>\n<p>优化后的Handler：</p>\n<p><img src=\"https://bbs.kanxue.com/upload/attach/202301/907036_6R6Y43C4JE5B64Z.png\" alt=\"handler_add_asm_deobf\"></p>\n<p>正则匹配：</p>\n<p><img src=\"https://bbs.kanxue.com/upload/attach/202301/907036_FNATEPQC4HKKNKT.png\" alt=\"handler_add_regex\"></p>\n<h4 id=\"2-1-3-2-DAG匹配\"><a href=\"#2-1-3-2-DAG匹配\" class=\"headerlink\" title=\"2.1.3.2 DAG匹配\"></a>2.1.3.2 DAG匹配</h4><p>这部分只是做一个尝试</p>\n<p>同样是加法的例子，这是其DAG图（不太严格，因为x86复杂指令集有点麻烦）</p>\n<p>蓝色下划线是从栈获取的操作数</p>\n<p>绿色下划线是将结果和RFLAGS放回栈</p>\n<p><img src=\"https://bbs.kanxue.com/upload/attach/202301/907036_EUQJ95E48BKJKPC.png\" alt=\"handler_add_dag\"></p>\n<h3 id=\"2-1-4-识别结果\"><a href=\"#2-1-4-识别结果\" class=\"headerlink\" title=\"2.1.4 识别结果\"></a>2.1.4 识别结果</h3><p>模拟执行顺序执行的片段：</p>\n<p><img src=\"https://bbs.kanxue.com/upload/attach/202301/907036_YBWT2VRM3J5AX8S.jpg\" alt=\"vasm\"></p>\n<h2 id=\"2-2-控制流还原\"><a href=\"#2-2-控制流还原\" class=\"headerlink\" title=\"2.2 控制流还原\"></a>2.2 控制流还原</h2><h3 id=\"2-2-1-虚拟机指令DU分析\"><a href=\"#2-2-1-虚拟机指令DU分析\" class=\"headerlink\" title=\"2.2.1 虚拟机指令DU分析\"></a>2.2.1 虚拟机指令DU分析</h3><p>先分析每条虚拟机指令对栈的读写，然后构建DU链</p>\n<p>接着利用DU链进行一次简单的优化，包括常量传播，折叠一些变量在VM栈和VM寄存器上的移动，还有简单的MBA表达式优化（简化接下来的判断分支等步骤）</p>\n<h3 id=\"2-2-2-判断是否为分支\"><a href=\"#2-2-2-判断是否为分支\" class=\"headerlink\" title=\"2.2.2 判断是否为分支\"></a>2.2.2 判断是否为分支</h3><p>进行到这里就可以判断是jmp还是jcc</p>\n<p>jmp的例子（左边是每条指令起始时VM字节码指针和VM栈指针）：</p>\n<p><img src=\"https://bbs.kanxue.com/upload/attach/202301/907036_HDG7GCYNFEH56ED.jpg\" alt=\"vasm_jmp\"></p>\n<p>jcc的例子：</p>\n<p><img src=\"https://bbs.kanxue.com/upload/attach/202301/907036_F9KTV3UPHEYAP73.jpg\" alt=\"vasm_jcc\"></p>\n<p>区别就是RET之前的一条语句PUSH的是否为一个立即数（依赖前面的常量传播优化）</p>\n<h3 id=\"2-2-3-获取分支去向\"><a href=\"#2-2-3-获取分支去向\" class=\"headerlink\" title=\"2.2.3 获取分支去向\"></a>2.2.3 获取分支去向</h3><p>接下来就可以通过DU链，获取分支的两条去向分别是什么</p>\n<p>依据是VMP的分支跳转伪代码为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">mask &#96;&#96;&#x3D;&#96; &#96;-&#96;&#96;1&#96; &#96;+&#96; &#96;flag&#96;&#96;a1 &#96;&#96;&#x3D;&#96; &#96;mask &amp; FAddr&#96;&#96;a2 &#96;&#96;&#x3D;&#96; &#96;~mask &amp; TAddr&#96;&#96;jmp &#96;&#96;&#x3D;&#96; &#96;a1 &#96;&#96;+&#96; &#96;a2</code></pre>\n\n<p>这里是识别的例子：</p>\n<p><img src=\"https://bbs.kanxue.com/upload/attach/202301/907036_CQHRNYR7VPWQYAG.jpg\" alt=\"vasm_du_jcc\"></p>\n<h3 id=\"2-2-4-获取分支条件（未完善）\"><a href=\"#2-2-4-获取分支条件（未完善）\" class=\"headerlink\" title=\"2.2.4 获取分支条件（未完善）\"></a>2.2.4 获取分支条件（未完善）</h3><p>这里我大致分成了两步：</p>\n<ul>\n<li>识别判断的rflags标志位</li>\n<li>识别<code>~(~x+y)</code></li>\n</ul>\n<p>一个比较标准的<code>test x-y</code>，然后判断CF的例子</p>\n<p>绿色框是上一步的跳转地址计算</p>\n<p>黄色框是rflags标志位的判断</p>\n<p>红色框是计算<code>x-y</code>的rflags</p>\n<p><img src=\"https://bbs.kanxue.com/upload/attach/202301/907036_W7SVSEBDSZDH58H.jpg\" alt=\"vasm_du_jcf\"></p>\n<p>一个<code>and x, x</code>，判断是否为0的例子</p>\n<p>绿框是上一步的跳转地址计算</p>\n<p>黄框是判断其ZF位</p>\n<p>红框是读取内存，然后获取其<code>and x, x</code>的rflags，没识别到</p>\n<p><img src=\"https://bbs.kanxue.com/upload/attach/202301/907036_KRKYJPTXN2VBC47.jpg\" alt=\"vasm_du_jzf_nn\"></p>\n<h3 id=\"2-2-5-控制流还原杂谈\"><a href=\"#2-2-5-控制流还原杂谈\" class=\"headerlink\" title=\"2.2.5 控制流还原杂谈\"></a>2.2.5 控制流还原杂谈</h3><p>在前面Handler语义识别的时候，难免会有错漏，出现识别不了的语句</p>\n<p>在模拟执行还原控制流时，妥协做法是停止该分支的分析</p>\n<p>这里截取了一段控制流</p>\n<p>每个圈圈是一个虚拟指令基本块</p>\n<p>这里绿色箭头的是前面<code>flag=1</code>分支、红色箭头是前面<code>flag=0</code>的分支</p>\n<p>红色圈圈的是遇到未知虚拟指令或模拟执行错误，停止分析的块</p>\n<p><img src=\"https://bbs.kanxue.com/upload/attach/202301/907036_4X6BDFWVHKN5D5A.jpg\" alt=\"vasm_bb\"></p>\n<h2 id=\"2-3-还原成C（做的不太好）\"><a href=\"#2-3-还原成C（做的不太好）\" class=\"headerlink\" title=\"2.3 还原成C（做的不太好）\"></a>2.3 还原成C（做的不太好）</h2><p>这一步随便水水了，只做了一部分，主要工作量太大了</p>\n<p>将虚拟指令输出成对应的C语言代码，然后上编译器编译</p>\n<p>给个加法的例子吧：</p>\n<p><img src=\"https://bbs.kanxue.com/upload/attach/202301/907036_YBZ3YHGDBQXGYQP.jpg\" alt=\"vasm_c_compile\"></p>\n<h1 id=\"3-结尾（欢迎指教）\"><a href=\"#3-结尾（欢迎指教）\" class=\"headerlink\" title=\"3 结尾（欢迎指教）\"></a>3 结尾（欢迎指教）</h1><h2 id=\"3-1-收获\"><a href=\"#3-1-收获\" class=\"headerlink\" title=\"3.1 收获\"></a>3.1 收获</h2><p>比较喜欢写代码吧，vmp代码还原的自动化又是个需要写很多代码的工程，就比较感兴趣，断断续续大学花了不少时间在这上面</p>\n<p>最大的收获是经验吧，写的时候花了很多时间在debug上，实际写的时间根本没多少</p>\n<p>我也明白，先设计好再写代码可以减少很多写代码和debug的时间，但缺乏还原经验，设计的时候无从入手，也考虑不周全，只能边写边想</p>\n<p>算是积累了一些经验吧</p>\n<p>然后实践了一下编译原理的入门知识，一个非常有意思的领域，希望以后有机会继续深入学习下去吧</p>\n<h2 id=\"3-2-关于分析深度和还原难度\"><a href=\"#3-2-关于分析深度和还原难度\" class=\"headerlink\" title=\"3.2 关于分析深度和还原难度\"></a>3.2 关于分析深度和还原难度</h2><p>在还原的过程中，我发现对虚拟机架构的分析越多，获得更多关于壳的信息，就能写出更容易实现、更有针对性、更有效果的优化</p>\n<p>有点类似窥孔优化的思路，牺牲通用性，以便实现和提高效果</p>\n<h1 id=\"4-相关链接\"><a href=\"#4-相关链接\" class=\"headerlink\" title=\"4 相关链接\"></a>4 相关链接</h1><p>VMP架构与虚拟机指令：</p>\n<p><a href=\"https://back.engineering/17/05/2021/#vm-handlers-specifications\">VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering</a></p>\n<p>虚拟机分支分析：</p>\n<p>[<a href=\"https://bbs.kanxue.com/thread-254445.htm\">分享]VMP学习笔记之万用门（七）-加壳脱壳-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p>\n<p><a href=\"https://bbs.kanxue.com/thread-274637.htm\">vmp3.5模拟x86分支指令je、jne、jge和jl的分析-软件逆向-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p>\n<p>编译原理（哪本书不记得了）：</p>\n<ul>\n<li>基本块的有向无环图表示</li>\n<li>DU链</li>\n</ul>\n<p>加密与解密</p>\n","feature":true,"text":"1 摘要1.1 关于代码优化与还原关于还原，我认为难点是工作量大，需要自动化提升效率 还原和混淆是一对反义词，相同点是保证代码功能相近，不同是一个是使代码更易读，后者则相反 而代码优化非常类似，也要保证代码功能相近，不同是减少代码的体积或运行速度 所以我感觉还原和代码优化有很多共...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"Re","slug":"Re","count":4,"path":"api/categories/Re.json"}],"tags":[{"name":"re","slug":"re","count":12,"path":"api/tags/re.json"},{"name":"vmp","slug":"vmp","count":1,"path":"api/tags/vmp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E6%91%98%E8%A6%81\"><span class=\"toc-text\">1 摘要</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E8%BF%98%E5%8E%9F\"><span class=\"toc-text\">1.1 关于代码优化与还原</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E8%BF%98%E5%8E%9F%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">1.2 还原流程</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">2 实现过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-Handler%E8%AF%AD%E4%B9%89%E8%AF%86%E5%88%AB\"><span class=\"toc-text\">2.1 Handler语义识别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-1-%E6%B5%85%E8%B0%88VMP%E7%9A%84CFG\"><span class=\"toc-text\">2.1.1 浅谈VMP的CFG</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-2-%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C%E8%BE%93%E5%87%BA%E8%99%9A%E6%8B%9F%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">2.1.2 模拟执行输出虚拟指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-3-Handler%E8%AF%86%E5%88%AB\"><span class=\"toc-text\">2.1.3 Handler识别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-3-1-%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">2.1.3.1 正则匹配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-3-2-DAG%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">2.1.3.2 DAG匹配</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-4-%E8%AF%86%E5%88%AB%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">2.1.4 识别结果</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E6%8E%A7%E5%88%B6%E6%B5%81%E8%BF%98%E5%8E%9F\"><span class=\"toc-text\">2.2 控制流还原</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-1-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%87%E4%BB%A4DU%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2.2.1 虚拟机指令DU分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-2-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%88%86%E6%94%AF\"><span class=\"toc-text\">2.2.2 判断是否为分支</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-3-%E8%8E%B7%E5%8F%96%E5%88%86%E6%94%AF%E5%8E%BB%E5%90%91\"><span class=\"toc-text\">2.2.3 获取分支去向</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-4-%E8%8E%B7%E5%8F%96%E5%88%86%E6%94%AF%E6%9D%A1%E4%BB%B6%EF%BC%88%E6%9C%AA%E5%AE%8C%E5%96%84%EF%BC%89\"><span class=\"toc-text\">2.2.4 获取分支条件（未完善）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-5-%E6%8E%A7%E5%88%B6%E6%B5%81%E8%BF%98%E5%8E%9F%E6%9D%82%E8%B0%88\"><span class=\"toc-text\">2.2.5 控制流还原杂谈</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E8%BF%98%E5%8E%9F%E6%88%90C%EF%BC%88%E5%81%9A%E7%9A%84%E4%B8%8D%E5%A4%AA%E5%A5%BD%EF%BC%89\"><span class=\"toc-text\">2.3 还原成C（做的不太好）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E7%BB%93%E5%B0%BE%EF%BC%88%E6%AC%A2%E8%BF%8E%E6%8C%87%E6%95%99%EF%BC%89\"><span class=\"toc-text\">3 结尾（欢迎指教）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E6%94%B6%E8%8E%B7\"><span class=\"toc-text\">3.1 收获</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E5%85%B3%E4%BA%8E%E5%88%86%E6%9E%90%E6%B7%B1%E5%BA%A6%E5%92%8C%E8%BF%98%E5%8E%9F%E9%9A%BE%E5%BA%A6\"><span class=\"toc-text\">3.2 关于分析深度和还原难度</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">4 相关链接</span></a></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"IA32e硬件与操作系统中断机制","uid":"e13f0f4c0a8cc181704cbc8ca9e68ace","slug":"IA32e-exception","date":"2023-01-19T04:00:00.000Z","updated":"2024-01-17T10:36:17.643Z","comments":true,"path":"api/articles/IA32e-exception.json","keywords":null,"cover":null,"text":"IA32e中断前言 前置知识： IA32e 全局描述符表（GDT） 平坦模式 描述符的字段 后置知识： TSS 这部分内容主要为intel白皮书的笔记，主要关注64位和软件相关的信息，忽略了影子栈和32位下的情况，还有优先级 sdm-vol3(v77)： 第6章：关于中断和异常处...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Windows","slug":"Windows","count":21,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":21,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":7,"path":"api/tags/kernel.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Last Branch Record","uid":"06423ce97f1a4b9a785e5e8bd6e7c6eb","slug":"LBR","date":"2023-01-10T04:00:00.000Z","updated":"2024-01-17T10:27:33.853Z","comments":true,"path":"api/articles/LBR.json","keywords":null,"cover":null,"text":"Last branch record摘要记录CPU产出的跳转指令，包括call、ret、jmp、中断、异常 当跳转发生时，会记录跳转指令地址（from）和目的地址（to） IA32_DEBUGCTL MSR位于01D9H flag： LBR (last branch/interr...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"Windows","slug":"Windows","count":21,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":21,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":7,"path":"api/tags/kernel.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}