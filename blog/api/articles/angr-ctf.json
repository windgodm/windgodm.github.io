{"title":"angr-ctf","uid":"771dec62b399749444e273209cdd8e6e","slug":"angr-ctf","date":"2022-10-27T04:00:00.000Z","updated":"2024-01-05T07:10:16.932Z","comments":true,"path":"api/articles/angr-ctf.json","keywords":null,"cover":null,"content":"<h1 id=\"angr-ctf\"><a href=\"#angr-ctf\" class=\"headerlink\" title=\"angr_ctf\"></a>angr_ctf</h1><p><a href=\"https://github.com/jakespringer/angr_ctf\">jakespringer/angr_ctf (github.com)</a></p>\n<p><a href=\"http://angr.oregonctf.org/\">angr CTF (oregonctf.org)</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV167411o7WK/\">angr符号执行练习 00_angr_find_哔哩哔哩_bilibili</a></p>\n<p><a href=\"https://www.mrskye.cn/archives/74204420/\">angr 学习 | SkYe231 Blog (mrskye.cn)</a></p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>（给出每个level新增或目标知识点）</p>\n<ul>\n<li><p>00 find</p>\n</li>\n<li><p>01 avoid</p>\n</li>\n<li><p>02 find condition</p>\n</li>\n<li><p>03 symbolic registers</p>\n<ul>\n<li>指定开始地址</li>\n<li>使用 symbolic bitvector</li>\n<li>给 寄存器 赋 BVS</li>\n</ul>\n</li>\n<li><p>04 symbolic stack</p>\n<ul>\n<li>模拟栈空间</li>\n<li>push BVS 到栈上</li>\n</ul>\n</li>\n<li><p>05 symbolic memory</p>\n<ul>\n<li>给内存赋 BVS</li>\n<li>字符串转换</li>\n</ul>\n</li>\n<li><p>06 symbolic dynamic memory</p>\n<ul>\n<li>简单假内存分配</li>\n</ul>\n</li>\n<li><p>07 symbolic file</p>\n<ul>\n<li>构造 symbolic file，用BVS作为数据流</li>\n</ul>\n</li>\n<li><p>08 constraints</p>\n<ul>\n<li>剪枝的思路</li>\n<li>添加约束</li>\n</ul>\n</li>\n<li><p>09 hooks</p>\n<ul>\n<li>hook 地址（调用位置）</li>\n</ul>\n</li>\n<li><p>10 simprocedures</p>\n<ul>\n<li>hook 符号</li>\n</ul>\n</li>\n<li><p>11 sim scanf</p>\n<ul>\n<li>global插件</li>\n</ul>\n</li>\n<li><p>12 veritesting</p>\n</li>\n<li><p>13 static binary</p>\n<ul>\n<li>使用Angr预先写好的SimProcedures</li>\n</ul>\n</li>\n<li><p>14 shared library</p>\n</li>\n</ul>\n<p>00-05<br>06-09<br>10-14</p>\n<h2 id=\"00-find\"><a href=\"#00-find\" class=\"headerlink\" title=\"00 find\"></a>00 find</h2><p>L52填的是<code>call puts</code>的地址，这是我们想到达的位置</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L35\npath_to_binary &#x3D; &quot;00_angr_find&quot;  # :string\n\n# L52\nprint_good_address &#x3D; 0x08048694  # :integer (probably in hexadecimal)</code></pre>\n\n<p>F5得到<code>b&#39;JXWVXRKX&#39;</code></p>\n<h2 id=\"01-avoid\"><a href=\"#01-avoid\" class=\"headerlink\" title=\"01 avoid\"></a>01 avoid</h2><p>也是找到<code>puts(&quot;Good Job.&quot;)</code>的位置，在函数<code>maybe_good</code>中</p>\n<p>同时<code>avoid_me()</code>这个函数名字就告诉我们是要避免的分支，这个函数会导致一定失败，添加avoid这个函数加速搜索</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L16-18\nprint_good_address &#x3D; 0x080485E5\nwill_not_succeed_address &#x3D; 0x080485A8\nsimulation.explore(find&#x3D;print_good_address, avoid&#x3D;will_not_succeed_address)</code></pre>\n\n<p>F5得到<code>b&#39;HUJOZMYS&#39;</code></p>\n<h2 id=\"02-find-condition\"><a href=\"#02-find-condition\" class=\"headerlink\" title=\"02 find condition\"></a>02 find condition</h2><p>之前是知道<code>puts(&quot;Good Job.&quot;)</code>的位置，这次假设不知道地址，只知道有这个输出</p>\n<p>（准确的说，之前是找达到<code>call puts</code>的状态；这次是找到标准输出为<code>Good Job.</code>的状态）</p>\n<p>需要注意的是，<code>stdout_output</code>类型是<code>bytes</code>，另外输出里还包括输入提示等字符串</p>\n<p>所以需要用<code>encode</code>和<code>in</code></p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L24-30\ndef is_successful(state):\n    stdout_output &#x3D; state.posix.dumps(sys.stdout.fileno())\n\treturn &quot;Good Job.&quot;.encode() in stdout_output  # :boolean\n# L36-38\ndef should_abort(state):\n    stdout_output &#x3D; state.posix.dumps(sys.stdout.fileno())\n    return &quot;Try again.&quot;.encode() in stdout_output  # :boolean</code></pre>\n\n<p>F5得到<code>b&#39;HETOBRCU&#39;</code></p>\n<h2 id=\"03-symbolic-registers\"><a href=\"#03-symbolic-registers\" class=\"headerlink\" title=\"03 symbolic registers\"></a>03 symbolic registers</h2><p>Angr 目前不支持用 scanf 读取多个东西（例如：<code>scanf(&quot;%u %u)</code>）在调用 scanf 之后，您必须告诉模拟引擎开始程序，并手动将符号注入寄存器。</p>\n<p>应该在scanf以后开始</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L17-18\nstart_address &#x3D; 0x08048980  # :integer (probably hexadecimal)\ninitial_state &#x3D; project.factory.blank_state(addr&#x3D;start_address)</code></pre>\n\n\n\n<p>创建 symbolic bitvector</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L28-33\npassword0_size_in_bits &#x3D; 32  # :integer\npassword0 &#x3D; claripy.BVS(&#39;password0&#39;, password0_size_in_bits)\npassword1_size_in_bits &#x3D; 32  # :integer\npassword1 &#x3D; claripy.BVS(&#39;password1&#39;, password1_size_in_bits)\npassword2_size_in_bits &#x3D; 32  # :integer\npassword2 &#x3D; claripy.BVS(&#39;password2&#39;, password2_size_in_bits)</code></pre>\n\n\n\n<p>设置寄存器为符号值</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L48-50\ninitial_state.regs.eax &#x3D; password0\ninitial_state.regs.ebx &#x3D; password1\ninitial_state.regs.edx &#x3D; password2</code></pre>\n\n\n\n<p>求解</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L72-74\nsolution0 &#x3D; solution_state.se.eval(password0)\nsolution1 &#x3D; solution_state.se.eval(password1)\nsolution2 &#x3D; solution_state.se.eval(password2)</code></pre>\n\n\n\n<p>F5得到<code>0xB9FFD04E 0xCCF63FE8 0x8FD4D959</code></p>\n<h2 id=\"04-symbolic-stack\"><a href=\"#04-symbolic-stack\" class=\"headerlink\" title=\"04 symbolic stack\"></a>04 symbolic stack</h2><p>同样是再scanf之后开始，这次scanf的内容被存在栈上</p>\n<p>scanf的调用约定是<code>_cdecl</code>，由调用者传参，所以在调用者平衡栈以后再开始</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L41\nstart_address &#x3D; 0x08048697</code></pre>\n\n\n\n<p>地址最高（最接近ebp）的局部变量0xC，size为4字节</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L121\npadding_length_in_bytes &#x3D; 0xC - 4  # :integer</code></pre>\n\n\n\n<p>理论上var_C先于var_10被分配到栈上（高地址、接近ebp先分配）</p>\n<p>调用scanf时，var_C的地址后入栈，函数参数从右到左入栈，所以var_C对应第一个参数pw0</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L132-133\ninitial_state.stack_push(password0)  # :bitvector (claripy.BVS, claripy.BVV, claripy.BV)\ninitial_state.stack_push(password1)</code></pre>\n\n\n\n<p>F5：<code>1704280884 2382341151</code></p>\n<h2 id=\"05-symbolic-memory\"><a href=\"#05-symbolic-memory\" class=\"headerlink\" title=\"05 symbolic memory\"></a>05 symbolic memory</h2><p>将BVS赋值到内存（angr memory.store默认大端序，需要手动指定为小端序）</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L24-25\npassword0_address &#x3D; 0x0A1BA1C0\ninitial_state.memory.store(password0_address, password0， endness&#x3D;project.arch.memory_endness)</code></pre>\n\n\n\n<p><strong>bug</strong></p>\n<p>因为python2中str就是字节流，python3中不一样，删掉<code>cast_to=str</code>否则会报错</p>\n<p>需要从 int 转 bytes 转 str</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L49-50\n# solution0 &#x3D; solution_state.se.eval(password0,cast_to&#x3D;str)\nsolution0 &#x3D; int.to_bytes(solution_state.se.eval(password0), 8, &#39;little&#39;).decode(&quot;utf-8&quot;)</code></pre>\n\n\n\n<h2 id=\"06-symbolic-dynamic-memory\"><a href=\"#06-symbolic-dynamic-memory\" class=\"headerlink\" title=\"06 symbolic dynamic memory\"></a>06 symbolic dynamic memory</h2><p>将BVS赋值到动态分配的内存</p>\n<p>这里提示到上节的问题，Angr默认使用大端序，需要手动指示使用内存序（<code>endness=project.arch.memory_endness</code>），x86的内存序就是小端序</p>\n<p>第一步：填充假堆地址（与05相比多出来的一步）</p>\n<p>fake_heap_address0是在紧挨着<code>extern</code>段之后的位置</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L27-30\nfake_heap_address0 &#x3D; 0xABCC8E0\npointer_to_malloc_memory_address0 &#x3D; 0x0ABCC8A4\ninitial_state.memory.store(0x0ABCC8A4, fake_heap_address0, endness&#x3D;project.arch.memory_endness)\ninitial_state.memory.store(0x0ABCC8AC, fake_heap_address0 + 8, endness&#x3D;project.arch.memory_endness)</code></pre>\n\n\n\n<p>第二步：填充假输入</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L35-36\ninitial_state.memory.store(fake_heap_address0, password0, endness&#x3D;project.arch.memory_endness)\ninitial_state.memory.store(fake_heap_address0 + 8, password1, endness&#x3D;project.arch.memory_endness)</code></pre>\n\n\n\n<p>F5<code>UBDKLMBV UNOERNYS</code></p>\n<h2 id=\"07-symbolic-file\"><a href=\"#07-symbolic-file\" class=\"headerlink\" title=\"07 symbolic file\"></a>07 symbolic file</h2><p>题目本意是从文件中读取密码，然后判断是否正确</p>\n<p>为了和别的题目一致，会从控制台读取代码，然后写入文件，这部分应该忽略掉。接下来的代码才是需要分析的，会读取文件并判断是否正确</p>\n<p>显然有许多种解法，而题目本意是学习模拟文件系统，用这种方法去解决</p>\n<p>起始地址应在<code>ignore_me</code>之后（打开文件之前）</p>\n<p>构造<code>symbolic file</code>，用BVS作为数据流（angr.storage.SimFile是大端序）</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 构造 symbolic file\npassword_file &#x3D; angr.storage.SimFile(filename,\n\tfile_options,\n\tcontent&#x3D;password,\n    size&#x3D;symbolic_file_size_bytes)\n# 写入到状态\ninitial_state.fs.insert(filename, password_file)</code></pre>\n\n\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>angr 已经不支持angr.state_plugins.SimSymbolicMemory()</p>\n<p>直接向SimFile的content提供BVS即可</p>\n<p>同时SimFile好像不支持file_options参数了，使用会报错</p></blockquote>\n<p>F5<code>b&#39;AZOMMMZM\\x00</code>，后面还杂数据，不知道什么问题</p>\n<h2 id=\"08-constraints\"><a href=\"#08-constraints\" class=\"headerlink\" title=\"08 constraints\"></a>08 constraints</h2><p>处理路径爆炸的问题：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define REFERENCE_PASSWORD &#x3D; &quot;AABBCCDDEEFFGGHH&quot;;\nint check_equals_AABBCCDDEEFFGGHH(char* to_check, size_t length) &#123;\n    uint32_t num_correct &#x3D; 0;\n    for (int i&#x3D;0; i&lt;length; ++i) &#123;\n        if (to_check[i] &#x3D;&#x3D; REFERENCE_PASSWORD[i]) &#123;\n            num_correct +&#x3D; 1;\n        &#125;\n    &#125;\n    return num_correct &#x3D;&#x3D; length;\n&#125;</code></pre>\n\n\n\n<p>懒得搞了，纯大端序，最后用<code>cast_to=bytes</code>即可得到正确顺序的字符串</p>\n<p>将explore的find改为check_equals_AABBCCDDEEFFGGHH的地址</p>\n<p>以便在比较之前停下来</p>\n<p>然后提取要比较的内容</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L77-81\nconstrained_parameter_address &#x3D; 0x0804A050 # func arg1 [ebp+8]\nconstrained_parameter_size_bytes &#x3D; 0x10 # func arg2 [ebp+Ch]\nconstrained_parameter_bitvector &#x3D; solution_state.memory.load(\n    constrained_parameter_address,\n    constrained_parameter_size_bytes)</code></pre>\n\n\n\n<p>根据提示，函数名就是比较的目标，也可以动态调试获得</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L86\nconstrained_parameter_desired_value &#x3D; &quot;AUPDNNPROEZRJWKB&quot; # :string</code></pre>\n\n\n\n<p>F5<code>b&#39;LGCRCDGJHYUNGUJB&#39;</code></p>\n<h2 id=\"09-hooks\"><a href=\"#09-hooks\" class=\"headerlink\" title=\"09 hooks\"></a>09 hooks</h2><p>用hook技术，hook调用比较函数的地方，代替前面那个导致路径爆炸的比较函数</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L26\ncheck_equals_called_address &#x3D; 0x080486B3\n\n# L34-35\n# 需要跳过的指令长度，这里只跳过call，所以是5\ninstruction_to_skip_length &#x3D; 5\n@project.hook(check_equals_called_address, length&#x3D;instruction_to_skip_length)\ndef skip_check_equals_(state):\n    # L40-41\n    user_input_buffer_address &#x3D; 0x0804A054 # :integer, probably hexadecimal\n    user_input_buffer_length &#x3D; 0x10\n\t\n    user_input_string &#x3D; state.memory.load(\n        user_input_buffer_address, \n        user_input_buffer_length\n    )\n    \n    # L55\n    # 静态分析或动态调试获得\n    check_against_string &#x3D; &quot;XYMKBKUHNIQYNQXE&quot; # :string\n\n    state.regs.eax &#x3D; claripy.If(\n        user_input_string &#x3D;&#x3D; check_against_string, \n        claripy.BVV(1, 32), \n        claripy.BVV(0, 32)\n    )</code></pre>\n\n\n\n<p>由angr处理输入，所以直接获取标准输入流</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L89\nsolution &#x3D; solution_state.posix.dumps(sys.stdin.fileno())</code></pre>\n\n\n\n<p>F5<code>b&#39;ZXIDRXEORJOTFFJNWUFAOUBLOGLQCCGK&#39;</code></p>\n<h2 id=\"10-simprocedures\"><a href=\"#10-simprocedures\" class=\"headerlink\" title=\"10 simprocedures\"></a>10 simprocedures</h2><p>用hook技术，这次hook函数开头，而不是调用位置</p>\n<p>定义一个继承自<code>angr.SimProcedure</code>的类，模拟被hook函数功能：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class ReplacementCheckEquals(angr.SimProcedure):\n    # L62\n    # 与函数原型一致\n    def run(self, to_check, length):\n        # L66-67\n        user_input_buffer_address &#x3D; to_check\n        user_input_buffer_length &#x3D; length\n\n        user_input_string &#x3D; self.state.memory.load(\n            user_input_buffer_address,\n            user_input_buffer_length\n        )\n\t\t\n        # L76\n        check_against_string &#x3D; &quot;ORSDDWXHZURJRBDH&quot;\n\n        # L81\n        # 返回值\n        return claripy.If(user_input_string &#x3D;&#x3D; check_against_string, claripy.BVV(1, 32), claripy.BVV(0, 32))</code></pre>\n\n\n\n<p>hook check_equals 符号。Angr自动查找与符号相关的地址。或者，你可以使用<code>hook</code>代替<code>hook_symbol</code>并指定函数的地址</p>\n<p>通过hook_symbol，替换目标函数：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">check_equals_symbol &#x3D; &quot;check_equals_ORSDDWXHZURJRBDH&quot; # :string\nproject.hook_symbol(check_equals_symbol, ReplacementCheckEquals())</code></pre>\n\n\n\n<p>F5<code>b&#39;MSWKNJNAVTTOZMRY&#39;</code></p>\n<h2 id=\"11-sim-scanf\"><a href=\"#11-sim-scanf\" class=\"headerlink\" title=\"11 sim scanf\"></a>11 sim scanf</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># class angr.SimProcedure, def run\nself.state.globals[&#39;solution0&#39;] &#x3D; scanf0\nself.state.globals[&#39;solution1&#39;] &#x3D; scanf1\n\nstored_solutions0 &#x3D; solution_state.globals[&#39;solution0&#39;]\nstored_solutions1 &#x3D; solution_state.globals[&#39;solution1&#39;]</code></pre>\n\n\n\n<p>F5<code>1448564819 1398294103</code></p>\n<h2 id=\"12-veritesting\"><a href=\"#12-veritesting\" class=\"headerlink\" title=\"12 veritesting\"></a>12 veritesting</h2><p>复制11的代码，改一下scanf的模拟函数</p>\n<p>修改创建 simulation manager 代码，开启veritesting</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">simulation &#x3D; project.factory.simgr(initial_state, veritesting&#x3D;True)</code></pre>\n\n\n\n<p>F5<code>b&#39;OQSUWYACEGIKMOQSUWYACEGIKMOQSUWY&#39;</code></p>\n<h2 id=\"13-static-binary\"><a href=\"#13-static-binary\" class=\"headerlink\" title=\"13 static binary\"></a>13 static binary</h2><p>这个挑战与第一个挑战完全相同，只是它被编译为静态二进制文件。通常情况下，Angr会自动用工作更快的simprocedure替换标准库函数。</p>\n<p>下面是一些SimProcedures Angr已经为你写好了。它们实现标准库函数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;malloc&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;fopen&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;fclose&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;fwrite&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;getchar&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;strncmp&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;strcmp&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;scanf&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;printf&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;puts&#39;]\n# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;exit&#39;]\n# angr.SIM_PROCEDURES[&#39;glibc&#39;][&#39;__libc_start_main&#39;]\n\n# As a reminder, you can hook functions with something similar to:\n# project.hook(malloc_address, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;malloc&#39;]())</code></pre>\n\n\n\n<p>更多：</p>\n<p><a href=\"https://github.com/angr/angr/tree/master/angr/procedures/libc\">https://github.com/angr/angr/tree/master/angr/procedures/libc</a></p>\n<p>复制01的代码，然后添加hook：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">project.hook(0x08048D10, angr.SIM_PROCEDURES[&#39;glibc&#39;][&#39;__libc_start_main&#39;]())\nproject.hook(0x0804ED40, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;printf&#39;]())\nproject.hook(0x0804ED80, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;scanf&#39;]())\nproject.hook(0x0804F350, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;puts&#39;]())</code></pre>\n\n\n\n<p>F5<code>b&#39;PNMXNMUD&#39;</code></p>\n<h2 id=\"14-shared-library\"><a href=\"#14-shared-library\" class=\"headerlink\" title=\"14 shared library\"></a>14 shared library</h2><p>符号执行so文件</p>\n<p>设置基址：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L20-25\nbase &#x3D; 0\nproject &#x3D; angr.Project(path_to_binary, load_options&#x3D;&#123; \n    &#39;main_opts&#39; : &#123; \n        &#39;custom_base_addr&#39; : base \n    &#125; \n&#125;)</code></pre>\n\n\n\n<p>准备从目标函数开始模拟执行，获取其状态：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L29-31\npassword_address &#x3D; claripy.BVV(base+0x3000, 32)\npassword &#x3D; claripy.BVS(&#39;password&#39;, 8*8)\npw_size &#x3D; claripy.BVV(8, 32)\n\n# L43-45\nvalidate_function_address &#x3D; base + 0x6D7\ninitial_state &#x3D; project.factory.call_state(validate_function_address, password_address, pw_size)\ninitial_state.memory.store(password_address, password)</code></pre>\n\n\n\n<p><strong>方案一</strong>（<code>scaffold14.py</code>）</p>\n<p>在return前hook，添加约束</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L54-56\n@project.hook(base + 0x77D, length&#x3D;0)\ndef skip_check_equals_(state):\n    state.add_constraints(state.regs.eax !&#x3D; 0)</code></pre>\n\n\n\n<p><strong>方案二</strong>（<code>scaffold14_2.py</code>）</p>\n<p>到达return后，添加约束</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># L57-58\nsuccess_address &#x3D; base + 0x783\nsimulation.explore(find&#x3D;success_address)\n\n# L66-67\nsolution_state.add_constraints(solution_state.regs.eax !&#x3D; 0)\nsolution &#x3D; solution_state.se.eval(password, cast_to&#x3D;bytes)</code></pre>\n\n\n\n<p>F5<code>b&#39;PGXSNWTS&#39;</code></p>\n","feature":true,"text":"angr_ctfjakespringer/angr_ctf (github.com) angr CTF (oregonctf.org) angr符号执行练习 00_angr_find_哔哩哔哩_bilibili angr 学习 | SkYe231 Blog (mrskye.cn)...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"CTF","slug":"CTF","count":8,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":8,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":11,"path":"api/tags/re.json"},{"name":"angr","slug":"angr","count":1,"path":"api/tags/angr.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#angr-ctf\"><span class=\"toc-text\">angr_ctf</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">目录</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#00-find\"><span class=\"toc-text\">00 find</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#01-avoid\"><span class=\"toc-text\">01 avoid</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#02-find-condition\"><span class=\"toc-text\">02 find condition</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#03-symbolic-registers\"><span class=\"toc-text\">03 symbolic registers</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#04-symbolic-stack\"><span class=\"toc-text\">04 symbolic stack</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#05-symbolic-memory\"><span class=\"toc-text\">05 symbolic memory</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#06-symbolic-dynamic-memory\"><span class=\"toc-text\">06 symbolic dynamic memory</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#07-symbolic-file\"><span class=\"toc-text\">07 symbolic file</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#08-constraints\"><span class=\"toc-text\">08 constraints</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#09-hooks\"><span class=\"toc-text\">09 hooks</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-simprocedures\"><span class=\"toc-text\">10 simprocedures</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-sim-scanf\"><span class=\"toc-text\">11 sim scanf</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-veritesting\"><span class=\"toc-text\">12 veritesting</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-static-binary\"><span class=\"toc-text\">13 static binary</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-shared-library\"><span class=\"toc-text\">14 shared library</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"SFU Compilers class 笔记6","uid":"dc41c1162c79a34f24cc5f032c462a3c","slug":"SFU-Compilers-6","date":"2022-09-23T04:00:00.000Z","updated":"2024-01-05T07:05:13.928Z","comments":true,"path":"api/articles/SFU-Compilers-6.json","keywords":null,"cover":null,"text":"SFU Compilers 笔记 6 语义分析和代码生成2llvm-p hw3 hw4 Practice LLVM环境如何在不同环境使用makefile： CSIL Linux机器：make llvmconfig=llvm-config-12 all（似乎是SFU的在线环境） m...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"CS","slug":"CS","count":6,"path":"api/categories/CS.json"}],"tags":[{"name":"note","slug":"note","count":25,"path":"api/tags/note.json"},{"name":"cs","slug":"cs","count":6,"path":"api/tags/cs.json"},{"name":"compiler","slug":"compiler","count":6,"path":"api/tags/compiler.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}