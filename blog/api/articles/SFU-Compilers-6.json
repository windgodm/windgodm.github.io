{"title":"SFU Compilers class 笔记6","uid":"dc41c1162c79a34f24cc5f032c462a3c","slug":"SFU-Compilers-6","date":"2022-09-23T04:00:00.000Z","updated":"2024-01-05T07:05:13.928Z","comments":true,"path":"api/articles/SFU-Compilers-6.json","keywords":null,"cover":null,"content":"<h1 id=\"SFU-Compilers-笔记-6-语义分析和代码生成2\"><a href=\"#SFU-Compilers-笔记-6-语义分析和代码生成2\" class=\"headerlink\" title=\"SFU Compilers 笔记 6 语义分析和代码生成2\"></a>SFU Compilers 笔记 6 语义分析和代码生成2</h1><p>llvm-p hw3 hw4</p>\n<h1 id=\"Practice-LLVM\"><a href=\"#Practice-LLVM\" class=\"headerlink\" title=\"Practice LLVM\"></a>Practice LLVM</h1><h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>如何在不同环境使用<code>makefile</code>：</p>\n<ol>\n<li>CSIL Linux机器：<code>make llvmconfig=llvm-config-12 all</code>（似乎是SFU的在线环境）</li>\n<li>macos或其他：<code>make all</code></li>\n</ol>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>下载页面：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">http:&#x2F;&#x2F;llvm.org&#x2F;releases&#x2F;download.html</code></pre>\n\n<p>wsl2直接执行以下命令：</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">apt-get update\napt-get install clang --fix-missing\napt install llvm</code></pre>\n\n\n\n<h2 id=\"Decaf标准库\"><a href=\"#Decaf标准库\" class=\"headerlink\" title=\"Decaf标准库\"></a>Decaf标准库</h2><p><code>decaf-stdlib.c</code>：包含Decaf的标准库，包含print_int等函数的实现</p>\n<p><code>decaf-stdlib-test.cpp</code>：测试用的C++程序，使用Decaf的标准库</p>\n<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h2><p>编译<code>helloword.ll</code>，一个<strong>LLVM汇编</strong>写的程序：</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">llvmconfig&#x3D;llvm-config\nlli_bin&#x3D;&#96;$llvmconfig --bindir&#96;&#x2F;lli\n$lli_bin helloworld.ll</code></pre>\n\n<p>前两行获取lli的路径<br>第3行使用<code>lli</code> 将 LLVM汇编 编译成 可执行文件</p>\n<h2 id=\"使用Decaf的库函数\"><a href=\"#使用Decaf的库函数\" class=\"headerlink\" title=\"使用Decaf的库函数\"></a>使用Decaf的库函数</h2><p>编译<code>add.ll</code>，并使用Decaf的库函数：<br>（以下命令在<code>run-llvm-code.sh</code>中，makefile中也有）</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">llvmconfig&#x3D;llvm-config\n&#96;$llvmconfig --bindir&#96;&#x2F;llvm-as add.ll  # convert LLVM assembly to bitcode\n&#96;$llvmconfig --bindir&#96;&#x2F;llc add.bc   # convert LLVM bitcode to x86 assembly\nclang add.s decaf-stdlib.c -o add </code></pre>\n\n<p>第2行使用LLVM的 <code>llvm-as</code> 将 LLVM汇编 转成 LLVM字节码<br>第3行使用LLVM的 <code>llc</code> 将 字节码 转成 x86汇编<br>第4行使用 <code>clang</code> 将 汇编 转成 机器码（也就是“汇编”）</p>\n<p>递归版加法函数，对应python如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def rec_add(a, b):\n    if a &#x3D;&#x3D; 0:\n        return b\n    else:\n        return rec_add(a-1, b+1)</code></pre>\n\n<p>给出了框架：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">define i32 @add2(i32 %a, i32 %b) &#123;\nentry:\n  %tmp1 &#x3D; icmp eq i32 %a, 0\n  br i1 %tmp1, label %done, label %recurse\nrecurse:\n  ; insert LLVM assembly here  \ndone:\n  ; insert LLVM assembly here\n&#125;</code></pre>\n\n<p><code>rec_add.ll</code>中是参考答案</p>\n<h2 id=\"简单递归\"><a href=\"#简单递归\" class=\"headerlink\" title=\"简单递归\"></a>简单递归</h2><p>用LLVM汇编实现阶乘，参考答案在<code>factorial.ll</code></p>\n<h2 id=\"LLVM-C-API-简介\"><a href=\"#LLVM-C-API-简介\" class=\"headerlink\" title=\"LLVM C++ API 简介\"></a>LLVM C++ API 简介</h2><h3 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h3><p>常用头文件：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">llvm&#x2F;IR&#x2F;DerivedTypes.h\nllvm&#x2F;IR&#x2F;LLVMContext.h\nllvm&#x2F;IR&#x2F;Module.h\nllvm&#x2F;IR&#x2F;Type.h\nllvm&#x2F;IR&#x2F;Verifier.h\nllvm&#x2F;IR&#x2F;IRBuilder.h</code></pre>\n\n<p><code>IRBuilder.h</code>：包含构建 Decaf 编译器所需的几乎所有功能，返回值都是<code>llvm::Value</code></p>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; this global variable contains all the generated code\nstatic llvm::Module *TheModule;\nstatic llvm::LLVMContext TheContext;\n&#x2F;&#x2F; this is the method used to construct the LLVM intermediate code (IR)\nstatic llvm::IRBuilder&lt;&gt; Builder(TheContext);</code></pre>\n\n<p>生成LLVM汇编：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">TheModule-&gt;print(llvm::errs(), nullptr);</code></pre>\n\n\n\n<h3 id=\"LLVM-Value\"><a href=\"#LLVM-Value\" class=\"headerlink\" title=\"LLVM::Value\"></a>LLVM::Value</h3><p>LLVM 中的几乎所有内容，包括类型、常量、函数等，都派生自基类<code>llvm::Value</code></p>\n<h3 id=\"LLVM-Type\"><a href=\"#LLVM-Type\" class=\"headerlink\" title=\"LLVM::Type\"></a>LLVM::Type</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th><code>llvm::Type*</code></th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void</td>\n<td>Builder.getVoidTy()</td>\n<td>just a void type</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Builder.getInt32Ty()</td>\n<td>assume 32 bit integers</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>Builder.getInt1Ty()</td>\n<td>a one bit integer</td>\n</tr>\n<tr>\n<td>string</td>\n<td>Builder.getInt8PtrTy()</td>\n<td>pointer to array of bytes (int8)</td>\n</tr>\n</tbody></table>\n<p>helper函数，为每种 Decaf 类型返回正确的 LLVM 类型：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef enum &#123; voidTy, intTy, boolTy, stringTy, &#125; decafType;\nllvm::Type *getLLVMType(decafType ty) &#123; \n    switch (ty) &#123;\n        case voidTy: return Builder.getVoidTy();\n        case intTy: return Builder.getInt32Ty();\n        case boolTy: return Builder.getInt1Ty();\n        case stringTy: return Builder.getInt8PtrTy(); default: throw runtime_error(&quot;unknown type&quot;);\n    &#125; \n&#125;</code></pre>\n\n\n\n<h3 id=\"LLVM-Constant\"><a href=\"#LLVM-Constant\" class=\"headerlink\" title=\"LLVM::Constant\"></a>LLVM::Constant</h3><p>初始化为0的常量</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>代码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int32</td>\n<td>Builder.getInt32(0)</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>Builder.getInt1(0)</td>\n</tr>\n</tbody></table>\n<h3 id=\"栈上存储\"><a href=\"#栈上存储\" class=\"headerlink\" title=\"栈上存储\"></a>栈上存储</h3><p>使用栈存储一些对象，比如变量、函数调用参数等（堆需要分配）</p>\n<p>以下API创建一个新位置，返回指向该位置的指针：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; llvm::Type* TYPE\nllvm::AllocaInst *Alloca &#x3D; Builder.CreateAlloca(TYPE, 0, NAME);</code></pre>\n\n<p>使用示例，在栈上创建一个32位整数：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">llvm::AllocaInst *Alloca;\n&#x2F;&#x2F; unlike CreateEntryBlockAlloca the following will\n&#x2F;&#x2F; create the alloca instr at the current insertion point \n&#x2F;&#x2F; rather than at the start of the block\nAlloca &#x3D; llvm::Builder.CreateAlloca(llvm::IntegerType::get(TheContext, 32), 0, &quot;variable_name&quot;);</code></pre>\n\n\n\n<p>当你想给这个位置赋值时，你可以使用<code>Alloca-&gt;getType()</code>访问指向类型 TYPE 的指针</p>\n<p>给变量赋值（lvalue = rvalue）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 获取rvalue的指针的类型\nconst llvm::PointerType *ptrTy &#x3D; rvalue-&gt;getType()-&gt;getPointerTo();\n&#x2F;&#x2F; 检查lvalue和rvalue的类型是否相等（检查两者的指针）\nptrTy &#x3D;&#x3D; Alloca-&gt;getType()\n&#x2F;&#x2F; 赋值\nllvm::Value *val &#x3D; Builder.CreateStore(rvalue, Alloca);</code></pre>\n\n<p>（Alloca是左值的指针，这里相当于检查<code>type(&amp;rvalue)==type(Alloca)</code>）</p>\n<h3 id=\"算术和布尔运算\"><a href=\"#算术和布尔运算\" class=\"headerlink\" title=\"算术和布尔运算\"></a>算术和布尔运算</h3><p>比如加法是<code>Builder.CreateAdd</code></p>\n<p>略</p>\n<h3 id=\"函数定义\"><a href=\"#函数定义\" class=\"headerlink\" title=\"函数定义\"></a>函数定义</h3><p>函数定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">llvm::Type *returnTy;\n&#x2F;&#x2F; assign the correct Type to returnTy\n\nstd::vector&lt;llvm::Type *&gt; args;\n&#x2F;&#x2F; fill up the args vector with types\n\nllvm::Function *func &#x3D; llvm::Function::Create(\n    llvm::FunctionType::get(returnTy, args, false),\n    llvm::Function::ExternalLinkage,\n    Name,\n    TheModule\n);</code></pre>\n\n<p>创建一个基本块来保存函数中的指令：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; Create a new basic block which contains a sequence of LLVM instructions\nllvm::BasicBlock *BB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;entry&quot;, func);\n&#x2F;&#x2F; insert &quot;entry&quot; into symbol table (not used in HW3 but useful in HW4)\n&#x2F;&#x2F; All subsequent calls to IRBuilder will place instructions in this location\nBuilder.SetInsertPoint(BB);</code></pre>\n\n<p>为函数生成代码时需要：</p>\n<ol>\n<li>为局部变量创建一个新的符号表</li>\n<li>创建一个基本块<code>BB</code></li>\n<li><code>Builder.SetInsertPoint(BB)</code></li>\n<li>使用<code>arg_iterator</code>遍历函数参数，并在栈上分配空间</li>\n</ol>\n<p>一个参数的写法：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">string name &#x3D; string(&quot;a&quot;);\nllvm::Function::arg_iterator AI &#x3D; func-&gt;arg_begin();\nAI-&gt;setName(name);\nllvm::AllocaInst *Alloca &#x3D; Builder.CreateAlloca(Builder.getInt32Ty(), nullptr, name.c_str());\n&#x2F;&#x2F; Store the initial value into the alloca.\nBuilder.CreateStore(static_cast&lt;llvm::Value *&gt;(&amp;*AI), Alloca);\n&#x2F;&#x2F; Add to symbol table\nsyms.enter_symtbl(name, Alloca);</code></pre>\n\n<p>遍历写法：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">for (auto &amp;Arg : func-&gt;args()) &#123;\n  llvm::AllocaInst *Alloca &#x3D; CreateEntryBlockAlloca(func, Arg.getName());\n  &#x2F;&#x2F; Store the initial value into the alloca.\n  Builder.CreateStore(&amp;Arg, Alloca);\n  &#x2F;&#x2F; Add to symbol table\n  syms.enter_symtbl(Arg.getName(), Alloca);\n&#125;</code></pre>\n\n\n\n<p>获取函数信息：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">llvm::BasicBlock *CurBB &#x3D; Builder.GetInsertBlock();\n&#x2F;&#x2F; gives you a link to the current basic block\n\nllvm::Function *func &#x3D; Builder.GetInsertBlock()-&gt;getParent();\n&#x2F;&#x2F; gives you a pointer to the function definition\n\nfunc-&gt;getReturnType()\n&#x2F;&#x2F; gives you the return type of the function</code></pre>\n\n\n\n<p>返回值：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">Builder.CreateRet(llvm::Value*)</code></pre>\n\n<p>应该通过检测在哪个函数，然后获取其返回值类型，再赋值<br>而不是把返回值类型传递给函数的所有子AST节点<br>（参考上面的获取函数信息）</p>\n<p>初始化返回值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">typedef enum &#123; voidTy, intTy, boolTy, stringTy, &#125; decafType;\nllvm::Constant *getZeroInit(decafType ty) &#123; \n    switch (ty) &#123;\n        case intTy: return Builder.getInt32(0);\n        case boolTy: return Builder.getInt1(0);\n        default: throw runtime_error(&quot;unknown type&quot;);\n    &#125; \n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">llvm::Function *call;\n&#x2F;&#x2F; assign this to the pointer to the function to call, \n&#x2F;&#x2F; usually loaded from the symbol table\n\nstd::vector&lt;llvm::Value *&gt; args;\n&#x2F;&#x2F; argvals are the values in the method call, \n&#x2F;&#x2F; e.g. foo(1) would have a vector of size one with value of 1 with type i32.\n\nbool isVoid &#x3D; call-&gt;getReturnType()-&gt;isVoidTy();\nllvm::Value *val &#x3D; Builder.CreateCall(\n    call,\n    args,\n    isVoid ? &quot;&quot; : &quot;calltmp&quot;\n);</code></pre>\n\n\n\n<h3 id=\"类型提升-boolean\"><a href=\"#类型提升-boolean\" class=\"headerlink\" title=\"类型提升 boolean\"></a>类型提升 boolean</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">llvm::Value *promo &#x3D; Builder.CreateZExt(*i, Builder.getInt32Ty(), &quot;zexttmp&quot;);</code></pre>\n\n\n\n<h3 id=\"全局字符串\"><a href=\"#全局字符串\" class=\"headerlink\" title=\"全局字符串\"></a>全局字符串</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">llvm::GlobalVariable *GS &#x3D; Builder.CreateGlobalString(s, &quot;globalstring&quot;);\nllvm::Value *stringConst &#x3D; Builder.CreateConstGEP2_32(GS-&gt;getValueType(), GS, 0, 0, &quot;cast&quot;);</code></pre>\n\n\n\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>验证函数声明</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">llvm::verifyFunction(F);</code></pre>\n\n\n\n<h2 id=\"剩下的（todo）\"><a href=\"#剩下的（todo）\" class=\"headerlink\" title=\"剩下的（todo）\"></a>剩下的（todo）</h2><p>需要hw3</p>\n<p>todo</p>\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><p><strong>全局标量</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; declare a global variable\nllvm::GlobalVariable *Foo &#x3D; new llvm::GlobalVariable(\n    *TheModule, \n    Builder.getInt32Ty(), \n    false,  &#x2F;&#x2F; variable is mutable\n    llvm::GlobalValue::InternalLinkage, \n    Builder.getInt32(0), \n    &quot;Foo&quot;\n);\n\n&#x2F;&#x2F; use\nllvm::Value *footmp &#x3D; Builder.CreateLoad(Foo, &quot;footmp&quot;);</code></pre>\n\n\n\n<p><strong>全局数组</strong></p>\n<p>定义和标量基本一样，只是类型不同</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; array size &#x3D; 10\nllvm::ArrayType *arrayi32 &#x3D; llvm::ArrayType::get(Builder.getInt32Ty(), 10);\n&#x2F;&#x2F; zeroinitalizer: initialize array to all zeroes\nllvm::Constant *zeroInit &#x3D; llvm::Constant::getNullValue(arrayi32);\n&#x2F;&#x2F; declare a global variable\nllvm::GlobalVariable *Foo &#x3D; new llvm::GlobalVariable(*TheModule, arrayi32, false, llvm::GlobalValue::ExternalLinkage, zeroInit, &quot;Foo&quot;);</code></pre>\n\n<p>读写</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; access Foo[8]\nllvm::Value *ArrayLoc &#x3D; Builder.CreateStructGEP(arrayi32, Foo, 0, &quot;arrayloc&quot;);\nllvm::Value *Index &#x3D; Builder.getInt32(8);\nllvm::Value *ArrayIndex &#x3D; Builder.CreateGEP(Builder.getInt32Ty(), ArrayLoc, Index, &quot;arrayindex&quot;);\n\n&#x2F;&#x2F; Foo[8] &#x3D; 1\nllvm::Value *ArrayStore &#x3D; Builder.CreateStore(Builder.getInt32(1), ArrayIndex);\n\n&#x2F;&#x2F; Value &#x3D; Foo[8]\nllvm::Value *Value &#x3D; Builder.CreateLoad(ArrayIndex, &quot;loadtmp&quot;);</code></pre>\n\n\n\n<p>获取Array的元素的类型</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">llvm::ArrayType *arrayTy &#x3D; (llvm::ArrayType *)GV-&gt;getValueType();\nllvm::Type *Ty &#x3D; arrayTy-&gt;getArrayElementType();</code></pre>\n\n\n\n\n\n<p>llvm::GlobalValue::InternalLinkage 和 ExternalLinkage 区别？</p>\n<h1 id=\"Homework-3-Expr-Codegen\"><a href=\"#Homework-3-Expr-Codegen\" class=\"headerlink\" title=\"Homework 3 Expr Codegen\"></a>Homework 3 Expr Codegen</h1><p>前置条件：hw2, llvm-practice</p>\n<p>目录：<code>decafexpr</code></p>\n<p>修改include</p>\n<p>修改<code>makefile</code></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yacclib&#x3D;y\nllvmlibs&#x3D;-lz -lncurses -ldl -lpthread -fcxx-exceptions</code></pre>\n\n<p>改为</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yacclib&#x3D;m\nllvmlibs&#x3D;-lm -lncurses -ldl -lpthread -fcxx-exceptions</code></pre>\n\n\n\n<h2 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h2><p>目标是实现Decaf语言的变量、简单表达式和函数的代码生成器</p>\n<p>输出是LLVM汇编，然后再编译成二进制文件</p>\n<p>第一步是实现<code>symbol table</code></p>\n<h2 id=\"任务-Step-1-符号表\"><a href=\"#任务-Step-1-符号表\" class=\"headerlink\" title=\"任务 Step 1: 符号表\"></a>任务 Step 1: 符号表</h2><p>实现一个符号表，跟踪 Decaf 中的变量和方法。</p>\n<p>每个<code>symbol_table</code>对应一个基本块</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef map&lt;string, descriptor*&gt; symbol_table;\ntypedef list&lt;symbol_table &gt; symbol_table_list;</code></pre>\n\n\n\n<p>在HW2的基础上修改AST生成代码，实现符号表</p>\n<p>目录<code>decafsym</code></p>\n<p>ast(hw2) &gt; sym(hw3 step1)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cp ..&#x2F;decafast&#x2F;answer&#x2F;default-defs.h .&#x2F;answer&#x2F;default-defs.h\ncp ..&#x2F;decafast&#x2F;answer&#x2F;decafast.cc .&#x2F;answer&#x2F;decafsym.cc\ncp ..&#x2F;decafast&#x2F;answer&#x2F;decafast.lex .&#x2F;answer&#x2F;decafsym.lex\ncp ..&#x2F;decafast&#x2F;answer&#x2F;decafast.y .&#x2F;answer&#x2F;decafsym.y</code></pre>\n\n\n\n<p>警告：</p>\n<ul>\n<li>class IdentifierAST<ul>\n<li>成员Name暴露了</li>\n</ul>\n</li>\n<li>class TypeAST<ul>\n<li>新增了str2</li>\n</ul>\n</li>\n</ul>\n<p>妈的不做<code>decafsym</code>了：</p>\n<ul>\n<li>func(a int, b int)，他的顺序和我相反，懒得搞</li>\n<li>要在每次use后面加注释，输出定义在哪行，好麻烦</li>\n</ul>\n<h2 id=\"任务-Step-2\"><a href=\"#任务-Step-2\" class=\"headerlink\" title=\"任务 Step 2:\"></a>任务 Step 2:</h2><p>为以下 Decaf 片段提供代码生成器：</p>\n<ul>\n<li>算术和布尔表达式<ul>\n<li>警告：不要尝试将此作业的布尔表达式短路。</li>\n</ul>\n</li>\n<li>函数调用</li>\n<li>函数定义（包括递归函数）</li>\n<li>外部函数（<code>extern func</code>）的声明（所有外部函数都在 decaf-stdlib.c 中定义）</li>\n</ul>\n<p>不要为字段（<code>field</code>）声明，即全局变量生成代码</p>\n<p>sym(hw3 step1) &gt; expr(hw3 step2)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cp ..&#x2F;..&#x2F;decafsym&#x2F;answer&#x2F;default-defs.h .&#x2F;default-defs.h\ncp ..&#x2F;..&#x2F;decafsym&#x2F;answer&#x2F;decafsym.cc .&#x2F;decafexpr.cc\ncp ..&#x2F;..&#x2F;decafsym&#x2F;answer&#x2F;decafsym.lex .&#x2F;decafexpr.lex\ncp ..&#x2F;..&#x2F;decafsym&#x2F;answer&#x2F;decafsym.y .&#x2F;decafexpr.y</code></pre>\n\n\n\n<p><strong>定义域</strong></p>\n<p>decaf中什么时候会enter_scope（带*表示已经在Codegen中写好）</p>\n<ul>\n<li>program（root）*</li>\n<li>package *</li>\n<li>method_block *</li>\n<li>block</li>\n</ul>\n<p><strong>Warning</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class BinaryOpAST\n\tpublic: enum BINARYOP Op;\n\nclass UnaryOpAST\n\tpublic: int Op;\n\t\nclass decafStmtList\n\tpublic: list&lt;decafAST *&gt; stmts;\n\nclass TypeAST\n    public: int Type;\n\ntryCast 返回值可能为null？，调用该函数的地方并没有检测\n    \nclass VariableExprAST\n    总是解引用\n\nclass Method\n    总是在最后添加默认return</code></pre>\n\n\n\n<p><strong>一元二元运算</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">Value *L &#x3D; LHS-&gt;Codegen();\nValue *R &#x3D; RHS-&gt;Codegen();\nreturn Builder.CreateAdd(L, R, &quot;addtmp&quot;);</code></pre>\n\n\n\n<p>除法</p>\n<ul>\n<li>SDIV：signed </li>\n<li>UDIV：unsigned</li>\n<li>FDIV：float</li>\n</ul>\n<p>一元操作</p>\n<ul>\n<li>Neg：一元减</li>\n<li>Not：一元非</li>\n</ul>\n<p><strong>测试</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">clear\nrm decafexpr\nmake decafexpr\ncd ..&#x2F;\npython3 zipout.py -r decafexpr\npython3 check.py -l log.txt</code></pre>\n\n\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">rm decafexpr; make decafexpr\n.&#x2F;decafexpr &lt; ..&#x2F;testcases&#x2F;dev&#x2F;and.decaf</code></pre>\n\n\n\n<h1 id=\"Homework-4-Decaf-Compiler\"><a href=\"#Homework-4-Decaf-Compiler\" class=\"headerlink\" title=\"Homework 4 Decaf Compiler\"></a>Homework 4 Decaf Compiler</h1><p>前置条件：hw3</p>\n<p>目录：<code>decafcomp</code></p>\n<p>复制<code>decafexpr</code>(hw3)为<code>decafcommp</code>(hw4)：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cp ..&#x2F;..&#x2F;decafexpr&#x2F;answer&#x2F;decafexpr.cc .&#x2F;decafcomp.cc\ncp ..&#x2F;..&#x2F;decafexpr&#x2F;answer&#x2F;decafexpr.lex .&#x2F;decafcomp.lex\ncp ..&#x2F;..&#x2F;decafexpr&#x2F;answer&#x2F;decafexpr.y .&#x2F;decafcomp.y</code></pre>\n\n<p>并修改include</p>\n<p>修改<code>makefile</code></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yacclib&#x3D;y\nllvmlibs&#x3D;-lz -lncurses -ldl -lpthread -fcxx-exceptions</code></pre>\n\n<p>改为</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yacclib&#x3D;m\nllvmlibs&#x3D;-lm -lncurses -ldl -lpthread -fcxx-exceptions</code></pre>\n\n\n\n<h2 id=\"挑战-1\"><a href=\"#挑战-1\" class=\"headerlink\" title=\"挑战\"></a>挑战</h2><p>写一个完整的Decaf语言编译器</p>\n<h2 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h2><p><strong>warning</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">VariableExprAST\n没有做类型检查\n因为tAllocaInst和tGlobalVariable\n都是Builder.CreateLoad(Val)\n\nclass FieldSizeAST\n    public: int Size;</code></pre>\n\n\n\n\n\n<h3 id=\"Step-1-Global-Variables\"><a href=\"#Step-1-Global-Variables\" class=\"headerlink\" title=\"Step 1: Global Variables\"></a>Step 1: Global Variables</h3><p>即field variables</p>\n<p>全局变量的定义：FieldDeclAST、AssignGlobalVarAST</p>\n<p>数组：（右值）ArrayLocExprAST、（左值）AssignArrayLocAST</p>\n<h3 id=\"Step-2-Zero-initialize-all-variables\"><a href=\"#Step-2-Zero-initialize-all-variables\" class=\"headerlink\" title=\"Step 2: Zero initialize all variables\"></a>Step 2: Zero initialize all variables</h3><p>VarDefAST 中在定义后进行0初始化</p>\n<h3 id=\"Step-3-Control-flow-and-Loops\"><a href=\"#Step-3-Control-flow-and-Loops\" class=\"headerlink\" title=\"Step 3: Control flow and Loops\"></a>Step 3: Control flow and Loops</h3><p>循环AST中会新建一个scope，第一个目的是便于存放BB，用于break、continue</p>\n<p>第二个目的是Condition中可能定义新变量（我不知道decaf支不支持，给出C的例子）</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">for (int i &#x3D; 0; i &lt; 10; i++) j++;</code></pre>\n\n\n\n<p>下面给出对应关系</p>\n<ul>\n<li>IfStmtAST<ul>\n<li>不需要</li>\n</ul>\n</li>\n<li>WhileStmtAST<ul>\n<li>loop - continue</li>\n<li>end - break</li>\n</ul>\n</li>\n<li>ForStmtAST<ul>\n<li>next - continue</li>\n<li>end - break</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Step-4-Short-Circuit\"><a href=\"#Step-4-Short-Circuit\" class=\"headerlink\" title=\"Step 4: Short Circuit\"></a>Step 4: Short Circuit</h3><p><strong>测试样例</strong></p>\n<ul>\n<li><p>skct：可以静态解决</p>\n</li>\n<li><p>short-circuit-bool：只能运行时解决</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; skct\nextern func print_int(int) void;\nextern func print_string(string) void;\n\npackage foo &#123;\n    func foo() bool &#123;\n        print_string(&quot;foo&quot;);\n        return(false);\n    &#125;\n    func main() int &#123;\n        var flag bool;\n        flag &#x3D; true || foo() &amp;&amp; !true;\n        print_int(flag);\n    &#125;\n&#125;</code></pre>\n\n<p>期望输出：1</p>\n<p>我未处理前输出：foo1</p>\n<p><strong>分析</strong></p>\n<p>第11行代码整理如下（优先级：非&gt;与&gt;或）：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">flag &#x3D; true || (foo() &amp;&amp; (!true));</code></pre>\n\n<p>首先，<code>true || any == true</code>，所以flag一定为true</p>\n<p>如果把整个表达式都执行一遍，foo()会输出<code>&quot;foo&quot;</code>，然后输出flag<code>&quot;1&quot;</code></p>\n<p>但Short Circuit的话，会把<code>||</code>后面的短路掉，foo()不会执行</p>\n<p><strong>短路规则</strong></p>\n<ul>\n<li><p><code>1 or x == 1</code>、<code>0 or x == x</code></p>\n</li>\n<li><p><code>0 and x == 0</code>、<code>1 and x == x</code></p>\n</li>\n</ul>\n<p><strong>短路思路</strong></p>\n<p>1 编译时短路：</p>\n<p>根据规则，将运算替换成常量。比如将<code>true || a</code>替换为<code>true</code></p>\n<p>判断变量是否为整数常量，并获取其布尔值：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">llvm::Value *Val\nllvm::ConstantInt *C;\nif ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(Val))) &#123;\n    if(C-&gt;getValue().getBoolValue()) &#123;\n        return Builder.getInt1(true);\n    &#125;\n&#125;</code></pre>\n\n<p>可以先新建两个BB存储L、R的expr，如果优化失败，最后再合并</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto CurBB &#x3D; Builder.GetInsertBlock();\nauto func &#x3D; CurBB-&gt;getParent();\n&#x2F;&#x2F; ... (gen LBB RBB)\nLBB-&gt;insertInto(func, CurBB);\nRBB-&gt;insertInto(func, CurBB);\nBuilder.SetInsertPoint(CurBB);\nreturn Builder.CreateOr(L, R, &quot;ortmp&quot;);</code></pre>\n\n\n\n<p>2 运行时短路：</p>\n<p>将<code>a || b</code>改写成：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">if (a) &#123;\n\tres &#x3D; true;\n&#125; else if (b) &#123;\n    res &#x3D; true;\n&#125;\n\nif (a) &#123;\n\tres &#x3D; true;\n&#125; else &#123;\n    res &#x3D; b;\n&#125;</code></pre>\n\n<p>将<code>a &amp;&amp; b</code>（等价<code>~(~a || ~b)</code>）改写成：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">if (!a) &#123;\n\tres &#x3D; false;\n&#125; else if (!b) &#123;\n    res &#x3D; false;\n&#125;\n\nif (!a) &#123;\n\tres &#x3D; false;\n&#125; else &#123;\n    res &#x3D; !b;\n&#125;</code></pre>\n\n\n\n<p>缺点：假设a、b是变量，而不是函数调用，那么这个短路显然没有必要</p>\n<p>3 优化（仅思路）：</p>\n<p>思路1：先尝试静态短路，再使用动态短路</p>\n<p>思路2：只使用运行时短路，然后使用常量传播、剪枝等优化，起到静态短路的剪枝效果</p>\n<p><strong>实现1</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">if (Op-&gt;Op &#x3D;&#x3D; And) &#123;\n    &#x2F;&#x2F; static short circuit\n    llvm::ConstantInt* C;\n    if ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(L))) &#123;\n        if(!C-&gt;getValue().getBoolValue()) &#123;\n            auto bb &#x3D; llvm::BasicBlock::Create(TheContext);\n            Builder.SetInsertPoint(CurBB);\n            return Builder.getInt1(false);\n        &#125;\n    &#125;\n    if ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(R))) &#123;\n        if(!C-&gt;getValue().getBoolValue()) &#123;\n            Builder.SetInsertPoint(CurBB);\n            return Builder.getInt1(false);\n        &#125;\n    &#125;\n    LBB-&gt;insertInto(func, CurBB);\n    RBB-&gt;insertInto(func, CurBB);\n    Builder.SetInsertPoint(CurBB);\n    return Builder.CreateAnd(L, R, &quot;andtmp&quot;);\n&#125;\n\nif (Op-&gt;Op &#x3D;&#x3D; Or) &#123;\n    &#x2F;&#x2F; static short circuit\n    llvm::ConstantInt* C;\n    if ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(L))) &#123;\n        if(C-&gt;getValue().getBoolValue()) &#123;\n            auto bb &#x3D; llvm::BasicBlock::Create(TheContext);\n            Builder.SetInsertPoint(CurBB);\n            return Builder.getInt1(true);\n        &#125;\n    &#125;\n    if ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(R))) &#123;\n        if(C-&gt;getValue().getBoolValue()) &#123;\n            Builder.SetInsertPoint(CurBB);\n            return Builder.getInt1(true);\n        &#125;\n    &#125;\n    LBB-&gt;insertInto(func, CurBB);\n    RBB-&gt;insertInto(func, CurBB);\n    Builder.SetInsertPoint(CurBB);\n    return Builder.CreateOr(L, R, &quot;ortmp&quot;);\n&#125;</code></pre>\n\n\n\n\n\n<p><strong>实现2</strong></p>\n<p>纯运行时短路</p>\n<p>And和Or的区别只有<code>skct BB</code>结尾的<code>CreateCondBr</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">if (Op-&gt;Op &#x3D;&#x3D; And) &#123;\n    auto CurBB &#x3D; Builder.GetInsertBlock();\n    auto func &#x3D; CurBB-&gt;getParent();\n    &#x2F;&#x2F; dynamic short circuit\n    auto noskctBB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;noskct&quot;, func);\n    auto endBB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;endskct&quot;, func);\n    &#x2F;&#x2F; cur (skct)\n    auto L &#x3D; LeftValue-&gt;Codegen();\n    auto LBB &#x3D; Builder.GetInsertBlock(); &#x2F;&#x2F; LeftValue codegen maybe create new BB\n    Builder.CreateCondBr(L, noskctBB, endBB);\n    &#x2F;&#x2F; noskct\n    Builder.SetInsertPoint(noskctBB);\n    auto R &#x3D; RightValue-&gt;Codegen();\n    auto RBB &#x3D; Builder.GetInsertBlock(); &#x2F;&#x2F; RightValue codegen maybe create new BB\n    Builder.CreateBr(endBB);\n    &#x2F;&#x2F; endskct\n    Builder.SetInsertPoint(endBB);\n    llvm::PHINode *val &#x3D; Builder.CreatePHI(Builder.getInt1Ty(), 2, &quot;phival&quot;);\n    val-&gt;addIncoming(L, LBB);\n    val-&gt;addIncoming(R, RBB);\n    return val;\n&#125;\n\nif (Op-&gt;Op &#x3D;&#x3D; Or) &#123;\n    auto CurBB &#x3D; Builder.GetInsertBlock();\n    auto func &#x3D; CurBB-&gt;getParent();\n    &#x2F;&#x2F; dynamic short circuit\n    auto noskctBB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;noskct&quot;, func);\n    auto endBB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;endskct&quot;, func);\n    &#x2F;&#x2F; cur (skct)\n    auto L &#x3D; LeftValue-&gt;Codegen();\n    auto LBB &#x3D; Builder.GetInsertBlock(); &#x2F;&#x2F; LeftValue codegen maybe create new BB\n    Builder.CreateCondBr(L, endBB, noskctBB);\n    &#x2F;&#x2F; noskct\n    Builder.SetInsertPoint(noskctBB);\n    auto R &#x3D; RightValue-&gt;Codegen();\n    auto RBB &#x3D; Builder.GetInsertBlock(); &#x2F;&#x2F; RightValue codegen maybe create new BB\n    Builder.CreateBr(endBB);\n    &#x2F;&#x2F; endskct\n    Builder.SetInsertPoint(endBB);\n    llvm::PHINode *val &#x3D; Builder.CreatePHI(Builder.getInt1Ty(), 2, &quot;phival&quot;);\n    val-&gt;addIncoming(L, LBB);\n    val-&gt;addIncoming(R, RBB);\n    return val;\n&#125;</code></pre>\n\n\n\n<h3 id=\"Step-5-Semantics\"><a href=\"#Step-5-Semantics\" class=\"headerlink\" title=\"Step 5: Semantics\"></a>Step 5: Semantics</h3><p><strong>已实现语法检查</strong></p>\n<p>按在代码中位置排序</p>\n<p>[序号]. “[错误信息]”（[检查位置]）： [描述]</p>\n<ol>\n<li>“unknown type”（getLLVMType）：未知变量类型，无法返回对应的<code>llvm::Type</code></li>\n<li>“unknown type when zero init”（getZeroInit）：该类型不支持零初始化，只支持Int和Bool</li>\n<li>“promoting fail”（tryCast）：类型提升错误，只支持布尔到整型</li>\n<li>“symbol ‘“ + ident +  “‘ not find”（access_symtbl）：没有在符号表中找到</li>\n<li>“no package definition in decaf program”（ProgramAST）：没有Package</li>\n<li>“expect return void, but return something”（ReturnStmtAST）：返回值类型错误</li>\n<li>“expect return something, but return void”（ReturnStmtAST）：返回值类型错误</li>\n<li>“no found symtbl break”（BreakStmtAST）：break失败，可能不在循环语句中</li>\n<li>“no found symtbl continue”（ContinueStmtAST）：continue失败，可能不在循环语句中</li>\n<li>“not a valid lvalue”（AssignVarAST）：左值类型不正确，应为位置，即<code>tAllocaInst</code>或<code>tGlobalVariable</code></li>\n<li>“lvalue is not glboal array”（AssignArrayLocAST）：左值类型不正确，应为数组<code>tGlobalArray</code></li>\n<li>“array index should be Integer”（AssignArrayLocAST）：数组下标应为整型</li>\n<li>“too many argments”（MethodCallAST）：传入参数多于函数定义</li>\n<li>“unknown binary op”（BinaryExprAST）：未知二元操作</li>\n<li>“unknown unary op”（UnaryExprAST）：未知一元操作</li>\n<li>“rvalue is not a array”（ArrayLocExprAST）：右值类型不正确，应为数组</li>\n<li>“array index should be Integer”（ArrayLocExprAST）：数组下标应为整型</li>\n</ol>\n<p><strong>忽略（不抛出运行时错误）</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>该列表参考 Decaf Spec - Decaf Semantics - Type Checking</p>\n<p><a href=\"http://anoopsarkar.github.io/compilers-class/decafspec.html\">SFU Compilers class: Decaf Specification (anoopsarkar.github.io)</a></p></blockquote>\n<ul>\n<li>算术运算符操作数只能是整型</li>\n<li>逻辑运算符操作数只能是布尔型</li>\n<li>相等运算符操作数类型必须相同</li>\n<li>函数参数应类似于局部变量（已实现）</li>\n<li>与和或运算使用short circuit（已实现）</li>\n<li>If you have multiple return statements in one block then only the first is used, but the others should still be type checked.</li>\n<li>省略了，写不下去了</li>\n</ul>\n<p><strong>注意</strong></p>\n<p><code>tGlobalVariable</code>对应全局标量，对应llvm中的标量<code>GlobalVariable</code></p>\n<p><code>tGlobalArray</code>对应全局数组，对应llvm中的数组<code>GlobalVariable</code></p>\n<p><strong>测试样例</strong></p>\n<ul>\n<li>err-bool-index：<code>x = xs[true];</code>，数组下标不能为布尔值</li>\n<li>if-scoping：我报错的原因是BlockAST继承自MethodBlockAST</li>\n<li>err-return-type：类型提升的问题，整型不应该能提升为布尔型</li>\n<li>undefined-return：我把语法错误信息输出到stdout里了</li>\n</ul>\n<h3 id=\"Step-6-Error-reporting\"><a href=\"#Step-6-Error-reporting\" class=\"headerlink\" title=\"Step 6: Error reporting\"></a>Step 6: Error reporting</h3><p>参考Step5里面的 <strong>已实现语法检查</strong> 列表</p>\n<h3 id=\"Step-7-Code-optimization-可选-（todo）\"><a href=\"#Step-7-Code-optimization-可选-（todo）\" class=\"headerlink\" title=\"Step 7: Code optimization (可选)（todo）\"></a>Step 7: Code optimization (可选)（todo）</h3><p>可选实施以下优化：</p>\n<ul>\n<li>将使用堆栈（Alloca）转为使用寄存器（mem2reg）</li>\n<li>简单的peephole优化（instruction combining pass）</li>\n<li>Re-associate expresssions</li>\n<li>Eliminate common sub-expressions (GVN)</li>\n<li>简化CFG</li>\n</ul>\n<p>可以使用 LLVM <code>opt</code> 工具，该工具执行上述所有优化</p>\n<p>也可以使用 LLVM API <code>FunctionPassManager</code> 实现优化pass，<a href=\"https://llvm.org/docs/WritingAnLLVMPass.html\">Writing an LLVM Pass — LLVM 16.0.0git documentation</a></p>\n<h3 id=\"Step8-Add-source-level-debug-info-可选-（todo）\"><a href=\"#Step8-Add-source-level-debug-info-可选-（todo）\" class=\"headerlink\" title=\"Step8: Add source-level debug info (可选)（todo）\"></a>Step8: Add source-level debug info (可选)（todo）</h3><p>todo</p>\n<h2 id=\"更正（相对于hw3）\"><a href=\"#更正（相对于hw3）\" class=\"headerlink\" title=\"更正（相对于hw3）\"></a>更正（相对于hw3）</h2><p>BlockAST不再继承自MethodBlockAST</p>\n<p>MethodBlockAST不再新建scope</p>\n<p>现有enter_scope：</p>\n<ul>\n<li><p>ProgramAST（root scope）</p>\n</li>\n<li><p>PackageAST</p>\n</li>\n<li><p>MethodAST（在BodyCodegen()中）</p>\n</li>\n<li><p>BlockAST</p>\n</li>\n<li><p>WhileStmtAST</p>\n</li>\n<li><p>ForStmtAST</p>\n</li>\n</ul>\n<p>取消：</p>\n<ul>\n<li><p>MethodBlockAST</p>\n</li>\n<li><p>IfStmtAST：</p>\n</li>\n</ul>\n","text":"SFU Compilers 笔记 6 语义分析和代码生成2llvm-p hw3 hw4 Practice LLVM环境如何在不同环境使用makefile： CSIL Linux机器：make llvmconfig=llvm-config-12 all（似乎是SFU的在线环境） m...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"CS","slug":"CS","count":6,"path":"api/categories/CS.json"}],"tags":[{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"cs","slug":"cs","count":6,"path":"api/tags/cs.json"},{"name":"compiler","slug":"compiler","count":6,"path":"api/tags/compiler.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SFU-Compilers-%E7%AC%94%E8%AE%B0-6-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%902\"><span class=\"toc-text\">SFU Compilers 笔记 6 语义分析和代码生成2</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Practice-LLVM\"><span class=\"toc-text\">Practice LLVM</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">环境</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">安装</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Decaf%E6%A0%87%E5%87%86%E5%BA%93\"><span class=\"toc-text\">Decaf标准库</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hello-World\"><span class=\"toc-text\">Hello World</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8Decaf%E7%9A%84%E5%BA%93%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">使用Decaf的库函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E9%80%92%E5%BD%92\"><span class=\"toc-text\">简单递归</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LLVM-C-API-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">LLVM C++ API 简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%B4%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">头文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">模块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LLVM-Value\"><span class=\"toc-text\">LLVM::Value</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LLVM-Type\"><span class=\"toc-text\">LLVM::Type</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LLVM-Constant\"><span class=\"toc-text\">LLVM::Constant</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88%E4%B8%8A%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">栈上存储</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%9C%AF%E5%92%8C%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">算术和布尔运算</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">函数定义</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">函数调用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87-boolean\"><span class=\"toc-text\">类型提升 boolean</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">全局字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">验证</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%A9%E4%B8%8B%E7%9A%84%EF%BC%88todo%EF%BC%89\"><span class=\"toc-text\">剩下的（todo）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">全局变量</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Homework-3-Expr-Codegen\"><span class=\"toc-text\">Homework 3 Expr Codegen</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%91%E6%88%98\"><span class=\"toc-text\">挑战</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1-Step-1-%E7%AC%A6%E5%8F%B7%E8%A1%A8\"><span class=\"toc-text\">任务 Step 1: 符号表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1-Step-2\"><span class=\"toc-text\">任务 Step 2:</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Homework-4-Decaf-Compiler\"><span class=\"toc-text\">Homework 4 Decaf Compiler</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%91%E6%88%98-1\"><span class=\"toc-text\">挑战</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">任务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Step-1-Global-Variables\"><span class=\"toc-text\">Step 1: Global Variables</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Step-2-Zero-initialize-all-variables\"><span class=\"toc-text\">Step 2: Zero initialize all variables</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Step-3-Control-flow-and-Loops\"><span class=\"toc-text\">Step 3: Control flow and Loops</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Step-4-Short-Circuit\"><span class=\"toc-text\">Step 4: Short Circuit</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Step-5-Semantics\"><span class=\"toc-text\">Step 5: Semantics</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Step-6-Error-reporting\"><span class=\"toc-text\">Step 6: Error reporting</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Step-7-Code-optimization-%E5%8F%AF%E9%80%89-%EF%BC%88todo%EF%BC%89\"><span class=\"toc-text\">Step 7: Code optimization (可选)（todo）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Step8-Add-source-level-debug-info-%E5%8F%AF%E9%80%89-%EF%BC%88todo%EF%BC%89\"><span class=\"toc-text\">Step8: Add source-level debug info (可选)（todo）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%AD%A3%EF%BC%88%E7%9B%B8%E5%AF%B9%E4%BA%8Ehw3%EF%BC%89\"><span class=\"toc-text\">更正（相对于hw3）</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"angr-ctf","uid":"771dec62b399749444e273209cdd8e6e","slug":"angr-ctf","date":"2022-10-27T04:00:00.000Z","updated":"2024-01-05T07:10:16.932Z","comments":true,"path":"api/articles/angr-ctf.json","keywords":null,"cover":null,"text":"angr_ctfjakespringer/angr_ctf (github.com) angr CTF (oregonctf.org) angr符号执行练习 00_angr_find_哔哩哔哩_bilibili angr 学习 | SkYe231 Blog (mrskye.cn)...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"CTF","slug":"CTF","count":8,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":8,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":12,"path":"api/tags/re.json"},{"name":"angr","slug":"angr","count":1,"path":"api/tags/angr.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"SFU Compilers class 笔记5","uid":"40c2cd491a15172739073405816f8de7","slug":"SFU-Compilers-5","date":"2022-09-19T04:00:00.000Z","updated":"2024-01-05T07:02:57.747Z","comments":true,"path":"api/articles/SFU-Compilers-5.json","keywords":null,"cover":[],"text":"SFU Compilers 笔记 5 语义分析和代码生成1week8 week9 week10 week11 Week 8 Semantics and Runtime SupportSEM1 Scoping语义分析的目标 确保程序有明确意义 验证前面两步分析中，没有捕获的程序的属...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"CS","slug":"CS","count":6,"path":"api/categories/CS.json"}],"tags":[{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"cs","slug":"cs","count":6,"path":"api/tags/cs.json"},{"name":"compiler","slug":"compiler","count":6,"path":"api/tags/compiler.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}