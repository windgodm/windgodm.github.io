{"title":"《逆向工程实战》实例A","uid":"a8aaa1ce0f83038b9e68ef408652298f","slug":"practicalreA","date":"2022-03-07T04:00:00.000Z","updated":"2022-04-13T13:57:40.716Z","comments":true,"path":"api/articles/practicalreA.json","keywords":null,"cover":null,"content":"<h1 id=\"《逆向工程实战》实例A\"><a href=\"#《逆向工程实战》实例A\" class=\"headerlink\" title=\"《逆向工程实战》实例A\"></a>《逆向工程实战》实例A</h1><p>参照书上对实例A的分析过程，对实例A的完整分析记录</p>\n<p>一个挺短的驱动后门（x86），用于支持R3程序修改SSDT，估计是xp或者win7时代的</p>\n<h2 id=\"DriverEntry-amp-DriverUnload\"><a href=\"#DriverEntry-amp-DriverUnload\" class=\"headerlink\" title=\"DriverEntry &amp; DriverUnload\"></a>DriverEntry &amp; DriverUnload</h2><p><code>DosDevices</code>是<code>??</code>的别名</p>\n<p><strong>DriverEntry</strong></p>\n<p>只是正常的初始化</p>\n<p>IRP：支持Create、Close、DeviceIoControl：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">mov     ecx, [ebp+DriverObject] ; ecx &#x3D; pDriverObj\n; 0,MJ_CREATE\nmov     dword ptr [ecx+38h], offset MJ_Create_Close_Ioctl\nmov     edx, [ebp+DriverObject]\n; 2,MJ_CLOSE\nmov     dword ptr [edx+40h], offset MJ_Create_Close_Ioctl\nmov     eax, [ebp+DriverObject]\n; 0xE,MJ_DEVICE_CONTROL\nmov     dword ptr [eax+70h], offset MJ_Create_Close_Ioctl\nmov     ecx, [ebp+DriverObject]\n; pDriverObj-&gt;DriverUnload\nmov     dword ptr [ecx+34h], offset DriverUnload</code></pre>\n\n\n\n<p>支持DriverUnload</p>\n<p>先尝试删除符号链接再重新创建</p>\n<p><strong>DriverUnload</strong></p>\n<p>也是正常的卸载</p>\n<p>删除了符号链接和设备</p>\n<p>从传入的驱动对象中获取设备指针：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">mov     eax, [ebp+DriverObject] ; pDriverObj\nmov     ecx, [eax+4]    ; pDriverObj-&gt;DeviceObject\npush    ecx             ; DeviceObject\ncall    ds:IoDeleteDevice</code></pre>\n\n\n\n<h2 id=\"IRP处理函数\"><a href=\"#IRP处理函数\" class=\"headerlink\" title=\"IRP处理函数\"></a>IRP处理函数</h2><p>Create、Close、DeviceIoCtrl都在同一个函数中</p>\n<p>首先是初始化IRP的返回状态，并获取IRP的类型：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">mov     eax, [ebp+Irp]\nmov     ecx, [ebp+status]\nmov     [eax+18h], ecx  ; Irp-&gt;IoStatus.Status &#x3D; status &#x3D; 0\nmov     edx, [ebp+Irp]\nmov     dword ptr [edx+1Ch], 0 ; Irp-&gt;IoStatus.Information &#x3D; 0\nmov     eax, [ebp+Irp]\nmov     ecx, [eax+60h]  ; ecx &#x3D; Irp-&gt;Tail.Overlay.CurrentStackLocation\nmov     [ebp+stack], ecx\nmov     edx, [ebp+stack]\nmovzx   eax, byte ptr [edx] ; eax &#x3D; stack-&gt;MajorFunction</code></pre>\n\n<p>IoGetCurrentIrpStackLocation是内联的：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">PIO_STACK_LOCATION IoGetCurrentIrpStackLocation(PIRP Irp) &#123;\n    return Irp-&gt;Tail.Overlay.CurrentStackLocation; &#x2F;&#x2F; ret [pIrp + 0x60]\n&#125;</code></pre>\n\n\n\n<p>整个处理逻辑是如果为Create、Close则直接返回成功</p>\n<p>如果为DeviceIoCtrl则检测CTL_CODE</p>\n<p><strong>DeviceIoCtrl</strong></p>\n<p>这一段汇编主要都是对结构体的操作，参照着结构体的定义就行</p>\n<p>需要注意的是，IO_STACK_LOCATION中有个union，要根据IRP的类型选择对应的结构</p>\n<p>这里贴一下实例中用到的偏移：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">IO_STACK_LOCATION\n  0xC  Parameters.DeviceIoControl.IoControlCode\n\nIRP\n  0xC  AssociatedIrp.SystemBuffer\n  0x18 IoStatus.Status\n  0x1C IoStatus.Information</code></pre>\n\n\n\n<p>会判断<code>CTL_CODE</code>是否为<code>0x22C004</code></p>\n<p>如果不是则返回<code>0xC0000010(STATUS_INVALID_OPERATION)</code></p>\n<p>如果是则调用<code>sub_103B0</code></p>\n<h2 id=\"DeviceIoCtrl处理函数\"><a href=\"#DeviceIoCtrl处理函数\" class=\"headerlink\" title=\"DeviceIoCtrl处理函数\"></a>DeviceIoCtrl处理函数</h2><p><code>IOCTL_handler(sub_103B0)</code>是处理<code>CTL_CODE=0x22C004</code>的函数（只有一个控制码）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">CTL_CODE 0x22C004\nDeviceType 0x22 FILE_DEVICE_UNKNOWN (def in ntifs.h DEVICE TYPE)\nFunction  0x1\nMethod    0x0   METHOD_NEITHER\nAccess    0x3   FILE_ACCESS_ANY</code></pre>\n\n<p>其中会调用到<code>sub_10460</code>和<code>sub_10550</code>，这两个是一对的函数</p>\n<p><strong>MapLockedMdl(sub_10460)</strong></p>\n<p>这个就是创建一个Mdl、以写权限锁定页面，映射</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">*pPMdl &#x3D; IoAllocateMdl(VirtualAddress, Length, 0, 0, 0);\nMmProbeAndLockPages(*pPMdl, KernelMode, IoWriteAccess);\nnewAddr &#x3D; MmMapLockedPagesSpecifyCache(*pPMdl, KernelMode, MmNonCached, 0, 0, NormalPagePriority);\n\n&#x2F;&#x2F; KernelMode 0\n&#x2F;&#x2F; NormalPagePriority 0x10</code></pre>\n\n\n\n<p>MmProbeAndLockPages需要在try中执行，在函数开头会有一段相关的汇编：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">push    ebp\nmov     ebp, esp                ; stack frame\npush    0FFFFFFFFh              ; ???\npush    offset stru_10748       ; ???\npush    offset _except_handler3 ; NewSEH.Handler\nmov     eax, large fs:0\npush    eax                     ; NewSEH.Next &#x3D; pOldSEH\nmov     large fs:0, esp         ; pSEH &#x3D; &amp;NewSEH\nadd     esp, 0FFFFFFF0h\npush    ebx\npush    esi\npush    edi\nmov     [ebp+ms_exc.old_esp], esp</code></pre>\n\n\n\n<p><strong>UnmapLockedMdl(sub_10550)</strong></p>\n<p>这个函数就是解除锁定页面映射、解锁页面，释放Mdl</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void __stdcall UnmapMdl(PMDL MemoryDescriptorList, PVOID BaseAddress)\n&#123;\n  MmUnmapLockedPages(BaseAddress, MemoryDescriptorList);\n  MmUnlockPages(MemoryDescriptorList);\n  IoFreeMdl(MemoryDescriptorList);\n&#125;</code></pre>\n\n\n\n<p><strong>IOCTL_handler(sub_103B0)</strong></p>\n<p>现在回到<code>IOCTL_handler(sub_103B0)</code></p>\n<p>整个函数IRQL处于DpcLevel中，会屏蔽掉线程分发器</p>\n<p>SDT的结构体：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _KSERVICE_TABLE_DESCRIPTOR\n&#123;\n    PULONG Base;   &#x2F;&#x2F; address or SSDT\n    PULONG Count;\n    ULONG Limit;   &#x2F;&#x2F; number of SSDT\n    PUCHAR Number;\n    &#x2F;&#x2F; ...\n&#125; KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</code></pre>\n\n\n\n<p>首先通过<code>MapLockedMdl(sub_10460)</code>创建了一个SSDT的写入权限映射：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">pSSDT &#x3D; (UINT32 *)MapLockedMdl(\n    &amp;MemoryDescriptorList,\n    KeServiceDescriptorTable.Base,\n    4 * KeServiceDescriptorTable.Limit;)</code></pre>\n\n\n\n<p>然后修改SSDT（符号：KiServiceTable）</p>\n<p>反编译：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">for ( i &#x3D; 0; i &lt; *newSSDT; ++i ) &#123;\n    if ( newSSDT[i + 1] ) &#123;\n        if ( pSSDT[i] !&#x3D; newSSDT[i + 1] )\n    \t\t_InterlockedExchange(pSSDT[i], newSSDT[i + 1]);\n    &#125;\n&#125;</code></pre>\n\n<p>核心部分反汇编：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">mov     edx, [ebp+var_8]\nmov     eax, [ebp+newSSDT]\nmov     ecx, [eax+edx*4+4] ; ecx &#x3D; newSSDT[i+1]\nmov     edx, [ebp+var_8]\nmov     eax, [ebp+pSSDT]\nlea     edx, [eax+edx*4] ; edx &#x3D; &amp;pSSDT[i]\nxchg    ecx, [edx]      ; swap(newSSDT[i+1], pSSDT[i])</code></pre>\n\n<p>得到输入缓冲区的结构如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">const int SYSCALL_NUM;\n\nstruct INBUF &#123;\n    int number &#x3D; SYSCALL_NUM;\n    void* syscalls[SYSCALL_NUM];\n&#125;</code></pre>\n\n\n\n<p>最后是释放与还原环境</p>\n<h2 id=\"思考题与总结\"><a href=\"#思考题与总结\" class=\"headerlink\" title=\"思考题与总结\"></a>思考题与总结</h2><p>win10这种办法应该是不行的，ssdt是只读的<br>对只读内存，MmProbeAndLockPages(IoWriteAccess)会导致蓝屏</p>\n<p><strong>书中题目</strong></p>\n<p>（1）这个驱动程序能工作于多核系统吗？</p>\n<p>在《windows kernel programing》中关于高IRQL同步的章节有讲到，提高IRQL不能应对多核情况的线程同步，原因是IRQL是于cpu核心关联的</p>\n<p>即使驱动线程所在的cpu核心的irql等级禁用了中断，另外一个核心的irql可能是0，仍然可以触发低等级的中断</p>\n<p>（2）为什么作者认为需要把IRQL提示到DISPATCH_LEVEL？是否有必要？</p>\n<p>我猜作者的目的是保护SSDT读写过程</p>\n<p>通常R3通过中断进入R0，并传入一个SSDT的索引，指定要执行的SSDT表项</p>\n<p>而DISPATCH_LEVEL是软件中断的最高级别，没有找到系统调用相关的信息，但系统调用也是通过软件中断实现的，猜测是禁用中断来达到禁止系统调用的目的</p>\n<p>（3）普通用户如何通过这个驱动在R0上下文任意执行代码？</p>\n<p>首先需要申请一块非页池内存，写入shellcode</p>\n<p>然后利用该驱动把shellcode的地址写入SSDT</p>\n<p>最后在R3触发对应的中断，就会进入R0并执行shellcode</p>\n<p>（4）假定作者想要通过用户空间的自定义替换某些系统调用，可能会遇到哪些问题？</p>\n<p>首先原系统调用的功能如何保留是个问题，有可能别的程序需要原功能</p>\n<p>然后就是win10直接尝试写入SSDT会蓝屏，MmProbeAndLockPages(IoWriteAccess)也会蓝</p>\n<p>另外shellcode需要在非页池内存中，如果在用户空间或页池中，可能会出现上下文不同或者换出的问题</p>\n","text":"《逆向工程实战》实例A参照书上对实例A的分析过程，对实例A的完整分析记录 一个挺短的驱动后门（x86），用于支持R3程序修改SSDT，估计是xp或者win7时代的 DriverEntry &amp; DriverUnloadDosDevices是??的别名 DriverEntry...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"Windows","slug":"Windows","count":21,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":21,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"practicalre","slug":"practicalre","count":5,"path":"api/tags/practicalre.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E5%AE%9E%E4%BE%8BA\"><span class=\"toc-text\">《逆向工程实战》实例A</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DriverEntry-amp-DriverUnload\"><span class=\"toc-text\">DriverEntry &amp; DriverUnload</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IRP%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">IRP处理函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DeviceIoCtrl%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">DeviceIoCtrl处理函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%80%83%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">思考题与总结</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"《逆向工程实战》实例B","uid":"49cfcba348975accba6443ccf555c536","slug":"practicalreB","date":"2022-03-08T04:00:00.000Z","updated":"2022-04-13T13:58:06.965Z","comments":true,"path":"api/articles/practicalreB.json","keywords":null,"cover":null,"text":"《逆向工程实战》实例B（练习部分）参照书上对实例BOnProcessNotify(sub_4045F8)、sub_4038F0的分析对实例B进行的一些分析记录 一个x64的驱动后门 进程创建回调、sub_4038F0部分是根据书本分析过程复现的记录 结构体还原在40A590有一个...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"Windows","slug":"Windows","count":21,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":21,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"practicalre","slug":"practicalre","count":5,"path":"api/tags/practicalre.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"《Windows Kernel Programming》 笔记 8~9 回调","uid":"334210967d7f70d0f127f10f28fddeb2","slug":"wkp8-9","date":"2022-03-01T04:00:00.000Z","updated":"2022-03-03T14:22:40.557Z","comments":true,"path":"api/articles/wkp8-9.json","keywords":null,"cover":null,"text":"Windows Kernel Programming 笔记 8~9 回调8 进程、线程通知（S5）内核驱动一种重要的机制：在某些重要活动发生时通知驱动 这章主要关于进程、线程的创建和销毁，还有映像的加载 使用这些回调的驱动程序必须在PE头中有 IMAGE_DLLCHARACTER...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"Windows","slug":"Windows","count":21,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":21,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":7,"path":"api/tags/kernel.json"},{"name":"wkp","slug":"wkp","count":3,"path":"api/tags/wkp.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}