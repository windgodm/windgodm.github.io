{"title":"《Windows Kernel Programming》 笔记 1~5 内核开发入门","uid":"2cdcc6b2635425e63dc5ac736f5a68f9","slug":"wkp1-5","date":"2021-12-24T04:00:00.000Z","updated":"2022-01-18T09:30:03.325Z","comments":true,"path":"api/articles/wkp1-5.json","keywords":null,"cover":[],"content":"<h1 id=\"Windows-Kernel-Programming-笔记-1-5-内核开发入门\"><a href=\"#Windows-Kernel-Programming-笔记-1-5-内核开发入门\" class=\"headerlink\" title=\"Windows Kernel Programming 笔记 1~5 内核开发入门\"></a>Windows Kernel Programming 笔记 1~5 内核开发入门</h1><h2 id=\"1-windows内部概况\"><a href=\"#1-windows内部概况\" class=\"headerlink\" title=\"1 windows内部概况\"></a>1 windows内部概况</h2><p>描述一些Windows内部工作中最重要、最基本的概念，部分概念将在后面的章节做更详细的研究</p>\n<h3 id=\"1-1-进程\"><a href=\"#1-1-进程\" class=\"headerlink\" title=\"1.1 进程\"></a>1.1 进程</h3><p>进程不运行（Processes dont’t run - processes manage），线程才执行代码</p>\n<p>进程拥有以下内容：</p>\n<ul>\n<li>一个可执行程序（PE文件），包括代码和数据</li>\n<li>私有的虚拟内存空间</li>\n<li>主令牌（primary token），是一个对象，存储进程默认安全上下文</li>\n<li>对象（事件、信号、文件）句柄表</li>\n<li>一个或多个线程（没有线程的用户态进程一般情况下会被内核销毁）</li>\n</ul>\n<h3 id=\"1-2-虚拟内存\"><a href=\"#1-2-虚拟内存\" class=\"headerlink\" title=\"1.2 虚拟内存\"></a>1.2 虚拟内存</h3><p>每个进程拥有自己的<strong>虚拟、私有、线性地址</strong>空间<br>（该地址空间初始时几乎为空，然后pe、ntdll.dll开始被影射，接着是其他子系统dll）</p>\n<p>32位进程默认地址空间<strong>2GB</strong>，设置pe中的<code>LARGEADDRESSAWARE</code>标志可以增加到<strong>3GB</strong>（32位系统）或<strong>4GB</strong>（64位系统）</p>\n<p>64位进程默认地址空间<strong>128TB</strong>（win8之前是8TB）</p>\n<p>虚拟内存被映射到物理内存（RAM）或临时驻留在文件中（如page file）<br>如果不在物理内存，则触发page fault异常，并或取数据到物理内存中</p>\n<p><strong>页（page）</strong>是内存管理的单位，默认大小为<strong>4KB</strong></p>\n<h4 id=\"页状态\"><a href=\"#页状态\" class=\"headerlink\" title=\"页状态\"></a>页状态</h4><p>虚拟内存中的页处于三种状态之一</p>\n<ul>\n<li>Free：未分配</li>\n<li>Committed：已分配，通常映射到RAM或文件（例如page file）</li>\n<li>Reserved：未分配，对cpu而言与Free相似，自动分配将不会使用该页<br>一个例子是线程栈（thread stack）</li>\n</ul>\n<h4 id=\"系统内存\"><a href=\"#系统内存\" class=\"headerlink\" title=\"系统内存\"></a>系统内存</h4><p>系统空间与进程无关</p>\n<p>系统空间就是内核</p>\n<h3 id=\"1-3-线程\"><a href=\"#1-3-线程\" class=\"headerlink\" title=\"1.3 线程\"></a>1.3 线程</h3><p>实际执行代码的是线程</p>\n<p>线程拥有的最重要的内容：</p>\n<ul>\n<li>当前访问模式（用户或内核）</li>\n<li>执行上下文</li>\n<li>一个或两个栈（stack）</li>\n<li>Thread Local Storage（TLS）</li>\n<li>基本优先级和当前（动态）优先级</li>\n<li>处理器关联信息</li>\n</ul>\n<p>线程最常处于的状态：</p>\n<ul>\n<li>Running：在逻辑处理器运行中</li>\n<li>Ready：等待运行（所有处理器在忙或不可用）</li>\n<li>Waiting：等待某个事件，事件触发就变成Ready</li>\n</ul>\n<p>括号中的数字是状态号：</p>\n<p>Running(2) =&gt; Waiting(5) =&gt; Deferred Ready(7), Ready(1) =&gt; Running(2)</p>\n<h4 id=\"1-3-1-线程栈\"><a href=\"#1-3-1-线程栈\" class=\"headerlink\" title=\"1.3.1 线程栈\"></a>1.3.1 线程栈</h4><p>线程至少有一个位于内核空间的栈（32位系统12KB，64位系统24KB）</p>\n<p>用户态的线程还有一个位于所属进程空间的栈（默认上限1MB）</p>\n<p>线程<code>Running</code>或<code>Ready</code>时，内核栈驻留在RAM</p>\n<p>栈初始时会尽可能少提交页（最少一页），剩下的页设置为<code>Reserved</code>，而最后一个<code>Committed</code>的页的下一页设置为<code>PAGE_GUARD</code></p>\n<h3 id=\"1-4-系统调用（又名系统服务）\"><a href=\"#1-4-系统调用（又名系统服务）\" class=\"headerlink\" title=\"1.4 系统调用（又名系统服务）\"></a>1.4 系统调用（又名系统服务）</h3><p>原标题：System Services (a.k.a. System Calls)</p>\n<p>R3代码通过系统调用完成一些只能在R0下完成的功能，如分配内存、打开文件、创建线程等</p>\n<p>大致流程是：<br>调用subsystem dll（如kernel32.dll）中的文档化api（如CreateFile）<br>进入NTDLL中的 Native Api（如NtCreateFile）<br>进入内核中的系统服务分发函数<br>进入Native Api对应的内核中的函数</p>\n<p>Native Api将调用号存入eax然后进入r0的系统服务分发函数，eax实际是SSDT（System Service Dispatch Table）的下标</p>\n<h3 id=\"1-5-通用系统架构\"><a href=\"#1-5-通用系统架构\" class=\"headerlink\" title=\"1.5 通用系统架构\"></a>1.5 通用系统架构</h3><p><img src=\"https://s4.ax1x.com/2022/01/18/70IBlR.png\"></p>\n<h3 id=\"1-6-句柄和对象\"><a href=\"#1-6-句柄和对象\" class=\"headerlink\" title=\"1.6 句柄和对象\"></a>1.6 句柄和对象</h3><p>对象被引用计数，当计数为0时才会被释放</p>\n<p>句柄是进程的对象表的索引</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：返回值为句柄的函数，大多数失败时返回<code>0</code>。有些返回<code>INVALID_HANDLE_VALUE (-1)</code>，比如<code>CreateFile</code></p></blockquote>\n<p>句柄值是4的倍数，0不是有效句柄值</p>\n<h4 id=\"1-6-1-对象名\"><a href=\"#1-6-1-对象名\" class=\"headerlink\" title=\"1.6.1 对象名\"></a>1.6.1 对象名</h4><p>某些类型的对象可以有名称，可用于通过合适的 Open 函数按名称打开对象。 </p>\n<p>用户模式调用 Create 函数按名称创建对象，如果存在，则仅打开现有对象。</p>\n<p>winObj中显示的名称有时不是对象的真实名称：</p>\n<ul>\n<li>进程和线程显示ID</li>\n<li>文件对象显示文件名（或设备名），因为共享的原因，无法通过文件名获得文件对象句柄</li>\n<li>（注册表）键对象与注册表的路径一起显示，原因同文件对象</li>\n<li>目录对象显示路径，目录不是文件系统对象，而是对象管理器目录，可通过Sysinternals WinObj查看</li>\n<li>令牌对象名称与存储在令牌中的用户名一起显示</li>\n</ul>\n<h4 id=\"1-6-2-访问现有对象\"><a href=\"#1-6-2-访问现有对象\" class=\"headerlink\" title=\"1.6.2 访问现有对象\"></a>1.6.2 访问现有对象</h4><p>Process Explorer 的句柄视图中的访问列显示用于打开或创建句柄的访问掩码</p>\n<p>Process Explorer中显示的引用数（References）不是实际引用数（outstanding references）</p>\n<p>[windbg]中用<code>!trueref</code>获取实际引用数（actual reference）</p>\n<h2 id=\"2-内核开发入门\"><a href=\"#2-内核开发入门\" class=\"headerlink\" title=\"2 内核开发入门\"></a>2 内核开发入门</h2><p>本章主要是关于准备内核开发所需的环境，包括开发和调试的工具以及环境配置</p>\n<p>以及启动和运行内核驱动的知识</p>\n<p>然后写一个可以加载和卸载的驱动</p>\n<h3 id=\"驱动开发准备工作\"><a href=\"#驱动开发准备工作\" class=\"headerlink\" title=\"驱动开发准备工作\"></a>驱动开发准备工作</h3><p>首先按 2.1安装工具 完成安装，然后为驱动开发配置虚拟机（未包括内核调试的配置）</p>\n<p><strong>安装无签名驱动</strong></p>\n<p>如果驱动没有签名，安装驱动需要以该模式启动系统</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">bcdedit &#x2F;set testsigning on</code></pre>\n\n\n\n<p><strong>显示内核调试信息</strong></p>\n<p>在<code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager</code>添加一个名为<code>Debug Print Filter</code>的键<br>在键中添加一个<code>DWORD</code>，名为<code>DEFAULT</code>，值为<code>8</code></p>\n<p><strong>虚拟机文件共享</strong></p>\n<p>实际操作时，安装在虚拟机中（避免本机崩溃），需要共享项目的文件给虚拟机</p>\n<p>共享本机的 vs解决方案文件夹 给虚拟机，名称为<code>MyDriver</code></p>\n<p>虚拟机中的debug输出路径为：<code>\\\\vmware-host\\Shared Folders\\MyDriver\\x64\\Debug</code></p>\n<p><strong>驱动调试工具</strong></p>\n<p>安装完WDK后，把<code>C:\\Program Files (x86)\\Windows Kits\\10\\Tools\\x64</code>这个目录复制到虚拟机中，这个是x64下的驱动开发调试工具，比如用于查看内存池的poolmon</p>\n<h3 id=\"2-1-安装工具\"><a href=\"#2-1-安装工具\" class=\"headerlink\" title=\"2.1 安装工具\"></a>2.1 安装工具</h3><p>需要vs2019、windows 10 sdk（vs2019中安装）、windows 10 driver kit（WDK）</p>\n<p>以及 Sysinternals，该工具包含debug view、process monitor等一系列有用的工具</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在实际编译中发现，新版本的vs驱动项目默认开启缓解Spectre 漏洞</p>\n<p>可以在c/c++、代码生成中关闭该项，或在vs installer中安装对应工具</p></blockquote>\n<h3 id=\"2-2-创建一个驱动工程\"><a href=\"#2-2-创建一个驱动工程\" class=\"headerlink\" title=\"2.2 创建一个驱动工程\"></a>2.2 创建一个驱动工程</h3><p>vs2019中选择创建一个<code>Empty WDM Driver</code>，创建完成后有个<code>inf</code>后缀的文件，暂时不需要，删除掉</p>\n<h3 id=\"2-3-DriverEntry-和-Unload-Routines\"><a href=\"#2-3-DriverEntry-和-Unload-Routines\" class=\"headerlink\" title=\"2.3 DriverEntry 和 Unload Routines\"></a>2.3 DriverEntry 和 Unload Routines</h3><p>DriverEntry 是驱动的默认入口点</p>\n<p>系统线程以<code>IRQL_PASSIVE_LEVEL</code>(0)调用 DriverEntry</p>\n<p>DriverEntry函数原型：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">extern &quot;C&quot;\nNTSTATUS\nDriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath);</code></pre>\n\n\n\n<p>一个简单的驱动（sample.cpp）：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;ntddk.h&gt;\n\nvoid SampleUnload(_In_ PDRIVER_OBJECT DriverObject) &#123;\n\tUNREFERENCED_PARAMETER(DriverObject);\n&#125;\n\nextern &quot;C&quot;\nNTSTATUS\nDriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) &#123;\n\tUNREFERENCED_PARAMETER(RegistryPath);\n    \n\tDriverObject-&gt;DriverUnload &#x3D; SampleUnload;\n    \n\treturn STATUS_SUCCESS;\n&#125;</code></pre>\n\n\n\n<h3 id=\"2-4-安装驱动\"><a href=\"#2-4-安装驱动\" class=\"headerlink\" title=\"2.4 安装驱动\"></a>2.4 安装驱动</h3><p>安装驱动和安装用户态服务相似，需要调用Create Service API或使用工具</p>\n<p>sc.exe（系统自带）是著名工具之一</p>\n<p>安装驱动需要管理员权限</p>\n<p>创建服务项：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">sc create sample type&#x3D; kernel binPath&#x3D; &quot;\\\\vmware-host\\Shared Folders\\MyDriver\\x64\\Debug\\sample.sys&quot;</code></pre>\n\n<p>随后就能在注册表（regedit.exe）的<code>HKLM\\System\\CurrentControlSet\\Services\\Sample</code>中看到该项</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注册表项位置：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Sample</p>\n<p>假设<code>binPath= c:\\</code>，注册表项<code>ImagePath= \\??\\c:\\</code></p>\n<p>假设<code>binPaht= &quot;\\\\vmware-hots\\&quot;</code>，注册表项<code>ImagePath= \\??\\UNC\\vmware-hots\\</code></p></blockquote>\n<p>加载驱动（启动服务）：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">sc start sample</code></pre>\n\n<p>在process explorer中，选择System进程，查看dll窗口，拉到最下面就能看到sample.sys</p>\n<p>卸载驱动（停止服务）：</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">sc stop sample</code></pre>\n\n\n\n<h3 id=\"2-5-简单跟踪（S1）\"><a href=\"#2-5-简单跟踪（S1）\" class=\"headerlink\" title=\"2.5 简单跟踪（S1）\"></a>2.5 简单跟踪（S1）</h3><p><code>KdPrint 宏</code>是<code>DbgPrint API</code>的包装</p>\n<p>通过在每个函数开头加入<code>KdPrint((&quot;Debug messgae&quot;));</code>可以观察函数调用的发生</p>\n<p>使用DebugView，选择capture Kernel可以看到内核调试信息</p>\n<h3 id=\"2-6-练习：显示系统信息（E1）\"><a href=\"#2-6-练习：显示系统信息（E1）\" class=\"headerlink\" title=\"2.6 练习：显示系统信息（E1）\"></a>2.6 练习：显示系统信息（E1）</h3><p>创建一个驱动用于显示系统版本信息，使用<code>RtlGetVersion</code></p>\n<p>code:</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; Get Version\nRTL_OSVERSIONINFOW versionInfo &#x3D; &#123; 0, &#125;;\nversionInfo.dwOSVersionInfoSize &#x3D; sizeof(RTL_OSVERSIONINFOW);\nRtlGetVersion(&amp;versionInfo);\n\n&#x2F;&#x2F; Print\nDbgPrint(&quot;[E1] Major:%d\\n[E1] Minor:%d\\n[E1] Build:%d&quot;,\n\tversionInfo.dwMajorVersion,\n\tversionInfo.dwMinorVersion,\n\tversionInfo.dwBuildNumber);</code></pre>\n\n<p>shell:</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">sc create E1_OSVersion type&#x3D; kernel binPath&#x3D; &quot;\\\\vmware-host\\Shared Folders\\MyDriver\\x64\\Debug\\E1_OSVersion.sys&quot;\nsc start E1_OSVersion\nsc stop E1_OSVersion</code></pre>\n\n\n\n<h2 id=\"3-内核编程基础\"><a href=\"#3-内核编程基础\" class=\"headerlink\" title=\"3 内核编程基础\"></a>3 内核编程基础</h2><p>研究一些内核的API、结构和定义，以及一些驱动程序中的机制</p>\n<h3 id=\"3-1-通用内核编程指南\"><a href=\"#3-1-通用内核编程指南\" class=\"headerlink\" title=\"3.1 通用内核编程指南\"></a>3.1 通用内核编程指南</h3><p>用户模式和内核模式调试的重要区别</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>用户模式</th>\n<th>内核模式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>未处理异常</td>\n<td>进程崩溃</td>\n<td>系统崩溃</td>\n</tr>\n<tr>\n<td>终止</td>\n<td>当进程终止，所有内存和资源都会被自动释放</td>\n<td>当驱动卸载，如果没有手动释放，会造成泄露直到重启</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>API错误有时候会忽略</td>\n<td>应该不忽略任何错误</td>\n</tr>\n<tr>\n<td>IRQL</td>\n<td>总是 PASSIVE_LEVEL (0)</td>\n<td>可能为更高</td>\n</tr>\n<tr>\n<td>错误代码</td>\n<td>通常只会影响本进程</td>\n<td>影响整个系统</td>\n</tr>\n<tr>\n<td>测试和调试</td>\n<td>通常在开发机器上调试</td>\n<td>需要双机调试</td>\n</tr>\n<tr>\n<td>库（Lib）</td>\n<td>可以使用C/C++库（如STL、boost）</td>\n<td>大多数标准库无法使用</td>\n</tr>\n<tr>\n<td>异常处理</td>\n<td>可以使用C++异常或SEH</td>\n<td>只能使用SEH</td>\n</tr>\n<tr>\n<td>C++支持</td>\n<td>完全的C++支持</td>\n<td>不支持C++ runtime</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-1-1-未处理异常\"><a href=\"#3-1-1-未处理异常\" class=\"headerlink\" title=\"3.1.1 未处理异常\"></a>3.1.1 未处理异常</h4><p>未处理异常会导致蓝屏，原因是防止继续执行代码、对系统造成不可逆转的伤害</p>\n<p>内核代码不应该跳过任何细节或错误检查</p>\n<h4 id=\"3-1-2-终止\"><a href=\"#3-1-2-终止\" class=\"headerlink\" title=\"3.1.2 终止\"></a>3.1.2 终止</h4><p>如果驱动程序卸载时仍保留分配的内存或打开的内核句柄，这些资源不会自动释放，只会在下次系统启动时释放</p>\n<p>原因是驱动程序可以分配一些缓冲区，然后将其传递给另一个与之合作的驱动程序</p>\n<h4 id=\"3-1-3-函数返回值\"><a href=\"#3-1-3-函数返回值\" class=\"headerlink\" title=\"3.1.3 函数返回值\"></a>3.1.3 函数返回值</h4><p>忽略内核API的返回值很危险，应该总是检查返回值</p>\n<h4 id=\"3-1-4-IRQL\"><a href=\"#3-1-4-IRQL\" class=\"headerlink\" title=\"3.1.4 IRQL\"></a>3.1.4 IRQL</h4><p>中断请求级（Interrupt Request Level, IRQL）通常为0</p>\n<p>用户模式下始终为0，内核模式下大部分时间为0</p>\n<h4 id=\"3-1-5-C-使用\"><a href=\"#3-1-5-C-使用\" class=\"headerlink\" title=\"3.1.5 C++使用\"></a>3.1.5 C++使用</h4><p>没有C++ runtime</p>\n<p>一些不支持的C++特性：</p>\n<ul>\n<li>不支持<code>new</code>和<code>delete</code>，这正常是在用户模式堆分配的</li>\n<li>不会调用具有非默认构造函数的全局变量<ul>\n<li>避免在构造函数中使用代码，创建一些要显式调用的Init函数</li>\n<li>仅将指针分配为全局变量，动态创建实例</li>\n</ul>\n</li>\n<li>不支持C++异常处理（<code>try</code>、<code>catch</code>、<code>throw</code>）</li>\n<li>不可使用标准C++库，如<code>std::vector&lt;&gt;</code>、<code>std::wstring</code>等</li>\n</ul>\n<p>一些支持的C++特性：</p>\n<ul>\n<li><code>nullptr</code>关键字</li>\n<li><code>auto</code>关键字</li>\n<li>模板将在有意义时使用</li>\n<li>重载new 和delete 运算符</li>\n<li>构造函数和析构函数，尤其是用于构建 RAII 类型</li>\n</ul>\n<h4 id=\"3-1-6-测试和调试\"><a href=\"#3-1-6-测试和调试\" class=\"headerlink\" title=\"3.1.6 测试和调试\"></a>3.1.6 测试和调试</h4><p>内核调试需要双机调试，一台作为调试者、另一台作为被调试者运行驱动程序</p>\n<h3 id=\"3-2-Debug-vs-Release-生成\"><a href=\"#3-2-Debug-vs-Release-生成\" class=\"headerlink\" title=\"3.2 Debug vs. Release 生成\"></a>3.2 Debug vs. Release 生成</h3><p>内核术语是 Checked（Debug）和 Free（Release）</p>\n<p>Debug意味着可以使用DBG符号</p>\n<h3 id=\"3-3-内核API\"><a href=\"#3-3-内核API\" class=\"headerlink\" title=\"3.3 内核API\"></a>3.3 内核API</h3><p>内核API常用前缀的意义：</p>\n<ul>\n<li>Ex：一般执行函数</li>\n<li>Ke：一般内核函数</li>\n<li>Mm：内存管理</li>\n<li>Rtl：一般运行时库</li>\n<li>FsRtl：文件系统运行时库</li>\n<li>Flt：文件系统迷你过滤库</li>\n<li>Ob：对象管理</li>\n<li>Io：I/O管理</li>\n<li>Se：安全</li>\n<li>Ps：进程结构</li>\n<li>Po：电源管理</li>\n<li>Wmi：Windows管理工具</li>\n<li>Zw：native API 包装</li>\n<li>Hal：硬件抽象层</li>\n<li>Cm：配置管理器（注册表）</li>\n</ul>\n<p>Nt前缀的内核函数对应NtDll.Dll的函数，会根据 KTHREAD 结构的标记（调用者是否来自内核）对参数进行检查</p>\n<p>Zw前缀的内核函数先将调用者模式设为<code>KernelMode(0)</code>，然后调用Nt前缀的内核函数</p>\n<h3 id=\"3-4-函数和错误代码\"><a href=\"#3-4-函数和错误代码\" class=\"headerlink\" title=\"3.4 函数和错误代码\"></a>3.4 函数和错误代码</h3><p>可以在<code>ntstatus.h</code>中找到<code>NTSTATUS</code>值的定义</p>\n<p>大多数代码并不关心错误具体是什么，仅测试最高位即可，可以使用<code>NT_SUCCESS</code>宏</p>\n<p>当返回到用户层时，会由<code>STATUS_xxx</code>转成<code>ERROR_yyy</code>，用户模式通过GetLastError可以得到这些错误</p>\n<p>通常遇到错误时，会返回相同的 NTSTATUS 到调用函数</p>\n<h3 id=\"3-5-字符串\"><a href=\"#3-5-字符串\" class=\"headerlink\" title=\"3.5 字符串\"></a>3.5 字符串</h3><p>内核使用<code>UNICODE_STRING</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _UNICODE_STRING &#123;\nUSHORT Length;\nUSHORT MaximumLength;\nPWCH Buffer;\n&#125; UNICODE_STRING;\ntypedef UNICODE_STRING *PUNICODE_STRING;\ntypedef const UNICODE_STRING *PCUNICODE_STRING;</code></pre>\n\n<p><code>Length</code>是字符串的字节数（不包括\\x00\\x00结束符）</p>\n<p><code>MaximumLength</code>是不需要重新分配内存的情况下、字符串字节数上限</p>\n<p>需要注意的是，UNICODE_STRING并<strong>不总是有\\x00\\x00结尾</strong></p>\n<p>一些常用的字符串操作函数：</p>\n<ul>\n<li>RtlInitUnicodeString</li>\n<li>RtlCopyUnicodeString</li>\n<li>RtlCompareUnicodeString </li>\n<li>RtlEqualUnicodeString </li>\n<li>RtlAppendUnicodeStringToString</li>\n<li>RtlAppendUnicodeToString</li>\n</ul>\n<h3 id=\"3-6-动态内存分配（S2）\"><a href=\"#3-6-动态内存分配（S2）\" class=\"headerlink\" title=\"3.6 动态内存分配（S2）\"></a>3.6 动态内存分配（S2）</h3><p>内核提供两种通用内存池（general memory pools）给驱动使用：</p>\n<ul>\n<li>页池（Paged pool）：可能会被换出（paged out）的内存池</li>\n<li>非页池（Non Paged Pool）：一直在RAM中的内存池</li>\n</ul>\n<p>枚举类型<code>POOL_TYPE</code>表示池类型，只有三种是可以用于驱动的：<br><code>PagedPool</code>、<code>NonPagedPool</code>、<code>NonPagedPoolNx</code><br>（non-page pool没有可执行权限）</p>\n<p>常用内存池函数：</p>\n<ul>\n<li>ExAllocatePool（已过时，将被下面的函数取代）</li>\n<li>ExAllocatePoolWithTag</li>\n<li>ExAllocatePoolWithQuotaTag</li>\n<li>ExFreePool</li>\n</ul>\n<p>tag是4字节的值</p>\n<p>可以在PoolMon（WDK的Windows Kits中）中观察到有tag的内存池（tag以大端序字符串显示）</p>\n<p>给ustring分配页池内存：</p>\n<p>code:</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">UNICODE_STRING strA;\nint length;\n&#x2F;&#x2F; allocate\nstrA.Buffer &#x3D; (WCHAR*)ExAllocatePoolWithTag(PagedPool,\n\tlength, &#39;dcba&#39;);\nif (strA.Buffer &#x3D;&#x3D; nullptr) &#123;\n    KdPrint((&quot;Failed to allocate memory\\n&quot;));\n    return STATUS_INSUFFICIENT_RESOURCES;\n&#125;\nstrA.MaximumLength &#x3D; length;</code></pre>\n\n<p>shell:</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">sc create S2_DynMemAlloc type&#x3D; kernel binPath&#x3D; &quot;\\\\vmware-host\\Shared Folders\\MyDriver\\x64\\Debug\\S2_DynMemAlloc.sys&quot;\nsc start S2_DynMemAlloc\nsc stop S2_DynMemAlloc</code></pre>\n\n\n\n<h3 id=\"3-7-链表\"><a href=\"#3-7-链表\" class=\"headerlink\" title=\"3.7 链表\"></a>3.7 链表</h3><p>内核使用循环双向链表：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _LIST_ENTRY &#123;\n    struct _LIST_ENTRY *Flink;\n    struct _LIST_ENTRY *Blink;\n&#125; LIST_ENTRY, *PLIST_ENTRY;</code></pre>\n\n\n\n<p><code>CONTAINING_RECORD</code>宏执行适当的偏移计算并转换为实际数据类型<br><code>CONTAINING_RECORD(pvoid, type, entry_member_name)</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct MyDataItem &#123;\n    &#x2F;&#x2F; some data members\n    LIST_ENTRY Link;\n    &#x2F;&#x2F; more data members\n&#125;;\n\nMyDataItem* GetItem(LIST_ENTRY* pEntry) &#123;\n\treturn CONTAINING_RECORD(pEntry, MyDataItem, Link);\n&#125;</code></pre>\n\n\n\n<p>常用链表函数（时间复杂度都是常数）：</p>\n<ul>\n<li>InitializeListHead</li>\n<li>InsertHeadList</li>\n<li>InsertTailList</li>\n<li>IsListEmpty</li>\n<li>RemoveHeadList</li>\n<li>RemoveTailList</li>\n<li>RemoveEntryList</li>\n<li>ExInterlockedInsertHeadList</li>\n<li>ExInterlockedInsertTailList</li>\n<li>ExInterlockedRemoveHeadList</li>\n</ul>\n<p>后三个关于自旋锁，在第6章详细讨论</p>\n<h3 id=\"3-8-驱动对象（The-Driver-Object）\"><a href=\"#3-8-驱动对象（The-Driver-Object）\" class=\"headerlink\" title=\"3.8 驱动对象（The Driver Object）\"></a>3.8 驱动对象（The Driver Object）</h3><p>常用major function代码：</p>\n<ul>\n<li>IRP_MJ_CREATE (0) </li>\n<li>IRP_MJ_CLOSE (2)</li>\n<li>IRP_MJ_READ (3) </li>\n<li>IRP_MJ_WRITE (4) </li>\n<li>IRP_MJ_DEVICE_CONTROL (14) </li>\n<li>IRP_MJ_INTERNAL_DEVICE_CONTROL (15)</li>\n<li>IRP_MJ_PNP (31) </li>\n<li>IRP_MJ_POWER (22)</li>\n</ul>\n<p><code>MajorFunction</code>数组由内核初始化指向内核内部例程<code>IopInvalidDeviceRequest</code>，该例程直接返回失败，表示不支持该操作</p>\n<h3 id=\"3-9-设备对象（Device-Objects）\"><a href=\"#3-9-设备对象（Device-Objects）\" class=\"headerlink\" title=\"3.9 设备对象（Device Objects）\"></a>3.9 设备对象（Device Objects）</h3><p>驱动通过设备与r3代码通信，驱动应该至少创建一个设备对象并为其命名</p>\n<p>CreateFile可以打开设备，第一个参数为设备对象名称</p>\n<p>打开文件或设备的句柄会创建内核结构 FILE_OBJECT 的实例，这是个半文档化的结构。 </p>\n<p>更准确的说，CreteFile接受一个<code>symbolic link</code>（符号链接）</p>\n<p>对象管理器中名为<code>??</code>的目录下的符号链接都可被用户模式代码通过CreateFile或Createfile2调用</p>\n<p>可以通过WinObj查看（WinObj中目录名为<code>Global??</code>）</p>\n<p>使用符号链接的CreateFile的文件名（第一个参数），必须加上前缀<code>\\\\.\\</code>（c++中是<code>&quot;\\\\\\\\.\\\\&quot;</code>）</p>\n<p>如果创建了多个设备对象，将形成一个单向链表，添加设备时是头插法，所以第一个创建的设备在链表的最后</p>\n<h2 id=\"4-驱动从头到尾（Driver-from-Start-to-Finish）（S3）\"><a href=\"#4-驱动从头到尾（Driver-from-Start-to-Finish）（S3）\" class=\"headerlink\" title=\"4 驱动从头到尾（Driver from Start to Finish）（S3）\"></a>4 驱动从头到尾（Driver from Start to Finish）（S3）</h2><p>将完成一个完整的驱动及客户端程序，利用驱动完成只能在内核模式下完成的功能（设置任意级别的线程优先级）</p>\n<h3 id=\"4-1-绪论\"><a href=\"#4-1-绪论\" class=\"headerlink\" title=\"4.1 绪论\"></a>4.1 绪论</h3><p>线程优先级 = 进程优先级 + 相对线程优先级</p>\n<p>用户模式下，设置进程优先级可以用<code>SetPriorityClass</code>，共有6个级别<br>设置相对线程优先级可以用<code>SetThreadPriority</code>，共有7个级别</p>\n<p>下面是线程优先级合法值的表（通过windows api设置），据别的书说是个未文档化的东西，windows不建议开发时考虑线程优先级，该表的值随windows版本变化可能发生改变</p>\n<table>\n<thead>\n<tr>\n<th>进程优先级</th>\n<th>-Sat</th>\n<th>-2</th>\n<th>-1</th>\n<th>0</th>\n<th>+1</th>\n<th>+2</th>\n<th>+sat</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Idle(low)</td>\n<td>1</td>\n<td></td>\n<td></td>\n<td>4</td>\n<td></td>\n<td></td>\n<td>15</td>\n</tr>\n<tr>\n<td>Below Normal</td>\n<td>1</td>\n<td></td>\n<td></td>\n<td>6</td>\n<td></td>\n<td></td>\n<td>15</td>\n</tr>\n<tr>\n<td>Normal</td>\n<td>1</td>\n<td></td>\n<td></td>\n<td>8</td>\n<td></td>\n<td></td>\n<td>15</td>\n</tr>\n<tr>\n<td>Above Normal</td>\n<td>1</td>\n<td></td>\n<td></td>\n<td>10</td>\n<td></td>\n<td></td>\n<td>15</td>\n</tr>\n<tr>\n<td>High</td>\n<td>1</td>\n<td></td>\n<td></td>\n<td>13</td>\n<td></td>\n<td></td>\n<td>15</td>\n</tr>\n<tr>\n<td>Real-time</td>\n<td>16</td>\n<td></td>\n<td></td>\n<td>24</td>\n<td></td>\n<td></td>\n<td>31</td>\n</tr>\n</tbody></table>\n<p>进程优先级枚举：级别+<code>_PRIORITY_CLASS</code></p>\n<p>线程优先级枚举：<code>THREAD_PRIORITY_</code>+级别</p>\n<h3 id=\"4-2-驱动初始化\"><a href=\"#4-2-驱动初始化\" class=\"headerlink\" title=\"4.2 驱动初始化\"></a>4.2 驱动初始化</h3><p>大多数驱动需要在DriverEntry中做如下操作：</p>\n<ul>\n<li>设置Unload例程</li>\n<li>设置驱动支持的调度例程</li>\n<li>创建一个设备对象</li>\n<li>创建一个指向设备对象的符号链接</li>\n</ul>\n<p>所有驱动必须支持<code>IRP_MJ_CREATE</code>和<code>IRP_MJ_CLOSE</code>，不然无法打开一个驱动的设备的句柄，通常这两个调度例程是相同的</p>\n<p>调度例程的函数原型：<code>NTSTATUS Function(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)</code></p>\n<h4 id=\"4-2-1-将信息传给驱动\"><a href=\"#4-2-1-将信息传给驱动\" class=\"headerlink\" title=\"4.2.1 将信息传给驱动\"></a>4.2.1 将信息传给驱动</h4><p>用户模式客户端可用的三个基础函数：<code>WriteFile</code>、<code>ReadFile</code>、<code>DeviceIoControl</code></p>\n<h4 id=\"4-2-2-客户端-驱动程序通信协议\"><a href=\"#4-2-2-客户端-驱动程序通信协议\" class=\"headerlink\" title=\"4.2.2 客户端/驱动程序通信协议\"></a>4.2.2 客户端/驱动程序通信协议</h4><p>必须使用<code>CTL_CODE</code>宏来构建控制代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \\\n    ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \\\n)</code></pre>\n\n<ul>\n<li>DeviceType：设备类型标识，<code>FILE_DEVICE_xxx</code>，第三方应以0x8000开头</li>\n<li>Function：指示特定操作的升序数字，第三方应该以0x800开头</li>\n<li>Method：指示客户端提供的输入和输出缓冲区如何传递给驱动程序（将在第6章详细讨论）</li>\n<li>Access：指示对驱动来说这个操作是什么？</li>\n</ul>\n<p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define MY_DEVICE 0x800\n#define IOCTL_MY_OP CTL_CODE(\\\nMY_DEVICE, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)</code></pre>\n\n\n\n<h4 id=\"4-2-3-创建一个设备对象\"><a href=\"#4-2-3-创建一个设备对象\" class=\"headerlink\" title=\"4.2.3 创建一个设备对象\"></a>4.2.3 创建一个设备对象</h4><p><strong>创建设备名：</strong></p>\n<p>在创建一个设备对象前，需要先创建一个<code>UNICODE_STRING</code>存储内部设备名称</p>\n<p>下面是两种初始化方式：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; plan A\nUNICODE_STRING devName &#x3D; RTL_CONSTANT_STRING(L&quot;\\\\Device\\\\YourName&quot;); \n\n&#x2F;&#x2F; plan B\nUNICODE_STRING devName;\nRtlInitUnicodeString(&amp;devName, L&quot;\\\\Device\\\\YourName&quot;);</code></pre>\n\n<p>设备名称需要在设备对象管理器目录下</p>\n<p>（RtlInitUnicodeString函数内部字符串的长度，RTL_CONSTANT_STRING宏在编译时计算长度）</p>\n<p><strong>创建设备对象：</strong></p>\n<p>创建设备对象需要调用<code>IoCreateDevice</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">NTSTATUS IoCreateDevice(\n    _In_ PDRIVER_OBJECT DriverObject,\n    _In_ ULONG DeviceExtensionSize,\n    _In_opt_ PUNICODE_STRING DeviceName,\n    _In_ DEVICE_TYPE DeviceType,\n    _In_ ULONG DeviceCharacteristics,\n    _In_ BOOLEAN Exclusive,\n    _Outptr_ PDEVICE_OBJECT *DeviceObject);</code></pre>\n\n\n\n<p><strong>创建设备完整示例：</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">UNICODE_STRING devName &#x3D; RTL_CONSTANT_STRING(L&quot;\\\\DEVICE\\\\devName&quot;);\nPDEVICE_OBJECT devObj;\nstatus &#x3D; IoCreateDevice(\n    DriverObject,        &#x2F;&#x2F; our driver object\n    0,                   &#x2F;&#x2F; no need for extra bytes\n    &amp;devName,            &#x2F;&#x2F; the device name\n    FILE_DEVICE_UNKNOWN, &#x2F;&#x2F; device type\n    0,                   &#x2F;&#x2F; characteristics flags\n    FALSE,               &#x2F;&#x2F; not exclusive\n    &amp;devObj              &#x2F;&#x2F; the resulting pointer\n);\nif (status &lt; 0) &#123;\n    KdPrint((&quot;[] Failed to create device object (0x%08X)\\n&quot;, status));\n    return status;\n&#125;</code></pre>\n\n\n\n<p><strong>创建符号链接：</strong></p>\n<p>需要创建一个指向设备的符号链接，供r3调用</p>\n<p>同样需要先创建一个字符串作为符号链接对象名称</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">UNICODE_STRING symLink &#x3D; RTL_CONSTANT_STRING(L&quot;\\\\??\\\\symLinkName&quot;);\nstatus &#x3D; IoCreateSymbolicLink(&amp;symLink, &amp;devName);\nif (status &lt; 0) &#123;\n\tKdPrint((&quot;[] Failed to create symbolic link (0x%08X)\\n&quot;, status));\n    return status;\n&#125;</code></pre>\n\n\n\n<p><strong>注意：资源释放</strong></p>\n<p>上面创建的字符串会自动释放（好像在函数的栈中）？但对象不会，需要（在unload例程中）手动删除</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void Unload(_In_ PDRIVER_OBJECT DriverObject) &#123;\n    &#x2F;&#x2F; delete symbolic link\n    UNICODE_STRING symLink &#x3D; RTL_CONSTANT_STRING(L&quot;\\\\??\\\\symLinkName&quot;);\n    IoDeleteSymbolicLink(&amp;symLink);\n    &#x2F;&#x2F; delete device object\n    IoDeleteDevice(DriverObject-&gt;DeviceObject);\n&#125;</code></pre>\n\n\n\n<h3 id=\"4-3-客户端代码\"><a href=\"#4-3-客户端代码\" class=\"headerlink\" title=\"4.3 客户端代码\"></a>4.3 客户端代码</h3><p>将用<code>CTL_CODE</code>构造的控制代码放到一个头文件中，供驱动代码和用户模式客户端代码同时使用</p>\n<p>通过符号链接获驱动的设备的句柄</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#123;\n    HANDLE hDevice &#x3D; CreateFile(L&quot;\\\\\\\\.\\\\symLinkName&quot;, GENERIC_WRITE,\n        FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);\n    if (hDevice &#x3D;&#x3D; INVALID_HANDLE_VALUE)\n        return Error(&quot;Failed to open device&quot;);\n&#125;\n    \nint Error(const char* msg) &#123;\n    printf(&quot;%s (error&#x3D;%d)\\n&quot;, msg, GetLastError());\n    return 1;\n&#125;</code></pre>\n\n\n\n<h3 id=\"4-4-Create和Close调度例程\"><a href=\"#4-4-Create和Close调度例程\" class=\"headerlink\" title=\"4.4 Create和Close调度例程\"></a>4.4 Create和Close调度例程</h3><p>该例程什么都不用做，直接返回成功即可</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">NTSTATUS PriorityBoosterCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123;\n    UNREFERENCED_PARAMETER(DeviceObject);\n    \n    Irp-&gt;IoStatus.Status &#x3D; STATUS_SUCCESS;\n    Irp-&gt;IoStatus.Information &#x3D; 0;\n    IoCompleteRequest(Irp, IO_NO_INCREMENT);\n    return STATUS_SUCCESS;\n&#125;</code></pre>\n\n\n\n<p>IRP是半文档化结构，通常来自运行中的管理器：I/O Manager, Plug &amp; Play Manager or Power Manager</p>\n<p>对驱动程序的每个请求总是包装在 IRP 中</p>\n<p>IRP中有一个或多个<code>IO_STACK_LOCATION</code>结构</p>\n<p>为了完成IRP，需要调用<code>IoCompleteRequest</code>，这个函数做很多东西，基本上理解为将IRP传播回创建者（通常是I/O管理器），然后由管理器通知客户端操作完成</p>\n<h3 id=\"4-5-DeviceIoControl调度例程\"><a href=\"#4-5-DeviceIoControl调度例程\" class=\"headerlink\" title=\"4.5 DeviceIoControl调度例程\"></a>4.5 DeviceIoControl调度例程</h3><p>调用<code>IoGetCurrentIrpStackLocation</code>获取当前设备对应的<code>IO_STACK_LOCATION</code></p>\n<p><code>IO_STACK_LOCATION</code>中有控制代码、输入输出buffer指针等</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>调度例程运行在调用该例程的用户模式进程的上下文中</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">DWORD threadId;\nPETHREAD Thread;\nstatus &#x3D; PsLookupThreadByThreadId(ULongToHandle(threadId), &amp;Thread);</code></pre>\n\n<p>使用<code>ULongToHandle</code>（这实际上只是个casting）将pid转换成<code>HANDLE</code></p>\n<p>线程和进程存在一个全局私有内核句柄表，句柄的“值”实际上就是ID</p>\n<p>（HANDLE在64位系统是64位，线程ID始终是32位）</p>\n<h3 id=\"4-6-安装和测试\"><a href=\"#4-6-安装和测试\" class=\"headerlink\" title=\"4.6 安装和测试\"></a>4.6 安装和测试</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">sc create S3_PriorityBooster type&#x3D; kernel binPath&#x3D; &quot;\\\\vmware-host\\Shared Folders\\MyDriver\\x64\\Debug\\S3_PriorityBooster.sys&quot;\nsc start S3_PriorityBooster\nsc stop S3_PriorityBooster\nsc delete S3_PriorityBooster</code></pre>\n\n\n\n<p>start后可以在WinObj中的<code>Driver</code>目录下看到驱动、<code>GLOBAL??</code>目录下看到符号链接</p>\n<p>可以在Process Explorer中查看进程的pid以及其线程的动态优先级</p>\n<h2 id=\"5-调试\"><a href=\"#5-调试\" class=\"headerlink\" title=\"5 调试\"></a>5 调试</h2><p>关于使用WinDbg进行调试</p>\n<h3 id=\"5-1-windows的调试工具\"><a href=\"#5-1-windows的调试工具\" class=\"headerlink\" title=\"5.1 windows的调试工具\"></a>5.1 windows的调试工具</h3><p>四个调试器：</p>\n<ul>\n<li>Cdb 和 Ntsd 是用户模式调试器，可以附加到进程上，是命令行界面，没有什么大的区别</li>\n<li>Kd 是内核调试器，提供命令行界面，可以附加到本地内核或其他机器</li>\n<li>WinDbg 是有图形化界面的调试器，可以调试用户和内核模式</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>WinDbg Preview是WinDbg的“最新版”，解决了一些WinDbg上的bug</p></blockquote>\n<p>这些调试器都是基于<code>DbgEng.Dll</code></p>\n<h3 id=\"5-2-WinDbg简介\"><a href=\"#5-2-WinDbg简介\" class=\"headerlink\" title=\"5.2 WinDbg简介\"></a>5.2 WinDbg简介</h3><p>虽然有GUI，实际上还是命令行，所有UI操作都会转成命令，显示在命令行窗口上</p>\n<p>WinDbg支持三种类型的命令：</p>\n<ul>\n<li>标准命令(Intrinsic)：内置在调试器中，在被调试的目标上运行</li>\n<li>元命令(Meta)：以<code>.</code>开头，作用于调试器(debugging process)本身，而不是直接作用于被调试目标</li>\n<li>拓展命令：以<code>!</code>开头，提供调试器大部分功能，都在拓展DLL中实现</li>\n</ul>\n<h4 id=\"教程：用户模式调试基础\"><a href=\"#教程：用户模式调试基础\" class=\"headerlink\" title=\"教程：用户模式调试基础\"></a>教程：用户模式调试基础</h4><p><strong>符号信息：</strong></p>\n<p>设置符号的方法1：<code>.symfix</code></p>\n<p>设置符号的方法2：设置环境变量<br><code>_NT_SYMBOL_PATH</code>=<code>SRV*c:\\Symbols*http://msdl.microsoft.com/download/symbols</code></p>\n<p><code>lm</code>：显示进程加载的模块，以及各模块是否加载了符号</p>\n<p><code>.reload /f modulename.dll</code>：强制加载模块的符号</p>\n<p><code>!sym noisy</code>：记录符号加载尝试的详细信息</p>\n<p><strong>线程：</strong></p>\n<p><code>~</code>：显示调试进程中所有线程的信息<br>线程信息前的<code>.</code>表示当前线程，<code>#</code>表示触发中断的线程<br>输入提示冒号右边的数字是当前线程的索引</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0  Id: 874c.18068 Suspend: 1 Teb: 00000001&#96;2229d000 Unfrozen\n[下标] Id: [PID].[TID] Suspend: [挂起计数] Teb: [TEB地址] [是否冻结]</code></pre>\n\n\n\n<p><code>~ns</code>：切换到索引为n的线程<br>可以组合命令<code>~nk</code>，这样可以在不切换线程的情况下，在别的线程执行操作（这里是显示别的线程的调用堆栈）</p>\n<p><code>k</code>：当前线程的调用堆栈（stack trace）</p>\n<p><code>!teb</code>：查看TEB的部分信息，默认当前线程的</p>\n<p><strong>进制转换：</strong></p>\n<p>16转10：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0:000&gt; ? 874c\nEvaluate expression: 34636 &#x3D; 0000874c</code></pre>\n\n<p>10转16：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0:000&gt; ? 0n34636\nEvaluate expression: 34636 &#x3D; 0000874c</code></pre>\n\n\n\n<p><strong>数据或结构的显示：</strong></p>\n<p><code>dt [type]</code>：显示数据结构的定义（如显示_TEB：<code>dt ntdll!_teb</code>）</p>\n<p><code>dt [type] [addr]</code>：显示数据结构的数据（如显示某个_TEB：<code> dt ntdll!_teb 000000`012229d000</code>）</p>\n<p><code>r [reg]</code>：读取寄存器（如读取rcx：<code>r rcx</code>）</p>\n<p><code>d&#123;a|b|c|d|D|f|p|q|u|w|W&#125;</code>：以指定类型显示指定地址的数据<br>a：ascii字符<br>b,w,d,q：字节<br>u：unicode<br>f：单精浮点<br>D：双精浮点</p>\n<p><code>u</code>：显示反汇编，默认8句汇编指令</p>\n<p><code>!error [error_code]</code>：显示错误信息</p>\n<p><strong>断点和运行：</strong></p>\n<p><code>bp [symbol]</code>：设置断点（如CreateFile：<code>bp kernel32!createfilew</code>）</p>\n<p><code>bl</code>：显示当前设置的断点</p>\n<p><code>bd</code>：禁用断点，禁用所有断点：<code>bd *</code></p>\n<p><code>bc</code>：删除断点</p>\n<p><code>g</code>(F5)：运行直到断点</p>\n<p><code>p</code>(F10)：步过</p>\n<p><code>t</code>(F11)：步进</p>\n<h3 id=\"5-3-内核调试（本地）\"><a href=\"#5-3-内核调试（本地）\" class=\"headerlink\" title=\"5.3 内核调试（本地）\"></a>5.3 内核调试（本地）</h3><h4 id=\"本地内核调试\"><a href=\"#本地内核调试\" class=\"headerlink\" title=\"本地内核调试\"></a>本地内核调试</h4><p>修改启动项：<code>bcdedit /debug on</code></p>\n<h4 id=\"本地内核调试教程\"><a href=\"#本地内核调试教程\" class=\"headerlink\" title=\"本地内核调试教程\"></a>本地内核调试教程</h4><p><code>!process 0 0</code>：显示所有进程的基本信息</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lkd&gt; !process 0 0\n**** NT ACTIVE PROCESS DUMP ****\nPROCESS ffff8d0e682a73c0\n    SessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000\n    DirBase: 001ad002 ObjectTable: ffffe20712204b80 HandleCount: 9542.\n    Image: System\n    \n(truncated)</code></pre>\n\n<ul>\n<li>PROCESS旁边的地址：EPROCESS的地址</li>\n<li>SessionId：进程所处的对话</li>\n<li>Cid：pid</li>\n<li>Peb：PEB地址（在用户模式地址空间）</li>\n<li>ParentCid：父进程pid</li>\n<li>DirBase：进程主页目录的物理地址（x32是PDPT基址、x64是PML4基址）</li>\n<li>ObjectTable：指向进程的私有句柄表的指针 </li>\n<li>HandleCount：进程中的句柄数</li>\n<li>Image：可执行文件名称，或与可执行文件无关的特殊进程名称 </li>\n</ul>\n<p><code>!process</code>指令后第一个数字是筛选特定进程，0表示所有进程；第二个数字是细节掩码，0表示最少细节；第三个参数是筛选可执行文件</p>\n<p><code>.process /p [EPROCESS]</code>：切换到指定进程</p>\n<p>peb在用户模式地址空间中，查看peb需要先设置正确的用户模式进程环境</p>\n<p>不切换的做法：<code>.process /p ffff8d0e849df080; !peb e8a8c9c000</code></p>\n<p>调用堆栈中，nt前缀表示内核</p>\n<p><code>.reload /user</code>：加载用户模式符号</p>\n<p>其余常用/有趣的内核模式调试指令：</p>\n<ul>\n<li><code>!pcr</code>：显示指定为附加索引的处理器的进程控制区域 (PCR)（如果未指定索引，则默认显示处理器 0）</li>\n<li><code>!vm</code>：显示系统和进程的内存统计信息</li>\n<li><code>!running</code>：显示有关在系统上所有处理器上运行的线程的信息</li>\n</ul>\n<h3 id=\"5-4-完全内核调试（双机）\"><a href=\"#5-4-完全内核调试（双机）\" class=\"headerlink\" title=\"5.4 完全内核调试（双机）\"></a>5.4 完全内核调试（双机）</h3><p>完全内核调试需要”双机“</p>\n<p>最好的连接方式是通过网络，这需要主机和被调试目标系统版最少为Win8</p>\n<p>另外一种方法是COM串口，大多数虚拟机支持虚拟串口而不需要真实（物理的）串口线</p>\n<p>详细配置方式略过</p>\n<h4 id=\"配置目标机器\"><a href=\"#配置目标机器\" class=\"headerlink\" title=\"配置目标机器\"></a>配置目标机器</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">bcdedit &#x2F;debug on\nbcdedit &#x2F;dbgsettings serial debugport:1 baudrate:115200</code></pre>\n\n\n\n<h4 id=\"配置主机\"><a href=\"#配置主机\" class=\"headerlink\" title=\"配置主机\"></a>配置主机</h4><p>调试器需要设置调试端口映射和命名管道，与虚拟机上的相同</p>\n<p>输入提示kd左边的数字是引起中断的处理器的索引</p>\n<h3 id=\"5-5-内核驱动调试教程\"><a href=\"#5-5-内核驱动调试教程\" class=\"headerlink\" title=\"5.5 内核驱动调试教程\"></a>5.5 内核驱动调试教程</h3><p>可以设置未来断点（在运行程序前设置断点）</p>\n<p>如设置驱动prioritybooster的入口点：<code>bu prioritybooster!driverentry</code></p>\n<p>可以设置只在指定进程上中断：<code>bp /p [EPROCESS] [symbol]</code><br>如：<code> bp /p ffffdd06042e4080 prioritybooster!priorityboosterdevicecontrol</code></p>\n","text":"Windows Kernel Programming 笔记 1~5 内核开发入门1 windows内部概况描述一些Windows内部工作中最重要、最基本的概念，部分概念将在后面的章节做更详细的研究 1.1 进程进程不运行（Processes dont’t run - proces...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"Windows","slug":"Windows","count":21,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":21,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":7,"path":"api/tags/kernel.json"},{"name":"wkp","slug":"wkp","count":3,"path":"api/tags/wkp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Windows-Kernel-Programming-%E7%AC%94%E8%AE%B0-1-5-%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">Windows Kernel Programming 笔记 1~5 内核开发入门</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-windows%E5%86%85%E9%83%A8%E6%A6%82%E5%86%B5\"><span class=\"toc-text\">1 windows内部概况</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">1.1 进程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98\"><span class=\"toc-text\">1.2 虚拟内存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">页状态</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98\"><span class=\"toc-text\">系统内存</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">1.3 线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-1-%E7%BA%BF%E7%A8%8B%E6%A0%88\"><span class=\"toc-text\">1.3.1 线程栈</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%88%E5%8F%88%E5%90%8D%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%EF%BC%89\"><span class=\"toc-text\">1.4 系统调用（又名系统服务）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-%E9%80%9A%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">1.5 通用系统架构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-%E5%8F%A5%E6%9F%84%E5%92%8C%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">1.6 句柄和对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-6-1-%E5%AF%B9%E8%B1%A1%E5%90%8D\"><span class=\"toc-text\">1.6.1 对象名</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-6-2-%E8%AE%BF%E9%97%AE%E7%8E%B0%E6%9C%89%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">1.6.2 访问现有对象</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">2 内核开发入门</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\"><span class=\"toc-text\">驱动开发准备工作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">2.1 安装工具</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E5%B7%A5%E7%A8%8B\"><span class=\"toc-text\">2.2 创建一个驱动工程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-DriverEntry-%E5%92%8C-Unload-Routines\"><span class=\"toc-text\">2.3 DriverEntry 和 Unload Routines</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8\"><span class=\"toc-text\">2.4 安装驱动</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E7%AE%80%E5%8D%95%E8%B7%9F%E8%B8%AA%EF%BC%88S1%EF%BC%89\"><span class=\"toc-text\">2.5 简单跟踪（S1）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-6-%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%EF%BC%88E1%EF%BC%89\"><span class=\"toc-text\">2.6 练习：显示系统信息（E1）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">3 内核编程基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E9%80%9A%E7%94%A8%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97\"><span class=\"toc-text\">3.1 通用内核编程指南</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-1-%E6%9C%AA%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">3.1.1 未处理异常</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-2-%E7%BB%88%E6%AD%A2\"><span class=\"toc-text\">3.1.2 终止</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-3-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">3.1.3 函数返回值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-4-IRQL\"><span class=\"toc-text\">3.1.4 IRQL</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-5-C-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">3.1.5 C++使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-6-%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">3.1.6 测试和调试</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-Debug-vs-Release-%E7%94%9F%E6%88%90\"><span class=\"toc-text\">3.2 Debug vs. Release 生成</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E5%86%85%E6%A0%B8API\"><span class=\"toc-text\">3.3 内核API</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E5%87%BD%E6%95%B0%E5%92%8C%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">3.4 函数和错误代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">3.5 字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%88S2%EF%BC%89\"><span class=\"toc-text\">3.6 动态内存分配（S2）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">3.7 链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-8-%E9%A9%B1%E5%8A%A8%E5%AF%B9%E8%B1%A1%EF%BC%88The-Driver-Object%EF%BC%89\"><span class=\"toc-text\">3.8 驱动对象（The Driver Object）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-9-%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%EF%BC%88Device-Objects%EF%BC%89\"><span class=\"toc-text\">3.9 设备对象（Device Objects）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E9%A9%B1%E5%8A%A8%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%EF%BC%88Driver-from-Start-to-Finish%EF%BC%89%EF%BC%88S3%EF%BC%89\"><span class=\"toc-text\">4 驱动从头到尾（Driver from Start to Finish）（S3）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E7%BB%AA%E8%AE%BA\"><span class=\"toc-text\">4.1 绪论</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E9%A9%B1%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">4.2 驱动初始化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-1-%E5%B0%86%E4%BF%A1%E6%81%AF%E4%BC%A0%E7%BB%99%E9%A9%B1%E5%8A%A8\"><span class=\"toc-text\">4.2.1 将信息传给驱动</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-2-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">4.2.2 客户端&#x2F;驱动程序通信协议</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-3-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">4.2.3 创建一个设备对象</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">4.3 客户端代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-Create%E5%92%8CClose%E8%B0%83%E5%BA%A6%E4%BE%8B%E7%A8%8B\"><span class=\"toc-text\">4.4 Create和Close调度例程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-DeviceIoControl%E8%B0%83%E5%BA%A6%E4%BE%8B%E7%A8%8B\"><span class=\"toc-text\">4.5 DeviceIoControl调度例程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-%E5%AE%89%E8%A3%85%E5%92%8C%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">4.6 安装和测试</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">5 调试</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-windows%E7%9A%84%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">5.1 windows的调试工具</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-WinDbg%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">5.2 WinDbg简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%99%E7%A8%8B%EF%BC%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E8%B0%83%E8%AF%95%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">教程：用户模式调试基础</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%EF%BC%88%E6%9C%AC%E5%9C%B0%EF%BC%89\"><span class=\"toc-text\">5.3 内核调试（本地）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">本地内核调试</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B\"><span class=\"toc-text\">本地内核调试教程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-%E5%AE%8C%E5%85%A8%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%EF%BC%88%E5%8F%8C%E6%9C%BA%EF%BC%89\"><span class=\"toc-text\">5.4 完全内核调试（双机）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8\"><span class=\"toc-text\">配置目标机器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA\"><span class=\"toc-text\">配置主机</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-5-%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B\"><span class=\"toc-text\">5.5 内核驱动调试教程</span></a></li></ol></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"sctf21 BabyDriver 出题思路","uid":"5492b18e2fa4da93951bdc6ad9c6b6ae","slug":"sctf21-babydriver","date":"2021-12-26T04:00:00.000Z","updated":"2022-01-18T09:38:46.013Z","comments":true,"path":"api/articles/sctf21-babydriver.json","keywords":null,"cover":null,"text":"BabyDriver 出题思路这题是和0x太上一起出的，他提供了题目的框架和内核通信部分的代码，我负责其余的实现 0xTalShang (0x太上) (github.com) SycloverTeam/SCTF2021: SCTF 2021 (github.com) 有选手反馈R...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"CTF","slug":"CTF","count":8,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":8,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":12,"path":"api/tags/re.json"},{"name":"wp","slug":"wp","count":7,"path":"api/tags/wp.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"《逆向工程实战》1.7练习 反编译windows内核例程","uid":"b18e35184f4ae33a90ef7f51ea6e9e65","slug":"practicalre1-7","date":"2021-11-08T14:07:00.000Z","updated":"2021-12-05T15:04:31.297Z","comments":true,"path":"api/articles/practicalre1-7.json","keywords":null,"cover":null,"text":"《逆向工程实战》1.7 练习 反编译windows内核例程例程选取自win10 x64 21h1 摘要每个例程反编译的知识点如下： KeInitializeDpc：结构体赋值，纯拷贝 KeInitializeApc：结构体赋值，有条件拷贝 ObFastDereferenceObj...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"Windows","slug":"Windows","count":21,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":21,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"practicalre","slug":"practicalre","count":5,"path":"api/tags/practicalre.json"},{"name":"antiDebug","slug":"antiDebug","count":2,"path":"api/tags/antiDebug.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}