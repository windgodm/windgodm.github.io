{"title":"《逆向工程实战》1.7练习 反编译windows内核例程","uid":"b18e35184f4ae33a90ef7f51ea6e9e65","slug":"practicalre1-7","date":"2021-11-08T14:07:00.000Z","updated":"2021-12-05T15:04:31.297Z","comments":true,"path":"api/articles/practicalre1-7.json","keywords":null,"cover":null,"content":"<h1 id=\"《逆向工程实战》1-7-练习-反编译windows内核例程\"><a href=\"#《逆向工程实战》1-7-练习-反编译windows内核例程\" class=\"headerlink\" title=\"《逆向工程实战》1.7 练习 反编译windows内核例程\"></a>《逆向工程实战》1.7 练习 反编译windows内核例程</h1><p>例程选取自win10 x64 21h1</p>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>每个例程反编译的知识点如下：</p>\n<ul>\n<li><p>KeInitializeDpc：结构体赋值，纯拷贝</p>\n</li>\n<li><p>KeInitializeApc：结构体赋值，有条件拷贝</p>\n</li>\n<li><p>ObFastDereferenceObject：while循环，比较后交换的分析</p>\n</li>\n<li><p>KeInitializeQueue：结构体赋值，有条件拷贝</p>\n</li>\n<li><p>KxWaitForLockChainValid：do-while循环，if(a &amp;&amp; b &amp;&amp; c){}else{}结构</p>\n</li>\n<li><p>KeReadyThread：嵌套的if(){}结构</p>\n</li>\n<li><p>KiInitializeTSS（未找到）</p>\n</li>\n<li><p>RtlValidateUnicodeString：if(a &amp;&amp; b || c){}else{}结构</p>\n</li>\n</ul>\n<h2 id=\"条件复杂的if-else\"><a href=\"#条件复杂的if-else\" class=\"headerlink\" title=\"条件复杂的if(){}else{}\"></a>条件复杂的if(){}else{}</h2><p>KxWaitForLockChainValid和RtlValidateUnicodeString都有类似if(a &amp;&amp; b || c)的结构</p>\n<p>其多个的jmp结果一定会去到两个分支之一，然后回到主分支</p>\n<p>可以理解成析取或合取表达式的提取</p>\n<p>我对windows采用的编译器的理解是，对于或（<code>||</code>）通过多个jmp实现：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; c++\nif(a&#x3D;&#x3D;0 || b&#x3D;&#x3D;0 || c&#x3D;&#x3D;0)\n    BranchA();\nelse\n    BranchB();</code></pre>\n\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\"># asm\ntest a, a\njz loc_A\ntest b, b\njz loc_A\ntest c, c\njz loc_A\ncall BranchB\njmp loc_ed\nloc_A:\ncall BrancA\nloc_ed:</code></pre>\n\n<p>对于（<code>&amp;&amp;</code>）会将后面的合取转成析取，然后生成一个chunk：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; c++ 1\nif(a&#x3D;&#x3D;0 &amp;&amp; b&#x3D;&#x3D;0 &amp;&amp; c&#x3D;&#x3D;0) &#x2F;&#x2F; &#x3D;&gt; if(a&#x3D;&#x3D;0 &amp;&amp; !(b!&#x3D;0 || c!&#x3D;0))\n    BranchA();\nelse\n    BranchB();\n\n&#x2F;&#x2F; c++ 2\nif(a&#x3D;&#x3D;0) &#123;\n    if(b!&#x3D;0 || c!&#x3D;0)\n         BranchB();\n    else\n        BranchA();\n&#125;\nelse &#123;\n    BranchB();\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\"># asm\ntest a, a\njz chunk_1\nloc_B:\ncall BranchB\nloc_ed:\n# ...\n\nchunk_1:\ntest b, b\njnz loc_B\ntest c, c\njnz loc_B\ncall BranchA\njmp loc_ed</code></pre>\n\n<h2 id=\"KeInitializeDpc\"><a href=\"#KeInitializeDpc\" class=\"headerlink\" title=\"KeInitializeDpc\"></a>KeInitializeDpc</h2><h3 id=\"前置信息\"><a href=\"#前置信息\" class=\"headerlink\" title=\"前置信息\"></a>前置信息</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; MSDN\nvoid KeInitializeDpc(\n  [out]          __drv_aliasesMem PRKDPC Dpc,\n  [in]           PKDEFERRED_ROUTINE      DeferredRoutine,\n  [in, optional] __drv_aliasesMem PVOID  DeferredContext\n);</code></pre>\n\n<p>KDPC的结构（该结构在win10 x64各版本中未发生过改变）：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct _KDPC\n&#123;\n    union\n    &#123;\n        ULONG TargetInfoAsUlong;    &#x2F;&#x2F;0x0\n        struct\n        &#123;\n            UCHAR Type;             &#x2F;&#x2F;0x0\n            UCHAR Importance;       &#x2F;&#x2F;0x1\n            volatile USHORT Number; &#x2F;&#x2F;0x2\n        &#125;;\n    &#125;;\n    struct _SINGLE_LIST_ENTRY DpcListEntry; &#x2F;&#x2F;0x8\n    ULONGLONG ProcessorHistory;     &#x2F;&#x2F;0x10\n    VOID (*DeferredRoutine)(struct _KDPC* arg1, VOID* arg2, VOID* arg3, VOID* arg4); &#x2F;&#x2F;0x18\n    VOID* DeferredContext; &#x2F;&#x2F;0x20\n    VOID* SystemArgument1; &#x2F;&#x2F;0x28\n    VOID* SystemArgument2; &#x2F;&#x2F;0x30\n    VOID* DpcData;         &#x2F;&#x2F;0x38\n&#125;; </code></pre>\n\n<h3 id=\"汇编\"><a href=\"#汇编\" class=\"headerlink\" title=\"汇编\"></a>汇编</h3><p>使用工具得到的反汇编如下：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">.text:00000001402E39E0 KeInitializeDpc proc near\n.text:00000001402E39E0                 xor     eax, eax\n.text:00000001402E39E2                 mov     dword ptr [rcx], 113h\n.text:00000001402E39E8                 mov     [rcx+38h], rax\n.text:00000001402E39EC                 mov     [rcx+10h], rax\n.text:00000001402E39F0                 mov     [rcx+18h], rdx\n.text:00000001402E39F4                 mov     [rcx+20h], r8\n.text:00000001402E39F8                 retn\n.text:00000001402E39F8 KeInitializeDpc endp</code></pre>\n\n<h3 id=\"反编译\"><a href=\"#反编译\" class=\"headerlink\" title=\"反编译\"></a>反编译</h3><p>该初始化函数只是简单的赋值</p>\n<p>反编译结果如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void KeInitializeDpc(\n    PRKDPC Dpc,\n    PKDEFERRED_ROUTINE DeferredRoutine,\n    PVOID DeferredContext)\n&#123;\n    Dpc-&gt;TargetInfoAsUlong &#x3D; 0x113; &#x2F;&#x2F; Type&#x3D;0x13, Importance&#x3D;0x1, Number&#x3D;0\n    Dpc-&gt;ProcessorHistory &#x3D; 0;\n    Dpc-&gt;DeferredRoutine &#x3D; DeferredRoutine;\n    Dpc-&gt;DeferredContext &#x3D; DeferredContext;\n    Dpc-&gt;DpcData &#x3D; 0;\n&#125;</code></pre>\n\n<h2 id=\"KeInitializeApc\"><a href=\"#KeInitializeApc\" class=\"headerlink\" title=\"KeInitializeApc\"></a>KeInitializeApc</h2><h3 id=\"前置信息-1\"><a href=\"#前置信息-1\" class=\"headerlink\" title=\"前置信息\"></a>前置信息</h3><p>这是个未文档化的函数</p>\n<p>显然会用到KAPC结构（win10 x64 21H1）：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;0x58 bytes (sizeof)\nstruct _KAPC\n&#123;\n    UCHAR Type;                      &#x2F;&#x2F;0x0\n    UCHAR SpareByte0;                &#x2F;&#x2F;0x1\n    UCHAR Size;                      &#x2F;&#x2F;0x2\n    UCHAR SpareByte1;                &#x2F;&#x2F;0x3\n    ULONG SpareLong0;                &#x2F;&#x2F;0x4\n    struct _KTHREAD* Thread;         &#x2F;&#x2F;0x8\n    struct _LIST_ENTRY ApcListEntry; &#x2F;&#x2F;0x10\n    VOID* Reserved[3];               &#x2F;&#x2F;0x20\n    VOID* NormalContext;             &#x2F;&#x2F;0x38\n    VOID* SystemArgument1;           &#x2F;&#x2F;0x40\n    VOID* SystemArgument2;           &#x2F;&#x2F;0x48\n    CHAR ApcStateIndex;              &#x2F;&#x2F;0x50\n    CHAR ApcMode;                    &#x2F;&#x2F;0x51\n    UCHAR Inserted;                  &#x2F;&#x2F;0x52\n&#125;; </code></pre>\n\n<p>在旧版本中（21H1之前），成员Reserved[3]被认为是union：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">union\n   &#123;\n       struct\n       &#123;\n           VOID (*KernelRoutine)(struct _KAPC* arg1, VOID (**arg2)(VOID* arg1, VOID* arg2, VOID* arg3), VOID** arg3, VOID** arg4, VOID** arg5); &#x2F;&#x2F;0x20\n           VOID (*RundownRoutine)(struct _KAPC* arg1);                     &#x2F;&#x2F;0x28\n           VOID (*NormalRoutine)(VOID* arg1, VOID* arg2, VOID* arg3);      &#x2F;&#x2F;0x30\n       &#125;;\n       VOID* Reserved[3];                                                  &#x2F;&#x2F;0x20\n   &#125;;</code></pre>\n\n<h3 id=\"汇编-1\"><a href=\"#汇编-1\" class=\"headerlink\" title=\"汇编\"></a>汇编</h3><p>使用工具得到的反汇编如下：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">.text:00000001402F93D0 KeInitializeApc proc near\n.text:00000001402F93D0 arg_20          &#x3D; qword ptr  28h ; RundownRoutine\n.text:00000001402F93D0 arg_28          &#x3D; qword ptr  30h ; NormalRoutine\n.text:00000001402F93D0 arg_30          &#x3D; byte ptr  38h  ; ApcMode\n.text:00000001402F93D0 arg_38          &#x3D; qword ptr  40h ; NormalContext\n.text:00000001402F93D0\n.text:00000001402F93D0                 mov     byte ptr [rcx], 12h   ; Apc-&gt;Type &#x3D; 0x12\n.text:00000001402F93D3                 mov     r10, rcx\n.text:00000001402F93D6                 mov     byte ptr [rcx+2], 58h ; Apc-&gt;Size &#x3D; 0x58\n.text:00000001402F93DA                 cmp     r8d, 2\n.text:00000001402F93DE                 jz      short loc_1402F9424\n.text:00000001402F93E0\n.text:00000001402F93E0 loc_1402F93E0:                          ; CODE XREF: KeInitializeApc+5B↓j\n.text:00000001402F93E0                 mov     rax, [rsp+arg_20]\n.text:00000001402F93E5                 mov     [rcx+50h], r8b ; Apc-&gt;ApcStateIndex &#x3D; ApcStateIndex\n.text:00000001402F93E9                 mov     [rcx+28h], rax ; Apc-&gt;RundownRoutine &#x3D; RundownRoutine\n.text:00000001402F93ED                 mov     [rcx+8], rdx   ; Apc-&gt;Thread &#x3D; Thread\n.text:00000001402F93F1                 mov     rdx, [rsp+arg_28]\n.text:00000001402F93F6                 mov     [rcx+30h], rdx ; Apc-&gt;NormalRoutine &#x3D; NormalRoutine\n.text:00000001402F93FA                 mov     rax, rdx\n.text:00000001402F93FD                 neg     rax\n.text:00000001402F9400                 mov     [rcx+20h], r9  ; Apc-&gt;KernelRoutine &#x3D; KernelRoutine\n.text:00000001402F9404                 sbb     rcx, rcx\n.text:00000001402F9407                 and     rcx, [rsp+arg_38]\n.text:00000001402F940C                 neg     rdx\n.text:00000001402F940F                 sbb     al, al\n.text:00000001402F9411                 and     al, [rsp+arg_30]\n.text:00000001402F9415                 mov     [r10+51h], al  ; Apc-&gt;ApcMode &#x3D; ApcMode\n.text:00000001402F9419                 mov     [r10+38h], rcx ; Apc-&gt;NormalContext &#x3D; NormalContext\n.text:00000001402F941D                 mov     byte ptr [r10+52h], 0 ; Apc-&gt;Inserted &#x3D; 0\n.text:00000001402F9422                 retn\n.text:00000001402F9422 ; ---------------------------------------------------------------------------\n.text:00000001402F9423                 align 4\n.text:00000001402F9424\n.text:00000001402F9424 loc_1402F9424:                          ; CODE XREF: KeInitializeApc+E↑j\n.text:00000001402F9424                 mov     r8b, [rdx+24Ah] ; ApcStateIndex &#x3D; Thread-&gt;ApcStateIndex\n.text:00000001402F942B                 jmp     short loc_1402F93E0\n.text:00000001402F942B KeInitializeApc endp</code></pre>\n\n<h3 id=\"反编译-1\"><a href=\"#反编译-1\" class=\"headerlink\" title=\"反编译\"></a>反编译</h3><p><code>1402F93D6 mov byte ptr [rcx+2], 58h</code>对照KAPC的结构，可以发现刚好成员<code>size</code>的偏移是<code>+2</code>，而<code>sizeof(_KAPC) = 0x58</code><br>由此判断rcx是<code>KAPC*</code></p>\n<p>根据后面对Apc的赋值，能够还原参数的符号</p>\n<p>比较有意思的是下面这段汇编：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">.text:00000001402F93F1                 mov     rdx, [rsp+arg_28] ; rdx &#x3D; NormalRoutine\n; ...\n.text:00000001402F93FA                 mov     rax, rdx          ; rax &#x3D; NormalRoutine\n; ...\n.text:00000001402F940C                 neg     rdx               ; rdx &#x3D; -NormalRoutine\n.text:00000001402F940F                 sbb     al, al            ; al &#x3D; NormalRoutine !&#x3D; 0 ? -1 : 0\n.text:00000001402F9411                 and     al, [rsp+arg_30]  ; al &#x3D; NormalRoutine !&#x3D; 0 ? ApcMode : 0;\n.text:00000001402F9415                 mov     [r10+51h], al</code></pre>\n\n<p>通过组合<code>neg b; sbb a, a; and a, c</code>实现的<code>a = b != 0 ? c : 0 </code></p>\n<p>当b不等于0时，neg会置cf为1，sbb便会借位，于是<code>a = a - a - 1 = -1</code>；而b等于0时，neg会置cf为0，<code>a = a - a = 0</code></p>\n<p>反编译代码如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void KeInitializeApc(\n    _KAPC* Apc,\n    struct _KTHREAD* Thread,\n    CHAR ApcStateIndex,\n    void* KernelRoutine,  &#x2F;&#x2F; func\n    void* RundownRoutine, &#x2F;&#x2F; func\n    void* NormalRoutine,  &#x2F;&#x2F; func\n    CHAR ApcMode,\n    VOID* NormalContext\n)\n&#123;\n    Apc-&gt;Type &#x3D; 0x12;\n    Apc-&gt;Size &#x3D; 0x58;\n    if(ApcStateIndex &#x3D;&#x3D; 2)\n        ApcStateIndex &#x3D; Thread-&gt;ApcStateIndex;\n     Apc-&gt;Thread &#x3D; Thread;\n    Apc-&gt;ApcStateIndex &#x3D; ApcStateIndex;\n    Apc-&gt;KernelRoutine &#x3D; KernelRoutine;\n    Apc-&gt;RundownRoutine &#x3D; RundownRoutine;\n    Apc-&gt;NormalRoutine &#x3D; NormalRoutine;\n    Apc-&gt;ApcMode &#x3D; NormalRoutine !&#x3D; 0 ? ApcMode : 0;\n    Apc-&gt;NormalContext &#x3D; NormalContext;\n&#125;</code></pre>\n\n<h2 id=\"ObFastDereferenceObject\"><a href=\"#ObFastDereferenceObject\" class=\"headerlink\" title=\"ObFastDereferenceObject\"></a>ObFastDereferenceObject</h2><h3 id=\"前置信息-2\"><a href=\"#前置信息-2\" class=\"headerlink\" title=\"前置信息\"></a>前置信息</h3><p>已知该函数在20h2和21h1中相同，且调用惯例应该是stdcall（被调用方清理栈），由于只有两个参数（通过寄存器传递），所以不需要清理</p>\n<p>查阅资料在win7中该函数的调用惯例应该也是stdcall</p>\n<p>MSDN原文:</p>\n<p><strong>ObDereferenceObject</strong> returns a value that is reserved for system use. Drivers must treat this value as VOID.</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; MSDN\nvoid ObDereferenceObject(\n  [in]  a\n);</code></pre>\n\n<h3 id=\"汇编-2\"><a href=\"#汇编-2\" class=\"headerlink\" title=\"汇编\"></a>汇编</h3><p>有一些比较陌生的汇编指令：</p>\n<p><code>prefectchw</code>：不影响程序的行为。用于将数据提前装入缓存，减少延迟。</p>\n<p><code>lock cmpxchg r/m, r</code>：x86上CAS被翻译成该指令。CAS是比较交换，无锁原子过程</p>\n<p><code>cmpxchg (r/m)a, (r)b</code>：将al/ax/eax/rax与首操作数比较；<br>若相等，等同于<code>mov a, b</code>且<code>zf=1</code>；否则等同于<code>mov al/ax/eax/rax, a</code>且<code>zf=0</code></p>\n<p>使用工具得到的反汇编如下：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">.text:0000000140298F70 ObFastDereferenceObject proc near\n.text:0000000140298F70                 sub     rsp, 28h\n.text:0000000140298F74                 mov     r9, rdx         ; r9 &#x3D; a2\n.text:0000000140298F77                 prefetchw byte ptr [rcx]\n.text:0000000140298F7A                 mov     rax, [rcx]      ; rax &#x3D; *a1\n.text:0000000140298F7D                 mov     r8, rax\n.text:0000000140298F80                 xor     r8, rdx         ; r8 &#x3D; (*a1) ^ a2\n.text:0000000140298F83                 cmp     r8, 0Fh\n.text:0000000140298F87                 jnb     short b1_140298F9A ; jmp r8 &gt;&#x3D; 0xf\n.text:0000000140298F89\n.text:0000000140298F89 loopBody_140298F89:                     ; CODE XREF: ObFastDereferenceObject+3E↓j\n.text:0000000140298F89                 lea     r8, [rax+1]     ; r8 &#x3D; *a1 + 1\n.text:0000000140298F8D                 lock cmpxchg [rcx], r8\n.text:0000000140298F92                 jnz     short loopCheck_140298FA4\n.text:0000000140298F94\n.text:0000000140298F94 ret_140298F94:                          ; CODE XREF: ObFastDereferenceObject+32↓j\n.text:0000000140298F94                 add     rsp, 28h\n.text:0000000140298F98                 retn\n.text:0000000140298F98 ; ---------------------------------------------------------------------------\n.text:0000000140298F99                 align 2\n.text:0000000140298F9A\n.text:0000000140298F9A b1_140298F9A:                           ; CODE XREF: ObFastDereferenceObject+17↑j\n.text:0000000140298F9A                                         ; ObFastDereferenceObject+40↓j\n.text:0000000140298F9A                 mov     rcx, r9         ; DmaAdapter\n.text:0000000140298F9D                 call    HalPutDmaAdapter\n.text:0000000140298FA2                 jmp     short ret_140298F94\n.text:0000000140298FA4 ; ---------------------------------------------------------------------------\n.text:0000000140298FA4\n.text:0000000140298FA4 loopCheck_140298FA4:                    ; CODE XREF: ObFastDereferenceObject+22↑j\n.text:0000000140298FA4                 mov     rdx, rax\n.text:0000000140298FA7                 xor     rdx, r9         ; rdx &#x3D; rax ^ r9\n.text:0000000140298FAA                 cmp     rdx, 0Fh\n.text:0000000140298FAE                 jb      short loopBody_140298F89 ; r8 &#x3D; *a1 + 1\n.text:0000000140298FB0                 jmp     short b1_140298F9A ; break\n.text:0000000140298FB0 ObFastDereferenceObject endp</code></pre>\n\n<h3 id=\"反编译-2\"><a href=\"#反编译-2\" class=\"headerlink\" title=\"反编译\"></a>反编译</h3><p>_InterlockedCompareExchange64(*Dst, Exc, Cmp)，Exc是新值，Cmp是比较值</p>\n<p>反编译代码如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void ObDereferenceObject(UInt64* obj, const UInt64 a2)\n&#123;\n    &#x2F;&#x2F; begin:\n    _m_prefectchw(obj);\n    UInt64 v0 &#x3D; *obj; &#x2F;&#x2F; rax\n    UInt64 v1 &#x3D; v0 ^ a2;\n    \n    while(v1 &lt; 0xf) &#123;\n        &#x2F;&#x2F; loopBody:\n        UInt64 oldV0 &#x3D; v0;\n        v0 &#x3D; _InterlockedCompareExchange64(obj, v0 + 1, v0);\n        if(oldV0 &#x3D;&#x3D; v0) &#x2F;&#x2F; if v0 not change(obj &#x3D; v0 + 1)\n            return;\n        &#x2F;&#x2F; loopCheck:\n        v1 &#x3D; v0 ^ a2;\n    &#125;\n    \n    &#x2F;&#x2F; b1:\n    v0 &#x3D; HalPutDmaAdapter(a2);\n    \n    &#x2F;&#x2F; ret:\n    return;\n&#125;</code></pre>\n\n<p>其中loopBody的四行代码相当于以下代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">if(*obj &#x3D;&#x3D; v0) &#123;\n    *obj &#x3D; v0 + 1;\n    return;\n&#125;\nelse&#123;\n    v0 &#x3D; *obj;\n&#125;</code></pre>\n\n<h2 id=\"KeInitializeQueue\"><a href=\"#KeInitializeQueue\" class=\"headerlink\" title=\"KeInitializeQueue\"></a>KeInitializeQueue</h2><h3 id=\"前置信息-3\"><a href=\"#前置信息-3\" class=\"headerlink\" title=\"前置信息\"></a>前置信息</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; MSDN\nvoid KeInitializeQueue(\n  [out] PRKQUEUE Queue,\n  [in]  ULONG    Count\n);\n\ntypedef struct _KQUEUE &#123;\n    DISPATCHER_HEADER Header;  &#x2F;&#x2F; +0h\n    LIST_ENTRY EntryListHead;  &#x2F;&#x2F; +18h\n    ULONG CurrentCount;        &#x2F;&#x2F; +28h\n    ULONG MaximumCount;        &#x2F;&#x2F; +2Ch\n    LIST_ENTRY ThreadListHead; &#x2F;&#x2F; +30h\n&#125; KQUEUE, *PKQUEUE, *RESTRICTED_POINTER PRKQUEUE;</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">struct _DISPATCHER_HEADER\n&#123;\n\tunion\n    &#123;\n        struct\n        &#123;\n            UCHAR QueueType;                           &#x2F;&#x2F;0x0\n            union\n            &#123;\n                UCHAR QueueControlFlags;               &#x2F;&#x2F;0x1\n                struct\n                &#123;\n                    UCHAR Abandoned:1;                 &#x2F;&#x2F;0x1\n                    UCHAR DisableIncrement:1;          &#x2F;&#x2F;0x1\n                    UCHAR QueueReservedControlFlags:6; &#x2F;&#x2F;0x1\n                &#125;;\n            &#125;;\n            UCHAR QueueSize;                           &#x2F;&#x2F;0x2\n            UCHAR QueueReserved;                       &#x2F;&#x2F;0x3\n        &#125;;\n    &#125;</code></pre>\n\n<h3 id=\"汇编-3\"><a href=\"#汇编-3\" class=\"headerlink\" title=\"汇编\"></a>汇编</h3><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">.text:00000001402DE420 KeInitializeQueue proc near\n.text:00000001402DE420                 push    rbx\n.text:00000001402DE422                 sub     rsp, 20h\n.text:00000001402DE426                 mov     rbx, rcx        ; rbx &#x3D; Queue\n.text:00000001402DE429                 mov     byte ptr [rcx], 4 ; Queue-&gt;Header.QueueType &#x3D; 4\n.text:00000001402DE42C                 xor     ecx, ecx\n.text:00000001402DE42E                 mov     word ptr [rbx+1], 1000h ; *(WORD*)&amp;Queue-&gt;Header.QueueControlFlags &#x3D; 0x1000\n.text:00000001402DE434                 lea     rax, [rbx+8]    ; rax &#x3D; &amp;Queue-&gt;Header.WaitListHead\n.text:00000001402DE438                 mov     [rax+8], rax    ; Queue-&gt;Header.WaitListHead.Blink &#x3D; &amp;Queue-&gt;Header.WaitListHead\n.text:00000001402DE43C                 mov     [rax], rax      ; Queue-&gt;Header.WaitListHead.Flink &#x3D; &amp;Queue-&gt;Header.WaitListHead\n.text:00000001402DE43F                 lea     rax, [rbx+18h]  ; rax &#x3D; &amp;Queue-&gt;EntryListHead\n.text:00000001402DE443                 mov     [rax+8], rax    ; Queue-&gt;EntryListHead.Blink &#x3D; &amp;Queue-&gt;EntryListHead\n.text:00000001402DE447                 mov     [rax], rax      ; Queue-&gt;EntryListHead.Flink &#x3D; &amp;Queue-&gt;EntryListHead\n.text:00000001402DE44A                 lea     rax, [rbx+30h]  ; rax &#x3D; &amp;Queue-&gt;ThreadListHead\n.text:00000001402DE44E                 mov     [rax+8], rax    ; Queue-&gt;ThreadListHead.Blink &#x3D; &amp;Queue-&gt;ThreadListHead\n.text:00000001402DE452                 mov     [rax], rax      ; Queue-&gt;ThreadListHead.Flink &#x3D; &amp;Queue-&gt;ThreadListHead\n.text:00000001402DE455                 mov     [rbx+4], ecx    ; Queue-&gt;Header.SignalState &#x3D; 0\n.text:00000001402DE458                 mov     [rbx+28h], ecx  ; Queue-&gt;CurrentCount &#x3D; 0\n.text:00000001402DE45B                 test    edx, edx\n.text:00000001402DE45D                 jnz     short loc_1402DE46B ; jmp if edx\n.text:00000001402DE45F                 mov     ecx, 0FFFFh     ; GroupNumber\n.text:00000001402DE464                 call    KeQueryActiveProcessorCountEx\n.text:00000001402DE469                 mov     edx, eax\n.text:00000001402DE46B\n.text:00000001402DE46B loc_1402DE46B:                          ; CODE XREF: KeInitializeQueue+3D↑j\n.text:00000001402DE46B                 mov     [rbx+2Ch], edx  ; Queue-&gt;MaximumCount &#x3D; Count\n.text:00000001402DE46E                 add     rsp, 20h\n.text:00000001402DE472                 pop     rbx\n.text:00000001402DE473                 retn\n.text:00000001402DE473 ; ---------------------------------------------------------------------------\n.text:00000001402DE474                 db 0CCh\n.text:00000001402DE474 KeInitializeQueue endp</code></pre>\n\n<h3 id=\"反编译-3\"><a href=\"#反编译-3\" class=\"headerlink\" title=\"反编译\"></a>反编译</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void KeInitializeQueue(PRKQUEUE Queue, ULONG Count)\n&#123;\n    Queue-&gt;Header.QueueType &#x3D; 4;\n    *(WORD*)&amp;Queue-&gt;Header.QueueControlFlags &#x3D; 0x1000;\n    Queue-&gt;Header.WaitListHead.Blink &#x3D; &amp;Queue-&gt;Header.WaitListHead;\n    Queue-&gt;Header.WaitListHead.Flink &#x3D; &amp;Queue-&gt;Header.WaitListHead;\n    Queue-&gt;EntryListHead.Blink &#x3D; &amp;Queue-&gt;EntryListHead;\n    Queue-&gt;EntryListHead.Flink &#x3D; &amp;Queue-&gt;EntryListHead;\n    Queue-&gt;ThreadListHead.Blink &#x3D; &amp;Queue-&gt;ThreadListHead;\n    Queue-&gt;ThreadListHead.Flink &#x3D; &amp;Queue-&gt;ThreadListHead;\n    Queue-&gt;Header.SignalState &#x3D; 0;\n    Queue-&gt;CurrentCount &#x3D; 0;\n    if ( !Count )\n    Count &#x3D; KeQueryActiveProcessorCountEx(0xFFFFu);\n    Queue-&gt;MaximumCount &#x3D; Count;\n&#125;</code></pre>\n\n<h2 id=\"KxWaitForLockChainValid\"><a href=\"#KxWaitForLockChainValid\" class=\"headerlink\" title=\"KxWaitForLockChainValid\"></a>KxWaitForLockChainValid</h2><h3 id=\"汇编-4\"><a href=\"#汇编-4\" class=\"headerlink\" title=\"汇编\"></a>汇编</h3><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">.text:0000000140279BD0 KxWaitForLockChainValid proc near\n.text:0000000140279BD0 arg_0           &#x3D; qword ptr  8\n.text:0000000140279BD0                 mov     [rsp+arg_0], rbx\n.text:0000000140279BD5                 push    rdi\n.text:0000000140279BD6                 sub     rsp, 20h\n.text:0000000140279BDA                 mov     rdi, rcx        ; rdi &#x3D; a1\n.text:0000000140279BDD                 xor     ebx, ebx        ; ebx &#x3D; 0\n.text:0000000140279BDF\n.text:0000000140279BDF loopStart_140279BDF:                    ; CODE XREF: KxWaitForLockChainValid+25↓j\n.text:0000000140279BDF                 inc     ebx             ; ebx++\n.text:0000000140279BE1                 test    cs:HvlLongSpinCountMask, ebx\n.text:0000000140279BE7                 jz      branch1_140437A78\n.text:0000000140279BED\n.text:0000000140279BED pause_140279BED:                        ; CODE XREF: KxWaitForLockChainValid+1BDEB0↓j\n.text:0000000140279BED                 pause\n.text:0000000140279BEF\n.text:0000000140279BEF loopCheck_140279BEF:                    ; CODE XREF: KxWaitForLockChainValid+1BDECB↓j\n.text:0000000140279BEF                 mov     rax, [rdi]      ; rax &#x3D; *a1\n.text:0000000140279BF2                 test    rax, rax\n.text:0000000140279BF5                 jz      short loopStart_140279BDF ; jmp if *a1 &#x3D;&#x3D; 0\n.text:0000000140279BF7                 mov     rbx, [rsp+28h+arg_0]\n.text:0000000140279BFC                 add     rsp, 20h\n.text:0000000140279C00                 pop     rdi\n.text:0000000140279C01                 retn\n.text:0000000140279C01 ; ---------------------------------------------------------------------------\n.text:0000000140279C02                 db 0CCh\n.text:0000000140279C02 KxWaitForLockChainValid endp\n\n\n.text:0000000140437A78 ; START OF FUNCTION CHUNK FOR KxWaitForLockChainValid\n.text:0000000140437A78\n.text:0000000140437A78 branch1_140437A78:                      ; CODE XREF: KxWaitForLockChainValid+17↑j\n.text:0000000140437A78                 mov     eax, cs:HvlEnlightenments\n.text:0000000140437A7E                 test    al, 40h\n.text:0000000140437A80                 jz      pause_140279BED\n.text:0000000140437A86                 call    KiCheckVpBackingLongSpinWaitHypercall\n.text:0000000140437A8B                 test    al, al\n.text:0000000140437A8D                 jz      pause_140279BED\n.text:0000000140437A93                 mov     ecx, ebx\n.text:0000000140437A95                 call    HvlNotifyLongSpinWait\n.text:0000000140437A9A                 nop\n.text:0000000140437A9B                 jmp     loopCheck_140279BEF ; rax &#x3D; *a1\n.text:0000000140437A9B ; END OF FUNCTION CHUNK FOR KxWaitForLockChainValid</code></pre>\n\n<h3 id=\"反编译-4\"><a href=\"#反编译-4\" class=\"headerlink\" title=\"反编译\"></a>反编译</h3><p>branch1实际上就是一个if(a &amp; b &amp; c){}else{}的结构，各个jcc是顺序排序，只要触发一个就去到false分支，分析关键是抓住能走完全部jcc的路径</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">unsigned long long KxWaitForLockChainValid(unsigned long long* a1)&#123;\n\tint i &#x3D; 0;\n    do&#123;\n        &#x2F;&#x2F; loopStart:\n        i++;\n        if((i &amp; HvlLongSpinCountMask) &#x3D;&#x3D; 0\n          &amp;&amp; (HvlEnlightenments &amp; 0x40) !&#x3D; 0\n          &amp;&amp; KiCheckVpBackingLongSpinWaitHypercall() !&#x3D; 0) &#123;\n            HvlNotifyLongSpinWait(i);\n        &#125;else&#123;\n            _mm_pause();\n        &#125;\n    &#125;while(!*a1);\n    return *a1;\n&#125;</code></pre>\n\n<h2 id=\"KeReadyThread\"><a href=\"#KeReadyThread\" class=\"headerlink\" title=\"KeReadyThread\"></a>KeReadyThread</h2><p>嵌套的if{}，结构如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#123;\n    c0();\n    if() &#123;\n        c1();\n        if() c2();\n        c3();\n        if() ret();\n    &#125;\n    c4();\n    ret();\n&#125;</code></pre>\n\n<h2 id=\"KiInitializeTSS（未找到）\"><a href=\"#KiInitializeTSS（未找到）\" class=\"headerlink\" title=\"KiInitializeTSS（未找到）\"></a>KiInitializeTSS（未找到）</h2><p>21h1的ntoskrnl.exe中未找到</p>\n<h2 id=\"RtlValidateUnicodeString\"><a href=\"#RtlValidateUnicodeString\" class=\"headerlink\" title=\"RtlValidateUnicodeString\"></a>RtlValidateUnicodeString</h2><p>if((a &amp;&amp; b) || c)结构</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">if(a || (!b &amp;&amp; (c || d || e || f)) || (g &amp;&amp; (h || !i))) &#123;\n    return 0xC000000D;\n&#125;else&#123;\n    return 0;\n&#125;</code></pre>\n\n","text":"《逆向工程实战》1.7 练习 反编译windows内核例程例程选取自win10 x64 21h1 摘要每个例程反编译的知识点如下： KeInitializeDpc：结构体赋值，纯拷贝 KeInitializeApc：结构体赋值，有条件拷贝 ObFastDereferenceObj...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"Windows","slug":"Windows","count":21,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":21,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"practicalre","slug":"practicalre","count":5,"path":"api/tags/practicalre.json"},{"name":"antiDebug","slug":"antiDebug","count":2,"path":"api/tags/antiDebug.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B1-7-%E7%BB%83%E4%B9%A0-%E5%8F%8D%E7%BC%96%E8%AF%91windows%E5%86%85%E6%A0%B8%E4%BE%8B%E7%A8%8B\"><span class=\"toc-text\">《逆向工程实战》1.7 练习 反编译windows内核例程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%91%98%E8%A6%81\"><span class=\"toc-text\">摘要</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E5%A4%8D%E6%9D%82%E7%9A%84if-else\"><span class=\"toc-text\">条件复杂的if(){}else{}</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KeInitializeDpc\"><span class=\"toc-text\">KeInitializeDpc</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BD%AE%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">前置信息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B1%87%E7%BC%96\"><span class=\"toc-text\">汇编</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">反编译</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KeInitializeApc\"><span class=\"toc-text\">KeInitializeApc</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BD%AE%E4%BF%A1%E6%81%AF-1\"><span class=\"toc-text\">前置信息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B1%87%E7%BC%96-1\"><span class=\"toc-text\">汇编</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E7%BC%96%E8%AF%91-1\"><span class=\"toc-text\">反编译</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ObFastDereferenceObject\"><span class=\"toc-text\">ObFastDereferenceObject</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BD%AE%E4%BF%A1%E6%81%AF-2\"><span class=\"toc-text\">前置信息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B1%87%E7%BC%96-2\"><span class=\"toc-text\">汇编</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E7%BC%96%E8%AF%91-2\"><span class=\"toc-text\">反编译</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KeInitializeQueue\"><span class=\"toc-text\">KeInitializeQueue</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BD%AE%E4%BF%A1%E6%81%AF-3\"><span class=\"toc-text\">前置信息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B1%87%E7%BC%96-3\"><span class=\"toc-text\">汇编</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E7%BC%96%E8%AF%91-3\"><span class=\"toc-text\">反编译</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KxWaitForLockChainValid\"><span class=\"toc-text\">KxWaitForLockChainValid</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B1%87%E7%BC%96-4\"><span class=\"toc-text\">汇编</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E7%BC%96%E8%AF%91-4\"><span class=\"toc-text\">反编译</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KeReadyThread\"><span class=\"toc-text\">KeReadyThread</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KiInitializeTSS%EF%BC%88%E6%9C%AA%E6%89%BE%E5%88%B0%EF%BC%89\"><span class=\"toc-text\">KiInitializeTSS（未找到）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RtlValidateUnicodeString\"><span class=\"toc-text\">RtlValidateUnicodeString</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"《Windows Kernel Programming》 笔记 1~5 内核开发入门","uid":"2cdcc6b2635425e63dc5ac736f5a68f9","slug":"wkp1-5","date":"2021-12-24T04:00:00.000Z","updated":"2022-01-18T09:30:03.325Z","comments":true,"path":"api/articles/wkp1-5.json","keywords":null,"cover":[],"text":"Windows Kernel Programming 笔记 1~5 内核开发入门1 windows内部概况描述一些Windows内部工作中最重要、最基本的概念，部分概念将在后面的章节做更详细的研究 1.1 进程进程不运行（Processes dont’t run - proces...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"Windows","slug":"Windows","count":21,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":21,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":7,"path":"api/tags/kernel.json"},{"name":"wkp","slug":"wkp","count":3,"path":"api/tags/wkp.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"从0开始：某fpsgo简单透视制作","uid":"7081df1a25a0e63a8adb7b11423fb4be","slug":"fpsgoPerspective","date":"2021-11-08T12:54:00.000Z","updated":"2021-12-05T15:10:44.986Z","comments":true,"path":"api/articles/fpsgoPerspective.json","keywords":null,"cover":null,"text":"从0开始：某fpsgo简易透视制作摘要 前置知识： 线性代数知识：矩阵的基本运算 图形学知识：齐次坐标，仿射变换，MVP模型 （可选）旋转、四元数与欧拉角（我也不懂） 其他：CE的基本使用、C++、dll编写与注入、IMGUI 一些资源： frk1/hazedumper: up ...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"Hack","slug":"Hack","count":1,"path":"api/categories/Hack.json"}],"tags":[{"name":"hack","slug":"hack","count":1,"path":"api/tags/hack.json"},{"name":"fps","slug":"fps","count":1,"path":"api/tags/fps.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}