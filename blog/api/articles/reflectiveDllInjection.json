{"title":"反射式dll注入源码笔记","uid":"672d33a00ecfe140728287608f94a579","slug":"reflectiveDllInjection","date":"2021-04-11T10:31:55.000Z","updated":"2021-09-28T10:21:56.361Z","comments":true,"path":"api/articles/reflectiveDllInjection.json","keywords":null,"cover":[],"content":"<h1 id=\"从反射注入学习pe文件加载\"><a href=\"#从反射注入学习pe文件加载\" class=\"headerlink\" title=\"从反射注入学习pe文件加载\"></a>从反射注入学习pe文件加载</h1><h2 id=\"前言？后记与总结\"><a href=\"#前言？后记与总结\" class=\"headerlink\" title=\"前言？后记与总结\"></a>前言？后记与总结</h2><p>这是我写完代码后写的总结。重新梳理一下反射注入到底想干什么、以及怎么干。以及从中学到了什么。</p>\n<h3 id=\"收获？目标？反射注入是什么\"><a href=\"#收获？目标？反射注入是什么\" class=\"headerlink\" title=\"收获？目标？反射注入是什么\"></a>收获？目标？反射注入是什么</h3><p>首先是学习反射注入的收获，当然也可以作为学习的目标，同时也是反射注入实际做的东西。</p>\n<p>我的理解是反射注入实际上就是手工加载模块。通过LoadLibrary加载dll会在peb中留下记录，通过手工实现加载过程，我们的dll能像正常dll那样工作，且不再peb中留下痕迹。</p>\n<p>也就是说，通过学习反射注入，可以了解到windows系统加载一个pe文件的流程。其中涉及到了部分的peb以及大量的pe结构。</p>\n<p>我们主要需要peb中的ldr结构，这个结构中保存了该进程已经加载了的dll。</p>\n<p>既然我们的主要工作是手工加载pe文件，自然要对pe文件格式有一定了解。但笔记中不会多提pe文件结构，实际上只要大概了解pe文件格是是个什么，然后在写代码时多去看pe结构的定义，就可以对pe文件结构有一个更深的理解。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>在学习过程中参考了许多资料，最主要的就是msf的反射注入payload的源码。其他如有不懂通过百度也可以找到详细的解释。相关文章比较多，dddd，就不一一列举了。</p>\n<h3 id=\"关于这篇东西\"><a href=\"#关于这篇东西\" class=\"headerlink\" title=\"关于这篇东西\"></a>关于这篇东西</h3><p>这篇东西由我阅读源码，查资料时做的笔记发展而来。国内虽然少但也有一些优秀的反射注入的文章，看雪中也有类似文章，但阅读门槛稍微有点高。因为是由笔记发展而来，这更像是一个零基础初学者的学习笔记（实际上在开始学反射注入之前，只知道pe文件格是是什么东西，几乎完全不了解。对windows的机制也完全不了解），希望能帮助到初学者，这项技术对我学习windows有很大帮助，虽然我只是一个初学者，但这项实践使我之后对书本、资料上的内容有了更深的了解。可能会有错误，希望发现错误的dalao可以帮帮我这个初学者纠正。</p>\n<h3 id=\"前置要求\"><a href=\"#前置要求\" class=\"headerlink\" title=\"前置要求\"></a>前置要求</h3><p>va、fa、rva这几个概念搞清楚好像就行。实际上就是对pe文件如何从文件映射到内存有一个大体的认识。我们的工作就是具体完成这个过程。可以参考下图。</p>\n<p><img src=\"https://z3.ax1x.com/2021/04/11/c0exl4.png\" alt=\"pe文件到内存的映射\"></p>\n<p>pe文件的格式网上有比较多的图片，这里就不贴了。</p>\n<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">(前置条件序号) 序号 流程内容\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n注入器：\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n(0)   1 打开dll文件(CreateFile)，获取dll长度(GetFileSize)\n(1)   2 分配内存(HealAlloc)，读取文件(ReadFile)\n(0)   3 打开目标进程(OpenProcess)\n(2,3) 4 调用反射注入函数(LoadLibraryR.c&gt;LoadRemoteLibraryR)\n(2)   5 获取反射加载函数的文件偏移(LoadLibraryR.c&gt;GetReflectiveLoaderOffset)\n(2,3) 6 在目标进程中分配空间(VirtualAllocEx)，写入dll(WriteProcessMemory)\n(6)   7 修改目标进程中的空间为可执行(VirtualProtectEx)\n(5,7) 8 创建远程线程，执行反射加载函数(CreateRemoteThread)\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n反射加载函数（运行在被注入进程的新建线程中）：\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n1 获取基地址\n2 获取需要的kernel32.dll及ntdll.dll的函数的va\n3 分配空间作为映像空间，并复制pe头到新的位置\n4 复制所有段到映像的对应位置\n5 处理导入表，填写iat\n6 重定位\n7 跳转到ep（_DllMainCRTStartup）\n8 返回entry point地址</code></pre>\n\n<h2 id=\"注入器\"><a href=\"#注入器\" class=\"headerlink\" title=\"注入器\"></a>注入器</h2><h3 id=\"主要流程\"><a href=\"#主要流程\" class=\"headerlink\" title=\"主要流程\"></a>主要流程</h3><p>首先打开dll文件，获取长度，并在堆中分配空间读取文件。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">hFile &#x3D; CreateFileW(dllPathname, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\ndwDllLen &#x3D; GetFileSize(hFile, 0);\nlpDll &#x3D; HeapAlloc(GetProcessHeap(), 0, dwDllLen);</code></pre>\n\n<p>然后找到dll中ReflectiveLoader的入口点。</p>\n<p>最后以RW申请空间，写入dll后改成RX，然后以ReflectiveLoader作为线程函数创建远程线程。</p>\n<h3 id=\"计算fa\"><a href=\"#计算fa\" class=\"headerlink\" title=\"计算fa\"></a>计算fa</h3><p>LoadLibraryR中有个函数Rva2Offset用于获取rva对应的fa。</p>\n<p>原理是遍历区块获取区块的section_rva和section_fa，然后比较rva和section_rva找到rva所在的section，最后计算出fa。再用fa+baseAddr得到内存中的位置。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">DWORD Rva2Fa(DWORD rva, PIMAGE_SECTION_HEADER sections, int sectionNum)\n&#123;\n    for (int i &#x3D; 0; i &lt; sectionNum; i++) &#123;\n        int sectionVa &#x3D; sections[i].VirtualAddress;\n        if ((rva &gt;&#x3D; sectionVa) &amp;&amp; ((sectionVa + sections[i].SizeOfRawData) &gt; rva))\n            return rva - (sectionVa - sections[i].PointerToRawData);\n    &#125;\n\n    return 0;\n&#125;</code></pre>\n\n<h3 id=\"获取ReflectivelLoader位置（输出表）\"><a href=\"#获取ReflectivelLoader位置（输出表）\" class=\"headerlink\" title=\"获取ReflectivelLoader位置（输出表）\"></a>获取ReflectivelLoader位置（输出表）</h3><p>通过nt头，计算出sections的fa，以及通过nt头的optionalheader获取输出表的rva。</p>\n<p>然后遍历section找到输出表的fa，接着遍历输出表的函数名字rva表，计算出rva对应fa得到导出函数名字，与需要的导出函数做对比，确定要找的函数在函数名表中的下标。用此下标在序号表中找到序号，最后再用序号去地址表找到地址。</p>\n<h2 id=\"反射加载函数\"><a href=\"#反射加载函数\" class=\"headerlink\" title=\"反射加载函数\"></a>反射加载函数</h2><h3 id=\"1-获取基址\"><a href=\"#1-获取基址\" class=\"headerlink\" title=\"1. 获取基址\"></a>1. 获取基址</h3><p>首先获取代码的位置，然后再往前找dos头。</p>\n<p>_ReturnAddress()返回当前调用函数的返回地址。所以在loader中调用一个函数，该函数再调用_ReturnAddress()，返回调用函数的返回地址，即loader中调用函数的下一条语句的地址。<br>其中 __declspec(noinline) 用于防止编译器优化该函数成内联函数，否则返回的就是loader的返回地址。</p>\n<p>使用_ReturnAddress需要intrin.h，并使用#pragma intrinsic防止内联优化。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;intrin.h&gt;\n#pragma intrinsic(_ReturnAddress)\n__declspec(noinline) PVOID NextAddr()\n&#123;\n\treturn (PVOID)_ReturnAddress();\n&#125;</code></pre>\n\n<p>根据pe格式可知，dos头(IMAGE_DOS_HEADER)中有有一个e_magic标志，值是0x5A4D(MZ)。<br>所以向前遍历内存，直到找到MZ标志，再检查pe头的PE标志，这样就找到dos头了。<br>需要注意的是，检查PE标志时要检查pe头偏移是否正确，防止错误的内存访问。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">while (TRUE) &#123;\n    if (dosHeadAddr-&gt;e_magic &#x3D;&#x3D; 0x5A4D) &#123;\n        LONG e_lfanew &#x3D; dosHeadAddr-&gt;e_lfanew;\n        if (e_lfanew &gt;&#x3D; sizeof(IMAGE_DOS_HEADER) &amp;&amp; e_lfanew &lt; 1024) &#123;\n            ntHeadAddr &#x3D; (PIMAGE_NT_HEADERS)((PVOID)dosHeadAddr + (PVOID)e_lfanew);\n            if (ntHeadAddr-&gt;Signature &#x3D;&#x3D; 0x4550)\n                break;\n        &#125;\n    &#125;\n    dosHeadAddr--;\n&#125;</code></pre>\n\n<p>这里也可以取巧，远程线程是可以传递一个参数的，对于我们这个简单的dll，imagebase实际上就是分配空间的首地址，可以作为参数传入。</p>\n<h3 id=\"2-获取需要的内核导出函数的va\"><a href=\"#2-获取需要的内核导出函数的va\" class=\"headerlink\" title=\"2. 获取需要的内核导出函数的va\"></a>2. 获取需要的内核导出函数的va</h3><h4 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h4><p>接下来的步骤中需要用到一些ntdll.dll，kernel32.dll中的导出函数，所以需要先找到这些函数的va。这些系统模块都是已经加载了的，可以在peb中找到其加载的位置。</p>\n<p>这里利用hash避免直接比较字符串。</p>\n<p>我们需要LoadLibraryA、GetProcAddress加载导入表中的dll的对应的函数。</p>\n<p>需要VirtualAlloc分配内存给我们把pe文件加载到其中。</p>\n<p>需要NtFlushInstructionCache刷新指令缓存。</p>\n<h4 id=\"LDR-DATA-TABLE-ENTRY\"><a href=\"#LDR-DATA-TABLE-ENTRY\" class=\"headerlink\" title=\"LDR_DATA_TABLE_ENTRY\"></a>LDR_DATA_TABLE_ENTRY</h4><p>InMemoryOrderModuleList对应的链表是一个环形双向链表，且有一个头节点（或者说哨兵节点）。InMemoryOrderModuleList的Flink指向链表的第一个节点，Blink指向链表最后一个节点。头节点的Flink是第一个节点，可以以此为跳出条件遍历该链表。</p>\n<p><img src=\"https://z3.ax1x.com/2021/04/11/c0mZ1e.jpg\" alt=\"ldr链\"></p>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>首先从peb中找到ldr，然后遍历InMemoryOrderModuleList，通过hash(BaseName)找到kernel32.dll和ntdll.dll对应的LDR_DATA_TABLE_ENTRY结构。</p>\n<p>找到dll对应的LDR_DATA_TABLE_ENTRY后，获取其imagebase，然后解析pe头，计算出导出表位置。同样利用hash比较字符串找到所需的导出函数，并计算出va。</p>\n<h4 id=\"实现代码\"><a href=\"#实现代码\" class=\"headerlink\" title=\"实现代码\"></a>实现代码</h4><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; 找pLdrDataTableEnrty\nDWORD pPeb &#x3D; __readfsdword(0x30);\nDWORD pLdr &#x3D; *(DWORD*)(pPeb + 0xc);\nDWORD pInMemoryOrderModuleList &#x3D; pLdr + 0x14; &#x2F;&#x2F; 第一个节点的二级指针\nDWORD pLdrDataTableEnrty &#x3D; *(DWORD*)(pInMemoryOrderModuleList + 0);\n&#x2F;&#x2F; 遍历LdrDataTableEnrty\ndo&#123;\n\tWCHAR* name &#x3D; (WCHAR*)*(DWORD*)(pLdrDataTableEnrty + 0x24 + 0x4);\n\thash &#x3D; YourHashFun(name); &#x2F;&#x2F; 使用你自己的函数计算hash值\n\tif(hash &#x3D;&#x3D; DLLHASH) &#123; &#x2F;&#x2F; DLLHASH由你自己的函数计算得出\n\t\tDWORD baseAddr &#x3D; *(DWORD*)(pLdrDataTableEnrty + 0x10);\n\t\t&#x2F;&#x2F; 解析pe头过程省略\n\t\tfor(int i &#x3D; 0; i &lt; funcNum; i++) &#123; &#x2F;&#x2F; funcNum是导出函数的个数\n\t\t\tchar* name &#x3D; (char*)(baseAddr + ((DWORD*)nameRvas)[i]);\n\t\t\tDWORD hash &#x3D; YourHashFun(name);\n\t\t\tif (hash &#x3D;&#x3D; FUNCHASH) &#123;\n\t\t\t\tpFunc &#x3D; (FUNC)(baseAddr + ((DWORD*)funcRvas)[((WORD*)ordRvas)[i]]);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;while(*(DWORD*)(pLdrDataTableEnrty) !&#x3D; *(DWORD*)(pInMemoryOrderModuleList))</code></pre>\n\n<h3 id=\"3-给映像分配空间，并加载pe头\"><a href=\"#3-给映像分配空间，并加载pe头\" class=\"headerlink\" title=\"3. 给映像分配空间，并加载pe头\"></a>3. 给映像分配空间，并加载pe头</h3><p>新分配大小等于sizeOfImga的内存作为映像加载的空间，然后把pe头复制到新内存里，这里我只更新了新nt头的imagebase地址。太简单就不贴代码了。</p>\n<h3 id=\"4-加载段\"><a href=\"#4-加载段\" class=\"headerlink\" title=\"4. 加载段\"></a>4. 加载段</h3><p>遍历section_header获取fa和rva，计算出section在旧内存中的va和新内存中的va。然后复制section到新内存中的对应位置。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">oldVA &#x3D; oldImageBase + sections[i].PointerToRawData;\nnewVA &#x3D; newImageBase + sections[i].VirtualAddress; </code></pre>\n\n<h3 id=\"5-处理导入表\"><a href=\"#5-处理导入表\" class=\"headerlink\" title=\"5. 处理导入表\"></a>5. 处理导入表</h3><h4 id=\"目标-1\"><a href=\"#目标-1\" class=\"headerlink\" title=\"目标\"></a>目标</h4><p>找到导入表，然后遍历导入表，依次加载对应的dll，及需要的dll的导出函数，并填写对应iat。</p>\n<h4 id=\"导入表结构\"><a href=\"#导入表结构\" class=\"headerlink\" title=\"导入表结构\"></a>导入表结构</h4><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; winnt.h\ntypedef struct _IMAGE_THUNK_DATA32 &#123;\n    union &#123;\n        DWORD ForwarderString;      &#x2F;&#x2F; PBYTE \n        DWORD Function;             &#x2F;&#x2F; PDWORD\n        DWORD Ordinal;\n        DWORD AddressOfData;        &#x2F;&#x2F; PIMAGE_IMPORT_BY_NAME (补充一下，这是个rva)\n    &#125; u1;\n&#125; IMAGE_THUNK_DATA32;\ntypedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;\n\ntypedef struct _IMAGE_IMPORT_BY_NAME &#123;\n    WORD    Hint;\n    CHAR   Name[1];\n&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</code></pre>\n\n<p>和导出表不同，导入表是一个结构体数组。它不提供结构体数量，最后一个结构体仅作为结束标志，不包含导入信息，其成员Characteristics为0，这可以作为遍历的退出条件。</p>\n<p>对于每个导入表，在文件中时OriginalFirstThunk和FirstThunk都是RVA，指向同一个IMAGE_THUNK_DATA结构体数组。<br>当加载到内存时，FirstThunk改为函数的VA，即iat。</p>\n<p>文件中时，OriginalFirstThunk和FirstThunk指向的结构体数组中，每一个IMAGE_THUNK_DATA的成员u1都被解释为Ordinal，若该函数应该通过序号导入，则Ordinal的最高位会被置为1。</p>\n<h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>见实现代码注释。</p>\n<h4 id=\"实现代码-1\"><a href=\"#实现代码-1\" class=\"headerlink\" title=\"实现代码\"></a>实现代码</h4><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pNewDosHeader + pNewNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\n\nfor (; pImportDescriptor-&gt;Characteristics; pImportDes++) &#123;\n    &#x2F;&#x2F; 加载dll\n    HMODULE libraryAddress &#x3D; pLoadLibraryA((LPCSTR)((DWORD)pNewDosHeader + pImportDes-&gt;Name));\n    if (!libraryAddress)\n            continue;\n    \n    &#x2F;&#x2F; parsing pe structure\n    PIMAGE_THUNK_DATA32 pOriginalThunk &#x3D; (PIMAGE_THUNK_DATA32)((DWORD)pNewDosHeader + pImportDes-&gt;OriginalFirstThunk);\n    PIMAGE_THUNK_DATA32 pThunk &#x3D; (PIMAGE_THUNK_DATA32)((DWORD)pNewDosHeader + pImportDes-&gt;FirstThunk);\n    PIMAGE_NT_HEADERS32 pLibNtHeader &#x3D; (PIMAGE_NT_HEADERS32)((DWORD)libraryAddress + ((PIMAGE_DOS_HEADER)libraryAddress)-&gt;e_lfanew);\n    PIMAGE_EXPORT_DIRECTORY pExportDir &#x3D; (PIMAGE_EXPORT_DIRECTORY)((DWORD)libraryAddress + pLibNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n    PDWORD funcRvas &#x3D; (PDWORD)((DWORD)libraryAddress + pExportDir-&gt;AddressOfFunctions);\n\t\n    while (*(DWORD*)pThunk) &#123;\n        if (pOriginalThunk &amp;&amp; pOriginalThunk-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG) &#123;\n            &#x2F;&#x2F; import by ord\n            WORD ord &#x3D; pOriginalThunk-&gt;u1.Ordinal - pExportDir-&gt;Base;\n            *(DWORD*)pThunk &#x3D; ((DWORD)libraryAddress + funcRvas[ord]);\n        &#125;\n        else &#123;\n            &#x2F;&#x2F; import by name (this is a rva)\n            *(DWORD*)pThunk &#x3D; (DWORD)pGetProcAddress(libraryAddress, ((PIMAGE_IMPORT_BY_NAME)((DWORD)pNewDosHeader + pThunk-&gt;u1.AddressOfData))-&gt;Name);\n        &#125;\n\n        pThunk++;\n        if (pOriginalThunk)\n            pOriginalThunk++;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"6-重定位\"><a href=\"#6-重定位\" class=\"headerlink\" title=\"6. 重定位\"></a>6. 重定位</h3><h4 id=\"目标-2\"><a href=\"#目标-2\" class=\"headerlink\" title=\"目标\"></a>目标</h4><p>完成重定位过程。</p>\n<h4 id=\"重定位表结构\"><a href=\"#重定位表结构\" class=\"headerlink\" title=\"重定位表结构\"></a>重定位表结构</h4><p>重定位表是一个结构体数组，DataDirectory中的重定位表项保存着第一个重定位表的rva，遍历每一个重定位表，并遍历重定位表中的表项，根据其重定位类型，执行重定位操作。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">typedef struct &#123;\n    WORD offset : 12;\n    WORD type : 4;\n&#125; RELOC;\ntypedef struct &#123;\n\tDWORD VA;\n\tDWORD size;\n\t&#x2F;&#x2F; RELOC reloc[];\n&#125; IMAGE_BASE_RELOCATION;</code></pre>\n\n<p>其中每一个重定位表保存着一个rva，重定位实际上就是遍历IMAGE_BASE_RELOCATION的成员reloc，然后执行<code>*(rva+baseAddr+reloc[i].offset) += baseAddr - ImageBase</code>。</p>\n<h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>两层循环，遍历重定位表，再遍历每个表的 RELOC reloc[]。然后根据重定位类型进行重定位。</p>\n<h4 id=\"实现代码-2\"><a href=\"#实现代码-2\" class=\"headerlink\" title=\"实现代码\"></a>实现代码</h4><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; 解析pe，并计算offset\nPIMAGE_DATA_DIRECTORY pDDBaseReloc &#x3D; &amp;pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];\nPIMAGE_BASE_RELOCATION pBaseRelocation;\nULONG_PTR offset &#x3D; (ULONG_PTR)pNewDosHeader - (ULONG_PTR)pNtHeaders-&gt;OptionalHeader.ImageBase;\n\nif (pDDBaseReloc-&gt;Size) &#123;\n    DWORD size &#x3D; pDDBaseReloc-&gt;Size;\n    pBaseRelocation &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pNewDosHeader + pDDBaseReloc-&gt;VirtualAddress);\n\t\n    &#x2F;&#x2F; 遍历重定位表结构体\n    while (size &amp;&amp; pBaseRelocation-&gt;SizeOfBlock) &#123;\n\n        DWORD va &#x3D; (DWORD)pNewDosHeader + pBaseRelocation-&gt;VirtualAddress;\n        DWORD num &#x3D; (pBaseRelocation-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) &#x2F; sizeof(IMAGE_RELOC); &#x2F;&#x2F; 计算reloc[]大小\n        PIMAGE_RELOC reloc &#x3D; (PIMAGE_RELOC)((DWORD)pBaseRelocation + sizeof(IMAGE_BASE_RELOCATION));\n\t\t\n        &#x2F;&#x2F; 遍历reloc[]，根据重定位类型重定位\n        while (num--) &#123;\n            DWORD type &#x3D; reloc-&gt;type;\n            if (type &#x3D;&#x3D; IMAGE_REL_BASED_HIGH) &#123;\n                *(WORD*)(va + reloc-&gt;offset) +&#x3D; HIWORD(offset);\n            &#125;\n            else if (type &#x3D;&#x3D; IMAGE_REL_BASED_LOW) &#123;\n                *(WORD*)(va + reloc-&gt;offset) +&#x3D; LOWORD(offset);\n            &#125;\n            else if (type &#x3D;&#x3D; IMAGE_REL_BASED_HIGHLOW) &#123;\n                *(DWORD*)(va + reloc-&gt;offset) +&#x3D; (DWORD)offset;\n            &#125;\n\n            reloc++;\n        &#125;\n\n        size -&#x3D; pBaseRelocation-&gt;SizeOfBlock;\n        pBaseRelocation &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pBaseRelocation + pBaseRelocation-&gt;SizeOfBlock);\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"7-跳转到ep\"><a href=\"#7-跳转到ep\" class=\"headerlink\" title=\"7. 跳转到ep\"></a>7. 跳转到ep</h3><p>跳转到dll的ep。实际上就是执行dll原本的_DllMainCRTStartup函数。该函数会完成一些初始化工作并转到dllMain，让我们的dllMain像正常dllmain那样运行，但又不在peb中留下dll加载的痕迹。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">typedef BOOL(WINAPI* DLLMAIN)(HINSTANCE, DWORD, LPVOID);\n\nPVOID entryPoint &#x3D; (PVOID)((DWORD)pNewDosHeader + pNewNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);\n\npNtFlushInstructionCache((HANDLE)-1, NULL, 0);\n\n((DLLMAIN)entryPoint)((HMODULE)pNewDosHeader, DLL_PROCESS_ATTACH, lpParameter);</code></pre>\n\n<h3 id=\"8-返回\"><a href=\"#8-返回\" class=\"headerlink\" title=\"8. 返回\"></a>8. 返回</h3><p>最后返回entrypoint。</p>\n<h2 id=\"参考-1\"><a href=\"#参考-1\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>本文看雪链接：<a href=\"https://bbs.pediy.com/thread-266929.htm\">https://bbs.pediy.com/thread-266929.htm</a></p>\n<p>msf反射注入源码：<a href=\"https://github.com/rapid7/ReflectiveDLLInjection\">https://github.com/rapid7/ReflectiveDLLInjection</a></p>\n","text":"从反射注入学习pe文件加载前言？后记与总结这是我写完代码后写的总结。重新梳理一下反射注入到底想干什么、以及怎么干。以及从中学到了什么。 收获？目标？反射注入是什么首先是学习反射注入的收获，当然也可以作为学习的目标，同时也是反射注入实际做的东西。 我的理解是反射注入实际上就是手工加...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Windows","slug":"Windows","count":18,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":18,"path":"api/tags/windows.json"},{"name":"dll","slug":"dll","count":4,"path":"api/tags/dll.json"},{"name":"note","slug":"note","count":21,"path":"api/tags/note.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0pe%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">从反射注入学习pe文件加载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80%EF%BC%9F%E5%90%8E%E8%AE%B0%E4%B8%8E%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">前言？后记与总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%94%B6%E8%8E%B7%EF%BC%9F%E7%9B%AE%E6%A0%87%EF%BC%9F%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">收获？目标？反射注入是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E8%BF%99%E7%AF%87%E4%B8%9C%E8%A5%BF\"><span class=\"toc-text\">关于这篇东西</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BD%AE%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">前置要求</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%85%A5%E5%99%A8\"><span class=\"toc-text\">注入器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">主要流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97fa\"><span class=\"toc-text\">计算fa</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96ReflectivelLoader%E4%BD%8D%E7%BD%AE%EF%BC%88%E8%BE%93%E5%87%BA%E8%A1%A8%EF%BC%89\"><span class=\"toc-text\">获取ReflectivelLoader位置（输出表）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E5%8A%A0%E8%BD%BD%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">反射加载函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%8E%B7%E5%8F%96%E5%9F%BA%E5%9D%80\"><span class=\"toc-text\">1. 获取基址</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%8E%B7%E5%8F%96%E9%9C%80%E8%A6%81%E7%9A%84%E5%86%85%E6%A0%B8%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E7%9A%84va\"><span class=\"toc-text\">2. 获取需要的内核导出函数的va</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">目标</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#LDR-DATA-TABLE-ENTRY\"><span class=\"toc-text\">LDR_DATA_TABLE_ENTRY</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">实现代码</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%BB%99%E6%98%A0%E5%83%8F%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%B9%B6%E5%8A%A0%E8%BD%BDpe%E5%A4%B4\"><span class=\"toc-text\">3. 给映像分配空间，并加载pe头</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%8A%A0%E8%BD%BD%E6%AE%B5\"><span class=\"toc-text\">4. 加载段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%A4%84%E7%90%86%E5%AF%BC%E5%85%A5%E8%A1%A8\"><span class=\"toc-text\">5. 处理导入表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E6%A0%87-1\"><span class=\"toc-text\">目标</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">导入表结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-1\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-1\"><span class=\"toc-text\">实现代码</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E9%87%8D%E5%AE%9A%E4%BD%8D\"><span class=\"toc-text\">6. 重定位</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E6%A0%87-2\"><span class=\"toc-text\">目标</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">重定位表结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-2\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-2\"><span class=\"toc-text\">实现代码</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E8%B7%B3%E8%BD%AC%E5%88%B0ep\"><span class=\"toc-text\">7. 跳转到ep</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">8. 返回</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83-1\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"21虎符CTF-RE-wp","uid":"60af909abdc466137935eaab74c3cdbb","slug":"HufuCtfReWp","date":"2021-04-15T14:04:21.000Z","updated":"2021-09-28T10:21:59.923Z","comments":true,"path":"api/articles/HufuCtfReWp.json","keywords":null,"cover":null,"text":"虎符 2021 REre1mips架构什么的，完全不了解，溜了 gocrypt是个go语言程序 里面有个encodeing_hex_Decode，作用是string转hex（”b0a0” =&gt; [0xa0, 0xb0]）第7个参数是dest第10个参数是source第11个...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"CTF","slug":"CTF","count":7,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":7,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":10,"path":"api/tags/re.json"},{"name":"wp","slug":"wp","count":7,"path":"api/tags/wp.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"hgame21","uid":"bc0ff34ebb27f27dad44c564d61b2fb3","slug":"hgame21","date":"2021-03-17T12:51:25.000Z","updated":"2021-09-28T10:21:44.929Z","comments":true,"path":"api/articles/hgame21.json","keywords":null,"cover":null,"text":"web week1智商检测鸡（150）我用的python requests+beautifulsoup。 这题是通过cookie当作账号，做出一题就会给出下一个cookie。 import requests from bs4 import BeautifulSoup import...","link":"","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"CTF","slug":"CTF","count":7,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":7,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":10,"path":"api/tags/re.json"},{"name":"pwn","slug":"pwn","count":2,"path":"api/tags/pwn.json"},{"name":"misc","slug":"misc","count":2,"path":"api/tags/misc.json"},{"name":"wp","slug":"wp","count":7,"path":"api/tags/wp.json"},{"name":"web","slug":"web","count":1,"path":"api/tags/web.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}