{"title":"21KctfSpring","uid":"546d298359e46b393eada3f4824c48b0","slug":"21KctfSpring","date":"2021-06-02T12:43:07.000Z","updated":"2021-09-28T10:22:05.596Z","comments":true,"path":"api/articles/21KctfSpring.json","keywords":null,"cover":null,"content":"<h1 id=\"21-kctf-春\"><a href=\"#21-kctf-春\" class=\"headerlink\" title=\"21 kctf 春\"></a>21 kctf 春</h1><h2 id=\"2-南冥神功\"><a href=\"#2-南冥神功\" class=\"headerlink\" title=\"2 南冥神功\"></a>2 南冥神功</h2><p>分析main函数</p>\n<h3 id=\"1-char-2-int\"><a href=\"#1-char-2-int\" class=\"headerlink\" title=\"1 char 2 int\"></a>1 char 2 int</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">chars_table &#x3D; &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;\nwhile(v24 !&#x3D; ++v23)\n&#123;\n\tif(chars_table[v23] &#x3D;&#x3D; input_i)\n        goto LABEL_11;\n&#125;</code></pre>\n\n<p>上面代码中input_i是输入的第i个字符，goto执行时，v23 = int(input_i)。</p>\n<h3 id=\"2-找出二维数组\"><a href=\"#2-找出二维数组\" class=\"headerlink\" title=\"2 找出二维数组\"></a>2 找出二维数组</h3><p>有一句 <code>&amp;aS_1[10*row+col]</code>可以判断出是二维数组。<br>该句上面是一个switch，对row和col操作，然后判断越界，然后才到v13 = &amp;aS_1。紧接着又有一个if(*v13) break猜测是走二维数组地图的题。且1为墙，0为空。</p>\n<h3 id=\"3-主要循环\"><a href=\"#3-主要循环\" class=\"headerlink\" title=\"3 主要循环\"></a>3 主要循环</h3><p>switch外面套了个for，然后还有一些向前的goto，构成了主要循环。下面是该循环的部分代码。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">x2 &#x3D; (i + int_inputs[i] &#x2F; 6) % 6;\nx &#x3D; 5 - (i + int_inputs[i]) % 6;\n\nfor (j &#x3D; 0 ;; j &#x3D; 1) &#123; &#x2F;&#x2F; 一共循环两次\n    \n    switch(x) &#123;&#125; &#x2F;&#x2F; 移动\n    \n    &#x2F;&#x2F; 越界撞墙判断\n    if (col &gt; 9) break;\n    if (row &gt; 8) break;\n    v13 &#x3D; &amp;aS_1[10 * row + col];\n    if ( *v13 ) break;\n    *v13 &#x3D; 1; &#x2F;&#x2F; 走过的位置填充\n    \n    if (j &#x3D;&#x3D; 1) &#123;\n        if (input[++i])\n        \tgoto LABEL_4; &#x2F;&#x2F; 去把inputs[i]转换成数字\n        else\n            goto LABEL_19; &#x2F;&#x2F; 到了输入结尾，去判断有没有全部被填充\n    &#125;\n    \n    x &#x3D; x2; &#x2F;&#x2F; x &#x3D; x2 再循环一次\n&#125;</code></pre>\n\n<p>可以看到实际上这个for循环执行了两次，也就是每个inputs[i]对应两次移动。</p>\n<p>其中LABEL_19对应的代码会检测aS_1是否全为1，全为1就输出”Good job!”</p>\n<h3 id=\"4-switch\"><a href=\"#4-switch\" class=\"headerlink\" title=\"4 switch\"></a>4 switch</h3><p>接着分析switch，即移动的方式。这里直接给结论。实际上可以不分析，直接复制这个switch去写暴力解码脚本。</p>\n<p>case 1：col += 1</p>\n<p>case 2：!(row&amp;1) 时col += 1，然后 row += 1</p>\n<p>case 3：row&amp;1 时col -= 1，然后 row += 1</p>\n<p>case 4：col -= 1</p>\n<p>case 5：row&amp;1 时col -= 1，然后 row -= 1</p>\n<p>case 0：!(row&amp;1) 时col += 1，然后 row -= 1</p>\n<h3 id=\"5-接下来就可以爆破了\"><a href=\"#5-接下来就可以爆破了\" class=\"headerlink\" title=\"5 接下来就可以爆破了\"></a>5 接下来就可以爆破了</h3><p>刚刚打完acm不想写爆破了。要不是每一个字符对应两次位移，可以建一个图来跑。</p>\n<h2 id=\"4-英雄救美\"><a href=\"#4-英雄救美\" class=\"headerlink\" title=\"4 英雄救美\"></a>4 英雄救美</h2><p>分析main函数</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">scanf_s(&quot;%s&quot;, pszIn, 81);\nnLen &#x3D; strlen(pszIn);\nif (nLen &lt;&#x3D; 64 &amp;&amp; fun2(nLen, pszIn, v10) &#x3D;&#x3D; 1 &amp;&amp; fun1(v10, nLen - 9) &#x3D;&#x3D; 1)&#123;\n    &#x2F;&#x2F; pass\n&#125;</code></pre>\n\n<p>可以看到有三个判定。fun2有三个参数，但我的ida在main中只识别出两个。通过看汇编把缺的参数补全了。</p>\n<h3 id=\"1-fun2\"><a href=\"#1-fun2\" class=\"headerlink\" title=\"1 fun2\"></a>1 fun2</h3><p>下面给出数据和重构的代码。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">char v60[16] &#x3D; &#123;0x46, 0x53, 0x4c, 0x52, 0x41, 0x3b, 0x2e, 0x6c, 0x3d, 0x43, 0x45, 0x6b, 0x76, 0x4b, 0x2d, 0x28&#125;;\nchar v70[16] &#x3D; &#123;0x6a, 0x69, 0x63, 0x30, 0x21, 0x68, 0x64, 0x79, 0x7b, 0x6f, 0x5a, 0x7a, 0x2d, 0x40, 0x6e, 0x2b&#125;;\nchar v80[16] &#x3D; &#123;0x24, 0x42, 0x50, 0x56, 0x3a, 0x75, 0x62, 0x66, 0x59, 0x70, 0x7d, 0x5d, 0x44, 0x74, 0x4e, 0x3e&#125;;\nchar v90[16] &#x3D; &#123;0x3f, 0x26, 0x25, 0x73, 0x5f, 0x2f, 0x67, 0x3c, 0x65, 0x5b, 0x57, 0x29, 0x58, 0x55, 0x78, 0x52&#125;;\nchar vA0[16] &#x3D; &#123;0x61, 0x54, 0x5e, 0x4d, 0x47, 0x6d, 0x4a, 0x51, 0x23, 0x2a, 0x48, 0x72, 0x60, 0x4f, 0x27, 0x77&#125;\n&#x2F;&#x2F; psTable &#x3D; v80+vA0+v70+v90+v60+0x71\nchar psTable[82] &#x3D; &quot;$BPV:ubfYp&#125;]DtN&gt;aT^MGmJQ#*Hr&#96;O&#39;wjic0!hdy&#123;oZz-@n+?&amp;%s_&#x2F;g&lt;e[W)XUxRFSLRA;.l&#x3D;CEkvK-(q&quot;;</code></pre>\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">i &#x3D; 0;\nj &#x3D; 0;\nv5 &#x3D; 0;\n&#x2F;&#x2F; psTable[81]\nwhile (1) &#123;\n    if(pszIn[i] &gt; &#39;0&#39; &amp;&amp; pszIn[i] &lt;&#x3D; &#39;9&#39;)&#123;\n        if(j + pszIn[i] &#x3D;&#x3D; &#39;9&#39;)&#123;\n            j &#x3D; 0;\n            v5 +&#x3D; 9;\n        &#125;\n        else&#123;\n            return -1;\n        &#125;\n    &#125;\n    else&#123;\n        v7 &#x3D; v5;\n        if(v5 &gt;&#x3D; 81)\n            return 0;\n        \n        &#x2F;&#x2F; v7 &#x3D; pszIn[i]对应psTable[]中相同字符的下标\n        while(pszIn[i] !&#x3D; *(psTable+v7)) &#123;\n            if(++v7 &gt;&#x3D; 81)\n                return 0;\n        &#125;\n        \n        v9 &#x3D; v7 % 9 + 1;\n        if( v9 &#x3D;&#x3D; -1)\n            return 0;\n        *pcV10 &#x3D; v9; &#x2F;&#x2F; 重构输入\n        j++;\n        pcV10++;\n    &#125;\n    \n    if(++i &gt;&#x3D; nLen)\n        return 1;\n&#125;</code></pre>\n\n<p>搞了一大堆，其中一个退出条件是，如果输入全都是9，就能return 1，但显然答案不是这个。</p>\n<p>相反，只要输入中没有1-9，v5就一直为0，这样就会根据输入字符在psTable中的相同字符的下标重构一个pcV10。</p>\n<p>比如 <code>pszIn = &quot;$$V:$V&quot;</code>，<code>pcV10 = &#123;1, 1, 4, 5, 1, 4&#125;</code></p>\n<h3 id=\"2-算flag\"><a href=\"#2-算flag\" class=\"headerlink\" title=\"2 算flag\"></a>2 算flag</h3><p>fun1实际上就是检测是否符合数独情况。</p>\n<p>解出数独答案来，然后推出输出。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">table &#x3D; [0x24, 0x42, 0x50, 0x56, 0x3A, 0x75, 0x62, 0x66, 0x59, 0x70, 0x7D, 0x5D, 0x44, 0x74, 0x4E, 0x3E, 0x61, 0x54, 0x5E, 0x4D, 0x47, 0x6D, 0x4A, 0x51, 0x23, 0x2A, 0x48, 0x72, 0x60, 0x4F, 0x27, 0x77, 0x6A, 0x69, 0x63, 0x30, 0x21, 0x68, 0x64, 0x79, 0x7B, 0x6F, 0x5A, 0x7A, 0x2D, 0x40, 0x6E, 0x2B, 0x3F, 0x26, 0x25, 0x73, 0x5F, 0x2F, 0x67, 0x3C, 0x65, 0x5B, 0x57, 0x29, 0x58, 0x55, 0x78, 0x52, 0x46, 0x53, 0x4C, 0x52, 0x41, 0x3B, 0x2E, 0x6C, 0x3D, 0x43, 0x45, 0x6B, 0x76, 0x4B, 0x2D, 0x28, 0x71]\n\no &#x3D; [[0, 4, 0, 7, 0, 0, 0, 0, 0],\n [9, 2, 0, 0, 0, 0, 6, 0, 7],\n [8, 3, 0, 0, 0, 5, 4, 0, 0],\n [0, 1, 0, 0, 0, 3, 0, 0, 0],\n [0, 0, 0, 2, 0, 1, 0, 0, 0],\n [0, 0, 0, 5, 0, 0, 0, 4, 0],\n [0, 0, 4, 9, 0, 0, 0, 7, 1],\n [3, 0, 5, 0, 0, 0, 0, 9, 4],\n [0, 0, 0, 0, 0, 8, 0, 6, 0]]\n\nr &#x3D; [[5, 4, 6, 7, 1, 9, 2, 3, 8],\n [9, 2, 1, 8, 3, 4, 6, 5, 7],\n [8, 3, 7, 6, 2, 5, 4, 1, 9],\n [7, 1, 8, 4, 6, 3, 9, 2, 5],\n [4, 5, 3, 2, 9, 1, 7, 8, 6],\n [6, 9, 2, 5, 8, 7, 1, 4, 3],\n [2, 8, 4, 9, 5, 6, 3, 7, 1],\n [3, 6, 5, 1, 7, 2, 8, 9, 4],\n [1, 7, 9, 3, 4, 8, 5, 6, 2]]\n\n# 1\nprint(&#39;#1&#39;)\nflag &#x3D; &#39;&#39;\nfor y in range(9):\n    j &#x3D; 0\n    for x in range(9):\n        if o[y][x] &#x3D;&#x3D; 0:\n            j +&#x3D; 1\n            flag +&#x3D; chr(table[r[y][x] - 1 + y * 9])\n    flag +&#x3D; chr(ord(&#39;9&#39;) - j)\nprint(flag)\n\n# 2\nprint(&#39;#2&#39;)\nflag &#x3D; &#39;&#39;\nj &#x3D; 0\nn9 &#x3D; 0\nfor y in range(9):\n    for x in range(9):\n        if o[y][x] &#x3D;&#x3D; 0:\n            j +&#x3D; 1\n            flag +&#x3D; chr(table[r[y][x] - 1 + n9 * 9])\n        if j &gt;&#x3D; 8:\n            flag +&#x3D; &#39;1&#39;\n            j &#x3D; 0\n            n9 +&#x3D; 1\nwhile n9 &lt; 9:\n    flag +&#x3D; chr(ord(&#39;9&#39;) - j)\n    j &#x3D; 0\n    n9 +&#x3D; 1\nprint(flag)</code></pre>\n\n<p>第一个flag是正确的，第二个只能过输入转换fun2和数独检测fun1，而不能弹出窗口。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">:u$YBPf2pa]Dt4#QM^H4ic&#39;j0&#96;w2y&#123;d-Zzo2%&#x2F;n_s@+2&lt;UW)e4AR;F.4&#x3D;-qEkvC2\n:u$YBPf$1a]Dt&gt;N&#125;p1H#*mQHMJ1&#39;wO0icjj1-hzZ!dhz1&amp;%+%@sn_1gXxe[W&lt;299</code></pre>\n\n<p>在VA之前有几个函数，这个函数会检测转换前的原始输入。如果原始输入不符合要求，将不能正确弹窗，（弹窗的代码依赖于正确的输入来生成，但前面的if检查并不严格，错误的原始输入产生了错误的代码）会报错0xc0000096然后崩溃。</p>\n","text":"21 kctf 春2 南冥神功分析main函数 1 char 2 intchars_table &#x3D; &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; while(v24 !&#x3D; ++v23) &#123; if(...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"CTF","slug":"CTF","count":7,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":7,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":10,"path":"api/tags/re.json"},{"name":"wp","slug":"wp","count":7,"path":"api/tags/wp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#21-kctf-%E6%98%A5\"><span class=\"toc-text\">21 kctf 春</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%8D%97%E5%86%A5%E7%A5%9E%E5%8A%9F\"><span class=\"toc-text\">2 南冥神功</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-char-2-int\"><span class=\"toc-text\">1 char 2 int</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%89%BE%E5%87%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">2 找出二维数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%B8%BB%E8%A6%81%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">3 主要循环</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-switch\"><span class=\"toc-text\">4 switch</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%8E%A5%E4%B8%8B%E6%9D%A5%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%88%86%E7%A0%B4%E4%BA%86\"><span class=\"toc-text\">5 接下来就可以爆破了</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E8%8B%B1%E9%9B%84%E6%95%91%E7%BE%8E\"><span class=\"toc-text\">4 英雄救美</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-fun2\"><span class=\"toc-text\">1 fun2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%AE%97flag\"><span class=\"toc-text\">2 算flag</span></a></li></ol></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"APIHook 调试技术 笔记","uid":"647fdfb1f4686f6ba30a2feb4f787ced","slug":"APIHookDebugNotebook","date":"2021-06-17T14:10:00.000Z","updated":"2021-09-28T10:22:08.768Z","comments":true,"path":"api/articles/APIHookDebugNotebook.json","keywords":null,"cover":null,"text":"APIHook-调试技术 笔记摘要 技术摘要： 动态修改进程内存中的代码。利用调试技术附加到目标进程钩取API。 术语： debuger：调试器debugee：被调试者 起源是逆向工程核心原理里面以记事本WriteFile()API钩取为例讲解利用调试来实现API钩取。该例子目标...","link":"","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"Windows","slug":"Windows","count":17,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":17,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":19,"path":"api/tags/note.json"},{"name":"api_hook","slug":"api-hook","count":3,"path":"api/tags/api-hook.json"},{"name":"reversecore","slug":"reversecore","count":4,"path":"api/tags/reversecore.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"games101笔记","uid":"f95e71ca907bcbbc367beb658acddc27","slug":"games101Note","date":"2021-05-24T14:12:26.000Z","updated":"2021-08-11T08:58:54.949Z","comments":true,"path":"api/articles/games101Note.json","keywords":null,"cover":null,"text":"games101-5 games 101 note ","link":"","photos":[],"count_time":{"symbolsCount":26,"symbolsTime":"1 mins."},"categories":[{"name":"ComputerGraphics","slug":"ComputerGraphics","count":1,"path":"api/categories/ComputerGraphics.json"}],"tags":[{"name":"note","slug":"note","count":19,"path":"api/tags/note.json"},{"name":"ComputerGraphics","slug":"ComputerGraphics","count":1,"path":"api/tags/ComputerGraphics.json"},{"name":"持续更新","slug":"持续更新","count":1,"path":"api/tags/持续更新.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}