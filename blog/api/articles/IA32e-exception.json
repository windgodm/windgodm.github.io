{"title":"IA32e硬件与操作系统中断机制","uid":"e13f0f4c0a8cc181704cbc8ca9e68ace","slug":"IA32e-exception","date":"2023-01-19T04:00:00.000Z","updated":"2024-01-17T10:36:17.643Z","comments":true,"path":"api/articles/IA32e-exception.json","keywords":null,"cover":null,"content":"<h1 id=\"IA32e中断\"><a href=\"#IA32e中断\" class=\"headerlink\" title=\"IA32e中断\"></a>IA32e中断</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>前置知识：</p>\n<ul>\n<li>IA32e 全局描述符表（GDT）<ul>\n<li>平坦模式</li>\n<li>描述符的字段</li>\n</ul>\n</li>\n</ul>\n<p>后置知识：</p>\n<ul>\n<li>TSS</li>\n</ul></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这部分内容主要为intel白皮书的笔记，主要关注64位和软件相关的信息，忽略了影子栈和32位下的情况，还有优先级</p>\n<p>sdm-vol3(v77)：</p>\n<ul>\n<li><p>第6章：关于中断和异常处理</p>\n<ul>\n<li><p>6.1：概述</p>\n</li>\n<li><p>6.2：异常和中断向量</p>\n</li>\n<li><p>6.3：中断源</p>\n</li>\n<li><p>6.4：异常源</p>\n</li>\n<li><p>6.5：异常分类</p>\n</li>\n<li><p>6.8：启用和禁用中断</p>\n</li>\n<li><p>6.10：IDT 描述符</p>\n</li>\n<li><p>6.12：处理异常和中断</p>\n</li>\n<li><p>6.14：特定于<code>IA-32e模式</code>和<code>64位子模式</code>的信息</p>\n</li>\n</ul>\n</li>\n</ul></blockquote>\n<h2 id=\"异常和中断概述\"><a href=\"#异常和中断概述\" class=\"headerlink\" title=\"异常和中断概述\"></a>异常和中断概述</h2><p>异常和中断：指示处理器有需要注意的事，通常会强制切换控制流</p>\n<p>来源：随机发生，来自硬件的信号、软件的<code>INT n</code>指令、处理器错误（比如除0）</p>\n<h2 id=\"异常和中断向量\"><a href=\"#异常和中断向量\" class=\"headerlink\" title=\"异常和中断向量\"></a>异常和中断向量</h2><p>向量号（vector number）：</p>\n<ul>\n<li>每个异常（exception）和中断条件（interrupt condition）分配一个唯一的数</li>\n<li>作为中断描述符表（IDT）的索引</li>\n<li>范围0~255<ul>\n<li>0~31：IA-32架构保留</li>\n<li>32~255：用户定义</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"异常和中断源\"><a href=\"#异常和中断源\" class=\"headerlink\" title=\"异常和中断源\"></a>异常和中断源</h2><p>中断源：</p>\n<ul>\n<li>外部（硬件）中断</li>\n<li>软件生成的中断<ul>\n<li><code>INT n</code>指令强制隐式调用中断号为n的中断处理程序</li>\n<li>0~255都可以作为指令参数</li>\n<li>不会使用EFLAGS的IF标记</li>\n</ul>\n</li>\n</ul>\n<p>异常源：</p>\n<ul>\n<li>处理器检测 到 程序错误 异常</li>\n<li>软件生成的异常<ul>\n<li>通过<code>INT n</code>指令产生的异常不会把错误代码入栈；而异常处理程序会尝试弹出错误代码，可能会导致错误的返回位置</li>\n</ul>\n</li>\n<li>机器检测异常</li>\n</ul>\n<h2 id=\"异常分类\"><a href=\"#异常分类\" class=\"headerlink\" title=\"异常分类\"></a>异常分类</h2><p>按照产生的原因和处理的方式分类：</p>\n<ul>\n<li>faults：可以被改正的异常，改正后将返回到产生异常的指令（然后再次执行）</li>\n<li>traps：返回到下一条指令</li>\n<li>aborts：不允许产生异常的程序或任务继续运行</li>\n</ul>\n<h2 id=\"保护模式保留的异常和中断\"><a href=\"#保护模式保留的异常和中断\" class=\"headerlink\" title=\"保护模式保留的异常和中断\"></a>保护模式保留的异常和中断</h2><p>![vol-3a-t-6-1 Protected-Mode Exceptions and Interrupts](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-t-6-1 Protected-Mode Exceptions and Interrupts.jpg)</p>\n<p>![vol-3a-t-6-1 Protected-Mode Exceptions and Interrupts (Contd.)](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-t-6-1 Protected-Mode Exceptions and Interrupts (Contd.).jpg)</p>\n<h2 id=\"启用和禁用中断\"><a href=\"#启用和禁用中断\" class=\"headerlink\" title=\"启用和禁用中断\"></a>启用和禁用中断</h2><p>根据处理器的状态以及EFLAGS中的IF和RF，处理器抑制某些中断的产生</p>\n<ul>\n<li>RF：设置时，调试异常（#DB）将无法生成（更多信息：17.3.1.1）</li>\n</ul>\n<p>切换ss通常需要两条指令：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">MOV SS, AX\nMOV ESP, StackTop</code></pre>\n\n<p>为了保护切换时的原子性，在MOV或POP修改SS时：</p>\n<ul>\n<li>下一条指令禁用指令断点（类似EFLAGS.RF=1）</li>\n<li>数据断点将被抑制直到两条指令完成</li>\n<li>在两条指令完成后交付单步陷阱</li>\n<li>连续的加载SS只有第一条加载指令遵循以上规则</li>\n</ul>\n<h2 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h2><p>如果出现多个中断，将按优先级处理</p>\n<h2 id=\"中断描述符表（IDT）\"><a href=\"#中断描述符表（IDT）\" class=\"headerlink\" title=\"中断描述符表（IDT）\"></a>中断描述符表（IDT）</h2><p>IDTR寄存器保存着IDT的基址，8字节对齐</p>\n<p>IDT存有有三种类型的门描述符（gate descriptor）：</p>\n<ul>\n<li>任务门描述符</li>\n<li>中断门描述符</li>\n<li>陷阱门描述符</li>\n</ul>\n<p>IA32 三种门描述符的格式</p>\n<p>![vol-3a-f-6-2 IDT Gate Descriptors](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-6-2 IDT Gate Descriptors.jpg)</p>\n<p>IA32e IDT表项由8字节拓展为16字节，以支持64位的地址偏移</p>\n<p>![vol-3a-f-6-8 64-Bit IDT Gate Descriptors](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-6-8 64-Bit IDT Gate Descriptors.png)</p>\n<p>TYPE字段同IA32</p>\n<p>IST（Interrupt Stack Table）字段用于栈切换基址</p>\n<h2 id=\"异常与中断流程\"><a href=\"#异常与中断流程\" class=\"headerlink\" title=\"异常与中断流程\"></a>异常与中断流程</h2><h3 id=\"找到处理函数\"><a href=\"#找到处理函数\" class=\"headerlink\" title=\"找到处理函数\"></a>找到处理函数</h3><p>根据中断向量，找到处理函数：</p>\n<p>![vol-3a-f-6-3 Interrupt Procedure Call](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-6-3 Interrupt Procedure Call.jpg)</p>\n<h3 id=\"IA32切换到处理函数\"><a href=\"#IA32切换到处理函数\" class=\"headerlink\" title=\"IA32切换到处理函数\"></a>IA32切换到处理函数</h3><p>IA32下，根据中断前特权级别和中断（描述符上）的特权级别，有两种情况：</p>\n<ul>\n<li>级别不变，在中断时的栈上，将相关寄存器入栈</li>\n<li>级别改变，切换到处理函数的栈，再将相关寄存器入栈</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>级别改变时会先额外入栈SS、ESP</li>\n<li>只有异常才会入栈Error Code（通过<code>int n</code>指令产生的不入栈）</li>\n</ul>\n<p>![vol-3a-f-6-4  Stack Usage on Transfers to Interrupt and Exception-Handling Routines](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-6-4  Stack Usage on Transfers to Interrupt and Exception-Handling Routines.jpg)</p>\n<h3 id=\"IA32e切换到处理函数的不同\"><a href=\"#IA32e切换到处理函数的不同\" class=\"headerlink\" title=\"IA32e切换到处理函数的不同\"></a>IA32e切换到处理函数的不同</h3><p>栈元素由4字节变为8字节，入栈内容一样</p>\n<p>新SS强制为0，从TSS中获取新RSP</p>\n<h3 id=\"IA32e-中断栈表（IST）\"><a href=\"#IA32e-中断栈表（IST）\" class=\"headerlink\" title=\"IA32e 中断栈表（IST）\"></a>IA32e 中断栈表（IST）</h3><p>IA32e中可以使用IST机制替代前面的栈切换机制</p>\n<p>中断描述符（IDT）的IST字段用于在TSS中索引（4位，范围0~7）</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当IST为0时，新栈指针为TSS的RSP0，否则为对应的ISTn</p></blockquote>\n<p>当使用影子栈时，处理器提供一个MSR<code>IA32_INTERRUPT_SSP_TABLE</code></p>\n<p>![vol-3a-f-6-10 Interrupt Shadow Stack Table](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-6-10 Interrupt Shadow Stack Table.jpg)</p>\n<h3 id=\"返回到中断或异常前代码\"><a href=\"#返回到中断或异常前代码\" class=\"headerlink\" title=\"返回到中断或异常前代码\"></a>返回到中断或异常前代码</h3><p>使用<code>iret</code>或<code>iretd</code>指令：将弹出切换时入栈的参数恢复对应寄存器，然后返回</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>官方文档<ul>\n<li>sdm-vol3(v77)</li>\n</ul>\n</li>\n<li>IA32中断异常的解说<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/57271206\">IA-32的中断和异常处理 - 知乎 (zhihu.com)</a></li>\n</ul>\n</li>\n<li>IA32e中断异常解说；在windows上使用windbg跟踪从32/64通过syscall进内核过程<ul>\n<li><a href=\"https://blog.csdn.net/qq_41988448/article/details/123111860\">Windows x64内核学习笔记（二）—— IA-32e模式_lzyddf的博客-CSDN博客</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"IA32e系统调用硬件支持\"><a href=\"#IA32e系统调用硬件支持\" class=\"headerlink\" title=\"IA32e系统调用硬件支持\"></a>IA32e系统调用硬件支持</h1><h2 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>主要关注IA32e的系统调用，忽略兼容模式</p>\n<p>sdm-vol3(v77)：</p>\n<ul>\n<li>2.2.1：IA32e 拓展特性启用寄存器</li>\n<li>5.8.7：快速调用系统过程 与 SYSENTER SYSEXIT</li>\n<li>5.8.8：64位模式的快速系统调用</li>\n</ul></blockquote>\n<p>IA32e为系统调用机制提供了一些支持，以便以受控制的方式从R3切换到R0</p>\n<h2 id=\"SYSENTER-SYSEXIT\"><a href=\"#SYSENTER-SYSEXIT\" class=\"headerlink\" title=\"SYSENTER SYSEXIT\"></a>SYSENTER SYSEXIT</h2><p>该对指令目的是为了提供一个机制，允许快速调用操作系统或执行过程</p>\n<p>SYSENTER可以在任意权限级别下进入R0</p>\n<p>SYSEXIT用于在R0下返回</p>\n<p>两条执行跳转时将从MSR寄存器和通用寄存器中获取所需的信息，以减少对内存的访问</p>\n<p>所有信息需要由调用过程显式保存</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Nehalem微架构：</p>\n<ul>\n<li>IA32_SYSENTER_CS 174H</li>\n<li>IA32_SYSENTER_ESP 175H</li>\n<li>IA32_SYSENTER_EIP 176H</li>\n</ul></blockquote>\n<p>IA32：</p>\n<ul>\n<li><p>SYSENTER</p>\n<ul>\n<li><p>目标代码段：<code>msr[IA32_SYSENTER_CS]</code></p>\n</li>\n<li><p>目标指令：<code>msr[IA32_SYSENTER_EIP]</code></p>\n</li>\n<li><p>栈段：<code>msr[IA32_SYSENTER_CS] + 8</code></p>\n</li>\n<li><p>栈指针：<code>msr[IA32_SYSENTER_ESP]</code></p>\n</li>\n</ul>\n</li>\n<li><p>SYSEXIT</p>\n<ul>\n<li><p>目标代码段：<code>msr[IA32_SYSENTER_CS] + 16</code></p>\n</li>\n<li><p>目标指令：<code>EDX</code></p>\n</li>\n<li><p>栈段：<code>msr[IA32_SYSENTER_CS] + 24</code></p>\n</li>\n<li><p>栈指针：<code>ECX</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>IA32e（msr寄存器拓展到64位，使用时也是读64位）：</p>\n<ul>\n<li>SYSENTER<ul>\n<li>目标代码段：<code>msr[IA32_SYSENTER_CS]</code>（非NULL选择子）</li>\n<li>新CS属性：<code>base=0</code>, <code>limit=FFFFFFFFH</code></li>\n<li>目标指令：<code>msr[IA32_SYSENTER_EIP]</code></li>\n<li>栈段：<code>msr[IA32_SYSENTER_CS] + 8</code></li>\n<li>新SS属性：<code>base=0</code>, <code>limit=FFFFFFFFH</code></li>\n<li>栈指针：<code>msr[IA32_SYSENTER_ESP]</code></li>\n</ul>\n</li>\n<li>SYSEXIT<ul>\n<li>目标代码段：<code>msr[IA32_SYSENTER_CS] + 32</code></li>\n<li>新CS属性：<code>L-bit=1</code>（强制到64位模式）</li>\n<li>目标指令：<code>RDX</code></li>\n<li>栈段：<code>msr[IA32_SYSENTER_CS] + 40</code></li>\n<li>栈指针：<code>RCX</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"快速系统调用\"><a href=\"#快速系统调用\" class=\"headerlink\" title=\"快速系统调用\"></a>快速系统调用</h2><p>MSR[<strong>IA32_EFER</strong>]（0xC0000080）的第0位指示是否支持<code>SYSCALL</code>和<code>SYSRET</code>指令</p>\n<p><code>SYSCALL</code>、<code>SYSRET</code>是为平坦模式设计的，连同<code>SYSENTER</code>、<code>SYSEXIT</code>适用于IA-32e模式，但前面一对在兼容模式（或保护模式）下不支持</p>\n<p>CPUID.80000001H.EDX[bit 11]指示是否支持<code>SYSCALL</code>、<code>SYSRET</code></p>\n<p>SYSCALL用于在R3下进入R0</p>\n<p>SYSRET用于在R0下返回到R3</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Nehalem微架构：</p>\n<ul>\n<li>IA32_EFER C0000080H</li>\n<li>IA32_STAR C0000081H</li>\n<li>IA32_LSTAR C0000082H</li>\n<li>IA32_FMASK C0000084H</li>\n</ul></blockquote>\n<p>SYSCALL和SYSRET会保存和恢复RFLAGS寄存器</p>\n<p>然后类似前面，也是使用MSR寄存器和通用寄存器</p>\n<ul>\n<li>SYSCALL<ul>\n<li>由处理器将RFLAGS存入R11；下一条指令的RIP存入RCX（返回地址）</li>\n<li>目标代码段：<code>msr[IA32_STAR][47:32]</code>（非NULL选择子）</li>\n<li>目标指令：<code>msr[IA32_LSTAR]</code></li>\n<li>栈段：<code>msr[IA32_STAR][47:32] + 8</code></li>\n<li>RFLAGS：<code>RFLAGS &amp; msr[IA32_FMASK]</code></li>\n</ul>\n</li>\n<li>SYSRET<ul>\n<li>目标代码段：<code>msr[IA32_STAR][63:48] + 16</code>（非NULL选择子）</li>\n<li>目标指令：<code>RCX</code></li>\n<li>栈段：<code>msr[IA32_STAR][63:48] + 8</code></li>\n<li>RFLAGS：<code>R11</code></li>\n</ul>\n</li>\n</ul>\n<p>操作系统应该保证这两条指令跳转时所切换的GDT/LDT表项内容的正确性</p>\n<p>栈指针也不会被保存和恢复，栈的切换交由操作系统实现</p>\n<p>上述所用MSR寄存器的布局</p>\n<p>![vol-3a-f-5-14 MSRs Used by SYSCALL and SYSRET](E:\\documents\\note\\md\\windows\\sdm-figure\\vol-3a-f-5-14 MSRs Used by SYSCALL and SYSRET.jpg)</p>\n<h2 id=\"参考-1\"><a href=\"#参考-1\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>官方文档<ul>\n<li>sdm-vol3(v77)</li>\n<li>sdm-vol4(v78)</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"windows系统调用概述\"><a href=\"#windows系统调用概述\" class=\"headerlink\" title=\"windows系统调用概述\"></a>windows系统调用概述</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>（指IA32架构下的windows系统）</p>\n<p>系统调用的大致机制为：</p>\n<p>通过硬件支持的中断或陷阱指令，进入到内核中的系统调用分发函数，然后再执行对应的系统调用处理函数</p>\n<p>windows有两个服务表（SDT），存储了系统调用的信息，第二个表用于GUI程序：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct _KSERVICE_TABLE_DESCRIPTOR\n&#123;\n    PULONG Base;   &#x2F;&#x2F; address or offsets&#39; array\n    PULONG Count;\n    ULONG Limit;   &#x2F;&#x2F; number of array\n    PUCHAR Number;\n    &#x2F;&#x2F; ...\n&#125; KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;\n\nKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;       &#x2F;&#x2F; SDT\nKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow; &#x2F;&#x2F; SDTS (+gui)</code></pre>\n\n<p>两个SDT的Base字段指向一个数组，存储了各个系统调用处理函数的地址，该数组又被称为SSDT</p>\n<p>内核还维护着两个全局指针指向两个地址/偏移量数组（SSDT）：</p>\n<p><code>KiServiceTable</code>，<code>W32pServiceTable</code></p>\n<p>获取某个系统调用函数地址的方式：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; x86\naddr[i] &#x3D; (DWORD*)KiServiceTable[i];\n\n&#x2F;&#x2F; x64\naddr[i] &#x3D; KiServiceTable + (DWORD*)KiServiceTable[i] &gt;&gt; 4;</code></pre>\n\n\n\n<h2 id=\"进入内核的方式\"><a href=\"#进入内核的方式\" class=\"headerlink\" title=\"进入内核的方式\"></a>进入内核的方式</h2><p><strong>思路</strong></p>\n<p>通过中断（int 2e）或者陷阱指令（sysenter、syscall），进入内核</p>\n<p>通过指定进入内核的位置为系统调用分发函数，实现系统调用</p>\n<p><strong>中断2E 实现（过时）</strong></p>\n<p>通过中断<strong>INT 0x2E</strong>实现系统调用</p>\n<p>IDT中0x2E表项对应<strong>KiSystemService</strong>，实现了系统调用的分发</p>\n<p><strong>sysenter 实现（过时）</strong></p>\n<p>通过IA32的快速调用指令<strong>SYSENTER/SYSEXIT</strong>实现（对硬件而言，32、64位都支持该指令）</p>\n<p><code>msr[IA32_SYSENTER_CS]</code>（174H）为通过SYSENTER指令进入内核的位置</p>\n<p>由windows系统初始化为<strong>KiFastCallEntry</strong></p>\n<p><strong>syscall 实现（现用）</strong></p>\n<p>通过IA32e的快速系统调用指令<strong>SYSCALL/SYSRET</strong>实现（对硬件而言只在<strong>64位</strong>下支持）</p>\n<p><code>msr[IA32_LSTAR]</code>（C000_0082H）为通过SYSCALL指令进入内核的位置</p>\n<p>由windows系统初始化为<strong>KiSystemCall64</strong></p>\n<h2 id=\"win10进入内核\"><a href=\"#win10进入内核\" class=\"headerlink\" title=\"win10进入内核\"></a>win10进入内核</h2><p>win10版本号：21H2</p>\n<p>处理器：AMD</p>\n<p>简单跟踪程序对CreateFile系统调用的执行过程</p>\n<h3 id=\"x64程序R3部分\"><a href=\"#x64程序R3部分\" class=\"headerlink\" title=\"x64程序R3部分\"></a>x64程序R3部分</h3><p>进入的过程：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">; test64.exe main\ncall qword ptr ds:[&lt;&amp;CreateFileW&gt;]\n\n; kernel32.dll, CreateFileW, STUB\njmp qword ptr ds:[&lt;&amp;CreateFileW&gt;]\n\n; kernelbase.dll, CreateFileW, 简单处理参数\n...\ncall CreateFileInternal\n; kernelbase.dll, CreateFileInternal, 处理参数\n...\ncall qword ptr ds:[&lt;&amp;NtCreateFile&gt;]\n\n; ntdll.dll, NtCreateFile\n...</code></pre>\n\n<p>ntdll.dll NtCreateFile的代码，其他系统调用的代码也是一样的格式：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">mov r10, rcx ; 保存rcx，syscall会把下一条指令（返回）地址存在rcx\nmov eax, 55  ; 调用号\ntest byte ptr ds:[7FFE0308h], 1 ; 检查是否支持syscall\njne l_int\nsyscall ; 通过syscall进入内核\nret\nl_int:\nint 2E ; 通过中断进入内核\nret</code></pre>\n\n\n\n<h3 id=\"x64程序-系统调用-R0入口\"><a href=\"#x64程序-系统调用-R0入口\" class=\"headerlink\" title=\"x64程序 系统调用 R0入口\"></a>x64程序 系统调用 R0入口</h3><p>sysenter在64位内核中已被弃用</p>\n<p><strong>syscall</strong>的系统调用分发函数 = <code>msr[IA32_LSTAR]</code>，windbg读出是<strong>KiSystemCall64</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1: kd&gt; rdmsr C0000082\nmsr[c0000082] &#x3D; fffff804&#96;33a0c2c0\n1: kd&gt; u fffff804&#96;33a0c2c0 l1\nnt!KiSystemCall64:\nfffff804&#96;33a0c2c0 0f01f8          swapgs</code></pre>\n\n\n\n<p>简单贴一下<code>KiSystemCall64</code>开头的汇编：</p>\n<p>（21H2的 KPCR 大小为 178H，KPRCB 似乎因为对齐从 gs:180H开始）</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">swapgs                   ; 切换gs\nmov     gs:10h, rsp      ; [gs+10h] _KPCR.UserRsp\nmov     rsp, gs:1A8h     ; [gs+180h+28h] _KPRCB.RspBase\npush    2Bh\npush    qword ptr gs:10h\npush    r11              ; syscall 之前的 rflags\npush    33h\npush    rcx              ; syscall 下一条指令的地址（返回到R3的地址）\nmov     rcx, r10         ; 恢复rcx寄存器</code></pre>\n\n\n\n<p><strong>int 2E</strong>的系统调用分发函数，windbg读出是<strong>KiIsrThunk+0x170</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1: kd&gt; dq idtr+10*2E l2\nffff8780&#96;16f4d2e0  339f8e00&#96;0010d770 00000000&#96;fffff804\n1: kd&gt; u fffff804339fd770 l3\nnt!KiIsrThunk+0x170:\nfffff804&#96;339fd770 6a2e            push    2Eh\nfffff804&#96;339fd772 55              push    rbp\nfffff804&#96;339fd773 e999060000      jmp     nt!KiIsrLinkage (fffff804&#96;339fde11)</code></pre>\n\n\n\n<h3 id=\"x32程序R3部分\"><a href=\"#x32程序R3部分\" class=\"headerlink\" title=\"x32程序R3部分\"></a>x32程序R3部分</h3><p>切换到x64之前的部分：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">; test32.exe main\ncall qword ptr ds:[&lt;&amp;CreateFileW&gt;]\n\n; kernel32.dll, CreateFileW, STUB\njmp qword ptr ds:[&lt;&amp;CreateFileW&gt;]\n\n; kernelbase.dll, CreateFileW, 简单处理参数\n...\ncall CreateFileInternal\n; kernelbase.dll, CreateFileInternal, 处理参数\n...\ncall qword ptr ds:[&lt;&amp;NtCreateFile&gt;]\n\n; ntdll.dll, NtCreateFile\n...\ncall edx ; Wow64SystemServiceCall\n\n; ntdll.dll, Wow64SystemServiceCall\njmp dword ptr ds:[&lt;Wow64Transition&gt;]</code></pre>\n\n<p>ntdll.dll NtCreateFile的代码：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">mov     eax, 55h ; NtCreateFile\nmov     edx, offset _Wow64SystemServiceCall@0 ; Wow64SystemServiceCall()\ncall    edx ; Wow64SystemServiceCall() ; Wow64SystemServiceCall()\nretn    2Ch</code></pre>\n\n<p>这个<code>Wow64SystemServiceCall</code>在CE中识别为<code>KiFastSystemCall</code>，作用是切换到64位：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">; x32 asm\n774F7000 | EA 09704F77 3300         | jmp far 33:774F7009\n; x64 asm\n774F7009 | 41 FF A7 F8000000        | jmp qword [r15 + 0xf8]</code></pre>\n\n\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>windows的系统调用机制大概为：</p>\n<p>x64一般使用syscall指令陷入内核中的系统调用分发函数</p>\n<p>x32先变成64位，再陷入</p>\n<h2 id=\"中断请求级概述\"><a href=\"#中断请求级概述\" class=\"headerlink\" title=\"中断请求级概述\"></a>中断请求级概述</h2><p>windows使用IRQL（Interrupt ReQuest Level，中断请求级）管理中断优先级，这是一个IA32硬件支持的功能</p>\n<p>windows为各优先级别赋予了意义：</p>\n<ul>\n<li>PASSIVE LEVEL（0）：最低级别，全部用户模式代码和大多数内核代码</li>\n<li>APC LEVEL（1）：异步过程调用（APC）的级别</li>\n<li>DISPATCH LEVEL（2）：最高级别的软件IRQL，线程分发器、延迟过程调用（DPC）的级别</li>\n</ul>\n<h2 id=\"参考-2\"><a href=\"#参考-2\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>《逆向工程实战》（《Practical Reverse Engineering》）</li>\n<li><a href=\"https://blog.csdn.net/qq_41988448/article/details/123111860\">Windows x64内核学习笔记（二）—— IA-32e模式_lzyddf的博客-CSDN博客</a></li>\n</ul>\n<h1 id=\"linux系统调用概述\"><a href=\"#linux系统调用概述\" class=\"headerlink\" title=\"linux系统调用概述\"></a>linux系统调用概述</h1><p>（指IA32架构下的linux系统）</p>\n<h2 id=\"给ubuntu2004添加系统调用\"><a href=\"#给ubuntu2004添加系统调用\" class=\"headerlink\" title=\"给ubuntu2004添加系统调用\"></a>给ubuntu2004添加系统调用</h2><p>虚拟机版本：VM 16.1.0</p>\n<p>系统版本：ubuntu-20.04.1，VM便捷安装</p>\n<p>查看内核版本（<code>uname -a</code>）：5.15.0-58</p>\n<h3 id=\"修改内核\"><a href=\"#修改内核\" class=\"headerlink\" title=\"修改内核\"></a>修改内核</h3><p>下载内核源码（<a href=\"https://www.kernel.org/%EF%BC%89%EF%BC%8C%E9%80%89%E6%8B%A9\">https://www.kernel.org/），选择</a> 5.15.90 版本（longterm）</p>\n<p>解压到 <code>/usr/src</code></p>\n<p>添加系统调用号</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sudo gedit arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscall_64.tbl</code></pre>\n\n<p>第一部分的系统调用号为1~448，第二部分为512以后，在448和512之间都可以添加新系统调用</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">449\t64\thw\t\t\tsys_hw</code></pre>\n\n\n\n<p>添加系统调用函数声明</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sudo gedit include&#x2F;linux&#x2F;syscalls.h </code></pre>\n\n<p>在最后一个系统调用函数声明后添加</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">asmlinkage long sys_hw(int arg);</code></pre>\n\n\n\n<p>添加系统调用函数定义</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sudo gedit kernel&#x2F;sys.c</code></pre>\n\n<p>在最后添加</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">asmlinkage long sys_hw(int arg)\n&#123;\n\tprintk(&quot;hello world, arg&#x3D;%d\\n&quot;, arg);\n\treturn 0;\n&#125;</code></pre>\n\n\n\n<h3 id=\"编译内核\"><a href=\"#编译内核\" class=\"headerlink\" title=\"编译内核\"></a>编译内核</h3><p><strong>安装编译所需工具</strong></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sudo apt-get install make\nsudo apt-get install build-essential openssl\nsudo apt-get install libncurses5-dev libssl-dev\nsudo apt-get install zlibc minizip\nsudo apt-get install libidn11-dev libidn11\nsudo apt-get install bison flex\nsudo apt-get install libelf-dev\nsudo apt-get install dwarves\nsudo apt-get install zstd</code></pre>\n\n<p>安装上面的几个似乎会附带安装下面这几个</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sudo apt-get install pkg-config\nsudo apt-get install libc6-dev</code></pre>\n\n\n\n<p>删除编译生成文件、内核配置文件</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sudo make mrproper\nsudo make clean</code></pre>\n\n\n\n<p><strong>配置</strong></p>\n<p>使用旧配置，在<code>/boot</code>中</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cp &#x2F;boot&#x2F;config-5.15.0-58-generic .&#x2F;.config</code></pre>\n\n<p>修改<code>.config</code>：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">CONFIG_SYSTEM_TRUSTED_KEYS&#x3D;&quot;&quot;\nCONFIG_SYSTEM_REVOCATION_KEYS&#x3D;&quot;&quot;\nCONFIG_DEBUG_INFO_BTF&#x3D;n</code></pre>\n\n\n\n<p><strong>编译</strong></p>\n<p>编译内核，大概7~8分钟</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sudo make bzImage -j8</code></pre>\n\n<p>编译模块，</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sudo make modules -j8</code></pre>\n\n\n\n<p><strong>启动文件</strong></p>\n<p>备份</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sudo cp &#x2F;etc&#x2F;default&#x2F;grub &#x2F;etc&#x2F;default&#x2F;grub.bak</code></pre>\n\n\n\n<p><strong>安装</strong></p>\n<p>安装模块</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sudo make INSTALL_MOD_STRIPE&#x3D;1 modules_install</code></pre>\n\n<p>安装内核 重启</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sudo make install\nsudo reboot</code></pre>\n\n\n\n<h2 id=\"参考-3\"><a href=\"#参考-3\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://blog.csdn.net/hhb442/article/details/106513084\">Ubuntu上增加系统调用（需要编译内核）Peanutty的博客-CSDN博客</a></li>\n<li><a href=\"https://blog.csdn.net/qq_45289233/article/details/106621835\">Ubuntu20.04下添加自定义系统调用 编程菜玑的博客-CSDN博客</a></li>\n<li><a href=\"https://www.jianshu.com/p/7547a58e68d3\">在Ubuntu下添加系统调用 - 简书 (jianshu.com)</a></li>\n<li><a href=\"https://blog.csdn.net/qq_36393978/article/details/118157426\">内核错误: No rule to make target ‘debian/canonical-certs.pem‘, needed by ‘certs/x509_certificate_list‘ Imagine Miracle的博客-CSDN博客</a></li>\n<li><a href=\"https://www.jianshu.com/p/061ec6c81ecf\">在Ubuntu 18.04 下编译Linux内核 - 简书 (jianshu.com)</a></li>\n<li><a href=\"https://blog.csdn.net/qq_40311939/article/details/127757299\">Ubuntu虚拟机扩展磁盘空间 Vis-Lin的博客-CSDN博客</a></li>\n</ul>\n","feature":true,"text":"IA32e中断前言 前置知识： IA32e 全局描述符表（GDT） 平坦模式 描述符的字段 后置知识： TSS 这部分内容主要为intel白皮书的笔记，主要关注64位和软件相关的信息，忽略了影子栈和32位下的情况，还有优先级 sdm-vol3(v77)： 第6章：关于中断和异常处...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Windows","slug":"Windows","count":21,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":21,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":7,"path":"api/tags/kernel.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#IA32e%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">IA32e中断</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">异常和中断概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F\"><span class=\"toc-text\">异常和中断向量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E6%BA%90\"><span class=\"toc-text\">异常和中断源</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">异常分类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">保护模式保留的异常和中断</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">启用和禁用中断</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">优先级</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88IDT%EF%BC%89\"><span class=\"toc-text\">中断描述符表（IDT）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">异常与中断流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">找到处理函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IA32%E5%88%87%E6%8D%A2%E5%88%B0%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">IA32切换到处理函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IA32e%E5%88%87%E6%8D%A2%E5%88%B0%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C\"><span class=\"toc-text\">IA32e切换到处理函数的不同</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IA32e-%E4%B8%AD%E6%96%AD%E6%A0%88%E8%A1%A8%EF%BC%88IST%EF%BC%89\"><span class=\"toc-text\">IA32e 中断栈表（IST）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%88%B0%E4%B8%AD%E6%96%AD%E6%88%96%E5%BC%82%E5%B8%B8%E5%89%8D%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">返回到中断或异常前代码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#IA32e%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">IA32e系统调用硬件支持</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80-1\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SYSENTER-SYSEXIT\"><span class=\"toc-text\">SYSENTER SYSEXIT</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">快速系统调用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83-1\"><span class=\"toc-text\">参考</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#windows%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">windows系统调用概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">进入内核的方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#win10%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8\"><span class=\"toc-text\">win10进入内核</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#x64%E7%A8%8B%E5%BA%8FR3%E9%83%A8%E5%88%86\"><span class=\"toc-text\">x64程序R3部分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#x64%E7%A8%8B%E5%BA%8F-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-R0%E5%85%A5%E5%8F%A3\"><span class=\"toc-text\">x64程序 系统调用 R0入口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#x32%E7%A8%8B%E5%BA%8FR3%E9%83%A8%E5%88%86\"><span class=\"toc-text\">x32程序R3部分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E7%BA%A7%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">中断请求级概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83-2\"><span class=\"toc-text\">参考</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">linux系统调用概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%99ubuntu2004%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">给ubuntu2004添加系统调用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E5%86%85%E6%A0%B8\"><span class=\"toc-text\">修改内核</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8\"><span class=\"toc-text\">编译内核</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83-3\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"VMP还原思路","uid":"a0e830c45ad93252cf7ca59a00282739","slug":"VMP-deobf","date":"2023-01-11T04:00:00.000Z","updated":"2024-01-17T10:29:52.502Z","comments":true,"path":"api/articles/VMP-deobf.json","keywords":null,"cover":[],"text":"1 摘要1.1 关于代码优化与还原关于还原，我认为难点是工作量大，需要自动化提升效率 还原和混淆是一对反义词，相同点是保证代码功能相近，不同是一个是使代码更易读，后者则相反 而代码优化非常类似，也要保证代码功能相近，不同是减少代码的体积或运行速度 所以我感觉还原和代码优化有很多共...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"Re","slug":"Re","count":4,"path":"api/categories/Re.json"}],"tags":[{"name":"re","slug":"re","count":12,"path":"api/tags/re.json"},{"name":"vmp","slug":"vmp","count":1,"path":"api/tags/vmp.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}