{"title":"21虎符CTF-RE-wp","uid":"60af909abdc466137935eaab74c3cdbb","slug":"HufuCtfReWp","date":"2021-04-15T14:04:21.000Z","updated":"2021-09-28T10:21:59.923Z","comments":true,"path":"api/articles/HufuCtfReWp.json","keywords":null,"cover":null,"content":"<h1 id=\"虎符-2021-RE\"><a href=\"#虎符-2021-RE\" class=\"headerlink\" title=\"虎符 2021 RE\"></a>虎符 2021 RE</h1><h2 id=\"re1\"><a href=\"#re1\" class=\"headerlink\" title=\"re1\"></a>re1</h2><p>mips架构什么的，完全不了解，溜了</p>\n<h2 id=\"gocrypt\"><a href=\"#gocrypt\" class=\"headerlink\" title=\"gocrypt\"></a>gocrypt</h2><p>是个go语言程序</p>\n<p>里面有个encodeing_hex_Decode，作用是string转hex（”b0a0” =&gt; [0xa0, 0xb0]）<br>第7个参数是dest<br>第10个参数是source<br>第11个参数是source的长度</p>\n<p>有个runtime_check会检查格式，推出格式是flag{hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh}</p>\n<p>main_myCipher_Encrypt中有(a+(a&gt;&gt;5)&amp;(16*a))猜出加密方式是xtea</p>\n<p>解密脚本就不贴了，实际上异或的另一边是密钥，利用异或的可逆很快就能推出解密脚本</p>\n<p>在打极客时就有个想法，这种简单的re题核心都是推导加密函数的逆函数，不知道能不能写个逻辑分析程序一把梭。</p>\n<h2 id=\"CrackMe\"><a href=\"#CrackMe\" class=\"headerlink\" title=\"CrackMe\"></a>CrackMe</h2><p>运行什么提示都没，但还是搜字符串试试，rva=2A90，2AB0的两个函数似乎有点重要。</p>\n<p>main里面有两次输入，判定两次。sub_1360这个函数ida似乎识别出了问题，不知道是不是bug。</p>\n<p>第一次输入后有两个循环，会把17个输入分成前7个和后10个</p>\n<p>第二次输入后有几个循环</p>\n<p>第一个循环是在求dx = 0.001，[0,100]，sub_1360(x, (v94/12379) + 1)*dx的积分 a</p>\n<p>然后int(2a+3) == 0x13AFA + 9 == 0x13B03 (sub_13A0中v7044+=9)</p>\n<p>第二个循环同样求和第一个差不多的积分 b，不过第二个参数变成了(v94%12379 + 1)</p>\n<p>然后int(2b+3) == 0x59D + 5 == 0x5A2 (sub_13A0中v7048+=5)</p>\n<p>爆破脚本</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;math.h&gt;\n#include&lt;iostream&gt;\n#include&lt;stdio.h&gt;\nusing namespace std;\ninline double f(double a, double b)\n&#123;\n\tdouble tmp &#x3D; pow(a, b - 1.0);\n\tdouble ret &#x3D; tmp &#x2F; exp(a);\n\treturn ret;\n&#125;\n\nint main() &#123;\n\tdouble s &#x3D; 0.0;\n\tdouble x &#x3D; 0.0;\n\tint i;\n\n\tfor (i &#x3D; 0; i &lt; 12379; ++i) &#123;\n\t\tx &#x3D; 0.0;\n\t\ts &#x3D; 0.0;\n\t\tdo &#123;\n\t\t\ts +&#x3D; f(x, (double)i) * 0.001;\n\t\t\tx +&#x3D; + 0.001;\n\t\t&#125; while (x &lt;&#x3D; 100.0);\n\t\tint ans &#x3D; (int)(s + s + 3.0);\n\t\tif (ans &#x3D;&#x3D; 0x5a2) &#123; &#x2F;&#x2F; 0x59D + 5\n\t\t\tprintf(&quot;i &#x3D; %d, v95 &#x3D; %d\\n&quot;, i, i-1); &#x2F;&#x2F; i &#x3D; 7, v95 &#x3D; 6\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\n\tfor (i &#x3D; i - 1; ; i +&#x3D; 12379) &#123;\n\t\tx &#x3D; 0.0;\n\t\ts &#x3D; 0.0;\n\t\tdouble b &#x3D; (double)((int)i &#x2F; 12379) + 1.0;\n\t\tdo &#123;\n\t\t\ts +&#x3D; f(x, (double)b) * 0.001;\n\t\t\tx +&#x3D; +0.001;\n\t\t&#125; while (x &lt;&#x3D; 100.0);\n\t\tint ans &#x3D; (int)(s + s + 3);\n\t\tif (ans &#x3D;&#x3D; 0x13B03) &#123; &#x2F;&#x2F; 0x13AFA + 9\n\t\t\tprintf(&quot;v95 &#x3D; %d\\n&quot;, i); &#x2F;&#x2F; v95 &#x3D; 99038\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;</code></pre>\n\n<p>最后与第一次输入的内容处理后，得到flag</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nint main() &#123;\n\tint i;\n\n\tchar a[8] &#x3D; &quot;9903819&quot;;\n\tshort s1[7] &#x3D; &#123;0x8, 0x4d, 0x59, 0x06, 0x73, 0x02, 0x40&#125;;\n\tchar c[20] &#x3D; &#123; 0 &#125;;\n\tfor (i &#x3D; 0; i &lt; 7; i++)\n\t\tc[i] &#x3D; a[i] ^ s1[i];\n\n\tchar s2[10] &#x3D; &#123; 0xb2, 0xd6, 0x8e, 0x3f, 0xaa, 0x14, 0x53, 0x54, 0xc6, 0x06 &#125;;\n\tchar key[10] &#x3D; &#123; 0xe0, 0x95, 0xba, 0x60, 0xc9, 0x66, 0x2a, 0x24, 0xb2, 0x36 &#125;;\n\n\tfor (i &#x3D; 0; i &lt; 10; i++)\n\t\tc[i + 7] &#x3D; s2[i] ^ key[i];\n\n\tcout &lt;&lt; c &lt;&lt; endl;\n\n\treturn 0;\n&#125;</code></pre>\n\n","text":"虎符 2021 REre1mips架构什么的，完全不了解，溜了 gocrypt是个go语言程序 里面有个encodeing_hex_Decode，作用是string转hex（”b0a0” =&gt; [0xa0, 0xb0]）第7个参数是dest第10个参数是source第11个...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"CTF","slug":"CTF","count":7,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":7,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":10,"path":"api/tags/re.json"},{"name":"wp","slug":"wp","count":7,"path":"api/tags/wp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%99%8E%E7%AC%A6-2021-RE\"><span class=\"toc-text\">虎符 2021 RE</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#re1\"><span class=\"toc-text\">re1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#gocrypt\"><span class=\"toc-text\">gocrypt</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CrackMe\"><span class=\"toc-text\">CrackMe</span></a></li></ol></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"CPP编写类库给其他语言使用的总结","uid":"76983b1b7b5d8ab212f2ed6fe2f81e66","slug":"CppDllForOthers","date":"2021-04-22T17:05:59.000Z","updated":"2021-06-19T07:20:55.468Z","comments":true,"path":"api/articles/CppDllForOthers.json","keywords":null,"cover":null,"text":"CPP编写类库给其他语言使用主要是使用vs2019作为ide，cpp为语言编写类库，然后编译成dll，供其他cpp、c#、python等语言的工程调用类库。目的是一次编写与编译某个类库，然后给多语言使用。 这里是个傻瓜式操作总结贴（我总是忘记细节emm），总结网上及书里提供的一些...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"Programing","slug":"Programing","count":2,"path":"api/categories/Programing.json"}],"tags":[{"name":"dll","slug":"dll","count":4,"path":"api/tags/dll.json"},{"name":"Programing","slug":"Programing","count":2,"path":"api/tags/Programing.json"},{"name":"cpp","slug":"cpp","count":1,"path":"api/tags/cpp.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"反射式dll注入源码笔记","uid":"672d33a00ecfe140728287608f94a579","slug":"reflectiveDllInjection","date":"2021-04-11T10:31:55.000Z","updated":"2021-09-28T10:21:56.361Z","comments":true,"path":"api/articles/reflectiveDllInjection.json","keywords":null,"cover":[],"text":"从反射注入学习pe文件加载前言？后记与总结这是我写完代码后写的总结。重新梳理一下反射注入到底想干什么、以及怎么干。以及从中学到了什么。 收获？目标？反射注入是什么首先是学习反射注入的收获，当然也可以作为学习的目标，同时也是反射注入实际做的东西。 我的理解是反射注入实际上就是手工加...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Windows","slug":"Windows","count":13,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":13,"path":"api/tags/windows.json"},{"name":"dll","slug":"dll","count":4,"path":"api/tags/dll.json"},{"name":"note","slug":"note","count":13,"path":"api/tags/note.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}