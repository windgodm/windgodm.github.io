{"title":"windows核心编程 dll笔记","uid":"c3979005c513d3a7ab25692f156963bc","slug":"winViaC-dll","date":"2021-03-16T08:52:35.000Z","updated":"2021-09-28T10:21:40.977Z","comments":true,"path":"api/articles/winViaC-dll.json","keywords":null,"cover":null,"content":"<h1 id=\"windows核心编程-dll笔记\"><a href=\"#windows核心编程-dll笔记\" class=\"headerlink\" title=\"windows核心编程 dll笔记\"></a>windows核心编程 dll笔记</h1><h2 id=\"构建及使用dll\"><a href=\"#构建及使用dll\" class=\"headerlink\" title=\"构建及使用dll\"></a>构建及使用dll</h2><p>以下是核心编程的示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;* .\\Mylib\\MyLib.h *&#x2F;\n#ifndef MYLIB\n#define MYLIB extern &quot;C&quot; __declspec(dllimport)\n#endif\n\nMYLIB int num;\n\nMYLIB int DllFun();</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;* .\\Mylib\\MyLib1.cpp *&#x2F;\n#include &lt;windows.h&gt;\n#define MYLIB extern &quot;C&quot; __declspec(dllexport)\n#include &quot;MyLib.h&quot;\n\nint dll_num;\n\nint DllFun() &#123;\n    return dll_num;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;* .\\MyExe.cpp *&#x2F;\n#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n#include &quot;MyLib\\MyLib.h&quot;\n\nint main()\n&#123;\n    dll_num &#x3D; 10;\n    std::cout &lt;&lt; DllFun();\n    return 0;\n&#125;</code></pre>\n\n<p>extern “C”修饰符用于指明使用C++。</p>\n<h2 id=\"载入dll模块\"><a href=\"#载入dll模块\" class=\"headerlink\" title=\"载入dll模块\"></a>载入dll模块</h2><h3 id=\"显式载入\"><a href=\"#显式载入\" class=\"headerlink\" title=\"显式载入\"></a>显式载入</h3><p>将dll映射到进程的地址空间</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">HMODULE LoadLibrary(PCTSTR pszDLLPathName);\nHMODULE LoadLibraryEx(PCTSTR pszDLLPathName,\n                      HANDLE hFile,\n                      DWORD dwFlags);</code></pre>\n\n<p>返回值是被映射到的虚拟内存地址。（此处HMODULE等价于HINSTANCE）</p>\n<p>通过GetLastError确定是否成功载入。</p>\n<h3 id=\"显式链接到导出符号\"><a href=\"#显式链接到导出符号\" class=\"headerlink\" title=\"显式链接到导出符号\"></a>显式链接到导出符号</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">FARPROC GetProcAddress(HMODULE hInstDll, PCSTR pszSymbolName);</code></pre>\n\n<h3 id=\"显式卸载\"><a href=\"#显式卸载\" class=\"headerlink\" title=\"显式卸载\"></a>显式卸载</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BOOL FreeLibrary(HMODULE hInstDll);\nVOID FreeLivraryAndExitThread(HMODULE hInstDll, DWORD dwExitCode);</code></pre>\n\n<h3 id=\"dll搜索顺序\"><a href=\"#dll搜索顺序\" class=\"headerlink\" title=\"dll搜索顺序\"></a>dll搜索顺序</h3><ul>\n<li>当前目录</li>\n<li>windows系统目录</li>\n<li>16位windows系统目录（windows目录下的system子目录）</li>\n<li>windows目录</li>\n<li>path环境变量中的目录</li>\n</ul>\n<h2 id=\"DllMain\"><a href=\"#DllMain\" class=\"headerlink\" title=\"DllMain\"></a>DllMain</h2><h3 id=\"fdwReason\"><a href=\"#fdwReason\" class=\"headerlink\" title=\"fdwReason\"></a>fdwReason</h3><p><strong>DLL_PROCESS_ATTACH：</strong><br>第一次将DLL<strong>映射到进程中</strong>时，会调用DllMain并传入该信号。<br>通常此时应该通过HeapCreate创建需要的堆。<br>返回值用于表示是否初始化成功。</p>\n<p><strong>DLL_THREAD_ATTACH：</strong><br>进程创建一个线程时触发。</p>\n<p><strong>DLL_THREAD_DETACH：</strong><br>ExitThread触发。</p>\n<p><strong>DLL_PROCESS_DETACH：</strong><br>撤销映射时传入该信号。<br>通常执行HeapDestroy销毁初始化时创建的堆。</p>\n<h2 id=\"模块的基地址重定位\"><a href=\"#模块的基地址重定位\" class=\"headerlink\" title=\"模块的基地址重定位\"></a>模块的基地址重定位</h2><p>重定位段(relocation section)包含一个字节偏移量的列表，记录机器指令的内存地址，用于需要重定位时遍历修改内存映像中的地址。</p>\n<h2 id=\"RemoteInject（CreateRemoteThread）\"><a href=\"#RemoteInject（CreateRemoteThread）\" class=\"headerlink\" title=\"RemoteInject（CreateRemoteThread）\"></a>RemoteInject（CreateRemoteThread）</h2><h3 id=\"大致流程\"><a href=\"#大致流程\" class=\"headerlink\" title=\"大致流程\"></a>大致流程</h3><ul>\n<li><p>获取目标进程pid，并打开目标进程。</p>\n</li>\n<li><p>在目标进程中申请空间，写入注入dll的路径。</p>\n</li>\n<li><p>获取LoadLibrary在Kernel32.dll的真实地址。</p>\n</li>\n<li><p>通过远程创建线程，在目标进程中创建一个线程，执行LoadLibrary(dllPathname)。</p>\n</li>\n<li><p>释放申请的空间，并关闭句柄。</p>\n</li>\n</ul>\n<h3 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h3><p>因为是在目标进程中执行LoadLibrary(dllPathname)的，所以需要先把dll路径写入目标进程中，并作为LoadLibrary的参数。</p>\n<p>直接调用LoadLibrary时，链接器会生成一个调用，调用导入段中的一个转换函数。即先跳转到转换函数，再跳转到实际函数。<br>而转换函数在不同进程中是会变的，但Kernel32.dll在所有进程中映射的地址是一样的，所以需要获取LoadLibrary在Kernel32.dll中的地址。</p>\n<h3 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;*\nRemoteInject.cpp\n*&#x2F;\n\n#include &lt;iostream&gt;\n#include &lt;windows.h&gt;\n#include &lt;TlHelp32.h&gt;\n\nusing std::cout;\nusing std::endl;\n\nDWORD GetPidByName(WCHAR* name);\n\nint main()\n&#123;\n\twchar_t targetName[20] &#x3D; L&quot;Target.exe&quot;;\n\twchar_t dllPathname[] &#x3D; L&quot;E:\\\\MyDll.dll&quot;;\n\tint pathnameLen &#x3D; (1 + lstrlenW(dllPathname)) * sizeof(wchar_t);\n\tDWORD pid &#x3D; 0, byw &#x3D; 0;\n\tHANDLE hTarget &#x3D; 0, hDll &#x3D; 0;\n\tPWSTR pszPathname &#x3D; 0;\n\tPTHREAD_START_ROUTINE realAddr &#x3D; 0;\n\n\t__try &#123;\n\t\t&#x2F;&#x2F; 1 get pid\n\t\tpid &#x3D; GetPidByName(targetName);\n\t\tif (pid &#x3D;&#x3D; 0) &#123;\n\t\t\tcout &lt;&lt; &quot;e:Get pid failed\\n&quot;;\n\t\t\t__leave;\n\t\t&#125;\n\t\tcout &lt;&lt; &quot;pid:&quot; &lt;&lt; pid &lt;&lt; endl;\n\n\t\t&#x2F;&#x2F; 2 open process\n\t\thTarget &#x3D; OpenProcess((PROCESS_CREATE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION), false, pid);\n\t\tif (hTarget &#x3D;&#x3D; NULL) &#123;\n\t\t\tcout &lt;&lt; &quot;e:Open process failed\\n&quot;;\n\t\t\t__leave;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 3 alloc memory for dll pathname\n\t\tpszPathname &#x3D; (PWSTR)VirtualAllocEx(hTarget, NULL, pathnameLen, MEM_COMMIT, PAGE_READWRITE);\n\t\tif (pszPathname &#x3D;&#x3D; NULL) &#123;\n\t\t\tcout &lt;&lt; &quot;e:Alloc memory failed\\n&quot;;\n\t\t\t__leave;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tcout &lt;&lt; &quot;pathname addr: &quot; &lt;&lt; pszPathname &lt;&lt; endl;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 4 write dll pathname\n\t\tWriteProcessMemory(hTarget, (LPVOID)pszPathname, dllPathname, pathnameLen, &amp;byw);\n\t\tcout &lt;&lt; &quot;dll pathname(len, write len): &quot; &lt;&lt; pathnameLen &lt;&lt; &quot; &quot; &lt;&lt; byw &lt;&lt; std::endl;\n\n\t\t&#x2F;&#x2F; 5 get the real address of LoadLibraryW in Kernel32.dll\n\t\tHMODULE mh &#x3D; GetModuleHandleW(L&quot;Kernel32.dll&quot;);\n\t\tif (mh &#x3D;&#x3D; NULL) &#123;\n\t\t\tcout &lt;&lt; &quot;e:kernel\\n&quot;;\n\t\t\t__leave;\n\t\t&#125;\n\t\trealAddr &#x3D; (PTHREAD_START_ROUTINE)GetProcAddress(mh, &quot;LoadLibraryW&quot;);\n\n\t\t&#x2F;&#x2F; 6 create a remote thread to call LoadLibraryW(dllPathname)\n\t\thDll &#x3D; CreateRemoteThread(hTarget, NULL, 0, realAddr, pszPathname, 0, NULL);\n\t\tif (hDll &#x3D;&#x3D; NULL) &#123;\n\t\t\tcout &lt;&lt; &quot;e:create remote thread failed\\n&quot;;\n\t\t\t__leave;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tcout &lt;&lt; &quot;hDll: &quot; &lt;&lt; hDll &lt;&lt; endl;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; wait\n\t\tWaitForSingleObject(hDll, INFINITE);\n\t&#125;\n\t__finally &#123;\n\t\t&#x2F;&#x2F; clean\n\t\tif (hDll !&#x3D; NULL) &#123;\n\t\t\tCloseHandle(hDll);\n\t\t&#125;\n\n\t\tif (hTarget !&#x3D; NULL) &#123;\n\t\t\tif (pszPathname !&#x3D; NULL)\n\t\t\t\tVirtualFreeEx(hTarget, pszPathname, 0, MEM_RELEASE);\n\n\t\t\tCloseHandle(hTarget);\n\t\t&#125;\n\t&#125;\n&#125;\n\nDWORD GetPidByName(WCHAR* name)\n&#123;\n\tHANDLE hsnapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\tif (hsnapshot &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;\n\t\tprintf_s(&quot;CreateToolhelp32Snapshot error!\\n&quot;);\n\t\treturn 0;\n\t&#125;\n\n\tPROCESSENTRY32 pe&#123;&#125;;\n\tpe.dwSize &#x3D; sizeof(PROCESSENTRY32);\n\n\tint flag &#x3D; Process32First(hsnapshot, &amp;pe);\n\n\twhile (flag !&#x3D; 0) &#123;\n\t\tif (wcscmp(pe.szExeFile, name) &#x3D;&#x3D; 0) &#123;\n\t\t\treturn pe.th32ProcessID;\n\t\t&#125;\n\t\tflag &#x3D; Process32Next(hsnapshot, &amp;pe);\n\t&#125;\n\n\tCloseHandle(hsnapshot);\n\n\treturn 0;\n&#125;</code></pre>\n\n<h2 id=\"ImageWalk\"><a href=\"#ImageWalk\" class=\"headerlink\" title=\"ImageWalk\"></a>ImageWalk</h2><p>遍历内存区块查询对应的信息</p>\n<h3 id=\"MEMORY-BASIC-INFORMATION\"><a href=\"#MEMORY-BASIC-INFORMATION\" class=\"headerlink\" title=\"MEMORY_BASIC_INFORMATION\"></a>MEMORY_BASIC_INFORMATION</h3><p>AllocationBase：内存单元起始地址</p>\n<p>BaseAddress：模块基地址</p>\n<p>RegionSize：模块所以页面的大小</p>\n<h3 id=\"C6262-堆栈溢出警告\"><a href=\"#C6262-堆栈溢出警告\" class=\"headerlink\" title=\"C6262 堆栈溢出警告\"></a>C6262 堆栈溢出警告</h3><p>C6262：函数使用了堆栈的“26300”个字节: 超过了 /analyze:stacksize ‘16384’。 请考虑将某些数据移到堆中。</p>\n<p>其中有一个变量为 char szBuf[260 * 100]，260是路径长度最大值，100是个数，这里减少下个数避免这个警告。</p>\n<p>其他解决方式如malloc或new就不再深究了。</p>\n<h2 id=\"小笔记\"><a href=\"#小笔记\" class=\"headerlink\" title=\"小笔记\"></a>小笔记</h2><p>__try和try：据说Release模式下，如果没有throw模块，vc会优化掉try catch</p>\n<p>线性地址：逻辑地址（偏移）+ 基地址</p>\n<p>HMODULE：模块句柄，win32下通常是被载入模块的线性地址</p>\n<p>MAX_PATH：宏常量，通常为260，代表编译器支持的最长路径长度</p>\n<p>sz：string zero，表示以零结尾的字符串，即c字符串</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>C6262：<a href=\"https://blog.csdn.net/mxclxp/article/details/7991127\">https://blog.csdn.net/mxclxp/article/details/7991127</a></p>\n<p>随书代码下载页面：<a href=\"https://www.wintellect.com/windows-via-cc-by-jeffrey-richter-and-christopher-nasarre/\">https://www.wintellect.com/windows-via-cc-by-jeffrey-richter-and-christopher-nasarre/</a></p>\n<p>随书代码下载地址：<a href=\"https://www.wintellect.com/wp-content/uploads/2017/11/Windows-via-C-Code-January-29-2008.zip\">https://www.wintellect.com/wp-content/uploads/2017/11/Windows-via-C-Code-January-29-2008.zip</a></p>\n","text":"windows核心编程 dll笔记构建及使用dll以下是核心编程的示例： &#x2F;* .\\Mylib\\MyLib.h *&#x2F; #ifndef MYLIB #define MYLIB extern &quot;C&quot; __declspec(dllimport) ...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"Windows","slug":"Windows","count":14,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":14,"path":"api/tags/windows.json"},{"name":"dll","slug":"dll","count":4,"path":"api/tags/dll.json"},{"name":"note","slug":"note","count":15,"path":"api/tags/note.json"},{"name":"windows_via_c","slug":"windows-via-c","count":1,"path":"api/tags/windows-via-c.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-dll%E7%AC%94%E8%AE%B0\"><span class=\"toc-text\">windows核心编程 dll笔记</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8dll\"><span class=\"toc-text\">构建及使用dll</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BD%BD%E5%85%A5dll%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">载入dll模块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%BE%E5%BC%8F%E8%BD%BD%E5%85%A5\"><span class=\"toc-text\">显式载入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%BE%E5%BC%8F%E9%93%BE%E6%8E%A5%E5%88%B0%E5%AF%BC%E5%87%BA%E7%AC%A6%E5%8F%B7\"><span class=\"toc-text\">显式链接到导出符号</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%BE%E5%BC%8F%E5%8D%B8%E8%BD%BD\"><span class=\"toc-text\">显式卸载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#dll%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">dll搜索顺序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DllMain\"><span class=\"toc-text\">DllMain</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#fdwReason\"><span class=\"toc-text\">fdwReason</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E5%9C%B0%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D\"><span class=\"toc-text\">模块的基地址重定位</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RemoteInject%EF%BC%88CreateRemoteThread%EF%BC%89\"><span class=\"toc-text\">RemoteInject（CreateRemoteThread）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">大致流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">细节</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">具体代码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ImageWalk\"><span class=\"toc-text\">ImageWalk</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MEMORY-BASIC-INFORMATION\"><span class=\"toc-text\">MEMORY_BASIC_INFORMATION</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#C6262-%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA%E8%AD%A6%E5%91%8A\"><span class=\"toc-text\">C6262 堆栈溢出警告</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%AC%94%E8%AE%B0\"><span class=\"toc-text\">小笔记</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"远程线程注入逆向","uid":"8974ac6b1252ccb40492ca6fb37e2ab1","slug":"dllRemoteInject","date":"2021-03-16T09:08:49.000Z","updated":"2021-09-28T10:21:35.600Z","comments":true,"path":"api/articles/dllRemoteInject.json","keywords":null,"cover":[],"text":"远程线程注入逆向资料MSDN中的函数定义OpenProcess (processthreadsapi.h) SyntaxHANDLE OpenProcess ( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcess...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Windows","slug":"Windows","count":14,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":14,"path":"api/tags/windows.json"},{"name":"dll","slug":"dll","count":4,"path":"api/tags/dll.json"},{"name":"note","slug":"note","count":15,"path":"api/tags/note.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}