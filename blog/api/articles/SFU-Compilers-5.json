{"title":"SFU Compilers class 笔记5","uid":"40c2cd491a15172739073405816f8de7","slug":"SFU-Compilers-5","date":"2022-09-19T04:00:00.000Z","updated":"2024-01-05T07:02:57.747Z","comments":true,"path":"api/articles/SFU-Compilers-5.json","keywords":null,"cover":[],"content":"<h1 id=\"SFU-Compilers-笔记-5-语义分析和代码生成1\"><a href=\"#SFU-Compilers-笔记-5-语义分析和代码生成1\" class=\"headerlink\" title=\"SFU Compilers 笔记 5 语义分析和代码生成1\"></a>SFU Compilers 笔记 5 语义分析和代码生成1</h1><p>week8 week9 week10 week11</p>\n<h2 id=\"Week-8-Semantics-and-Runtime-Support\"><a href=\"#Week-8-Semantics-and-Runtime-Support\" class=\"headerlink\" title=\"Week 8 Semantics and Runtime Support\"></a>Week 8 Semantics and Runtime Support</h2><h3 id=\"SEM1-Scoping\"><a href=\"#SEM1-Scoping\" class=\"headerlink\" title=\"SEM1 Scoping\"></a>SEM1 Scoping</h3><p><strong>语义分析的目标</strong></p>\n<ul>\n<li>确保程序有明确意义</li>\n<li>验证前面两步分析中，没有捕获的程序的属性：<ul>\n<li>所有变量在使用前声明</li>\n<li>在表达式中使用正确类型</li>\n<li>函数调用具有正确的参数和返回值</li>\n</ul>\n</li>\n<li>其次，可能需要收集一些信息以生成代码：<ul>\n<li>确定每个标识符（Id）所表示的变量</li>\n<li>构建继承层次结构的内部表示</li>\n<li>跟踪变量的作用域（确定每行代码的域包含哪些变量）</li>\n</ul>\n</li>\n</ul>\n<p><strong>语义分析的实现</strong></p>\n<ul>\n<li>属性语法<ul>\n<li>扩充语法规则，在解析期间完成语义分析</li>\n<li>Single-pass 语义分析</li>\n</ul>\n</li>\n<li>递归遍历AST树<ul>\n<li>在解析完生成AST树后，遍历AST</li>\n</ul>\n</li>\n</ul>\n<p><strong>标识符（Name/Identifier）</strong></p>\n<ul>\n<li><p>相同的标识符在程序不同的位置可能指代不同的东西</p>\n</li>\n<li><p>比如可能是个类名、类型、或是不同的变量等</p>\n</li>\n</ul>\n<p><strong>域（scope）</strong></p>\n<ul>\n<li>一个实体的域，指的是程序中的一组指向该实体的标识符的位置</li>\n<li>将新变量引入域可能会隐藏旧变量</li>\n</ul>\n<p><strong>符号表</strong></p>\n<ul>\n<li>将标识符映射到描述符</li>\n<li>语义分析时，不断更新符号表，其中包含域的信息（记录什么在域内）</li>\n<li>典型实现：栈</li>\n<li>基本操作：<ul>\n<li>push scope：进入新的域</li>\n<li>pop scope：离开域，丢弃（该域的）所有声明</li>\n<li>insert symbol：添加新标识符到当前域（入栈）</li>\n<li>lookup symbol：寻找某标识符的描述符（从栈顶找第一个具有相同标识符的描述符）</li>\n</ul>\n</li>\n</ul>\n<p><strong>Spaghetti Stack</strong></p>\n<p>每个栈对应一个域</p>\n<p>每个栈有一个指针，指向上一个域</p>\n<p>寻址标识符时，如果遍历到栈底，则向指针指向的栈顶继续遍历</p>\n<p><img src=\"E:\\documents\\note\\md\\img\\SEM1-SpaghettiStack.jpg\"></p>\n<p><strong>Single/Multi-pass 编译</strong></p>\n<ul>\n<li>Single pass编译：<ul>\n<li>扫描一次输入，同时完成词法、语法、语义分析和代码生成</li>\n<li>C，C++</li>\n</ul>\n</li>\n<li>Multi pass编译：<ul>\n<li>需要多次扫描输入</li>\n<li>Java</li>\n</ul>\n</li>\n</ul>\n<p>有些语言的定义支持Single-Pass，而有些需要Multi-pass</p>\n<p>有些语言比如python则需要动态（在程序运行时）分析作用域</p>\n<p><strong>Multi-pass编译器中的作用域</strong></p>\n<ul>\n<li>第一次遍历：解析输入，生成AST</li>\n<li>第二次遍历：遍历AST，获取类的信息</li>\n<li>第三次遍历：遍历AST，做语义分析和代码生成</li>\n</ul>\n<h3 id=\"Runtime-Suport\"><a href=\"#Runtime-Suport\" class=\"headerlink\" title=\"Runtime Suport\"></a>Runtime Suport</h3><p>Activate Tree，讲控制流受数据流影响（递归函数的例子），讲为什么函数调用要用栈</p>\n<p>栈帧讲的有点乱（纯栈实现调用），好像和传统C的调用约定不一样（可能我没听懂，还是C的舒服）</p>\n<p>后面讲到可以用寄存器优化调用过程（包括栈帧建立）中的变量传递</p>\n<h3 id=\"sem2-Type-Systems（todo）\"><a href=\"#sem2-Type-Systems（todo）\" class=\"headerlink\" title=\"sem2 Type Systems（todo）\"></a>sem2 Type Systems（todo）</h3><h2 id=\"Week-9-Intermediate-Representation-and-SSA-Form\"><a href=\"#Week-9-Intermediate-Representation-and-SSA-Form\" class=\"headerlink\" title=\"Week 9 Intermediate Representation and SSA Form\"></a>Week 9 Intermediate Representation and SSA Form</h2><h3 id=\"IR-Intermediate-Representation\"><a href=\"#IR-Intermediate-Representation\" class=\"headerlink\" title=\"IR Intermediate Representation\"></a>IR Intermediate Representation</h3><p><strong>IR</strong></p>\n<p>前端生成AST，由AST生成IR，由IR生成机器码</p>\n<p>IR独立于编程语言和机器码</p>\n<p>后面讲了一些IR中的概念</p>\n<p>还有条件、循环语句在llvm中的代码思路</p>\n<p><strong>Basic Blocks</strong></p>\n<ul>\n<li>基本块（只能）从第一条语句进入，以分支结束</li>\n<li>函数调用将控制流由调用者交给被调用函数</li>\n</ul>\n<p><strong>Backpatching</strong></p>\n<p>在处理分支、循环语句的时候，使用类似占位符的机制</p>\n<p>生成一个偏移随机的jmp，待目标地址的代码生成时，再填上jmp的偏移</p>\n<p><strong>表示</strong></p>\n<p>通常用3地址码（op，arg1，arg2，result）</p>\n<p>或三元组（op，arg1，arg2）（指令序号作为隐性result）</p>\n<h3 id=\"SSA1-Intro-to-SSA-Form\"><a href=\"#SSA1-Intro-to-SSA-Form\" class=\"headerlink\" title=\"SSA1 Intro to SSA Form\"></a>SSA1 Intro to SSA Form</h3><ul>\n<li><p>Static Single Assignment Form</p>\n</li>\n<li><p>对每个变量，一处定义（赋值），多处使用</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li>每个变量只有一个定义，更易于数据流分析和优化</li>\n<li>如果变量有N处使用，M处定义（对应N+M条指令），其def-use链大小为（N*M）</li>\n<li>SSA没有降低复杂度，但在定义数量上通常是线性的</li>\n<li>简化了寄存器分配图（reg interference graph）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Week-10-Creating-SSA-Form\"><a href=\"#Week-10-Creating-SSA-Form\" class=\"headerlink\" title=\"Week 10 Creating SSA Form\"></a>Week 10 Creating SSA Form</h2><h3 id=\"SSA2-Creating-SSA-Form\"><a href=\"#SSA2-Creating-SSA-Form\" class=\"headerlink\" title=\"SSA2 Creating SSA Form\"></a>SSA2 Creating SSA Form</h3><p>讲如何生成 使用phi函数最少的 SSA Form的 中间代码</p>\n<p><strong>SSA Form</strong></p>\n<ul>\n<li>SSA生成算法：<ul>\n<li>原始算法，by Cytron et al. 1986（这节课讲的）</li>\n<li>Lengauer-Tarjan（龙书讲的）</li>\n<li>Harel</li>\n</ul>\n</li>\n</ul>\n<p><strong>转换为SSA格式</strong></p>\n<ul>\n<li>简单思想：在每个join point添加每个变量的phi函数</li>\n<li>join point：指CFG中，拥有不只一个前驱的节点</li>\n<li>phi函数：（IR中的内容），决定某个变量来源于哪一个前驱</li>\n<li>重点：存在浪费（其实不是每个变量都需要添加）</li>\n</ul>\n<p><strong>支配关系（的定义）</strong></p>\n<p>（大写字母表示CFG中的一个节点，或者BB）</p>\n<ul>\n<li>X 支配 Y：从起点到Y，必须经过X；换而言之，X必要的影响着Y</li>\n<li>D(X)：X 严格支配的节点的集合</li>\n<li>X 严格支配 Y：X 支配 Y，且 X 不等于 Y</li>\n</ul>\n<p><img src=\"E:\\documents\\note\\md\\img\\SSA2-D.jpg\"></p>\n<p><strong>支配的属性</strong></p>\n<ul>\n<li>SSA form的最根本的属性是：变量的定义 必须支配 变量的使用：<ul>\n<li>如果a 通过phi函数 在X中使用，则定义a的块 支配X的前驱</li>\n<li>如果a 不通过phi函数 在X中使用，则定义a的块 支配X</li>\n</ul>\n</li>\n</ul>\n<p>重点是：a在X定义，若 X 支配 Y，在Y中可以直接使用a，不需要phi</p>\n<p><strong>支配前沿</strong></p>\n<ul>\n<li>Dominance Frontier，DF(X)是任意Y的集合：<ul>\n<li>X支配Y的前驱，X不严格支配Y</li>\n</ul>\n</li>\n</ul>\n<p>（S(X)：X的后继的集合）</p>\n<p>简单计算DF的方法：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def DominanceFrontier(X):\n\tD_X &#x3D; Dominance(X)\n    # 1\n    DF_X &#x3D; Successor(X) - D_X\n    # 2.1\n    for Y in D:\n        DF_X |&#x3D; Successor(Y)\n    # 2.2\n    DF_X -&#x3D; D\n    return DF_X</code></pre>\n\n<p><img src=\"E:\\documents\\note\\md\\img\\SSA2-DF.jpg\"></p>\n<p>动态计算DF的方法：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def DominanceFrontier(X):\n    if X in DF:\n        return DF[X]\n    \n    D_X &#x3D; Dominance(X)\n    # Local(X)\n    Local_X &#x3D; Successor(X) - D_X\n    # Up(X)\n    Up_X &#x3D; set()\n    for K in D_X:\n        Up_X |&#x3D; DF(K) - D_X\n    # DF(X)\n    DF_X &#x3D; Local_X | Up_X\n    DF[X] &#x3D; DF_X\n    return DF_X</code></pre>\n\n\n\n<ul>\n<li>若 X 中定义 a，DF(X) 中若使用 a，必须用phi定义一个新的a</li>\n</ul>\n<p>我的理解是：若 Y 属于 DF(X)，则必须用phi定义一个新的a，以供Y和Y的后继使用</p>\n<h3 id=\"SSA3-Creating-SSA-Form\"><a href=\"#SSA3-Creating-SSA-Form\" class=\"headerlink\" title=\"SSA3 Creating SSA Form\"></a>SSA3 Creating SSA Form</h3><p>上一课的延续，举了一些计算D()、DF()、插入phi的例子</p>\n<p><strong>转换为SSA Form</strong></p>\n<p>支配关系是嵌套的，可以表示为一棵树</p>\n<p>（如果A支配B、B支配C，意味着起点到C一定经过B，而起点到B又一定经过A，所以起点到C必然先经过A，然后再经过B）</p>\n<p><img src=\"E:\\documents\\note\\md\\img\\SSA3-DT.jpg\"></p>\n<p>转换过程（下图中DF(2) = {2}）</p>\n<p><img src=\"E:\\documents\\note\\md\\img\\SSA3-C2SSA.jpg\"></p>\n<h2 id=\"Week-11-Register-Allocation-and-Code-Optimization\"><a href=\"#Week-11-Register-Allocation-and-Code-Optimization\" class=\"headerlink\" title=\"Week 11 Register Allocation and Code Optimization\"></a>Week 11 Register Allocation and Code Optimization</h2><h3 id=\"OPT1-Register-Allocation（todo）\"><a href=\"#OPT1-Register-Allocation（todo）\" class=\"headerlink\" title=\"OPT1 Register Allocation（todo）\"></a>OPT1 Register Allocation（todo）</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">- c_def\n+ c_use\n+ l_def</code></pre>\n\n\n\n\n\n<h3 id=\"OPT2-Spilling-in-Register-Allocation（todo）\"><a href=\"#OPT2-Spilling-in-Register-Allocation（todo）\" class=\"headerlink\" title=\"OPT2 Spilling in Register Allocation（todo）\"></a>OPT2 Spilling in Register Allocation（todo）</h3><p>def-&gt;store</p>\n<p>load-&gt;use</p>\n<p>有个可以3色的算成4色</p>\n<h3 id=\"OPT3-Linear-Scan-Register-Allocation（todo）\"><a href=\"#OPT3-Linear-Scan-Register-Allocation（todo）\" class=\"headerlink\" title=\"OPT3 Linear Scan Register Allocation（todo）\"></a>OPT3 Linear Scan Register Allocation（todo）</h3><h3 id=\"OPT4-Intro-to-Code-Optimization（todo）\"><a href=\"#OPT4-Intro-to-Code-Optimization（todo）\" class=\"headerlink\" title=\"OPT4 Intro to Code Optimization（todo）\"></a>OPT4 Intro to Code Optimization（todo）</h3><p>advanced compiler design and implement</p>\n","text":"SFU Compilers 笔记 5 语义分析和代码生成1week8 week9 week10 week11 Week 8 Semantics and Runtime SupportSEM1 Scoping语义分析的目标 确保程序有明确意义 验证前面两步分析中，没有捕获的程序的属...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"CS","slug":"CS","count":6,"path":"api/categories/CS.json"}],"tags":[{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"cs","slug":"cs","count":6,"path":"api/tags/cs.json"},{"name":"compiler","slug":"compiler","count":6,"path":"api/tags/compiler.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SFU-Compilers-%E7%AC%94%E8%AE%B0-5-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%901\"><span class=\"toc-text\">SFU Compilers 笔记 5 语义分析和代码生成1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Week-8-Semantics-and-Runtime-Support\"><span class=\"toc-text\">Week 8 Semantics and Runtime Support</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SEM1-Scoping\"><span class=\"toc-text\">SEM1 Scoping</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Runtime-Suport\"><span class=\"toc-text\">Runtime Suport</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#sem2-Type-Systems%EF%BC%88todo%EF%BC%89\"><span class=\"toc-text\">sem2 Type Systems（todo）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Week-9-Intermediate-Representation-and-SSA-Form\"><span class=\"toc-text\">Week 9 Intermediate Representation and SSA Form</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IR-Intermediate-Representation\"><span class=\"toc-text\">IR Intermediate Representation</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SSA1-Intro-to-SSA-Form\"><span class=\"toc-text\">SSA1 Intro to SSA Form</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Week-10-Creating-SSA-Form\"><span class=\"toc-text\">Week 10 Creating SSA Form</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SSA2-Creating-SSA-Form\"><span class=\"toc-text\">SSA2 Creating SSA Form</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SSA3-Creating-SSA-Form\"><span class=\"toc-text\">SSA3 Creating SSA Form</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Week-11-Register-Allocation-and-Code-Optimization\"><span class=\"toc-text\">Week 11 Register Allocation and Code Optimization</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OPT1-Register-Allocation%EF%BC%88todo%EF%BC%89\"><span class=\"toc-text\">OPT1 Register Allocation（todo）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OPT2-Spilling-in-Register-Allocation%EF%BC%88todo%EF%BC%89\"><span class=\"toc-text\">OPT2 Spilling in Register Allocation（todo）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OPT3-Linear-Scan-Register-Allocation%EF%BC%88todo%EF%BC%89\"><span class=\"toc-text\">OPT3 Linear Scan Register Allocation（todo）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OPT4-Intro-to-Code-Optimization%EF%BC%88todo%EF%BC%89\"><span class=\"toc-text\">OPT4 Intro to Code Optimization（todo）</span></a></li></ol></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"SFU Compilers class 笔记6","uid":"dc41c1162c79a34f24cc5f032c462a3c","slug":"SFU-Compilers-6","date":"2022-09-23T04:00:00.000Z","updated":"2024-01-05T07:05:13.928Z","comments":true,"path":"api/articles/SFU-Compilers-6.json","keywords":null,"cover":null,"text":"SFU Compilers 笔记 6 语义分析和代码生成2llvm-p hw3 hw4 Practice LLVM环境如何在不同环境使用makefile： CSIL Linux机器：make llvmconfig=llvm-config-12 all（似乎是SFU的在线环境） m...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"CS","slug":"CS","count":6,"path":"api/categories/CS.json"}],"tags":[{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"cs","slug":"cs","count":6,"path":"api/tags/cs.json"},{"name":"compiler","slug":"compiler","count":6,"path":"api/tags/compiler.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"SFU Compilers class 笔记4","uid":"4f7d6d0fadf06b2d208599f31c49d097","slug":"SFU-Compilers-4","date":"2022-07-29T04:00:00.000Z","updated":"2024-01-05T07:02:52.286Z","comments":true,"path":"api/articles/SFU-Compilers-4.json","keywords":null,"cover":null,"text":"SFU Compilers 笔记 4 语法分析2week7 hw2 Week 7 Syntax Directed TranslationLR6 Syntax Directed Translation for LR Parsers语法导向翻译（SDT）用于将解析树（Parse tr...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"CS","slug":"CS","count":6,"path":"api/categories/CS.json"}],"tags":[{"name":"note","slug":"note","count":27,"path":"api/tags/note.json"},{"name":"cs","slug":"cs","count":6,"path":"api/tags/cs.json"},{"name":"compiler","slug":"compiler","count":6,"path":"api/tags/compiler.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}