{"title":"sctf21 BabyDriver 出题思路","uid":"5492b18e2fa4da93951bdc6ad9c6b6ae","slug":"sctf21-babydriver","date":"2021-12-26T04:00:00.000Z","updated":"2022-01-18T09:38:46.013Z","comments":true,"path":"api/articles/sctf21-babydriver.json","keywords":null,"cover":null,"content":"<h1 id=\"BabyDriver-出题思路\"><a href=\"#BabyDriver-出题思路\" class=\"headerlink\" title=\"BabyDriver 出题思路\"></a>BabyDriver 出题思路</h1><p>这题是和0x太上一起出的，他提供了题目的框架和内核通信部分的代码，我负责其余的实现</p>\n<p><a href=\"https://github.com/0xTalShang\">0xTalShang (0x太上) (github.com)</a></p>\n<p><a href=\"https://github.com/SycloverTeam/SCTF2021\">SycloverTeam/SCTF2021: SCTF 2021 (github.com)</a></p>\n<p>有选手反馈R3部分出得不太好，确实没有很好的把驱动的考点和R3的加密结合在一起，下次加油吧</p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>题目有一个R3的客户端<code>babydriver.exe</code>和一个驱动<code>sctf.sys</code></p>\n<p>客户端会要求输入一个flag，并读取文件<code>key.bin</code>，然后对flag进行运算</p>\n<p>运算的结果会传给驱动</p>\n<p>驱动进行第二次运算，然后与目标值比较</p>\n<p>客户端再向驱动查询比较结果是否正确</p>\n<h3 id=\"babydriver-exe\"><a href=\"#babydriver-exe\" class=\"headerlink\" title=\"babydriver.exe\"></a>babydriver.exe</h3><p>客户端会要求输入一个flag，并读取文件<code>key.bin</code>。</p>\n<p>flag的输入格式限制为只能用64个字符</p>\n<p>然后对flag进行一个类似base64解密的过程，把输入的20个字节的flag转换成15字节的数据</p>\n<p>这个过程按每两位的移动，拆分成了60个位移函数。一共有60*60共3600个函数用于移动。</p>\n<p>程序根据<code>key.bin</code>决定使用哪些位移函数（实际上就是3600取60）。</p>\n<p>每个位移函数会有一个<code>费用</code>，总<code>费用</code>必须为3100</p>\n<h3 id=\"内核通信\"><a href=\"#内核通信\" class=\"headerlink\" title=\"内核通信\"></a>内核通信</h3><p>驱动程序会注册一个时间回调函数，客户端修改时间会触发该回调函数。</p>\n<p>整个通讯流程是客户端把要传输的数据写入PE文件头，然后修改时间触发回调进入内核。回调函数再从PE头文件中读写数据，并做处理。</p>\n<h3 id=\"sctf-sys\"><a href=\"#sctf-sys\" class=\"headerlink\" title=\"sctf.sys\"></a>sctf.sys</h3><p>驱动要手动启动，该驱动负责实现和注册回调函数，并对传输给内核的数据做校验。</p>\n<p>驱动对传入数据的处理是将传入的15字节分成4组，每组进行一个模乘，比较结果是否为目标值</p>\n<h3 id=\"陷阱\"><a href=\"#陷阱\" class=\"headerlink\" title=\"陷阱\"></a>陷阱</h3><p>babydriver.exe中利用VEH添加了一些call 0和除0语句，以触发异常<br>其中除0异常用于跳转到位移函数</p>\n<p>驱动中在接收数据后，会对后3字节做一些处理，将后3字节左移一个字节，然后填充一个10h，模乘校验完后再还原回去</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"key-bin\"><a href=\"#key-bin\" class=\"headerlink\" title=\"key.bin\"></a>key.bin</h3><p>位移函数格式如下（实际上是无参的）</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void name() &#123;\n    char x &#x3D; inBuf[iIdx] &gt;&gt; (iSh * 2);\n    x &#x3D; x &amp; 3;\n    x &#x3D; x &lt;&lt; (oSh * 2);\n    outBuf[oIdx] |&#x3D; x;\n    totalC -&#x3D; cost;\n&#125;</code></pre>\n\n<p>首先需要提取3600个位移函数的参数</p>\n<p>已知约束是cost的和必须为3100</p>\n<p>根据题意得到隐含的约束条件是要选择其中的60个函数，每个函数会从输入中选2个位，复制到输出中，输入的偏移和输出的偏移不能相同</p>\n<p>然后用动态规划算法找出解</p>\n<p>和为3100且选择了60个的解有多个。但完全覆盖输入和输出所有位的解只有1个</p>\n<p>这里给出python版本的参考代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def ReadMM(name, n, w):\n    mm &#x3D; [[0 for j in range(w)] for i in range(n)]\n    with open(&#39;&#123;&#125;_&#123;&#125;_&#123;&#125;.txt&#39;.format(name, n, w), &#39;r&#39;) as f:\n        lines &#x3D; f.readlines()\n        i &#x3D; 0\n        for line in lines:\n            j &#x3D; 0\n            for w in line.split():\n                mm[i][j] &#x3D; int(w)\n                j +&#x3D; 1\n            i +&#x3D; 1\n                \n    return mm\n\n\ndef msOrd2wsOrd(ms_ord):\n\n    a &#x3D; ms[ms_ord][0]*3+ms[ms_ord][1]\n    b &#x3D; ms[ms_ord][2]*4+ms[ms_ord][3]\n    return a * 60 + b\n\n\ndef dp3(ii, ww):\n\n    if ww &lt; 0:\n        return 0\n\n    ans &#x3D; 0\n\n    if mm3[ii][ww] !&#x3D; -1:\n        return mm3[ii][ww]\n\n    # take ws[n]\n    if ii &#x3D;&#x3D; 59:\n        for n in range(ii*60, (ii+1)*60):\n            print(n)\n            new_w &#x3D; ww - ws[n]\n            ans +&#x3D; dp3(ii-1, new_w)\n    else:\n        for n in range(ii*60, (ii+1)*60):\n            new_w &#x3D; ww - ws[n]\n            ans +&#x3D; dp3(ii-1, new_w)\n\n    mm3[ii][ww] &#x3D; ans\n    return ans\n\n\nopos &#x3D; [0]*60\ncur_ans &#x3D; []\ndef findPath(ii, ww):\n\n    total_ans &#x3D; []\n\n    if ii &#x3D;&#x3D; 0:\n        for oo in range(60):\n            if ws[oo] &#x3D;&#x3D; ww:\n                total_ans &#x3D; [cur_ans[:] + [oo]]\n                break\n        return total_ans\n\n    n &#x3D; ii*60\n    for oo in range(60):\n        if opos[oo]:\n            n +&#x3D; 1\n            continue\n\n        new_w &#x3D; ww - ws[n]\n        if new_w &gt;&#x3D; 0 and mm3[ii-1][new_w] &gt; 0:\n            opos[oo] &#x3D; 1\n            cur_ans.append(n)\n\n            new_ans &#x3D; findPath(ii-1, new_w)\n\n            total_ans +&#x3D; new_ans\n\n            del cur_ans[-1]\n            opos[oo] &#x3D; 0\n\n        # continue\n        n +&#x3D; 1\n    \n    return total_ans\n\n\nw &#x3D; 3100\nms &#x3D; ReadMM(&#39;ms&#39;, 3600, 5)\n\nwsOrd2msOrd &#x3D; [0]*3600\nws &#x3D; [0]*3600\nfor msOrd in range(3600):\n    wsOrd &#x3D; msOrd2wsOrd(msOrd)\n    wsOrd2msOrd[wsOrd] &#x3D; msOrd\n    ws[wsOrd] &#x3D; ms[msOrd][4]\n\n# step 1 dp\n\nmm3 &#x3D; [[-1 for i in range(w+1)] for j in range(60)]\nfor ww in range(w+1):\n    mm3[0][ww] &#x3D; 0\nfor oo in range(60):\n    mm3[0][ws[oo]] &#x3D; 1\ndp3(59, w)\nprint(mm3[59][w])\n\n# step 2 dfs\n\nansWsOrds &#x3D; findPath(59, w)[0]\nansMsOrds &#x3D; [wsOrd2msOrd[ord] for ord in ansWsOrds]\nprint(ansMsOrds)\n\n# step 3 key\n\nans &#x3D; [0]*3600\nfor ord in ansMsOrds:\n    ans[ord] &#x3D; 1\n\ns &#x3D; &#39;&#39;\nfor x in ans:\n    s +&#x3D; str(x)\n\nwith open(&#39;.&#x2F;key.bin&#39;, &#39;wb&#39;) as f:\n    for i in range(0, 3600, 8):\n        f.write(int(s[i:i+8][::-1], 2).to_bytes(1, &#39;little&#39;))\n</code></pre>\n\n<h3 id=\"一元同余方程\"><a href=\"#一元同余方程\" class=\"headerlink\" title=\"一元同余方程\"></a>一元同余方程</h3><p>这个比较简单就不说了</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>求出一元同余方程的解，得到变形base64的输出。然后求出key.bin得到base64的规则，逆推出输入。</p>\n","feature":true,"text":"BabyDriver 出题思路这题是和0x太上一起出的，他提供了题目的框架和内核通信部分的代码，我负责其余的实现 0xTalShang (0x太上) (github.com) SycloverTeam/SCTF2021: SCTF 2021 (github.com) 有选手反馈R...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"CTF","slug":"CTF","count":7,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":7,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":10,"path":"api/tags/re.json"},{"name":"wp","slug":"wp","count":7,"path":"api/tags/wp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#BabyDriver-%E5%87%BA%E9%A2%98%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">BabyDriver 出题思路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE\"><span class=\"toc-text\">题目</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%91%98%E8%A6%81\"><span class=\"toc-text\">摘要</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#babydriver-exe\"><span class=\"toc-text\">babydriver.exe</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E6%A0%B8%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">内核通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#sctf-sys\"><span class=\"toc-text\">sctf.sys</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%99%B7%E9%98%B1\"><span class=\"toc-text\">陷阱</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">解题思路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#key-bin\"><span class=\"toc-text\">key.bin</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E5%85%83%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B\"><span class=\"toc-text\">一元同余方程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"《Windows Kernel Programming》 笔记 6~7 内核机制与IRP","uid":"08a6adcddaf28cd0d0b42adf778ccd2a","slug":"wkp6-7","date":"2022-01-02T04:00:00.000Z","updated":"2022-02-25T10:01:23.134Z","comments":true,"path":"api/articles/wkp6-7.json","keywords":null,"cover":[],"text":"Windows Kernel Programming 笔记 6~7 内核机制与IRP6 内核机制关于windows内核提供的一些机制。这些机制，驱动开发会使用，或者有关。 6.1 中断优先级中断处理例程（Interrupt Service Routine，ISR） 中断优先级（I...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"18 mins."},"categories":[{"name":"Windows","slug":"Windows","count":13,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":13,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":13,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":2,"path":"api/tags/kernel.json"},{"name":"wkp","slug":"wkp","count":2,"path":"api/tags/wkp.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"《Windows Kernel Programming》 笔记 1~5 内核开发入门","uid":"2cdcc6b2635425e63dc5ac736f5a68f9","slug":"wkp1-5","date":"2021-12-24T04:00:00.000Z","updated":"2022-01-18T09:30:03.325Z","comments":true,"path":"api/articles/wkp1-5.json","keywords":null,"cover":[],"text":"Windows Kernel Programming 笔记 1~5 内核开发入门1 windows内部概况描述一些Windows内部工作中最重要、最基本的概念，部分概念将在后面的章节做更详细的研究 1.1 进程进程不运行（Processes dont’t run - proces...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"Windows","slug":"Windows","count":13,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":13,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":13,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":2,"path":"api/tags/kernel.json"},{"name":"wkp","slug":"wkp","count":2,"path":"api/tags/wkp.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}