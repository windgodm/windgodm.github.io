{"title":"vmp2 (3) handler类型总结","uid":"796d9083672966112e1391db00c01e6d","slug":"vmp2-p3","date":"2021-09-28T04:00:00.000Z","updated":"2021-09-28T10:30:30.953Z","comments":true,"path":"api/articles/vmp2-p3.json","keywords":null,"cover":null,"content":"<h1 id=\"VMP2（3）handler类型总结\"><a href=\"#VMP2（3）handler类型总结\" class=\"headerlink\" title=\"VMP2（3）handler类型总结\"></a>VMP2（3）handler类型总结</h1><h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>详细分析push、pop、计算类handler以及粗略分析其余handler后对handler进行分类并做一些总结。</p>\n<h2 id=\"字节码\"><a href=\"#字节码\" class=\"headerlink\" title=\"字节码\"></a>字节码</h2><p>vm字节码结构有三种：</p>\n<ul>\n<li>opcode(1B)</li>\n<li>opcode(1B) + Imm(1~8B)</li>\n<li>opcode(1B) + VmRegOffset(1B)</li>\n</ul>\n<p>所有字节码都是经过加密的，解析时需要根据rbx动态解密。</p>\n<p>vm字节码各部分是倒序排列的，也就是说后一条指令在前面，Imm、VmRegOffset在opcode前面。</p>\n<h2 id=\"vm虚拟栈与虚拟寄存器\"><a href=\"#vm虚拟栈与虚拟寄存器\" class=\"headerlink\" title=\"vm虚拟栈与虚拟寄存器\"></a>vm虚拟栈与虚拟寄存器</h2><p>通过分析涉及vm栈的handler（如push、pop、add等），得出vm栈是2字节对齐的。vm寄存器实质可以理解为一个全局数组，也是2字节对齐的。</p>\n<h2 id=\"push类\"><a href=\"#push类\" class=\"headerlink\" title=\"push类\"></a>push类</h2><p>push类指令push数据到栈上。分为三种：</p>\n<ul>\n<li>push 立即数</li>\n<li>push vm寄存器</li>\n<li>push 真实寄存器</li>\n</ul>\n<p>立即数即指令的Imm部分，push到vm寄存器时则根据VmRegOffset部分。</p>\n<p>push压栈元素的大小不小于被压栈数据的长度。比如push 4字节的立即数有两条指令：一条是压入4字节(VmRsp-=4)；一条是压入8字节(VmRsp-=8)，其中被压入的立即数在栈顶的低4字节([VmRsp] = ImmD)。</p>\n<h2 id=\"pop类\"><a href=\"#pop类\" class=\"headerlink\" title=\"pop类\"></a>pop类</h2><p>pop类指令从vm栈上pop数据。分为两种：</p>\n<ul>\n<li>pop到vm寄存器中</li>\n<li>pop到真实寄存器中（包括popfq）。</li>\n</ul>\n<p>显然pop到vm寄存器的指令长度为2字节，第二个字节指示了vm寄存器的偏移。</p>\n<h2 id=\"计算类\"><a href=\"#计算类\" class=\"headerlink\" title=\"计算类\"></a>计算类</h2><p>计算类指令有七种：</p>\n<ul>\n<li>nor</li>\n<li>add</li>\n<li>div</li>\n<li>shl</li>\n<li>shld</li>\n<li>shr</li>\n<li>shrd</li>\n</ul>\n<p>逻辑运算由nor组合实现，减法可以通过逻辑运算和加法实现，乘法可以由位移和加法组合实现。</p>\n<p>各种指令的操作数也是分长度的。</p>\n<p>计算类指令基于栈实现，可以等价成以下4步：</p>\n<ul>\n<li>所有操作数出栈</li>\n<li>计算结果</li>\n<li>入栈结果</li>\n<li>入栈RFLAGS</li>\n</ul>\n<p>也就是计算以后操作数将清除，栈顶为RFLAGS(8Byte)、栈顶第二项为结果(长度由指令决定)</p>\n<h2 id=\"Indirection类\"><a href=\"#Indirection类\" class=\"headerlink\" title=\"Indirection类\"></a>Indirection类</h2><p>该类指令用于解除应用。伪代码如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">top &#x3D; *top</code></pre>\n\n<p>等价于以下3步：</p>\n<ul>\n<li>出栈（8字节指针）</li>\n<li>解除引用</li>\n<li>入栈结果</li>\n</ul>\n<h2 id=\"subscript类\"><a href=\"#subscript类\" class=\"headerlink\" title=\"subscript类\"></a>subscript类</h2><p>该类指令用于给内存地址赋值。伪代码如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">*top &#x3D; top2</code></pre>\n\n<p>等价于以下3步：</p>\n<ul>\n<li>出栈左值（8字节指针）</li>\n<li>出栈右值</li>\n<li>往指针指向地址赋值</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>还有初始化虚拟机、call、ret、修改rbx、修改bp、基于vm栈的cpuid等指令。</p>\n","text":"VMP2（3）handler类型总结摘要详细分析push、pop、计算类handler以及粗略分析其余handler后对handler进行分类并做一些总结。 字节码vm字节码结构有三种： opcode(1B) opcode(1B) + Imm(1~8B) opcode(1B) +...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"Re","slug":"Re","count":3,"path":"api/categories/Re.json"}],"tags":[{"name":"re","slug":"re","count":10,"path":"api/tags/re.json"},{"name":"vmp2","slug":"vmp2","count":3,"path":"api/tags/vmp2.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#VMP2%EF%BC%883%EF%BC%89handler%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">VMP2（3）handler类型总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%91%98%E8%A6%81\"><span class=\"toc-text\">摘要</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E8%8A%82%E7%A0%81\"><span class=\"toc-text\">字节码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vm%E8%99%9A%E6%8B%9F%E6%A0%88%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">vm虚拟栈与虚拟寄存器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#push%E7%B1%BB\"><span class=\"toc-text\">push类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pop%E7%B1%BB\"><span class=\"toc-text\">pop类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E7%B1%BB\"><span class=\"toc-text\">计算类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Indirection%E7%B1%BB\"><span class=\"toc-text\">Indirection类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#subscript%E7%B1%BB\"><span class=\"toc-text\">subscript类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96\"><span class=\"toc-text\">其他</span></a></li></ol></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"pbctf21 btree wp","uid":"37d6e393a967114c82f7d8a550ead81e","slug":"pbctf21-btree-Wp","date":"2021-10-09T04:00:00.000Z","updated":"2021-11-05T11:34:18.434Z","comments":true,"path":"api/articles/pbctf21-btree-Wp.json","keywords":null,"cover":null,"text":"PBCTF21 RE BinaryTree Beaengine+dijkstra解法思路代码是动态解密的，简单的xor，解密一块执行一块。每一块结尾会设置rbx，rbx决定下一块被解密的代码。 实际上每一块代码相当于一个节点，里面有一个根据输入的jz，决定下一个rbx以及一个co...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"CTF","slug":"CTF","count":7,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":7,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":10,"path":"api/tags/re.json"},{"name":"wp","slug":"wp","count":7,"path":"api/tags/wp.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"neo4j与CQL","uid":"ff3b8559df1c08290e25585b94350c6d","slug":"neo4j-CQL","date":"2021-09-20T04:00:00.000Z","updated":"2021-09-28T10:12:41.150Z","comments":true,"path":"api/articles/neo4j-CQL.json","keywords":null,"cover":null,"text":"ne04j与CQL摘要neo4j是个nosql数据库，通过docker安装可以启动一个本地服务器，在浏览器中访问。能画出数据的关系图。通过CQL语言进行操作。 主要用途是构建社会关系、知识图谱这种类型的数据库。自带图形化展示数据的功能。 通过docker安装首先安装docker，...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"Database","slug":"Database","count":1,"path":"api/categories/Database.json"}],"tags":[{"name":"Database","slug":"Database","count":2,"path":"api/tags/Database.json"},{"name":"neo4j","slug":"neo4j","count":1,"path":"api/tags/neo4j.json"},{"name":"CQL","slug":"CQL","count":1,"path":"api/tags/CQL.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}