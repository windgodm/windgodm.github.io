{"title":"BeaEngine","uid":"14f57ee55d88ddbbbcf4ab3554ca49cd","slug":"BeaEngine","date":"2021-09-20T04:00:00.000Z","updated":"2021-09-28T10:17:39.992Z","comments":true,"path":"api/articles/BeaEngine.json","keywords":null,"cover":null,"content":"<h1 id=\"BeaEngine\"><a href=\"#BeaEngine\" class=\"headerlink\" title=\"BeaEngine\"></a>BeaEngine</h1><h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>一个反汇编引擎，支持c++、python等。</p>\n<p>具体使用参照官方github的example，非常详细。</p>\n<h2 id=\"常用\"><a href=\"#常用\" class=\"headerlink\" title=\"常用\"></a>常用</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">char buf;\nUINT64 va;\n\nDISASM infos;\nint len;\n\n&#x2F;&#x2F; init\nmemset(&amp;infos, 0, sizeof(DISASM));\ninfos.EIP &#x3D; buf;\ninfos.VirtualAddr &#x3D; va;\n\n&#x2F;&#x2F; disasm\nlen &#x3D; Disasm(&amp;infos);\n\n&#x2F;&#x2F; Branch type\nif (infos.Instruction.BranchType &#x3D;&#x3D; JmpType); &#x2F;&#x2F; RetType, CallType\n\n&#x2F;&#x2F; Operater\ninfos.Instruction.Mnemonic; &#x2F;&#x2F; &quot;add&quot;\n\n&#x2F;&#x2F; Reg\ninfos.Operand1.OpMnemonic; &#x2F;&#x2F; &quot;rax&quot;\ninfos.Operand1.Registers.gpr;\n\n&#x2F;&#x2F; Continue\ninfos.EIP +&#x3D; len;\ninfos.VirtualAddr +&#x3D; len;\n\n&#x2F;&#x2F; Jmp\nUINT64 nextVA &#x3D; infos.Instruction.AddrValue;\nUINT64 curVA &#x3D; infos.VirtualAddr;\ninfos.EIP +&#x3D; nextVA - curVA;\ninfos.VirtualAddr &#x3D; nextVA;</code></pre>\n\n<h2 id=\"vs2019-amp-static-lib\"><a href=\"#vs2019-amp-static-lib\" class=\"headerlink\" title=\"vs2019 &amp; static lib\"></a>vs2019 &amp; static lib</h2><h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>项目属性页 -&gt; C/C++ -&gt; 常规 -&gt; 附加包含目录 添加beaengine的headers目录</p>\n<p>项目属性页 -&gt; C/C++ -&gt; 代码生成 -&gt; 运行库 /MD /MDd改成/MT /MTd</p>\n<p>项目属性页 -&gt; 链接器 -&gt; 输入 -&gt; 忽略特定默认库 添加crt64.lib</p>\n<p>然后在代码开头添加以下语句。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define BEA_ENGINE_STATIC\n#include &quot;BeaEngine.h&quot;\n#pragma comment(lib,&quot;legacy_stdio_definitions.lib&quot;)\n#pragma comment(lib, &quot;D:\\\\beaengine-5.3.0\\\\lib_static_x64\\\\BeaEngine.lib&quot;)</code></pre>\n\n<p>重点是：第一行在include”BeaEngine.h”前指明是静态，修改运行库、忽略crt64.lib以及第三行链接兼容库。</p>\n<h3 id=\"可能的错误\"><a href=\"#可能的错误\" class=\"headerlink\" title=\"可能的错误\"></a>可能的错误</h3><h4 id=\"无法解析的外部符号\"><a href=\"#无法解析的外部符号\" class=\"headerlink\" title=\"无法解析的外部符号\"></a>无法解析的外部符号</h4><p>如果缺少第一行，报错如下：</p>\n<p><code>error LNK2019: 无法解析的外部符号 __imp_Disasm</code></p>\n<p>使用静lib库时必须在include前通过define指明使用静态库</p>\n<h4 id=\"无法打开crt64-lib-或-sprintf无效引用\"><a href=\"#无法打开crt64-lib-或-sprintf无效引用\" class=\"headerlink\" title=\"无法打开crt64.lib 或 sprintf无效引用\"></a>无法打开crt64.lib 或 sprintf无效引用</h4><p>如果没有忽略crt64.lib或者没有修改运行库，报错如下：</p>\n<p><code>LINK : fatal error LNK1104: 无法打开文件“crt64.lib”</code></p>\n<p>这时尝试在配置链接器中忽略掉crt64.lib这个库，就会报<code>_sprintf无效引用</code></p>\n<p>这时需要链接兼容库<code>legacy_stdio_definitions.lib</code></p>\n","text":"BeaEngine摘要一个反汇编引擎，支持c++、python等。 具体使用参照官方github的example，非常详细。 常用char buf; UINT64 va; DISASM infos; int len; &#x2F;&#x2F; init memset(&amp;i...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"Programing","slug":"Programing","count":2,"path":"api/categories/Programing.json"}],"tags":[{"name":"Programing","slug":"Programing","count":2,"path":"api/tags/Programing.json"},{"name":"BeaEngine","slug":"BeaEngine","count":2,"path":"api/tags/BeaEngine.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#BeaEngine\"><span class=\"toc-text\">BeaEngine</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%91%98%E8%A6%81\"><span class=\"toc-text\">摘要</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8\"><span class=\"toc-text\">常用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vs2019-amp-static-lib\"><span class=\"toc-text\">vs2019 &amp; static lib</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">配置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%83%BD%E7%9A%84%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">可能的错误</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A4%96%E9%83%A8%E7%AC%A6%E5%8F%B7\"><span class=\"toc-text\">无法解析的外部符号</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80crt64-lib-%E6%88%96-sprintf%E6%97%A0%E6%95%88%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">无法打开crt64.lib 或 sprintf无效引用</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"vmp2 (3) handler类型总结","uid":"796d9083672966112e1391db00c01e6d","slug":"vmp2-p3","date":"2021-09-28T04:00:00.000Z","updated":"2021-09-28T10:30:30.953Z","comments":true,"path":"api/articles/vmp2-p3.json","keywords":null,"cover":null,"text":"VMP2（3）handler类型总结摘要详细分析push、pop、计算类handler以及粗略分析其余handler后对handler进行分类并做一些总结。 字节码vm字节码结构有三种： opcode(1B) opcode(1B) + Imm(1~8B) opcode(1B) +...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"Re","slug":"Re","count":3,"path":"api/categories/Re.json"}],"tags":[{"name":"re","slug":"re","count":11,"path":"api/tags/re.json"},{"name":"vmp2","slug":"vmp2","count":3,"path":"api/tags/vmp2.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"neo4j与CQL","uid":"ff3b8559df1c08290e25585b94350c6d","slug":"neo4j-CQL","date":"2021-09-20T04:00:00.000Z","updated":"2021-09-28T10:12:41.150Z","comments":true,"path":"api/articles/neo4j-CQL.json","keywords":null,"cover":null,"text":"ne04j与CQL摘要neo4j是个nosql数据库，通过docker安装可以启动一个本地服务器，在浏览器中访问。能画出数据的关系图。通过CQL语言进行操作。 主要用途是构建社会关系、知识图谱这种类型的数据库。自带图形化展示数据的功能。 通过docker安装首先安装docker，...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"Database","slug":"Database","count":1,"path":"api/categories/Database.json"}],"tags":[{"name":"Database","slug":"Database","count":2,"path":"api/tags/Database.json"},{"name":"neo4j","slug":"neo4j","count":1,"path":"api/tags/neo4j.json"},{"name":"CQL","slug":"CQL","count":1,"path":"api/tags/CQL.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}