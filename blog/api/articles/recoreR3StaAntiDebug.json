{"title":"逆向工程核心原理 R3静态反调试 笔记","uid":"2b002dec449ce21e3d8b7af026d74ae7","slug":"recoreR3StaAntiDebug","date":"2021-10-16T04:00:00.000Z","updated":"2021-11-05T11:43:17.496Z","comments":true,"path":"api/articles/recoreR3StaAntiDebug.json","keywords":null,"cover":null,"content":"<h1 id=\"逆向工程核心原理-R3静态反调试-笔记\"><a href=\"#逆向工程核心原理-R3静态反调试-笔记\" class=\"headerlink\" title=\"逆向工程核心原理 R3静态反调试 笔记\"></a>逆向工程核心原理 R3静态反调试 笔记</h1><h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>主要是R3层面的静态反调试手段</p>\n<p>参考逆向工程核心原理51章静态反调试</p>\n<p>涉及的API：</p>\n<ul>\n<li><p>IsDebuggerPresent()</p>\n</li>\n<li><p>NtQueryInformationProcess()</p>\n</li>\n<li><p>NtQuerySystemInformation()</p>\n</li>\n<li><p>NtQueryObject()</p>\n</li>\n<li><p>ZwSetInformationThread()</p>\n</li>\n<li><p>DebugActiveProcessStop()</p>\n</li>\n</ul>\n<h2 id=\"51-2-涉及peb的检查方式\"><a href=\"#51-2-涉及peb的检查方式\" class=\"headerlink\" title=\"51.2 涉及peb的检查方式\"></a>51.2 涉及peb的检查方式</h2><table>\n<thead>\n<tr>\n<th>偏移</th>\n<th>名称</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x2</td>\n<td>BeingDebugged</td>\n<td>UChar</td>\n</tr>\n<tr>\n<td>0xc</td>\n<td>Ldr</td>\n<td>Ptr32 _PEB_LDR_DATA</td>\n</tr>\n<tr>\n<td>0x18</td>\n<td>ProcessHesap</td>\n<td>Ptr32 Void</td>\n</tr>\n<tr>\n<td>0x68</td>\n<td>NtGlobalFlag</td>\n<td>Uint48</td>\n</tr>\n</tbody></table>\n<p><strong>BeingDebugged 标志位</strong> </p>\n<p>处于调试状态，BeingDebugged被设置为1。<br>IsDebuggerPresent()检查 BeingDebugged。</p>\n<p><strong>Ldr 堆内存检查</strong></p>\n<p>调试进程未使用堆内存填充<code>0xFEEEFEEE</code>(x32)。<br>该方法只在xp中有效，且附加不存在该特征：<br>PEB_LDR_DATA结构体在堆内存中创建，扫描该区域是否存在上述特征。</p>\n<p><strong>ProcessHeap 标志</strong></p>\n<p>processheap结构//todo<br>该方法只在xp中有效，且附加不存在该特征：<br>正常情况Heap.Flags=2，Heap.ForceFlags=0</p>\n<p><strong>NtGlobalFlag Bitmap</strong></p>\n<p>该方法通过附加无效<br>调试状态PEB.NtGlobalFlag |= 0x70<br>由以下位组成<br>FLG_HEAP_ENABLE_TAIL_CHECK (0x10)<br>FLG_HEAP_ENABLE_FREE_CHECK (0x20)<br>FLG_HEAP_VALIDATE_PARAMETERS (0x40)</p>\n<h2 id=\"51-3-NtQueryInformationProcess\"><a href=\"#51-3-NtQueryInformationProcess\" class=\"headerlink\" title=\"51.3 NtQueryInformationProcess()\"></a>51.3 NtQueryInformationProcess()</h2><p>该函数用于查询进程信息。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef enum PROCESSINFOCLASS &#123;\n\tProcessDebugPort &#x3D; 0x7,\n\tProcessDebugObjectHandle &#x3D; 0x1e,\n\tProcessDebugFlags &#x3D; 0x1f\n&#125;;\n\n&#x2F;&#x2F; MSDN\n__kernel_entry NTSTATUS NtQueryInformationProcess(\n  HANDLE           ProcessHandle,\n  PROCESSINFOCLASS ProcessInformationClass,\n  PVOID            ProcessInformation,\n  ULONG            ProcessInformationLength,\n  PULONG           ReturnLength\n);</code></pre>\n\n<p>第二个参数指定查询的信息。</p>\n<p>非调试情况第三个参数指向地址被填充的值：<br>ProcessDebugPort 填充为0<br>ProcessDebugObjectHandle 填充为0<br>ProcessDebugFlags 填充为1</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bool CheckNtQfP_API()\n&#123;\n\t&#x2F;&#x2F; get api\n\n\tHMODULE hNtdll &#x3D; GetModuleHandleW(L&quot;NtDll.dll&quot;);\n\tauto pNtQueryInformationProcess &#x3D; (PNtQueryInformationProcess)GetProcAddress(hNtdll, &quot;NtQueryInformationProcess&quot;);\n\n\t&#x2F;&#x2F; temp values\n\n\tHANDLE hCurProc &#x3D; GetCurrentProcess();\n\tbool beingDebug &#x3D; false;\n\n\t&#x2F;&#x2F; Process Debug Port (0x7)\n\n\tDWORD dwDebugPort;\n\tpNtQueryInformationProcess(hCurProc, ProcessDebugPort, &amp;dwDebugPort, sizeof(dwDebugPort), NULL);\n    \n\tif (dwDebugPort) beingDebug &#x3D; true;\n\n\t&#x2F;&#x2F; Process Debug Object Handle (0x1E)\n\n\tHANDLE hDebugObject &#x3D; NULL;\n\tpNtQueryInformationProcess(hCurProc, ProcessDebugObjectHandle, &amp;hDebugObject, sizeof(hDebugObject), NULL);\n\n\tif (hDebugObject) beingDebug &#x3D; true;\n\n\t&#x2F;&#x2F; Process Debug Flags (0x1F)\n\n\tBOOL bDebugFlag &#x3D; true;\n\tpNtQueryInformationProcess(hCurProc, ProcessDebugFlags, &amp;bDebugFlag, sizeof(bDebugFlag), NULL);\n\n\tif (bDebugFlag &#x3D;&#x3D; 0) beingDebug &#x3D; true;\n\n    &#x2F;&#x2F; return\n    \n\treturn beingDebug;\n&#125;</code></pre>\n\n<h2 id=\"51-4-NtQuerySystemInformation\"><a href=\"#51-4-NtQuerySystemInformation\" class=\"headerlink\" title=\"51.4 NtQuerySystemInformation()\"></a>51.4 NtQuerySystemInformation()</h2><p>该函数用于查询系统信息，可以检测系统是否在调试模式下运行。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef enum SYSTEM_INFORMATION_CLASS &#123;\n\tSystemKernelDebuggerInformation &#x3D; 0x23\n&#125;;\ntypedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION &#123;\n\tBOOLEAN DebuggerEnabled;\n\tBOOLEAN DebuggerNotPresent;\n&#125;SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;\n\n&#x2F;&#x2F; MSDN\n__kernel_entry NTSTATUS NtQuerySystemInformation(\n  SYSTEM_INFORMATION_CLASS SystemInformationClass,\n  PVOID                    SystemInformation,\n  ULONG                    SystemInformationLength,\n  PULONG                   ReturnLength\n);</code></pre>\n\n<p>非调试情况，debuggerInfo.DebuggerEnabled = 0</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bool CheckNtQSI_API()\n&#123;\n\t&#x2F;&#x2F; get api\n\n\tHMODULE hNtdll &#x3D; GetModuleHandleW(L&quot;NtDll.dll&quot;);\n\tauto pNtQuerySystemInformation &#x3D; (PNtQuerySystemInformation)GetProcAddress(hNtdll, &quot;NtQuerySystemInformation&quot;);\n\n\t&#x2F;&#x2F; SystemKernelDebuggerInformation(0x23)\n\n\tSYSTEM_KERNEL_DEBUGGER_INFORMATION debuggerInfo &#x3D; &#123; 0, &#125;;\n\tpNtQuerySystemInformation(SystemKernelDebuggerInformation, &amp;debuggerInfo, sizeof(debuggerInfo), 0);\n\n\treturn debuggerInfo.DebuggerEnabled;\n&#125;</code></pre>\n\n<p><strong>应对</strong></p>\n<p>xp中修改boot.ini，删除<code>/debugport=coml /baudrate=115200 /Debug</code></p>\n<p>win7 cmd中执行<code>bcdedit /debug off</code></p>\n<h2 id=\"51-5-NtQueryObject\"><a href=\"#51-5-NtQueryObject\" class=\"headerlink\" title=\"51.5 NtQueryObject()\"></a>51.5 NtQueryObject()</h2><p>该函数用于查询内核对象，可以用于检测是否存在调试对象类型的内核对象。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef enum _OBJECT_INFORMATION_CLASS &#123;\n\tObjectAllTypesInformation &#x3D; 3\n&#125; OBJECT_INFORMATION_CLASS;\ntypedef struct _UNICODE_STRING &#123; &#x2F;&#x2F; sizeof &#x3D; 8\n\tUSHORT Length;\n\tUSHORT MaximumLength;\n\tPWSTR Buffer;\n&#125; UNICODE_STRING, * PUNICODE_STRING;\ntypedef struct _OBJECT_TYPE_INFORMATION &#123; &#x2F;&#x2F; sizeof &#x3D; 16\n\tUNICODE_STRING TypeName;\n\tULONG TotalNumberOfHandles;\n\tULONG TotalNumberOfObjects;\n&#125; OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;\ntypedef struct _OBJECT_ALL_INFORMATION &#123;\n\tULONG NumberOfObjectsTypes;\n\tOBJECT_TYPE_INFORMATION ObjectTypeInformation[1];\n&#125; OBJECT_ALL_INFORMATION, *POBJECT_ALL_INFORMATION;\n\n&#x2F;&#x2F; MSDN\n__kernel_entry NTSYSCALLAPI NTSTATUS NtQueryObject(\n  HANDLE                   Handle,\n  OBJECT_INFORMATION_CLASS ObjectInformationClass,\n  PVOID                    ObjectInformation,\n  ULONG                    ObjectInformationLength,\n  PULONG                   ReturnLength\n);</code></pre>\n\n<h3 id=\"分析返回的OBJECT-ALL-INFORMATION\"><a href=\"#分析返回的OBJECT-ALL-INFORMATION\" class=\"headerlink\" title=\"分析返回的OBJECT_ALL_INFORMATION\"></a>分析返回的OBJECT_ALL_INFORMATION</h3><p>ObjectInformation中会填充OBJECT_ALL_INFORMATION，需要遍历这个结构，我在一次调试中记录下了一些地址用于分析该结构<br>下面是返回的ObjectInformation指向的buf的数据内容：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0x750000: OBJECT_ALL_INFORMATION\n  +0h : NumberOfObjectsTypes(ULONG)&#x3D; 67\n  +4h : ObjectTypeInformation(STRUCT)\n\n0x750004: (OBJECT_TYPE_INFORMATION)\n  +0h : ObjectTypeInformation[0].TypeName.Length(USHORT)&#x3D; 8\n  +2h : ObjectTypeInformation[0].TypeName.LengthMaximumLength(USHORT)&#x3D; 10\n  +4h : ObjectTypeInformation[0].TypeName.Buffer(wchar_t*)&#x3D; 0x750064\n  +8h : ObjectTypeInformation[0].TotalNumberOfHandles(ULONG)&#x3D; 67\n  +ch: ObjectTypeInformation[0].TotalNumberOfObjects(ULONG)&#x3D; 0\n\n0x750014: (BYTE[80]) &#x2F;&#x2F; unknown\n\n0x750064: (wchar[5]) &#x3D; L&quot;Type&quot;\n\n0x75006E: (BYTE[2]) &#x3D; \\x00\\x00\n\n0x750070: (OBJECT_TYPE_INFORMATION)\n  +0h : ObjectTypeInformation[1].TypeName.Length(USHORT)&#x3D; 18\n  +2h : ObjectTypeInformation[1].TypeName.LengthMaximumLength(USHORT)&#x3D; 20\n  +4h : ObjectTypeInformation[1].TypeName.Buffer(wchar_t*)&#x3D; 0x7500D0\n  ...\n\n0x750080: (BYTE[80]) &#x2F;&#x2F; unknown\n\n0x7500D0: (wchar[10]) &#x3D; L&quot;Directory&quot;\n\n0x7500E4: (OBJECT_TYPE_INFORMATION)\n  +0h : ObjectTypeInformation[2].TypeName.Length(USHORT)&#x3D; 24\n  +2h : ObjectTypeInformation[2].TypeName.LengthMaximumLength(USHORT)&#x3D; 26\n  +4h : ObjectTypeInformation[2].TypeName.Buffer(wchar_t*)&#x3D; 0x750144\n  ...\n\n0x7500F4: (BYTE[80]) &#x2F;&#x2F; unknown\n\n0x750144: (wchar[13]) &#x3D; L&quot;SymbolicLink&quot;\n\n...</code></pre>\n\n<p>可以看到内存布局可简化为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">NumberOfObjectsTypes\nObjectTypeInformation[0]\n80bytes undocument date\nwchar[]\nObjectTypeInformation[1]\n80bytes undocument date\nwchar[]\nObjectTypeInformation[2]\n80bytes undocument date\nwchar[]</code></pre>\n\n<p>我的理解是<code>OBJECT_ALL_INFORMATION</code>中的<code>OBJECT_TYPE_INFORMATION[]</code>是个元素长度可变的”数组”</p>\n<p><code>OBJECT_TYPE_INFORMATION[]</code>“数组”每个元素由已知的<code>OBJECT_TYPE_INFORMATION（16bytes）+ 未文档化数据（80bytes）+ wchar[]（长度不定）</code>组成</p>\n<p>同时根据书中代码的<code>&amp;0xfffffffc</code>可知是4字节对齐，也就是元素起始地址为4的倍数</p>\n<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><p>这里着重分析next那部分代码。</p>\n<p>书中的做法是：<br>首先是找到<code>最后一个字符地址</code>（wchar字符串以\\x00\\x00结尾）<br>然后清楚低两位（实现4字节对齐）<br>然后加上4</p>\n<p>不考虑对齐，<code>最后一个字符地址+2</code>=<code>下一个元素地址</code>（wchar字符串以\\x00\\x00结尾）</p>\n<p>如果最后一个字符地址已经对齐，那么下一个元素地址就不对齐，偏移原本为+2，为了对齐变成+4</p>\n<p>如果最后一个字符地址不对其，那么下一个元素地址就对齐，偏移原本为+2，但字符地址清楚了低两位，所以变成+4</p>\n<p>所以最后不管是否对齐都是+4</p>\n<p>也可以先猜测下一个元素地址，然后再判断是否对齐，不对齐就+2，但这样更费劲</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bool CheckNtQO_API()\n&#123;\n\tbool beingDebug &#x3D; false;\n\n\t&#x2F;&#x2F; get api\n\n\tHMODULE hNtdll &#x3D; GetModuleHandleW(L&quot;NtDll.dll&quot;);\n\tauto pNtQueryObject &#x3D; (PNtQueryObject)GetProcAddress(hNtdll, &quot;NtQueryObject&quot;);\n\n\t&#x2F;&#x2F; ObjectAllTypesInformation(0x3)\n\n\t&#x2F;&#x2F; get size\n\tULONG lSize &#x3D; 0;\n\tpNtQueryObject(0, ObjectAllTypesInformation, &amp;lSize, sizeof(lSize), &amp;lSize);\n\t&#x2F;&#x2F; alloc memory\n\tchar* buf &#x3D; 0;\n\tbuf &#x3D; (char*)VirtualAlloc(NULL, lSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n\t&#x2F;&#x2F; get info\n\tNTSTATUS sta;\n\tsta &#x3D; pNtQueryObject((HANDLE)0xFFFFFFFF, ObjectAllTypesInformation, buf, lSize, NULL);\n\tauto pObjAllInfo &#x3D; (POBJECT_ALL_INFORMATION)buf;\n\t&#x2F;&#x2F; check\n\tULONG objNum &#x3D; pObjAllInfo-&gt;NumberOfObjectsTypes;\n\tauto pObjTypeInfo &#x3D; pObjAllInfo-&gt;ObjectTypeInformation;\n\tfor (ULONG i &#x3D; 0; i &lt; objNum; i++) &#123;\n\t\tif (wcscmp(L&quot;DebugObject&quot;, pObjTypeInfo-&gt;TypeName.Buffer) &#x3D;&#x3D; 0) &#123;\n\t\t\tbeingDebug &#x3D; true;\n\t\t\tbreak;\n\t\t&#125;\n\t\t&#x2F;&#x2F; next\n        &#x2F;&#x2F; go to last wchar\n\t\tpObjTypeInfo &#x3D; (POBJECT_TYPE_INFORMATION)((ULONG)pObjTypeInfo-&gt;TypeName.Buffer + pObjTypeInfo-&gt;TypeName.Length);\n        &#x2F;&#x2F; alignment\n\t\tpObjTypeInfo &#x3D; (POBJECT_TYPE_INFORMATION)(((ULONG)pObjTypeInfo) &amp; 0xFFFFFFFC);\n        &#x2F;&#x2F; alignment offset\n\t\tpObjTypeInfo &#x3D; (POBJECT_TYPE_INFORMATION)((ULONG)pObjTypeInfo + sizeof(DWORD));\n\t&#125;\n\n\tif (buf)\n\t\tVirtualFree(buf, 0, MEM_RELEASE);\n\n\treturn beingDebug;\n&#125;</code></pre>\n\n<h2 id=\"51-6-ZwSetInformationThread\"><a href=\"#51-6-ZwSetInformationThread\" class=\"headerlink\" title=\"51.6 ZwSetInformationThread()\"></a>51.6 ZwSetInformationThread()</h2><p>该函数用于设置线程信息，可将线程隐藏起来，使调试器收不到消息</p>\n<p>DebugActiveProcessStop()则可以分离调试器和被调试线程</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef enum _THREADINFOCLASS &#123;\n\tThreadHideFromDebugger &#x3D; 0x11\n&#125; THREADINFOCLASS;\n\n&#x2F;&#x2F; MSDN\nNTSYSAPI NTSTATUS ZwSetInformationThread(\n  HANDLE          ThreadHandle,\n  THREADINFOCLASS ThreadInformationClass,\n  PVOID           ThreadInformation,\n  ULONG           ThreadInformationLength\n);</code></pre>\n\n<p>用法示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void Detach()\n&#123;\n\t&#x2F;&#x2F; get api\n\n\tHMODULE hNtdll &#x3D; GetModuleHandleW(L&quot;NtDll.dll&quot;);\n\tauto pZwSetInformationThread &#x3D; (PZwSetInformationThread)GetProcAddress(hNtdll, &quot;ZwSetInformationThread&quot;);\n\n\t&#x2F;&#x2F; detach\n\tpZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0);·\n&#125;\n\nvoid Stop()\n&#123;\n    &#x2F;&#x2F; #include &lt;windows.h&gt;\n    DebugActiveProcessStop(GetCurrentProcessId());\n&#125;</code></pre>\n\n<h2 id=\"51-7-TLS\"><a href=\"#51-7-TLS\" class=\"headerlink\" title=\"51.7 TLS\"></a>51.7 TLS</h2><p>tls回调函数会在ep之前执行（实际上是在创建终止进程时都会执行）</p>\n<p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma comment(linker, &quot;&#x2F;INCLUDE:__tls_used&quot;)\n\nvoid NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved);\n\n#pragma data_seg(&quot;.CRT$XLX&quot;)\nPIMAGE_TLS_CALLBACK pTLS_callbacks[] &#x3D; &#123; TLS_CALLBACK1, TLS_CALLBACK2 &#125;;\n#pragma data_seg()\n\nint main()\n&#123;\n    return 0;\n&#125;\n\nvoid NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)\n&#123;\n\tswitch (Reason) &#123;\n\tcase DLL_PROCESS_ATTACH:\n\t\tcout &lt;&lt; &quot;tls:process attach\\n\\n&quot;;\n        &#x2F;&#x2F; YourAntiDebug();\n\t\tbreak;\n\tcase DLL_THREAD_ATTACH:\n\t\tcout &lt;&lt; &quot;tls:thread attach\\n\\n&quot;;\n\t\tbreak;\n\tcase DLL_THREAD_DETACH:\n\t\tcout &lt;&lt; &quot;tls:thread detach\\n\\n&quot;;\n\t\tbreak;\n\tcase DLL_PROCESS_DETACH:\n\t\tcout &lt;&lt; &quot;tls:process detach\\n\\n&quot;;\n\t\tbreak;\n\t&#125;\n&#125;</code></pre>\n\n<h2 id=\"51-8-ETC\"><a href=\"#51-8-ETC\" class=\"headerlink\" title=\"51.8 ETC\"></a>51.8 ETC</h2><p>检测窗口 FindWindow()</p>\n<p>检测进程 CreateToolhelp32Snapshot()</p>\n<p>检测计算机名</p>\n<p>检测运行路径</p>\n<p>检测虚拟机</p>\n","text":"逆向工程核心原理 R3静态反调试 笔记摘要主要是R3层面的静态反调试手段 参考逆向工程核心原理51章静态反调试 涉及的API： IsDebuggerPresent() NtQueryInformationProcess() NtQuerySystemInformation() N...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Windows","slug":"Windows","count":19,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":19,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":25,"path":"api/tags/note.json"},{"name":"reversecore","slug":"reversecore","count":4,"path":"api/tags/reversecore.json"},{"name":"antiDebug","slug":"antiDebug","count":2,"path":"api/tags/antiDebug.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-R3%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95-%E7%AC%94%E8%AE%B0\"><span class=\"toc-text\">逆向工程核心原理 R3静态反调试 笔记</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%91%98%E8%A6%81\"><span class=\"toc-text\">摘要</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-2-%E6%B6%89%E5%8F%8Apeb%E7%9A%84%E6%A3%80%E6%9F%A5%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">51.2 涉及peb的检查方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-3-NtQueryInformationProcess\"><span class=\"toc-text\">51.3 NtQueryInformationProcess()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-4-NtQuerySystemInformation\"><span class=\"toc-text\">51.4 NtQuerySystemInformation()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-5-NtQueryObject\"><span class=\"toc-text\">51.5 NtQueryObject()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E8%BF%94%E5%9B%9E%E7%9A%84OBJECT-ALL-INFORMATION\"><span class=\"toc-text\">分析返回的OBJECT_ALL_INFORMATION</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">示例代码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-6-ZwSetInformationThread\"><span class=\"toc-text\">51.6 ZwSetInformationThread()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-7-TLS\"><span class=\"toc-text\">51.7 TLS</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-8-ETC\"><span class=\"toc-text\">51.8 ETC</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"《逆向工程实战》实例J","uid":"a1005445484098080c05958ea32d43c1","slug":"practicalreJ","date":"2021-10-22T04:00:00.000Z","updated":"2022-04-13T13:57:09.139Z","comments":true,"path":"api/articles/practicalreJ.json","keywords":null,"cover":null,"text":"《逆向工程实战》实例JDllMain 反编译尽量按汇编反编译结果（没有太多优化）： BOOL DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) &#123; char[8] idtr; unsigne...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"Windows","slug":"Windows","count":19,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":19,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":25,"path":"api/tags/note.json"},{"name":"practicalre","slug":"practicalre","count":5,"path":"api/tags/practicalre.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"pbctf21 btree wp","uid":"37d6e393a967114c82f7d8a550ead81e","slug":"pbctf21-btree-Wp","date":"2021-10-09T04:00:00.000Z","updated":"2021-11-05T11:34:18.434Z","comments":true,"path":"api/articles/pbctf21-btree-Wp.json","keywords":null,"cover":null,"text":"PBCTF21 RE BinaryTree Beaengine+dijkstra解法思路代码是动态解密的，简单的xor，解密一块执行一块。每一块结尾会设置rbx，rbx决定下一块被解密的代码。 实际上每一块代码相当于一个节点，里面有一个根据输入的jz，决定下一个rbx以及一个co...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"CTF","slug":"CTF","count":8,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":8,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":11,"path":"api/tags/re.json"},{"name":"wp","slug":"wp","count":7,"path":"api/tags/wp.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}