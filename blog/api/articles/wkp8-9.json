{"title":"《Windows Kernel Programming》 笔记 8~9 回调","uid":"334210967d7f70d0f127f10f28fddeb2","slug":"wkp8-9","date":"2022-03-01T04:00:00.000Z","updated":"2022-03-03T14:22:40.557Z","comments":true,"path":"api/articles/wkp8-9.json","keywords":null,"cover":null,"content":"<h1 id=\"Windows-Kernel-Programming-笔记-8-9-回调\"><a href=\"#Windows-Kernel-Programming-笔记-8-9-回调\" class=\"headerlink\" title=\"Windows Kernel Programming 笔记 8~9 回调\"></a>Windows Kernel Programming 笔记 8~9 回调</h1><h2 id=\"8-进程、线程通知（S5）\"><a href=\"#8-进程、线程通知（S5）\" class=\"headerlink\" title=\"8 进程、线程通知（S5）\"></a>8 进程、线程通知（S5）</h2><p>内核驱动一种重要的机制：在某些重要活动发生时通知驱动</p>\n<p>这章主要关于进程、线程的创建和销毁，还有映像的加载</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>使用这些回调的驱动程序必须在PE头中有 IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY 标志</p>\n<p>没有它，注册函数的调用返回 STATUS_ACCESS_DENIED </p>\n<p>需要在 链接器-&gt;命令行 中添加 <code>/integritycheck</code></p></blockquote>\n<h3 id=\"8-1-进程通知\"><a href=\"#8-1-进程通知\" class=\"headerlink\" title=\"8.1 进程通知\"></a>8.1 进程通知</h3><p>驱动可以在进程创建或销毁时收到通知</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>windows还提供另一种通知机制ETW，来记录进程的创建或销毁，这些通知可以被R3的进程接收</p>\n<p>但ETW有固定的1~3s的延迟</p></blockquote>\n<p>注册进程通知：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">NTSTATUS\nPsSetCreateProcessNotifyRoutineEx (\n\t_In_ PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,\n\t_In_ BOOLEAN Remove);\n\ntypedef void\n(*PCREATE_PROCESS_NOTIFY_ROUTINE_EX) (\n\t_Inout_ PEPROCESS Process,\n\t_In_ HANDLE ProcessId,\n\t_Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo);</code></pre>\n\n<p>进程退出通知的<code>CreateInfo</code>为<code>NULL</code></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>目前系统范围限制为 64 次注册，因此理论上注册功能可能会失败。 </p></blockquote>\n<p>当进程创建时，回调函数运行在<strong>创建进程的线程</strong>的上下文</p>\n<p>当进程退出时，回调函数运行在<strong>the last thread to exit the process</strong>的上下文</p>\n<p>回调函数都运行在<code>critical region</code>（normal kernel APCs disabled）</p>\n<p>提供给回调函数的参数的结构体：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _PS_CREATE_NOTIFY_INFO &#123;\n    _In_ SIZE_T Size;\n    union &#123;\n        _In_ ULONG Flags;\n        struct &#123;\n            _In_ ULONG FileOpenNameAvailable : 1;\n            _In_ ULONG IsSubsystemProcess : 1;\n            _In_ ULONG Reserved : 30;\n        &#125;;\n    &#125;;\n    _In_ HANDLE ParentProcessId;             &#x2F;&#x2F; 父进程\n    _In_ CLIENT_ID CreatingThreadId;         &#x2F;&#x2F; 创建进程的调用方\n    _Inout_ struct _FILE_OBJECT *FileObject;\n    _In_ PCUNICODE_STRING ImageFileName;\n    _In_opt_ PCUNICODE_STRING CommandLine;\n    _Inout_ NTSTATUS CreationStatus;         &#x2F;&#x2F; 返回给调用者\n&#125; PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;</code></pre>\n\n<p>ImageFileName：如果设置了标志 FileOpenNameAvailable 则可用 </p>\n<p>CreationStatus：设置为失败状态可以使进程创建失败（比如<code>STATUS_ACCESS_DENIED</code>）</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>win10 1607开始，提供了另外一个函数<code>PsSetCreateProcessNotifyRoutineEx2</code></p>\n<p>与之前的类似但<code>invoked on Pico processes</code>，用于WSL</p></blockquote>\n<h3 id=\"8-2-实现进程通知\"><a href=\"#8-2-实现进程通知\" class=\"headerlink\" title=\"8.2 实现进程通知\"></a>8.2 实现进程通知</h3><p>实现一个驱动记录所有进程的创建和销毁到一个链表中<br>使用fast mutex保证链表的安全</p>\n<p>结构体定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; common.h\n\nenum class RecordType : short &#123;\n    None,\n    ProcessCreate,\n    ProcessExit\n&#125;;\n\nstruct RecordHeader &#123;\n    RecordType type;\n    USHORT size;\n    LARGE_INTEGER time;\n&#125;;\n\nstruct ProcessCreateInfo : RecordHeader &#123;\n    ULONG pid;\n    ULONG parentPid;\n    USHORT cmdLength;\n    USHORT cmdOffset;\n&#125;;\n\nstruct ProcessExitInfo : RecordHeader &#123;\n    ULONG pid;\n&#125;;\n\n&#x2F;&#x2F; driver.h\n\ntemplate&lt;typename T&gt;\nstruct RecordEntry &#123;\n\tLIST_ENTRY Entry;\n\tT Data;\n&#125;;\n\nstruct RecordLinks &#123;\n\tLIST_ENTRY head;\n\tint count;\n\tMyFastMutex mutex;\n&#125;;</code></pre>\n\n\n\n<p>回调函数：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void OnProcessNotify(\n    PEPROCESS Process,\n    HANDLE ProcessId,\n\tPPS_CREATE_NOTIFY_INFO CreateInfo) &#123;\n    if (CreateInfo) &#123;\n    \t&#x2F;&#x2F; process create\n    &#125;\n    else &#123;\n    \t&#x2F;&#x2F; process exit\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"8-3-提供数据给用户模式\"><a href=\"#8-3-提供数据给用户模式\" class=\"headerlink\" title=\"8.3 提供数据给用户模式\"></a>8.3 提供数据给用户模式</h3><p>详情看代码吧</p>\n<h3 id=\"8-4-线程通知\"><a href=\"#8-4-线程通知\" class=\"headerlink\" title=\"8.4 线程通知\"></a>8.4 线程通知</h3><p>内核提供线程创建和销毁的回调机制</p>\n<p>API：<code>PsSetCreateThreadNotifyRoutine</code>、<code>PsRemoveCraeteThreadNotifyRoutine</code></p>\n<p>回调函数：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void OnThreadNotify(HANDLE ProcessId, HANDLE ThreadId, BOOLEAN Create) &#123;\n\t&#x2F;&#x2F; ...\n&#125;</code></pre>\n\n\n\n<h3 id=\"8-5-映像加载通知\"><a href=\"#8-5-映像加载通知\" class=\"headerlink\" title=\"8.5 映像加载通知\"></a>8.5 映像加载通知</h3><p>API：<code>PsSetLoadImageNotifyRoutine</code>、<code>PsRemoveLoadImageNotifyRoutine</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef void (*PLOAD_IMAGE_NOTIFY_ROUTINE)(\n    _In_opt_ PUNICODE_STRING FullImageName,\n    _In_ HANDLE ProcessId, &#x2F;&#x2F; pid into which image is being mapped\n    _In_ PIMAGE_INFO ImageInfo);\n\ntypedef struct _IMAGE_INFO &#123;\n    union &#123;\n        ULONG Properties;\n        struct &#123;\n            ULONG ImageAddressingMode : 8; &#x2F;&#x2F; Code addressing mode\n            ULONG SystemModeImage : 1; &#x2F;&#x2F; System mode image\n            ULONG ImageMappedToAllPids : 1; &#x2F;&#x2F; Image mapped into all processes\n            ULONG ExtendedInfoPresent : 1; &#x2F;&#x2F; IMAGE_INFO_EX available\n            ULONG MachineTypeMismatch : 1; &#x2F;&#x2F; Architecture type mismatch\n            ULONG ImageSignatureLevel : 4; &#x2F;&#x2F; Signature level\n            ULONG ImageSignatureType : 3; &#x2F;&#x2F; Signature type\n            ULONG ImagePartialMap : 1; &#x2F;&#x2F; Nonzero if entire image is not mapped\n            ULONG Reserved : 12;\n        &#125;;\n    &#125;;\n    PVOID ImageBase;\n    ULONG ImageSelector;\n    SIZE_T ImageSize;\n    ULONG ImageSectionNumber;\n&#125; IMAGE_INFO, *PIMAGE_INFO;</code></pre>\n\n<p>ExtendedInfoPresent：如果该标志位被设置，则<code>IMAGE_INFO</code>是<code>IMAGE_INFO_EX</code>的一部分</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>没有映像卸载的回调机制</p></blockquote>\n<p>ProcessId是加载该映像的进程的pid. 对于驱动程序（内核映像），此值为零。</p>\n<h3 id=\"8-6-练习\"><a href=\"#8-6-练习\" class=\"headerlink\" title=\"8.6 练习\"></a>8.6 练习</h3><ol>\n<li>创建一个驱动，监控进程创建；并提供一个客户端用于设置可执行路径黑名单（todo）</li>\n<li>创建一个驱动 （或给S5_SysMon添加功能)），检测远程线程创建（进程中的第一个线程总是“远程”创建的），并通知客户端。写一个测试程序，使用<code>CreateRemoteThread</code>。</li>\n</ol>\n<p><strong>2、检测远程线程创建：</strong></p>\n<p>思路：OnThreadNotify的在调用方上下文，检查当前上下文的进程的pid和创建线程的pid是否一致</p>\n<p>通过EPROCESS获取pid比通过pid获取EPROCESS简单一点:</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">PsGetProcessId  proc near\n    mov     rax, [rcx+440h] ; PEPROCESS-&gt;UniqueProcessId\n    retn\nPsGetProcessId  endp</code></pre>\n\n<p>检测代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void OnThreadNotify(HANDLE ProcessId, HANDLE ThreadId, BOOLEAN Create) &#123;\n\tif (Create) &#123;\n\t\tauto curPid &#x3D; PsGetCurrentProcessId();\n\t\tif (curPid !&#x3D; ProcessId) &#123;\n\t\t\tKdPrint((&quot;Detect remote thread create pid:%u tid:%u rpid:%u&quot;,\n\t\t\t\tHandleToULong(ProcessId),\n\t\t\t\tHandleToULong(ThreadId),\n\t\t\t\tHandleToULong(curPid)));\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>测试结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">被注入进程pid：3480\n注入器pid：5336\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n18:00:59.568: Thread Create\npid:3480 tid:3164\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n18:00:59.569: Image Load\npid:3480 ImageBase:0x6FC30000\nFullImageName:\\Device\\HarddiskVolume3\\Users\\wind\\Desktop\\MyDll.dll\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\nDetect remote thread create pid:3480 tid:3164 rpid:5336</code></pre>\n\n\n\n<h2 id=\"9-对象、注册表通知\"><a href=\"#9-对象、注册表通知\" class=\"headerlink\" title=\"9 对象、注册表通知\"></a>9 对象、注册表通知</h2><h3 id=\"9-1-对象通知\"><a href=\"#9-1-对象通知\" class=\"headerlink\" title=\"9.1 对象通知\"></a>9.1 对象通知</h3><p>驱动可以在打开或复制某些对象的句柄时，收到通知。这些对象的类型可以是进程、线程、Desktop(win10)</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Desktop 对象</p>\n<p>一个desktop包括windows、menus、hooks（SetWindowsHookEx）</p>\n<p>当一个用户登录，两个desktop会被创建。</p>\n<p>一个由<code>Winlogon.exe</code>创建名为<code>Winlogon</code>，就是<code>Secure Attention Sequence（Ctrl+Alt+Del）</code>时的桌面</p>\n<p>一个名为<code>default</code>，就是平常看到的桌面</p>\n<p>使用<code>SwitchDesktop()</code>切换desktop</p>\n<p><a href=\"https://scorpiosoftware.net/2019/02/17/windows-10-desktops-vs-sysinternals-desktops/\">https://scorpiosoftware.net/2019/02/17/windows-10-desktops-vs-sysinternals-desktops/</a></p></blockquote>\n<p>注册对象回调相关定义：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">NTSTATUS ObRegisterCallbacks (\n    _In_ POB_CALLBACK_REGISTRATION CallbackRegistration,\n    _Outptr_ PVOID *RegistrationHandle);\n\ntypedef struct _OB_CALLBACK_REGISTRATION &#123;\n    _In_ USHORT Version;\n    _In_ USHORT OperationRegistrationCount;\t\n    _In_ UNICODE_STRING Altitude;\n    _In_ PVOID RegistrationContext;\n    _In_ OB_OPERATION_REGISTRATION *OperationRegistration;\n&#125; OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;\n\ntypedef struct _OB_OPERATION_REGISTRATION &#123;\n    _In_ POBJECT_TYPE *ObjectType;\n    _In_ OB_OPERATION Operations;\n    _In_ POB_PRE_OPERATION_CALLBACK PreOperation;\n    _In_ POB_POST_OPERATION_CALLBACK PostOperation;\n&#125; OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION</code></pre>\n\n<p><strong>OB_CALLBACK_REGISTRATION：</strong></p>\n<p><code>Version</code>：必须设为<code>OB_FLT_REGISTRATION_VERSION</code></p>\n<p><code>Altitude</code>：字符串格式的数字，是回调执行的顺序（越小越先执行），必须不能与别的重复（增加随机的小数点后数字）</p>\n<p>Altitude重复会返回<code>STATUS_FLT_INSTANCE_ALTITUDE_COLLISION</code></p>\n<p><code>RegistrationContext</code>：驱动定义的传递给回调函数的值</p>\n<p><strong>OB_OPERATION_REGISTRATION：</strong></p>\n<p><code>ObjectType</code>：指向全局变量<code>PsProcessType</code>、<code>PsThreadType</code>、<code>ExDesktopObjectType</code></p>\n<p><code>Operations</code>：create/open(<code>OB_OPERATION_HANDLE_CREATE</code>)，duplicate(<code>OB_OPERATION_HANDLE_DUPLICATE</code>)</p>\n<h4 id=\"9-1-1-Pre-Operation-回调\"><a href=\"#9-1-1-Pre-Operation-回调\" class=\"headerlink\" title=\"9.1.1 Pre-Operation 回调\"></a>9.1.1 Pre-Operation 回调</h4><p>在craete/open/duplicate之前</p>\n<p>回调函数会接收到如下结构体：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 回调函数定义\nOB_PREOP_CALLBACK_STATUS OnPreOpenProcess(\n    PVOID RegistrationContext,\n    POB_PRE_OPERATION_INFORMATION Info)\n\ntypedef struct _OB_PRE_OPERATION_INFORMATION &#123;\n    _In_ OB_OPERATION Operation; &#x2F;&#x2F; craete&#x2F;open&#x2F;duplicate\n    union &#123;\n        _In_ ULONG Flags;\n        struct &#123;\n            _In_ ULONG KernelHandle:1;\n            _In_ ULONG Reserved:31;\n        &#125;;\n    &#125;;\n    _In_ PVOID Object;\n    _In_ POBJECT_TYPE ObjectType;\n    _Out_ PVOID CallContext; &#x2F;&#x2F; &lt;&#x3D;RegistrationContext\n    _In_ POB_PRE_OPERATION_PARAMETERS Parameters;\n&#125; OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;\n\ntypedef union _OB_PRE_OPERATION_PARAMETERS &#123;\n    _Inout_ OB_PRE_CREATE_HANDLE_INFORMATION CreateHandleInformation;\n    _Inout_ OB_PRE_DUPLICATE_HANDLE_INFORMATION DuplicateHandleInformation;\n&#125; OB_PRE_OPERATION_PARAMETERS, *POB_PRE_OPERATION_PARAMETERS;\n\ntypedef struct _OB_PRE_CREATE_HANDLE_INFORMATION &#123;\n    _Inout_ ACCESS_MASK DesiredAccess;\n    _In_ ACCESS_MASK OriginalDesiredAccess;\n&#125; OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;\n\ntypedef struct _OB_PRE_DUPLICATE_HANDLE_INFORMATION &#123;\n    _Inout_ ACCESS_MASK DesiredAccess;\n    _In_ ACCESS_MASK OriginalDesiredAccess;\n    _In_ PVOID SourceProcess;\n    _In_ PVOID TargetProcess;\n&#125; OB_PRE_DUPLICATE_HANDLE_INFORMATION, *POB_PRE_DUPLICATE_HANDLE_INFORMATION;</code></pre>\n\n\n\n<h4 id=\"9-1-2-Post-Operation-回调\"><a href=\"#9-1-2-Post-Operation-回调\" class=\"headerlink\" title=\"9.1.2 Post-Operation 回调\"></a>9.1.2 Post-Operation 回调</h4><p>在操作完成后，不能修改任何东西，只能看结果</p>\n<p>回调函数接收以下结构体：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _OB_POST_OPERATION_INFORMATION &#123;\n    _In_ OB_OPERATION Operation; &#x2F;&#x2F; craete&#x2F;open&#x2F;duplicate\n    union &#123;\n        _In_ ULONG Flags;\n        struct &#123;\n            _In_ ULONG KernelHandle:1;\n            _In_ ULONG Reserved:31;\n        &#125;;\n    &#125;;\n    _In_ PVOID Object;\n    _In_ POBJECT_TYPE ObjectType;\n    _In_ PVOID CallContext; &#x2F;&#x2F; &lt;&#x3D;RegistrationContext\n    _In_ NTSTATUS ReturnStatus;\n    _In_ POB_POST_OPERATION_PARAMETERS Parameters;\n&#125; OB_POST_OPERATION_INFORMATION,*POB_POST_OPERATION_INFORMATION;</code></pre>\n\n\n\n<h3 id=\"9-2-进程保护驱动（S6）\"><a href=\"#9-2-进程保护驱动（S6）\" class=\"headerlink\" title=\"9.2 进程保护驱动（S6）\"></a>9.2 进程保护驱动（S6）</h3><p>保护进程不被注销（禁止打开具有对应权限的句柄）</p>\n<p>修改进程对象的DesiredAccess即可</p>\n<p>也可以去掉Read、Write的Access，达到禁止读写的目的</p>\n<p>初始化：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">OB_OPERATION_REGISTRATION objOps[] &#x3D; &#123;\n    &#123;\n        PsProcessType,\n        OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE,\n        OnPreOpenProcess, &#x2F;&#x2F; pre\n        nullptr           &#x2F;&#x2F; post\n    &#125;\n&#125;;\nOB_CALLBACK_REGISTRATION objCallback &#x3D; &#123;\n    OB_FLT_REGISTRATION_VERSION,\n    1, &#x2F;&#x2F; count\n    RTL_CONSTANT_STRING(L&quot;12345.114514&quot;), &#x2F;&#x2F; altitude\n    nullptr, &#x2F;&#x2F; context\n    objOps\n&#125;;\nstatus &#x3D; ObRegisterCallbacks(&amp;objCallback, &amp;g_data.regHandle);\nif (status &lt; 0) break;</code></pre>\n\n<p>卸载：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">if(g_data.regHandle)\n\tObUnRegisterCallbacks(g_data.regHandle);</code></pre>\n\n<p>回调函数：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">OB_PREOP_CALLBACK_STATUS OnPreOpenProcess(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION Info) &#123;\n\tUNREFERENCED_PARAMETER(RegistrationContext);\n\n\tif (Info-&gt;KernelHandle)\n\t\treturn OB_PREOP_SUCCESS;\n\n\tauto proc &#x3D; (PEPROCESS)Info-&gt;Object;\n\tauto pid &#x3D; HandleToULong(PsGetProcessId(proc));\n\n\tAutoLock&lt;MyFastMutex&gt; lock(g_data.mutex);\n\n\tif (FindProcess(pid)) &#123;\n\t\tInfo-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess &amp;&#x3D; (~PROCESS_TERMINATE);\n\t&#125;\n\n\treturn OB_PREOP_SUCCESS;\n&#125;</code></pre>\n\n\n\n<h3 id=\"9-3-注册表通知\"><a href=\"#9-3-注册表通知\" class=\"headerlink\" title=\"9.3 注册表通知\"></a>9.3 注册表通知</h3><p>API：<code>CmRegisterCallbackEx</code>、<code>CmUnRegisterCallback</code></p>\n<p>回调函数说明（MSDN上的全一点）：<a href=\"https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nc-wdm-ex_callback_function\">EX_CALLBACK_FUNCTION (wdm.h) - Windows drivers | Microsoft Docs</a></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">NTSTATUS RegistryCallback (\n    _In_ PVOID CallbackContext,\n    _In_opt_ PVOID Argument1,\n    _In_opt_ PVOID Argument2);</code></pre>\n\n<p>部分内容：</p>\n<table>\n<thead>\n<tr>\n<th>Notification(Arg1)</th>\n<th>Associated structure(Arg2)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RegNtPreDeleteKey</td>\n<td>REG_DELETE_KEY_INFORMATION</td>\n</tr>\n<tr>\n<td>RegNtPostDeleteKey</td>\n<td>REG_POST_OPERATION_INFORMATION</td>\n</tr>\n<tr>\n<td>RegNtPreSetValueKey</td>\n<td>REG_SET_VALUE_KEY_INFORMATION</td>\n</tr>\n<tr>\n<td>RegNtPostSetValueKey</td>\n<td>REG_POST_OPERATION_INFORMATION</td>\n</tr>\n<tr>\n<td>RegNtPreCreateKey</td>\n<td>REG_PRE_CREATE_KEY_INFORMATION</td>\n</tr>\n<tr>\n<td>RegNtPostCreateKey</td>\n<td>REG_POST_CREATE_KEY_INFORMATION</td>\n</tr>\n</tbody></table>\n<p><strong>Pre</strong></p>\n<p>回调函数可以做的事：</p>\n<ul>\n<li>返回<code>STATUS_SUCCESS</code>，让配置管理器继续处理注册表操作</li>\n<li>返回一些错误状态，让配置管理器不执行操作，并将该错误状态返回给调用方</li>\n<li>处理请求，并返回<code>STATUS_CALLBACK_BYPASS</code>，配置管理器不执行任何操作，并将返回成功状态</li>\n</ul>\n<p><strong>Post</strong></p>\n<p>回调函数可以做的事：</p>\n<ul>\n<li>监视操作结果</li>\n<li>修改返回给调用方的状态（<code>ReturnStatus</code>），然后回调函数返回<code>STATUS_CALLBACK_BYPASS</code></li>\n<li>修改返回的参数（<code>REG_xxx_KEY_INFORMATION </code>），然后回调函数返回<code>STATUS_SUCCESS</code></li>\n</ul>\n<p><strong>性能注意事项</strong></p>\n<p>注册表的读操作经常发生，驱动应避免处理读操作<br>如果确实需要处理读操作，应限制只处理某些key</p>\n<p>写和创建操作相对比较少</p>\n<p>底线很简单：为尽可能少的键做尽可能少的事情 </p>\n<h3 id=\"9-4-实现注册表通知\"><a href=\"#9-4-实现注册表通知\" class=\"headerlink\" title=\"9.4 实现注册表通知\"></a>9.4 实现注册表通知</h3><p>拓展S5_SysMon，记录<code>RegNtPostSetValueKey</code>且在<code>HKEY_LOCAL_MACHINE</code>目录下的注册表操作</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; register\nUNICODE_STRING altitude &#x3D; RTL_CONSTANT_STRING(L&quot;7657.114514&quot;);\nstatus &#x3D; CmRegisterCallbackEx(\n    OnRegistryNotify,\n    &amp;altitude,\n    g_data.pDriverObj,\n    nullptr,\n    &amp;g_data.regCookie,\n    nullptr);\n\n&#x2F;&#x2F; unregister\nstatus &#x3D; CmUnRegisterCallback(g_data.regCookie);\n\n&#x2F;&#x2F; callback\nNTSTATUS OnRegistryNotify(_In_ PVOID CallbackContext, _In_opt_ PVOID Argument1, _In_opt_ PVOID Argument2) &#123;\n\tUNREFERENCED_PARAMETER(CallbackContext);\n\n\tstatic const WCHAR machine[] &#x3D; L&quot;\\\\REGISTRY\\\\MACHINE\\\\&quot;;\n\n\tauto status &#x3D; STATUS_SUCCESS;\n\n\tswitch ((REG_NOTIFY_CLASS)(ULONG_PTR)Argument1) &#123;\n\tcase RegNtPostSetValueKey: &#123;\n\t\tauto args &#x3D; (PREG_POST_OPERATION_INFORMATION)Argument2;\n\t\tif (!args) break;\n\t\tif (args-&gt;Status &lt; 0) break;\n\t\t\n\t\tPCUNICODE_STRING name &#x3D; nullptr;\n\t\tstatus &#x3D; CmCallbackGetKeyObjectIDEx(&amp;g_data.regCookie, args-&gt;Object, nullptr, &amp;name, 0);\n\t\tif (status &lt; 0) break;\n\n\t\tif (wcsncmp(name-&gt;Buffer, machine, ARRAYSIZE(machine) - 1) &#x3D;&#x3D; 0) &#123;\n\t\t\tauto preInfo &#x3D; (PREG_SET_VALUE_KEY_INFORMATION)args-&gt;PreInformation;\n\t\t\t&#x2F;&#x2F;if (!preInfo) break;\n\n\t\t\t&#x2F;&#x2F; alloc\n\t\t\tauto allocSize &#x3D; sizeof(RecordEntry&lt;RegistrySetValueInfo&gt;);\n\t\t\tauto recordEntry &#x3D; (RecordEntry&lt;RegistrySetValueInfo&gt;*)ExAllocatePoolWithTag(\n\t\t\t\tPagedPool,\n\t\t\t\tallocSize,\n\t\t\t\tDRIVER_TAG);\n\t\t\tif (recordEntry &#x3D;&#x3D; nullptr) break;\n\t\t\tRtlZeroMemory(recordEntry, allocSize);\n\t\t\t\n\t\t\tauto&amp; record &#x3D; recordEntry-&gt;Data;\n\t\t\trecord.type &#x3D; RecordType::RegistrySetValue;\n\t\t\trecord.size &#x3D; sizeof(RegistrySetValueInfo);\n\t\t\tKeQuerySystemTimePrecise(&amp;record.time);\n\t\t\trecord.pid &#x3D; HandleToULong(PsGetCurrentProcessId());\n\t\t\trecord.tid &#x3D; HandleToULong(PsGetCurrentThreadId());\n\t\t\twcsncpy_s(record.keyName, name-&gt;Buffer, name-&gt;Length &#x2F; sizeof(WCHAR) - 1);\n\t\t\twcsncpy_s(record.valueName, preInfo-&gt;ValueName-&gt;Buffer, preInfo-&gt;ValueName-&gt;Length &#x2F; sizeof(WCHAR) - 1);\n\t\t\trecord.dataType &#x3D; preInfo-&gt;Type;\n\t\t\trecord.dataSize &#x3D; preInfo-&gt;DataSize;\n\t\t\tmemcpy(record.data, preInfo-&gt;Data, min(record.dataSize, sizeof(record.data)));\n\n\t\t\tPushRecord(&amp;recordEntry-&gt;Entry);\n\t\t&#125;\n\n\t\tCmCallbackReleaseKeyObjectIDEx(name);\n\n\t\tbreak;\n\t&#125;\n\tdefault:\n\t\tbreak;\n\t&#125;\n\n\treturn status;\n&#125;</code></pre>\n\n\n\n<h3 id=\"9-5-练习\"><a href=\"#9-5-练习\" class=\"headerlink\" title=\"9.5 练习\"></a>9.5 练习</h3><ol>\n<li><p>实现一个驱动程序，除非目标进程正在被调试，否则不允许被线程注入。（todo）</p>\n</li>\n<li><p>实现一个驱动程序，保护注册表不被修改。客户端可以选择被保护的键。（todo）</p>\n</li>\n<li><p>实现一个驱动程序，如果它们访问 HKEY_LOCAL_MACHINE，则将来自选定进程（由客户端选择）的注册表写入操作重定向到它们自己的私钥。 如果应用程序正在写入数据，它会转到其私有存储。如果是读取数据，首先检查私有存储，如果没有值，则转到真正的注册表项。这是应用程序沙盒的一个方面。（todo）</p>\n</li>\n</ol>\n<h2 id=\"总结：通知的注册与注销\"><a href=\"#总结：通知的注册与注销\" class=\"headerlink\" title=\"总结：通知的注册与注销\"></a>总结：通知的注册与注销</h2><p>这里直接使用9.4中的练习：添加 I/O control codes 来 enable/disable 通知类型</p>\n<p>使用了bitmap来选择开启或关闭的通知</p>\n<p>这里整个函数都在互斥锁中（和记录通知的LIST_ENTRY用的同一个<code>FAST_MUTEX</code>），也就是不能同时修改bitmap，同时修改bitmap时、也无法向LIST_ENTRY中插入新记录的通知</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void SetNotify(UINT8 newBmNotify) &#123;\n\tAutoLock&lt;MyFastMutex&gt; lock(g_data.mutex);\n\tNTSTATUS status;\n\tUINT8 dif &#x3D; g_data.bmNotify ^ newBmNotify;\n\n\tdo &#123;\n\t\t&#x2F;&#x2F; process notification \n\t\tif (dif &amp; SYS_MON_PROCESS_NOTIFY) &#123;\n\t\t\tif (newBmNotify &amp; SYS_MON_PROCESS_NOTIFY)&#123;\n\t\t\t\tKdPrint((&quot;[s5]Process On&quot;));\n\t\t\t\tstatus &#x3D; PsSetCreateProcessNotifyRoutineEx(OnProcessNotify, false);\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\tKdPrint((&quot;[s5]Process Off&quot;));\n\t\t\t\tstatus &#x3D; PsSetCreateProcessNotifyRoutineEx(OnProcessNotify, true);\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F; thread notification\n\t\tif (dif &amp; SYS_MON_THREAD_NOTIFY) &#123;\n\t\t\tif (newBmNotify &amp; SYS_MON_THREAD_NOTIFY) &#123;\n\t\t\t\tKdPrint((&quot;[s5]Thread On&quot;));\n\t\t\t\tstatus &#x3D; PsSetCreateThreadNotifyRoutine(OnThreadNotify);\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\tKdPrint((&quot;[s5]Thread Off&quot;));\n\t\t\t\tstatus &#x3D; PsRemoveCreateThreadNotifyRoutine(OnThreadNotify);\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F; image load notification\n\t\tif (dif &amp; SYS_MON_IMAGE_LOAD_NOTIFY) &#123;\n\t\t\tif (newBmNotify &amp; SYS_MON_IMAGE_LOAD_NOTIFY) &#123;\n\t\t\t\tKdPrint((&quot;[s5]Image Load On&quot;));\n\t\t\t\tstatus &#x3D; PsSetLoadImageNotifyRoutine(OnImageNotify);\n\t\t\t&#125;\n\t\t\telse&#123;\n\t\t\t\tKdPrint((&quot;[s5]Image Load Off&quot;));\n\t\t\t\tstatus &#x3D; PsRemoveLoadImageNotifyRoutine(OnImageNotify);\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F; register notification\n\t\tif (dif &amp; SYS_MON_REGISTRY_SET_VALUE_NOTIFY) &#123;\n\t\t\tif (newBmNotify &amp; SYS_MON_REGISTRY_SET_VALUE_NOTIFY) &#123;\n\t\t\t\tKdPrint((&quot;[s5]Registry Set Value On&quot;));\n\t\t\t\tUNICODE_STRING altitude &#x3D; RTL_CONSTANT_STRING(L&quot;7657.114514&quot;);\n\t\t\t\tstatus &#x3D; CmRegisterCallbackEx(\n\t\t\t\t\tOnRegistryNotify,\n\t\t\t\t\t&amp;altitude,\n\t\t\t\t\tg_data.pDriverObj,\n\t\t\t\t\tnullptr,\n\t\t\t\t\t&amp;g_data.regCookie,\n\t\t\t\t\tnullptr);\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\tKdPrint((&quot;[s5]Registry Set Value Off&quot;));\n\t\t\t\tstatus &#x3D; CmUnRegisterCallback(g_data.regCookie);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125; while (false);\n\n\tg_data.bmNotify &#x3D; newBmNotify;\n&#125;</code></pre>\n\n\n\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>8，p196，使用注册表来设置保存的信息的最大数量（todo）</p>\n<p>8，p199，添加映像文件名到进程创建信息结构中（见S5_SysMon）</p>\n<p>8，p207，给客户端添加功能：显示线程创建和销毁时所属的进程的映像名（todo）</p>\n<p>8，p209，给驱动添加功能：只记录R3的映像加，客户端显示映像路径、pid、基址（见S5_SysMon）</p>\n<p>8.6，p209，Exercises（todo）</p>\n<p>9.2，p226，添加允许查询当前受保护进程的控制代码（todo）</p>\n<p>9.4，p235，改进 S5_SysMon， 添加 I/O control codes 来 enable/disable 通知类型（见总结：通知的注册与注销）</p>\n<p>9.5，p235，Exercises（todo）</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>8.6练习，如何通知R3客户端</p>\n<h2 id=\"勘误\"><a href=\"#勘误\" class=\"headerlink\" title=\"勘误\"></a>勘误</h2><p>8</p>\n<p>p207，<code>PsRemoveImageNotifyRoutine</code>应该为<code>PsRemoveLoadImageNotifyRoutine</code></p>\n","text":"Windows Kernel Programming 笔记 8~9 回调8 进程、线程通知（S5）内核驱动一种重要的机制：在某些重要活动发生时通知驱动 这章主要关于进程、线程的创建和销毁，还有映像的加载 使用这些回调的驱动程序必须在PE头中有 IMAGE_DLLCHARACTER...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"Windows","slug":"Windows","count":18,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":18,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":21,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":4,"path":"api/tags/kernel.json"},{"name":"wkp","slug":"wkp","count":3,"path":"api/tags/wkp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Windows-Kernel-Programming-%E7%AC%94%E8%AE%B0-8-9-%E5%9B%9E%E8%B0%83\"><span class=\"toc-text\">Windows Kernel Programming 笔记 8~9 回调</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%9F%A5%EF%BC%88S5%EF%BC%89\"><span class=\"toc-text\">8 进程、线程通知（S5）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-1-%E8%BF%9B%E7%A8%8B%E9%80%9A%E7%9F%A5\"><span class=\"toc-text\">8.1 进程通知</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-2-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%80%9A%E7%9F%A5\"><span class=\"toc-text\">8.2 实现进程通知</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-3-%E6%8F%90%E4%BE%9B%E6%95%B0%E6%8D%AE%E7%BB%99%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">8.3 提供数据给用户模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-4-%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%9F%A5\"><span class=\"toc-text\">8.4 线程通知</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-5-%E6%98%A0%E5%83%8F%E5%8A%A0%E8%BD%BD%E9%80%9A%E7%9F%A5\"><span class=\"toc-text\">8.5 映像加载通知</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-6-%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">8.6 练习</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E5%AF%B9%E8%B1%A1%E3%80%81%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%80%9A%E7%9F%A5\"><span class=\"toc-text\">9 对象、注册表通知</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-1-%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%9F%A5\"><span class=\"toc-text\">9.1 对象通知</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-1-1-Pre-Operation-%E5%9B%9E%E8%B0%83\"><span class=\"toc-text\">9.1.1 Pre-Operation 回调</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-1-2-Post-Operation-%E5%9B%9E%E8%B0%83\"><span class=\"toc-text\">9.1.2 Post-Operation 回调</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-2-%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8A%A4%E9%A9%B1%E5%8A%A8%EF%BC%88S6%EF%BC%89\"><span class=\"toc-text\">9.2 进程保护驱动（S6）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%80%9A%E7%9F%A5\"><span class=\"toc-text\">9.3 注册表通知</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-4-%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%80%9A%E7%9F%A5\"><span class=\"toc-text\">9.4 实现注册表通知</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-5-%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">9.5 练习</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A%E9%80%9A%E7%9F%A5%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%B3%A8%E9%94%80\"><span class=\"toc-text\">总结：通知的注册与注销</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">练习</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8B%98%E8%AF%AF\"><span class=\"toc-text\">勘误</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"《逆向工程实战》实例A","uid":"a8aaa1ce0f83038b9e68ef408652298f","slug":"practicalreA","date":"2022-03-07T04:00:00.000Z","updated":"2022-04-13T13:57:40.716Z","comments":true,"path":"api/articles/practicalreA.json","keywords":null,"cover":null,"text":"《逆向工程实战》实例A参照书上对实例A的分析过程，对实例A的完整分析记录 一个挺短的驱动后门（x86），用于支持R3程序修改SSDT，估计是xp或者win7时代的 DriverEntry &amp; DriverUnloadDosDevices是??的别名 DriverEntry...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"Windows","slug":"Windows","count":18,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":18,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":21,"path":"api/tags/note.json"},{"name":"practicalre","slug":"practicalre","count":5,"path":"api/tags/practicalre.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"SFU Compilers class 笔记1","uid":"9e0e6e8e4af299f867f70b1bab4c4ab9","slug":"SFU-Compilers-1","date":"2022-02-27T04:00:00.000Z","updated":"2022-07-10T14:23:05.109Z","comments":true,"path":"api/articles/SFU-Compilers-1.json","keywords":null,"cover":null,"text":"SFU Compilers 笔记1 简介week1 hw0 Week 1 Introduction to CompilersIN1 Evangelize Compliers内容： Lexing-词法分析 Parsing-句法分析 Type analysis-类型分析 代码生成和优...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"CS","slug":"CS","count":3,"path":"api/categories/CS.json"}],"tags":[{"name":"note","slug":"note","count":21,"path":"api/tags/note.json"},{"name":"cs","slug":"cs","count":3,"path":"api/tags/cs.json"},{"name":"compiler","slug":"compiler","count":3,"path":"api/tags/compiler.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}