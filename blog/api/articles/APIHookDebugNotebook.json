{"title":"APIHook 调试技术 笔记","uid":"647fdfb1f4686f6ba30a2feb4f787ced","slug":"APIHookDebugNotebook","date":"2021-06-17T14:10:00.000Z","updated":"2021-09-28T10:22:08.768Z","comments":true,"path":"api/articles/APIHookDebugNotebook.json","keywords":null,"cover":null,"content":"<h1 id=\"APIHook-调试技术-笔记\"><a href=\"#APIHook-调试技术-笔记\" class=\"headerlink\" title=\"APIHook-调试技术 笔记\"></a>APIHook-调试技术 笔记</h1><h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>技术摘要：</p>\n<p><strong>动态</strong>修改<strong>进程内存</strong>中的<strong>代码</strong>。利用<strong>调试</strong>技术附加到目标进程钩取API。</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>术语：</p>\n<p>debuger：调试器<br>debugee：被调试者</p></blockquote>\n<p>起源是逆向工程核心原理里面以记事本WriteFile()API钩取为例讲解利用调试来实现API钩取。<br>该例子目标是在文件保存时把小写转成大写。</p>\n<p>概括来说就是实现一个调试器，给对应api下断点。</p>\n<p>以记事本WriteFile()API为例，大概流程是作为调试器附加到notepad上，然后给WriteFile()的起始地址下个int 3断点，这样控制流就能回到调试器，就可以读取栈获得api参数了。</p>\n<p>大概流程如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1: 作为调试器附加\n2: 进入调试循环\n\n判断是否为int3断点，且断点位置为目标api起始地址\nOnException:\n  1: unhook\n  2: get thread context\n  3: your patch\n  4: change ctx(eip&#x2F;rip)\n  5: continue debugee\n  Sleep(0)\n  6: hook\n\n对于其他异常，交回给debugee的seh处理</code></pre>\n\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><p>首先是要注意32和64位的问题，然后可能需要获取Debug权限。</p>\n<h2 id=\"实例：记事本WriteFile-API（x32）\"><a href=\"#实例：记事本WriteFile-API（x32）\" class=\"headerlink\" title=\"实例：记事本WriteFile()API（x32）\"></a>实例：记事本WriteFile()API（x32）</h2><p>该例子对象是win10的x32的notepad.exe。</p>\n<h3 id=\"1-作为调试器附加\"><a href=\"#1-作为调试器附加\" class=\"headerlink\" title=\"1 作为调试器附加\"></a>1 作为调试器附加</h3><p>代码如下只有一行：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">DebugActiveProcess(dwPID);</code></pre>\n\n<p>附加失败会返回0，通过GetLastError()可以获取错误代码，x32的debuger附加x64的debugee会失败并得到0x32这个错误代码。</p>\n<p>成功后会发送一个CREATE_PROCESS_DEBUG_EVENT事件，可以被WaitForDebugEvent()获取。</p>\n<p>还有另外一种方法是用CreateProcess()来创建并附加一个进程。</p>\n<h3 id=\"2-调试循环\"><a href=\"#2-调试循环\" class=\"headerlink\" title=\"2 调试循环\"></a>2 调试循环</h3><p>附加成功后就要进入调试循环：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">DEBUG_EVENT de;\nDWORD dwDECode;\nDWORD dwContinueStatus;\n\n&#x2F;&#x2F; wait for debug event\nwhile (WaitForDebugEvent(&amp;de, INFINITE)) &#123;\n    dwContinueStatus &#x3D; DBG_EXCEPTION_NOT_HANDLED;\n    dwDECode &#x3D; de.dwDebugEventCode;\n    &#x2F;&#x2F; exception\n    if (dwDECode &#x3D;&#x3D; EXCEPTION_DEBUG_EVENT) &#123;\n        if (OnException(&amp;de))\n            continue;\n    &#125;\n    &#x2F;&#x2F; on create or attach debug event\n    else if (dwDECode &#x3D;&#x3D; CREATE_PROCESS_DEBUG_EVENT) &#123;\n        OnCreate(&amp;de);\n        dwContinueStatus &#x3D; DBG_CONTINUE;\n    &#125;\n    &#x2F;&#x2F; debuggee exit\n    else if (dwDECode &#x3D;&#x3D; EXIT_PROCESS_DEBUG_EVENT) &#123;\n        break;\n    &#125;\n    &#x2F;&#x2F; continue to run debuggee\n    ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus);\n&#125;</code></pre>\n\n<p>WaitForDebugEvent()用于等待调试事件。第一个参数用于接收调试信息；第二个为等待时间(ms)，如果等待时间为INFINITE(0xFFFFFFFF)则会一直等待直到有调试时间再返回，这时debugee会被挂起。</p>\n<h3 id=\"3-处理调试事件\"><a href=\"#3-处理调试事件\" class=\"headerlink\" title=\"3 处理调试事件\"></a>3 处理调试事件</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; minwinbase.h\ntypedef struct _DEBUG_EVENT &#123;\n    DWORD dwDebugEventCode;\n    DWORD dwProcessId;\n    DWORD dwThreadId;\n    union &#123;\n        EXCEPTION_DEBUG_INFO Exception;\n        CREATE_THREAD_DEBUG_INFO CreateThread;\n        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;\n        EXIT_THREAD_DEBUG_INFO ExitThread;\n        EXIT_PROCESS_DEBUG_INFO ExitProcess;\n        LOAD_DLL_DEBUG_INFO LoadDll;\n        UNLOAD_DLL_DEBUG_INFO UnloadDll;\n        OUTPUT_DEBUG_STRING_INFO DebugString;\n        RIP_INFO RipInfo;\n    &#125; u;\n&#125; DEBUG_EVENT, *LPDEBUG_EVENT;</code></pre>\n\n<p><strong>EXCEPTION_DEBUG_EVENT</strong><br>(u.Exception = EXCEPTION_DEBUG_INFO)<br>为异常调试事件，<strong>int 3</strong>中断时会触发该事件，这时我们需要执行自己的代码，具体见“6 异常调试事件”。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; minwinbase.h\ntypedef struct _EXCEPTION_DEBUG_INFO &#123;\n    EXCEPTION_RECORD ExceptionRecord;\n    DWORD dwFirstChance;\n&#125; EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;\n&#x2F;&#x2F; winnt.h\ntypedef struct _EXCEPTION_RECORD &#123;\n    DWORD    ExceptionCode;\n    DWORD ExceptionFlags;\n    struct _EXCEPTION_RECORD *ExceptionRecord;\n    PVOID ExceptionAddress;\n    DWORD NumberParameters;\n    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];\n&#125; EXCEPTION_RECORD;</code></pre>\n\n<p><strong>CREATE_PROCESS_DEBUG_EVENT</strong><br>(u.CreateProcessInfo = CREATE_PROCESS_DEBUG_INFO)<br>在<strong>刚附加</strong>到debugee时会触发，这时需要完成hook，具体见“5 首次hook”。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; minwinbase.h\ntypedef struct _CREATE_PROCESS_DEBUG_INFO &#123;\n    HANDLE hFile;\n    HANDLE hProcess;\n    HANDLE hThread;\n    LPVOID lpBaseOfImage;\n    DWORD dwDebugInfoFileOffset;\n    DWORD nDebugInfoSize;\n    LPVOID lpThreadLocalBase;\n    LPTHREAD_START_ROUTINE lpStartAddress;\n    LPVOID lpImageName;\n    WORD fUnicode;\n&#125; CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;</code></pre>\n\n<p><strong>EXIT_PROCESS_DEBUG_EVENT</strong><br>(u.ExitProcess = EXIT_PROCESS_DEBUG_INFO)<br>在debugee退出时触发。</p>\n<h3 id=\"4-继续运行debugee\"><a href=\"#4-继续运行debugee\" class=\"headerlink\" title=\"4 继续运行debugee\"></a>4 继续运行debugee</h3><p>处理完调试事件后，调用ContinueDebugEvent()以继续运行debugee。</p>\n<p>ContinueDebugEvent第三个参数比较特殊，如果处理成功设置为DBG_CONTINUE即可，如果不能处理设置成DBG_EXCEPTION_NOT_HANDLED让seh来处理。</p>\n<h3 id=\"5-首次hook\"><a href=\"#5-首次hook\" class=\"headerlink\" title=\"5 首次hook\"></a>5 首次hook</h3><p>该事件在刚附加时触发一次，这时我们需要完成对API的hook：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bool OnCreate(DEBUG_EVENT* pde)\n&#123;\n    &#x2F;&#x2F; get api address\n\n    hKernel32 &#x3D; GetModuleHandleW(L&quot;kernel32.dll&quot;);\n    if (hKernel32 &#x3D;&#x3D; 0) &#123; cout &lt;&lt; &quot;Get kernel32.dll failed.\\n&quot;; return false; &#125;\n    pWriteFile &#x3D; GetProcAddress(hKernel32, &quot;WriteFile&quot;);\n    if (pWriteFile &#x3D;&#x3D; 0) &#123; cout &lt;&lt; &quot;Get WriteFile() failed.\\n&quot;; return false; &#125;\n\n    &#x2F;&#x2F; hook\n\n    memcpy(&amp;cpdi, &amp;pde-&gt;u.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_INFO));\n    ReadProcessMemory(cpdi.hProcess, pWriteFile, &amp;chOrigin, 1, NULL);\n    WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chINT3, 1, NULL);\n\n    return true;\n&#125;</code></pre>\n\n<p>kernel32在不同进程中加载到同样位置，直接在本进程GetModuleHandleW就行。</p>\n<p>需要注意的是把CreateProcessInfo保存下来，其中有一些信息比如debugee的进程、线程id我们在接下来的再次hook时也需要使用。</p>\n<h3 id=\"6-异常调试事件（补丁代码）\"><a href=\"#6-异常调试事件（补丁代码）\" class=\"headerlink\" title=\"6 异常调试事件（补丁代码）\"></a>6 异常调试事件（补丁代码）</h3><p>发生异常调试事件时触发，如果为int3且断点为目标api地址就执行我们的补丁，这里我们的补丁是把文本的小写字母转换成大写：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">bool OnException(DEBUG_EVENT* pde)\n&#123;\n    CONTEXT ctx;\n    PEXCEPTION_RECORD per &#x3D; &amp;pde-&gt;u.Exception.ExceptionRecord;\n    DWORD dwBuffer, dwNum; &#x2F;&#x2F; WriteFile() param 2, 3\n    PBYTE lpBuffer &#x3D; NULL;\n\n    int i;\n\n    &#x2F;&#x2F; int 3\n    if (per-&gt;ExceptionCode &#x3D;&#x3D; EXCEPTION_BREAKPOINT) &#123;\n        &#x2F;&#x2F; breakpoint address\n        if (per-&gt;ExceptionAddress &#x3D;&#x3D; pWriteFile) &#123;\n            &#x2F;&#x2F; 1: unhook\n            WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chOrigin, 1, NULL);\n\n            &#x2F;&#x2F; 2: get thread context\n            ctx.ContextFlags &#x3D; CONTEXT_CONTROL;\n            GetThreadContext(cpdi.hThread, &amp;ctx);\n\n            &#x2F;&#x2F; 3.1: get WriteFile() param 2, 3\n            ReadProcessMemory(cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;dwBuffer, 4, NULL);\n            ReadProcessMemory(cpdi.hProcess, (LPVOID)(ctx.Esp + 0xC), &amp;dwNum, 4, NULL);\n\n            &#x2F;&#x2F; 3.2: malloc buffer\n            lpBuffer &#x3D; (PBYTE)malloc(dwNum + 1);\n            memset(lpBuffer, 0, dwNum + 1);\n\n            &#x2F;&#x2F; 3.3: copy to buffer\n            ReadProcessMemory(cpdi.hProcess, (LPVOID)dwBuffer, lpBuffer, dwNum, NULL);\n            cout &lt;&lt; &quot;\\nOrigin:\\n&quot; &lt;&lt; lpBuffer &lt;&lt; endl;\n\n            &#x2F;&#x2F; 3.4: Convert\n            for (i &#x3D; 0; i &lt; dwNum; i++) &#123;\n                if (&#39;a&#39; &lt;&#x3D; lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;&#x3D; &#39;z&#39;)\n                    lpBuffer[i] -&#x3D; 0x20;\n            &#125;\n            cout &lt;&lt; &quot;\\nConverted:\\n&quot; &lt;&lt; lpBuffer &lt;&lt; endl;\n\n            &#x2F;&#x2F; 3.5: copy back\n            WriteProcessMemory(cpdi.hProcess, (LPVOID)dwBuffer, lpBuffer, dwNum, NULL);\n            free(lpBuffer);\n\n            &#x2F;&#x2F; 4: change ctx(eip)\n            ctx.Eip &#x3D; (DWORD)pWriteFile;\n            SetThreadContext(cpdi.hThread, &amp;ctx);\n\n            &#x2F;&#x2F; 5: run\n            ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE);\n\n            Sleep(0);\n\n            &#x2F;&#x2F; 6: hook\n            WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chINT3, 1, NULL);\n\n            return true;\n        &#125;\n    &#125;\n\n    return false;\n&#125;</code></pre>\n\n<p>流程是unhook -&gt; 获取上下文 -&gt; 补丁 -&gt; 恢复eip/rip -&gt; 继续运行debugee -&gt; 恢复hook</p>\n<p>在继续运行debugee之后需要Sleep(0)再恢复hook，是因为hook会修改内存中的代码，此时debugee也在运行同一段内存的代码，可能会发生内存访问异常。Sleep(0)可以释放当前线程的剩余时间，让cpu先去执行其他线程，然后再回来恢复hook。</p>\n<p>其中需要用到api的参数，这里简单分析下此时的栈。此时刚刚进入函数，还未push ebp，所以esp指向旧的栈顶，也就是函数放回地址。32位以寄存器传参，第n的参数此时在esp+4*n的位置。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>逆向工程核心原理：part4-API钩取：第30章-记事本WriteFile()API钩取</p>\n","text":"APIHook-调试技术 笔记摘要 技术摘要： 动态修改进程内存中的代码。利用调试技术附加到目标进程钩取API。 术语： debuger：调试器debugee：被调试者 起源是逆向工程核心原理里面以记事本WriteFile()API钩取为例讲解利用调试来实现API钩取。该例子目标...","link":"","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"Windows","slug":"Windows","count":14,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":14,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":15,"path":"api/tags/note.json"},{"name":"api_hook","slug":"api-hook","count":3,"path":"api/tags/api-hook.json"},{"name":"reversecore","slug":"reversecore","count":4,"path":"api/tags/reversecore.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#APIHook-%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0\"><span class=\"toc-text\">APIHook-调试技术 笔记</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%91%98%E8%A6%81\"><span class=\"toc-text\">摘要</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">细节</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile-API%EF%BC%88x32%EF%BC%89\"><span class=\"toc-text\">实例：记事本WriteFile()API（x32）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BD%9C%E4%B8%BA%E8%B0%83%E8%AF%95%E5%99%A8%E9%99%84%E5%8A%A0\"><span class=\"toc-text\">1 作为调试器附加</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%B0%83%E8%AF%95%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">2 调试循环</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%A4%84%E7%90%86%E8%B0%83%E8%AF%95%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">3 处理调试事件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%BB%A7%E7%BB%AD%E8%BF%90%E8%A1%8Cdebugee\"><span class=\"toc-text\">4 继续运行debugee</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E9%A6%96%E6%AC%A1hook\"><span class=\"toc-text\">5 首次hook</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%BC%82%E5%B8%B8%E8%B0%83%E8%AF%95%E4%BA%8B%E4%BB%B6%EF%BC%88%E8%A1%A5%E4%B8%81%E4%BB%A3%E7%A0%81%EF%BC%89\"><span class=\"toc-text\">6 异常调试事件（补丁代码）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"APIHook DLL注入实现IAT钩取 笔记","uid":"cc4abc1dfb3fac0a8ab6b7033be4ca99","slug":"APIHookDllIATCalc","date":"2021-06-19T06:22:00.000Z","updated":"2021-09-28T10:22:11.422Z","comments":true,"path":"api/articles/APIHookDllIATCalc.json","keywords":null,"cover":null,"text":"APIHook - DLL注入实现IAT钩取 笔记摘要 技术摘要： 动态修改进程内存中的IAT。利用DLL注入修改API的IAT。 起源是逆向工程核心原理里面以计算器SetWindowText()API钩取为例讲解利用dll注入修改api的iat来实现钩取。该例子目标是把显示的阿...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"Windows","slug":"Windows","count":14,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":14,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":15,"path":"api/tags/note.json"},{"name":"api_hook","slug":"api-hook","count":3,"path":"api/tags/api-hook.json"},{"name":"reversecore","slug":"reversecore","count":4,"path":"api/tags/reversecore.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"21KctfSpring","uid":"546d298359e46b393eada3f4824c48b0","slug":"21KctfSpring","date":"2021-06-02T12:43:07.000Z","updated":"2021-09-28T10:22:05.596Z","comments":true,"path":"api/articles/21KctfSpring.json","keywords":null,"cover":null,"text":"21 kctf 春2 南冥神功分析main函数 1 char 2 intchars_table &#x3D; &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; while(v24 !&#x3D; ++v23) &#123; if(...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"CTF","slug":"CTF","count":7,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":7,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":10,"path":"api/tags/re.json"},{"name":"wp","slug":"wp","count":7,"path":"api/tags/wp.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}