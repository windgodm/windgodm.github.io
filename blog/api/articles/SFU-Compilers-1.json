{"title":"SFU Compilers class 笔记1","uid":"9e0e6e8e4af299f867f70b1bab4c4ab9","slug":"SFU-Compilers-1","date":"2022-02-27T04:00:00.000Z","updated":"2022-07-10T14:23:05.109Z","comments":true,"path":"api/articles/SFU-Compilers-1.json","keywords":null,"cover":null,"content":"<h1 id=\"SFU-Compilers-笔记1-简介\"><a href=\"#SFU-Compilers-笔记1-简介\" class=\"headerlink\" title=\"SFU Compilers 笔记1 简介\"></a>SFU Compilers 笔记1 简介</h1><p>week1 hw0</p>\n<h2 id=\"Week-1-Introduction-to-Compilers\"><a href=\"#Week-1-Introduction-to-Compilers\" class=\"headerlink\" title=\"Week 1 Introduction to Compilers\"></a>Week 1 Introduction to Compilers</h2><h3 id=\"IN1-Evangelize-Compliers\"><a href=\"#IN1-Evangelize-Compliers\" class=\"headerlink\" title=\"IN1 Evangelize Compliers\"></a>IN1 Evangelize Compliers</h3><p>内容：</p>\n<ul>\n<li>Lexing-词法分析</li>\n<li>Parsing-句法分析</li>\n<li>Type analysis-类型分析</li>\n<li>代码生成和优化</li>\n</ul>\n<p>分析下面这两段代码：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void send (char *to, char *from, int count)\n&#123; \n    while (count-- &gt; 0)\n    *to++ &#x3D; *from++;\n&#125;\n\n\nvoid send2 (char *to, char *from, int count)\n&#123; \n    int n &#x3D; (count+7)&#x2F;8; \n    switch (count % 8) &#123; \n    case 0: do &#123; *to++ &#x3D; *from++; \n    case 7: \t *to++ &#x3D; *from++; \n    case 6: \t *to++ &#x3D; *from++; \n    case 5: \t *to++ &#x3D; *from++; \n    case 4: \t *to++ &#x3D; *from++; \n    case 3: \t *to++ &#x3D; *from++; \n    case 2: \t *to++ &#x3D; *from++; \n    case 1: \t *to++ &#x3D; *from++;\n    \t&#125; while(--n &gt; 0); \n    &#125;\n&#125;</code></pre>\n\n<p>第二个switch实际上就是一个goto，跳到do-while循环里</p>\n<h3 id=\"IN2-Trusting-Trust\"><a href=\"#IN2-Trusting-Trust\" class=\"headerlink\" title=\"IN2 Trusting Trust\"></a>IN2 Trusting Trust</h3><p>Quine是一个生成自身源代码的程序</p>\n<p>c语言例子，源代码编译出来的可执行程序会输出源代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\nint main()&#123;char *c&#x3D;&quot;#include &lt;stdio.h&gt;%cint main()&#123;char \n*c&#x3D;%c%s%c;printf(c,10,34,c,34,10);&#125;%c&quot;;printf(c,10,34,c,34,10);&#125;</code></pre>\n\n\n\n<p>编译器也有源代码，也需要编译器的编译器来把编译器的源代码编译成编译器</p>\n<p>源代码 不等于 编译出来的可执行文件</p>\n<p>编译器可以插入恶意二进制指令到编译结果中<br>这时编译器的源码是恶意的，而被编译程序的源码是正常的</p>\n<p>更进一步的，编译器的编译器可能会恶意插入指令到编译器中<br>既编译器的源码是正常的，但编译出来的编译器被插入了恶意指令</p>\n<h3 id=\"IN3-What-is-a-Compiler\"><a href=\"#IN3-What-is-a-Compiler\" class=\"headerlink\" title=\"IN3 What is a Compiler\"></a>IN3 What is a Compiler</h3><p><strong>编译器的需求</strong></p>\n<ul>\n<li>支持高级语言特性</li>\n<li>易读的错误信息</li>\n<li>编译速度</li>\n<li>可执行文件速度</li>\n</ul>\n<p><strong>Bootstrapping a Compiler</strong></p>\n<ul>\n<li>先使用机器代码</li>\n<li>制作语言的简单的子集，为其写编译器</li>\n<li>用子集完成语言剩余部分</li>\n<li>解释器：用低级语言写编译器（比如python解释器用C语言编写）</li>\n<li>交叉编译</li>\n</ul>\n<p><strong>Modern challenges</strong></p>\n<ul>\n<li>指令并行性（乱序执行、分支预测）</li>\n<li>并行算法（网格计算、多核计算机）</li>\n<li>内存层级结构：寄存器、缓存、内存</li>\n<li>新架构：GPU、量子计算机、DNA计算机</li>\n<li>硬件级优化（终端内循环优化）</li>\n</ul>\n<h3 id=\"IN4-Stages-of-a-Compiler\"><a href=\"#IN4-Stages-of-a-Compiler\" class=\"headerlink\" title=\"IN4 Stages of a Compiler\"></a>IN4 Stages of a Compiler</h3><p><strong>Building a compiler</strong></p>\n<p>编译器的编译器：</p>\n<ul>\n<li>yacc = yet another compiler compiler</li>\n<li>bison = yacc的一个版本，GNU项目</li>\n</ul>\n<p><strong>Stages of a Compiler</strong></p>\n<ul>\n<li>分析（前端）<ul>\n<li>词法分析（Lexing）</li>\n<li>语法分析（Sytax、Parsing）</li>\n<li>语义分析（类型检查）</li>\n</ul>\n</li>\n<li>合成（后端）<ul>\n<li>中间代码生成</li>\n<li>代码优化</li>\n<li>代码生成</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"hw0\"><a href=\"#hw0\" class=\"headerlink\" title=\"hw0\"></a>hw0</h2><h3 id=\"windows配置\"><a href=\"#windows配置\" class=\"headerlink\" title=\"windows配置\"></a>windows配置</h3><p>获取作业文件：</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">git clone https:&#x2F;&#x2F;github.com&#x2F;anoopsarkar&#x2F;compilers-class-hw.git</code></pre>\n\n\n\n<p><code>rmprefix</code>目录中有用于测试的python脚本</p>\n<p><code>answer/default.cc</code>为未完成的作业，复制为<code>answer/rmprefix.cc</code>并完成</p>\n<p><code>python zipout.py</code>：在测试集上运行，并得到结果</p>\n<p><code>python check.py</code>：检测结果的正确率</p>\n<p><strong>windows平台操作指南：</strong></p>\n<p>在<code>answer</code>目录下使用powshell编译</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">g++ rmprefix.cc -o rmprefix.</code></pre>\n\n<p>在<code>rmprefix</code>目录下使用wsl</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">python3 zipout.py\npython3 check.py</code></pre>\n\n\n\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>解决方案1：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">line.erase(0, line.find_first_not_of(&#39;\\t&#39;));\nline.erase(0, line.find_first_not_of(&#39; &#39;));</code></pre>\n\n<p>解决方案2：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int fn &#x3D; 0;\nfor (fn &#x3D; 0; line[fn]; fn++)&#123;\n    if(line[fn] &#x3D;&#x3D; &#39; &#39;)\n    \tcontinue;\n    if(line[fn] &#x3D;&#x3D; &#39;\\t&#39;)\n    \tcontinue;\n    break;\n&#125;\nline.erase(0, fn);</code></pre>\n\n","text":"SFU Compilers 笔记1 简介week1 hw0 Week 1 Introduction to CompilersIN1 Evangelize Compliers内容： Lexing-词法分析 Parsing-句法分析 Type analysis-类型分析 代码生成和优...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"CS","slug":"CS","count":6,"path":"api/categories/CS.json"}],"tags":[{"name":"note","slug":"note","count":25,"path":"api/tags/note.json"},{"name":"cs","slug":"cs","count":6,"path":"api/tags/cs.json"},{"name":"compiler","slug":"compiler","count":6,"path":"api/tags/compiler.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SFU-Compilers-%E7%AC%94%E8%AE%B01-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">SFU Compilers 笔记1 简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Week-1-Introduction-to-Compilers\"><span class=\"toc-text\">Week 1 Introduction to Compilers</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IN1-Evangelize-Compliers\"><span class=\"toc-text\">IN1 Evangelize Compliers</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IN2-Trusting-Trust\"><span class=\"toc-text\">IN2 Trusting Trust</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IN3-What-is-a-Compiler\"><span class=\"toc-text\">IN3 What is a Compiler</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IN4-Stages-of-a-Compiler\"><span class=\"toc-text\">IN4 Stages of a Compiler</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#hw0\"><span class=\"toc-text\">hw0</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#windows%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">windows配置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">解决方案</span></a></li></ol></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"《Windows Kernel Programming》 笔记 8~9 回调","uid":"334210967d7f70d0f127f10f28fddeb2","slug":"wkp8-9","date":"2022-03-01T04:00:00.000Z","updated":"2022-03-03T14:22:40.557Z","comments":true,"path":"api/articles/wkp8-9.json","keywords":null,"cover":null,"text":"Windows Kernel Programming 笔记 8~9 回调8 进程、线程通知（S5）内核驱动一种重要的机制：在某些重要活动发生时通知驱动 这章主要关于进程、线程的创建和销毁，还有映像的加载 使用这些回调的驱动程序必须在PE头中有 IMAGE_DLLCHARACTER...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"Windows","slug":"Windows","count":19,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":19,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":25,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":5,"path":"api/tags/kernel.json"},{"name":"wkp","slug":"wkp","count":3,"path":"api/tags/wkp.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"《Windows Kernel Programming》 笔记 6~7 内核机制与IRP","uid":"08a6adcddaf28cd0d0b42adf778ccd2a","slug":"wkp6-7","date":"2022-01-02T04:00:00.000Z","updated":"2022-02-25T10:01:23.134Z","comments":true,"path":"api/articles/wkp6-7.json","keywords":null,"cover":[],"text":"Windows Kernel Programming 笔记 6~7 内核机制与IRP6 内核机制关于windows内核提供的一些机制。这些机制，驱动开发会使用，或者有关。 6.1 中断优先级中断处理例程（Interrupt Service Routine，ISR） 中断优先级（I...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"18 mins."},"categories":[{"name":"Windows","slug":"Windows","count":19,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":19,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":25,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":5,"path":"api/tags/kernel.json"},{"name":"wkp","slug":"wkp","count":3,"path":"api/tags/wkp.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}