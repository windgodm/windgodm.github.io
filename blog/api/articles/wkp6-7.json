{"title":"《Windows Kernel Programming》 笔记 6~7 内核机制与IRP","uid":"08a6adcddaf28cd0d0b42adf778ccd2a","slug":"wkp6-7","date":"2022-01-02T04:00:00.000Z","updated":"2022-02-25T10:01:23.134Z","comments":true,"path":"api/articles/wkp6-7.json","keywords":null,"cover":[],"content":"<h1 id=\"Windows-Kernel-Programming-笔记-6-7-内核机制与IRP\"><a href=\"#Windows-Kernel-Programming-笔记-6-7-内核机制与IRP\" class=\"headerlink\" title=\"Windows Kernel Programming 笔记 6~7 内核机制与IRP\"></a>Windows Kernel Programming 笔记 6~7 内核机制与IRP</h1><h2 id=\"6-内核机制\"><a href=\"#6-内核机制\" class=\"headerlink\" title=\"6 内核机制\"></a>6 内核机制</h2><p>关于windows内核提供的一些机制。这些机制，驱动开发会使用，或者有关。</p>\n<h3 id=\"6-1-中断优先级\"><a href=\"#6-1-中断优先级\" class=\"headerlink\" title=\"6.1 中断优先级\"></a>6.1 中断优先级</h3><p>中断处理例程（Interrupt Service Routine，ISR）</p>\n<p>中断优先级（Interrupt Request Level，IRQL）：每个硬件中断关联的一个优先级</p>\n<p>每个处理器有自身的IRQL</p>\n<p>IRQL可以等价于CPU的一个寄存器</p>\n<p>所有ISR都运行在发生中断前的线程的上下文中</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>The interrupted thread does not get its quantum reduced because of these “interruptions”. It’s not its fault, so to speak.</p></blockquote>\n<p>IRQL：</p>\n<ul>\n<li>PASSIVE_LEVEL（0）：R3及大多数R0代码工作于此优先级。可以线程调度。</li>\n<li>APC_LEVEL（1）：特殊的内核APC。可以线程调度。</li>\n<li>DISPATCH_LEVEL（2）：调度器被屏蔽；页池(Paged memory)不能访问；不允许等待内核对象（这回造成系统崩溃）</li>\n<li>Device IRQL：硬件中断</li>\n<li>HIGH_LEVEL：屏蔽所有中断；通常用于处理链表的API（原子性）</li>\n</ul>\n<p>当 IRQL &gt;= 2：</p>\n<ul>\n<li>访问页池是危险的，应只使用非页池内存</li>\n<li>等待内核对象会导致系统崩溃（如果等待超时为0则被允许，用于同步）</li>\n</ul>\n<p>调度器“运行”在IRQL2，IRQL&gt;=2时调度器将被屏蔽</p>\n<p>[windbg]：<code>! irql</code>查看当前cpu IRQL</p>\n<p>[windbg]：<code>! idt </code>查看已注册的中断</p>\n<p><strong>提高和降低IRQL</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">KIRQL oldIrql;\nKeRaiseIrql(DISPATCH_LEVEL, &amp;oldIrql);\n&#x2F;&#x2F; pass\nKeLowerIrql(oldIrql);</code></pre>\n\n\n\n<p><strong>线程优先级与IRQL</strong></p>\n<p>IRQL是处理器的属性</p>\n<p>线程优先级只有在IRQL&lt;2时才有意义</p>\n<p>任务管理器中以伪进程 系统中断 显示IRQL&gt;=2的运行时间</p>\n<h3 id=\"6-2-DPC\"><a href=\"#6-2-DPC\" class=\"headerlink\" title=\"6.2 DPC\"></a>6.2 DPC</h3><p>延迟过程调用，Deferred Procedure Calls，DPC</p>\n<p>硬件中断的IRQl&gt;2，IoCompleteRequest只能在<code>IRQL&lt;=DISPATCH_LEVEL(2)</code>时调用</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果不用DPC，而是选择降低IRQL调用IoCompleteRequest，再提升回去，会造成死锁，原因见 Spin Lock 章节</p></blockquote>\n<p>DPC机制用于允许ISR尽快调用IoCompleteRequest</p>\n<p>每个cpu有一个DPC队列，KeInsertQueueDpc默认把DPC入队当前CPU</p>\n<p>当ISR返回时，在IRQL降为0前，会检测DPC队列</p>\n<p>如果DPC队列不为空，则IRQL降到2，然后处理DPC队列直到为空</p>\n<p>执行完再降IRQL为0并返回到中断前的代码</p>\n<p><strong>带定时器的DPC</strong></p>\n<p>不是所有的DPC都是由ISR创建的，有些系统机制也会创建DPC，比如内核计时器（KTIMER）</p>\n<p>以下代码是将定时器关联到DPC的示例</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">KTimer Timer;\nKDPC TimerDpc;\n\nvoid InitAndStartTimer(ULONG msec) &#123;\n    KeInitializeTimer(&amp;Timer);\n    KeInitializeDpc(&amp;TimerDpc,\n                    OnTimerExpired, &#x2F;&#x2F; callback\n                    nullptr);       &#x2F;&#x2F; passed to callback as &quot;context&quot;\n    \n    &#x2F;&#x2F; relative interval is in 100nsec units (and must be negative)\n    LARGE_INTEGER interval;\n    interval.QuadPart &#x3D; -10000LL * msec;\n    KeSetTimer(&amp;Timer, interval, &amp;TimerDpc);\n&#125;\n\nvoid OnTimerExpried(KDPC* Dpc, PVOID context, PVOID, PVOID) &#123;\n    UNREFERENCED_PARAMETER(Dpc);\n    UNREFERENCED_PARAMETER(context);\n    \n    &#x2F;&#x2F; pass\n&#125;</code></pre>\n\n\n\n<h3 id=\"6-3-APC\"><a href=\"#6-3-APC\" class=\"headerlink\" title=\"6.3 APC\"></a>6.3 APC</h3><p>异步过程调用，Asynchronous Procedure Calls，APC</p>\n<p>每个线程都有一个关联的APC队列</p>\n<p>APC类型：</p>\n<ul>\n<li>R3 APC：在R3下，只有在线程进入alertable state时，以<code>PASSIVE_LEVEL</code>运行<br>通常通过调用API实现，如：SleepEx、WaitForSingleObjectEx或类似的API等<br>这些函数最后一个参数可以设置线程于alertable state，这时线程会检测APC队列直到为空</li>\n<li>正常R0 APC：在R0下，以<code>PASSIVE_LEVEL</code>运行并抢占R3代码和R3 APC</li>\n<li>特殊R0 APC：在R0下，以<code>APC_LEVEL</code>抢占R3代码、R3 APC、普通R0 APC<br>这些APC被IO系统用于完成IO操作</li>\n</ul>\n<p><strong>Critical Regions and Guarded Regions</strong></p>\n<p>Critical Region 阻止 R3、正常R0 APC 运行</p>\n<p><code>KeEnterCriticalRegion</code>，<code>KeLeaveCriticalRegion</code></p>\n<p>Guarded Region 阻止所有 APC 运行</p>\n<p><code>KeEnterGuardedRegion</code>，<code>KeLeaveGuardedRegion</code></p>\n<h3 id=\"6-4-SEH\"><a href=\"#6-4-SEH\" class=\"headerlink\" title=\"6.4 SEH\"></a>6.4 SEH</h3><p>结构化异常处理，Structured Exception Handling，SEH</p>\n<p>由指令引起CPU错误会触发异常</p>\n<p>异常类似于中断，区别是异常是同步、可重现的，中断是异步且随时发生的<br>（这里应该是说异常的发生与代码的执行有关，比如坏的闹钟每个早上都不会响<br>而中断是突发的，比如突然发生了地震）</p>\n<p>异常的例子：除0(0)、断点(3)、无效指令(6)、换页错误(14)、栈溢出</p>\n<p>内核异常处理基于IDT（中断调用表，Interrupt Dispatch Table）</p>\n<p>低编号的 中断向量 实际上是 异常处理程序</p>\n<p>引发异常后，会在异常发生的地方搜索处理函数（除了透明处理的异常，如断点）<br>如果找不到，就会向上搜索调用堆栈，直到系统崩溃</p>\n<p>驱动、R3都可以用SEH机制来抛出自定义异常</p>\n<p>使用（c++）RAII包装来确保资源被正确释放</p>\n<h3 id=\"6-5-系统崩溃\"><a href=\"#6-5-系统崩溃\" class=\"headerlink\" title=\"6.5 系统崩溃\"></a>6.5 系统崩溃</h3><p>如果内核发生未处理的异常，系统就会崩溃<br>通常称为蓝屏（Blue Screen of Death，BSOD）</p>\n<p>蓝屏是一种保护机制，防止崩溃后执行非预期操作修改系统如注册表等、造成不可逆错误</p>\n<p>可以设置系统在系统崩溃时执行一些操作（win10改了设置不知道怎么搞233）</p>\n<p><strong>崩溃转储信息</strong></p>\n<p>[windbg]：<code>!analyze -v</code>，最常用的初步分析dump的指令</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>帮助诊断此类问题的一种方法是使用 Driver Verifier。 将在模块 11 中了解 Driver Verifier</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>获得故障转储代码后，查看主题为“Bugcheck Code Reference”的windbg文档会很有帮助</p></blockquote>\n<p><strong>分析转储文件</strong></p>\n<p>转储文件是系统的快照</p>\n<p><code>!process</code>、<code>!thread</code>、<code>lm</code>、<code>k</code>等指仍能正常使用</p>\n<p>[windbg]：<code>~ns</code>，切换cpu，n是cpu索引（R3是切换线程）</p>\n<p>[windbg]：<code>!running</code>，列出崩溃时所有cpu上的线程；<code>-t</code>，显示线程的调用堆栈</p>\n<p>[windbg]：<code>!stack</code>，列出所有线程的调用堆栈；<code>!stack 0 str </code>，列出模块或函数名中包含str的线程调用堆栈</p>\n<p><strong>系统挂起</strong></p>\n<p>有时候系统会死循环，不崩溃。系统内核工具<code>NotMyFault</code>可以强制系统崩溃，进而生成转储文件</p>\n<p>如果系统无响应但连接了调试器，且事先在注册表中配置，可以通过组合键产生崩溃<br>这种情况崩溃代码是0xe2（MANUALLY_INITIATED_CRASH）</p>\n<h3 id=\"6-6-线程同步\"><a href=\"#6-6-线程同步\" class=\"headerlink\" title=\"6.6 线程同步\"></a>6.6 线程同步</h3><p>驱动可能被多个客户端调用，必须以原子方式操作链表 </p>\n<p>内核提供几个原语（primitive）帮助同步，保护数据的并发访问</p>\n<h4 id=\"6-6-1-Interlocked\"><a href=\"#6-6-1-Interlocked\" class=\"headerlink\" title=\"6.6.1 Interlocked\"></a>6.6.1 Interlocked</h4><p>Interlocked 函数集由硬件提供原子性，非常高效，尽量使用这些函数</p>\n<p>一些驱动使用的Interlocked函数：</p>\n<ul>\n<li>InterlockedIncrement/16/ /64</li>\n<li>InterlockedDecrement/16/ /64</li>\n<li>InterlockedAdd/ /64</li>\n<li>InterlockedExchange/8/16/ /64</li>\n<li>InterlockedCompareExchange/ /64/128</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>InterlockedCompareExchange用于无锁编程，无需使用软件对象实现复杂原子操作</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Interlocked函数在R3下也可用，本质上这些是特殊的CPU指令</p></blockquote>\n<h4 id=\"6-6-2-Dispatcher-Waitable-对象\"><a href=\"#6-6-2-Dispatcher-Waitable-对象\" class=\"headerlink\" title=\"6.6.2 Dispatcher/Waitable 对象\"></a>6.6.2 Dispatcher/Waitable 对象</h4><p>内核提供了一组称为 Dispatcher Objects 的原语，也称为 Waitable Objects</p>\n<p>这些对象有一个状态称为有信号和无信号 </p>\n<p>常见 Disapatcher 对象的 signaled 和 nonsignaled 的含义：</p>\n<table>\n<thead>\n<tr>\n<th>对象类型</th>\n<th>Signal</th>\n<th>Non-Signal</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Process</td>\n<td>进程已终止</td>\n<td>进程尚未终止</td>\n</tr>\n<tr>\n<td>Thread</td>\n<td>线程已终止</td>\n<td>线程尚未终止</td>\n</tr>\n<tr>\n<td>Mutex</td>\n<td>free</td>\n<td>held</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>set</td>\n<td>reset</td>\n</tr>\n<tr>\n<td>Semaphore</td>\n<td>计数大于0</td>\n<td>计数为0</td>\n</tr>\n<tr>\n<td>Timer</td>\n<td>已过期</td>\n<td>未过期</td>\n</tr>\n<tr>\n<td>File</td>\n<td>异步IO完成</td>\n<td>异步IO处理中</td>\n</tr>\n</tbody></table>\n<h4 id=\"6-6-3-Mutex\"><a href=\"#6-6-3-Mutex\" class=\"headerlink\" title=\"6.6.3 Mutex\"></a>6.6.3 Mutex</h4><p>互斥锁在空闲时设为有信号</p>\n<p>当一个线程调用一个等待函数等待互斥对象，等待结束后（互斥锁空闲、有信号），互斥锁会马上上锁（无信号），此时该线程成为互斥锁的持有者</p>\n<p>使用示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">KMUTEX myMutex;\nLIST_ENTRY data;\n\nvoid Init() &#123;\n    KeInitializeMutex(&amp;myMutex, 0);\n&#125;\n\nvoid DoWork() &#123;\n    &#x2F;&#x2F; wait for mutex to be free, then held the mutex automatically\n    KeWaitForSingleObject(&amp;myMutex, Executive, KernelMode, FALSE, nullptr);\n    \n    __try &#123;\n    \t&#x2F;&#x2F; access data\n    &#125;\n    __finally &#123;\n        &#x2F;&#x2F; release\n    \tKeReleaseMutex(&amp;myMutex, false);\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>RAII包装：</p>\n<p>首先包装mutex，提供初始化、上锁、解锁的接口：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; mutex wrapper\nstruct MyMutex &#123;\n    void Init() &#123;\n        KeInitializeMutex(&amp;_mutex, false);\n    &#125;\n    \n    void Lock()&#123;\n        KeWaitForSingleObject(&amp;_mutex, Executive, KernelMode, FALSE, nullptr);\n    &#125;\n    \n    void Unlock()&#123;\n        KeReleaseMutex(&amp;_mutex, false);\n    &#125;\n    \nprivate:\n    KMUTEX _mutex;\n&#125;</code></pre>\n\n<p>然后包装一个自动锁类型，自动上锁、解锁：<br>（利用变量的自动初始化和析构）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; lock wrapper\ntemplate&lt;typename TLock&gt;\nstruct AutoLock &#123;\n    AutoLock(TLock&amp; lock) : _lock(lock) &#123;\n        lock.Lock();\n    &#125;\n    \n    ~AutoLock() &#123;\n        _lock.Unlock();\n    &#125;\n\nprivate:\n    TLock&amp; _lock;\n&#125;;</code></pre>\n\n<p>使用示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">MyMutex myMutex;\n\nvoid Init() &#123;\n    myMutex.Init();\n&#125;\n\nvoid DoWork() &#123;\n    AutoLock&lt;MyMutex&gt; autolock(myMutex);\n    \n    &#x2F;&#x2F; access data\n&#125;</code></pre>\n\n\n\n<h4 id=\"6-6-4-Fast-Mutex\"><a href=\"#6-6-4-Fast-Mutex\" class=\"headerlink\" title=\"6.6.4 Fast Mutex\"></a>6.6.4 Fast Mutex</h4><p>Fast Mutex 是 Mutex 的替代，不一样的特点如下：</p>\n<ul>\n<li>无法递归获取，这会造成死锁</li>\n<li>当获取 Fast Mutex 时，IRQL被提升到APC_LEVEL(1)</li>\n<li>Fast Mutex 只能无限期等待，无法指定超时时限</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>fast mutex只能在R0使用，R3只能用mutex</p></blockquote>\n<p>RAII包装示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MyFastMutex &#123;\npublic:\n    void Init();\n    void Lock();\n    void Unlock();\nprivate:\n    FAST_MUTEX _mutex;\n&#125;;\n\nvoid MyFastMutex::Init() &#123;\n    ExInitializeFastMutex(&amp;_mutex);\n&#125;\n\nvoid MyFastMutex::Lock() &#123;\n    ExAcquireFastMutex(&amp;_mutex);\n&#125;\n\nvoid MyFastMutex::Unlock() &#123;\n    ExReleaseFastMutex(&amp;_mutex);\n&#125;\n\n&#123;\n    &#x2F;&#x2F; init\n    MyFastMutex myFastMutex;\n    myFastMute.Init();\n    \n    &#x2F;&#x2F; auto lock and unlock\n    &#123;\n        AutoLock&lt;MyFastMutex&gt; autolock(myFastMutex);\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"6-6-5-Semaphore\"><a href=\"#6-6-5-Semaphore\" class=\"headerlink\" title=\"6.6.5 Semaphore\"></a>6.6.5 Semaphore</h4><p>信号量的主要目标是限制某些东西，例如队列的长度</p>\n<p>当它的内部计数大于零时，信号量设为有信号 </p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">KeInitializeSemaphore();\nKeWaitForSingleObject(); &#x2F;&#x2F; Semaphore -1\nKeReleaseSemaphore(); &#x2F;&#x2F; Semaphore +</code></pre>\n\n\n\n<h4 id=\"6-6-6-Event\"><a href=\"#6-6-6-Event\" class=\"headerlink\" title=\"6.6.6 Event\"></a>6.6.6 Event</h4><p>一个事件封装了一个布尔值，表示是否有信号</p>\n<p>事件在初始化时可以设为手动或自动重置</p>\n<ul>\n<li>手动重置：当事件有信号，且被等待成功后，仍然有信号，所以等待线程都会被唤醒</li>\n<li>自动重置：当事件有信号，且被等待成功后，会变成无信号，只有一个等待线程会被唤醒</li>\n</ul>\n<p>通过在非页池中分配 <code>KEVENT</code> 来创建事件</p>\n<h4 id=\"6-6-7-Executive-Resource\"><a href=\"#6-6-7-Executive-Resource\" class=\"headerlink\" title=\"6.6.7 Executive Resource\"></a>6.6.7 Executive Resource</h4><p>互斥锁本质上是并发杀手（原文），因为一次只能执行一个线程</p>\n<p>对于读写操作分开的情况，内核提供另一种原语，称为单写入器、多读取器</p>\n<p>这个对象是<code>Executive Resource</code>，这不是一个<code>dispatcher</code>对象</p>\n<p>通过在非页池中分配 <code>ERESOURCE</code> 并调用 <code>ExInitializeResourceLite()</code> 来初始化</p>\n<p>获取排他锁（写锁）<code>ExAcquireResourceExclusiveLite()</code></p>\n<p>获取共享锁（读锁）<code>ExAcquireResourceSharedLite()</code></p>\n<p>获取和释放锁都需要屏蔽 普通R0APC（Critical Region）</p>\n<p>示例：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">ERESOURCE resource;\n\nvoid WriteData() &#123;\n    KeEnterCriticalRegion();\n    ExAcquireResourceExclusiveLite(&amp;resource, TRUE);\n    \n    &#x2F;&#x2F; write data\n    \n    ExReleaseResourceLite(&amp;resource);\n    KeLeaveCriticalRegion();\n&#125;\n\nvoid WriteData() &#123;\n    ExEnterCriticalRegionAndAcquireResourceExclusive(&amp;resource, TRUE);\n    \n    &#x2F;&#x2F; write data\n    \n    ExReleaseResourceAndLeaveCriticalRegion(&amp;resource);\n&#125;</code></pre>\n\n\n\n<p>（练习）RAII包装示例：// todo</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MyResource &#123;\npublic:\n    void Init();\n    void ReadLock();\n    void WriteLock();\n    void Unlock();\n\t\nprivate:\n    ERESOURCE _resource;\n&#125;\n\nvoid MyResource::Init() &#123;\n    ExInitializeResourceLite(&amp;_resource);\n&#125;\n\nvoid MyResource::ReadLock() &#123;\n    ExEnterCriticalRegionAndAcquireSharedExclusive(&amp;_resource， TRUE);\n&#125;\n\nvoid MyResource::WriteLock() &#123;\n    ExEnterCriticalRegionAndAcquireResourceExclusive(&amp;_resource， TRUE);\n&#125;\n\nvoid MyResource::Unlock() &#123;\n    ExReleaseResourceAndLeaveCriticalRegion(&amp;_resource);\n&#125;\n\ntemplate&lt;typename TLock&gt;\nstruct AutoLockEx &#123;\n    AutuLock(TLock&amp; lock, BOOL isWrite) : _lock(lock) &#123;\n        if(isWrite)\n        \tlock.WriteLock();\n        else\n            lock.ReadLock();\n    &#125;\n    \n    ~AutoLock() &#123;\n        _lock.Unlock();\n    &#125;\n\nprivate:\n    TLock&amp; _lock;\n&#125;</code></pre>\n\n\n\n<h3 id=\"6-7-高IRQL下的同步\"><a href=\"#6-7-高IRQL下的同步\" class=\"headerlink\" title=\"6.7 高IRQL下的同步\"></a>6.7 高IRQL下的同步</h3><p>当 IRQL&gt;=2（DISPATCH_LEVEL或更高）时线程不能等待，意味着不能用上面的东西来实现同步</p>\n<p>比如IRQL0的代码和DPC共用一个资源，或者两个cpu的DPC同时使用一个资源的时候</p>\n<p>前者在IRQL0的代码中临时提升IRQL到2可以避免DPC的干扰</p>\n<p>在多CPU系统中需要使用 Spin Lock</p>\n<p><strong>Spin Lock</strong></p>\n<p>自旋锁是内存中的一个简单位，它通过 API 提供原子测试和修改操作 </p>\n<p>创建自旋锁需要在非页池中分配 <code>KSPIN_LOCK</code></p>\n<p>获取自旋锁有两步：提升IRQL到合适级别；获取自旋锁</p>\n<p>（合适级别指所有使用该资源的代码的最高级别）</p>\n<p>获取和释放自旋锁的API会执行上述两个步骤</p>\n<table>\n<thead>\n<tr>\n<th>IRQL</th>\n<th>获取</th>\n<th>释放</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2</td>\n<td>KeAcquireSpinLock</td>\n<td>KeReleaseSpinLock</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>KeAcquireSpinLockAtDpcLevel</td>\n<td>KeReleaseSpinLockFromDpcLevel</td>\n<td>(1)</td>\n</tr>\n<tr>\n<td>Device IRQL</td>\n<td>KeAcquireInterruptSpinLock</td>\n<td>KeReleaseInterruptSpinLock</td>\n<td>(2)</td>\n</tr>\n<tr>\n<td>HIGH_LEVEL</td>\n<td>ExInterlockedXxx</td>\n<td>(none)</td>\n<td>(3)</td>\n</tr>\n</tbody></table>\n<p>(1) 只可以在IRQL=2的时候调用（API只获取或释放锁，不修改IRQL）</p>\n<p>(2) 用于将 ISR 与任何其他功能同步。 具有中断源的基于硬件的驱动程序使用这些例程。参数是一个中断对象——自旋锁是它的一部分</p>\n<p>(3) 用于操作基于 LIST_ENTRY 的链表的 3 个函数。这些函数使用提供的自旋锁并将 IRQL 提升到 HIGH_LEVEL。由于高 IRQL，这些例程可以在任何情况下使用，且总是安全的</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>确保自旋锁在同一个函数获取和释放，否则会造成死锁</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Cancel 自旋锁是一个特例，由内核在调用驱动的取消例程之前获取，由驱动释放</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>通常当多个CPU竞争一个自旋锁，电子速度快的CPU获胜。</p>\n<p>内核提供另一种队列自旋锁用于处理这种竞争</p>\n<p>KeAcquireInStackQueuedSpinLock</p>\n<p>KeReleaseInStackQueuedSpinLock</p></blockquote>\n<h3 id=\"6-8-Work-Item\"><a href=\"#6-8-Work-Item\" class=\"headerlink\" title=\"6.8 Work Item\"></a>6.8 Work Item</h3><p>内核提供了创建单独运行的线程的函数：PsCreateSystemThread、IoCreateSystemThread<br>如果驱动程序需要在后台长时间运行代码，这些函数是合适的</p>\n<p>对于有时间限制的操作，最好使用内核提供的线程池，它将在某个系统工作线程上执行您的代码</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>首选 IoCreateSystemThread，因为它允许将设备或驱动程序对象与线程相关联</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>驱动程序创建的线程必须调用 PsTerminateSystemThread 来终止自身。 如果成功，此函数永远不会返回。 </p></blockquote>\n<p>Work Item 描述的是一些在系统线程池队列中的函数</p>\n<p>看起来与DPC非常相似，主要区别是Work Item总是在IRQL 0<br>这意味着当DPC需要执行IRQL2不能执行的操作时，可以使用 work item</p>\n<p>创建和初始化一个work item的两种方法：</p>\n<ul>\n<li>使用 <code>IoAllocateWorkItem()</code> 分配和初始化work item<br>该函数返回 <code>IO_WORKITEM</code> 结构体的指针<br>work item完成后必须使用 <code>IoFreeWorkItem()</code></li>\n<li>根据 <code>IoSizeofWorkItem()</code> 动态分配一个 <code>IO_WORKITEM</code><br>然后调用 <code>IoInitializeWorkItem()</code><br>work item完成后必须使用 <code>IoUninitializeWorkItem()</code></li>\n</ul>\n<p>使用 <code>IoQueueWorkItem()</code> 查询已有 work item：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void IoQueueWorkItem(\n    _Inout_ PIO_WORKITEM IoWorkItem,         &#x2F;&#x2F; the work item\n    _In_ PIO_WORKITEM_ROUTINE WorkerRoutine, &#x2F;&#x2F; the function to be called\n    _In_ WORK_QUEUE_TYPE QueueType,          &#x2F;&#x2F; queue type\n    _In_opt_ PVOID Context);                 &#x2F;&#x2F; driver-defined value</code></pre>\n\n\n\n<p><code>IO_WORKITEM_ROUTINE</code> 回调函数：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void WorkerRoutine(\n    _In_ PDEVICE_OBJECT DeviceObject,\n    _In_opt_ PVOID Context\n);</code></pre>\n\n\n\n<p>系统线程池有多个队列，基于不同的线程优先级，<code>WORK_QUEUE_TYPE</code> 枚举：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef enum _WORK_QUEUE_TYPE &#123;\n    CriticalWorkQueue,      &#x2F;&#x2F; priority 13\n    DelayedWorkQueue,       &#x2F;&#x2F; priority 12\n    HyperCriticalWorkQueue, &#x2F;&#x2F; priority 15\n    NormalWorkQueue,        &#x2F;&#x2F; priority 8\n    BackgroundWorkQueue,    &#x2F;&#x2F; priority 7\n    RealTimeWorkQueue,      &#x2F;&#x2F; priority 18\n    SuperCriticalWorkQueue, &#x2F;&#x2F; priority 14\n    MaximumWorkQueue,\n    CustomPriorityWorkQueue &#x3D; 32\n&#125; WORK_QUEUE_TYPE;</code></pre>\n\n<p>文档表明必须使用 <code>DelayedWorkQueue</code>，但实际上可以使用任意支持的级别</p>\n<h2 id=\"7-IRP\"><a href=\"#7-IRP\" class=\"headerlink\" title=\"7 IRP\"></a>7 IRP</h2><p>典型的驱动在 DriverEntry 中完成初始化后，其主要工作是处理请求</p>\n<p>这些请求被打包为半文档化的 I/O Request Packet（IRP）结构</p>\n<p>本章关于了解IRP，及驱动如何处理常见的IRP</p>\n<h3 id=\"7-1-IRP简介\"><a href=\"#7-1-IRP简介\" class=\"headerlink\" title=\"7.1 IRP简介\"></a>7.1 IRP简介</h3><p>IRP在非页池</p>\n<p><code>allocated by one of the “managers” in  the Executive(I/O Manager, Plug &amp; Play Manager, Power Manager) </code>，也可以由驱动分配，用于将请求传递给另外一个驱动</p>\n<p>IRP通常伴随着一个或多个 <code>IO_STACK_LOCATION</code></p>\n<p>分配IRP时必须指定由多少个 <code>IO_STACK_LOCATION</code></p>\n<p><code>IO_STACK_LOCATION</code> 的数量 = 设备堆栈中设备对象的数量</p>\n<p>使用宏 <code>IoGetCurrentIrpStackLocation </code> 获取当前的 <code>IO_STACK_LOCATION</code></p>\n<h3 id=\"7-2-设备栈\"><a href=\"#7-2-设备栈\" class=\"headerlink\" title=\"7.2 设备栈\"></a>7.2 设备栈</h3><p>IO系统以设备为中心：</p>\n<ul>\n<li>可以命名设备对象并且可以打开设备对象的句柄<br>CreateFile 函数接受指向设备对象名称的符号链接<br>CreateFile 不能接受驱动程序的名称作为参数</li>\n<li>设备可以堆叠，发送到较低设备的请求将先到达最上层</li>\n</ul>\n<p>堆叠的一组设备称为设备栈（device stack）或设备节点（device node）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">设备栈例子：\n（上层）\nFiDO\nFiDO\nFDO\nFiDO\nFiDO\nPDO\n（底层）</code></pre>\n\n<p>FiDO（Filter Device Object）：可选的过滤驱动创建的过滤设备</p>\n<p>FDO（Functional Device Object）：由“真正”的驱动创建的；这些驱动通常由硬件供应商提供</p>\n<p>PDO（Physical Device Object）：由总线驱动(bus driver，负责特定总线，例如PCI、USB)创建；该设备对象表示该总线上的插槽中存在某个设备</p>\n<p>例子：</p>\n<p>P&amp;P管理器（Plug &amp; Play manager）负责从底部开始加载驱动</p>\n<p>创建设备栈的事件序列总结如下：</p>\n<ol>\n<li>PCI总线驱动程序 (pci.sys) 识别出插槽中存在硬件，创建一个PDO (IoCreateDevice)</li>\n<li>PCI总线企业的程序 通知 P&amp;P管理器 它的总线发生了变化</li>\n<li>P&amp;P管理器 向 总线驱动 请求PDO链表，该链表包括新PDO</li>\n<li>准备找到并加载新PDO的正确的驱动程序，它将向 总线驱动 查询完整的硬件设备ID</li>\n<li>P&amp;P管理器 根据硬件ID，在注册表中查找<code>HKLM\\System\\ CurrentControlSet\\Enum\\PCI\\(HardwareID)</code><br>如果驱动已经加载，将注册并加载</li>\n<li>驱动加载并创建FDO，通过附加调用 IoAttachDeviceToDeviceStack 将自身附加到（通常是PDO）前一层</li>\n</ol>\n<h4 id=\"IRP-流\"><a href=\"#IRP-流\" class=\"headerlink\" title=\"IRP 流\"></a>IRP 流</h4><p>驱动在处理IRP时有如下几种选择：</p>\n<p><strong>向下传递</strong>：</p>\n<p>如果驱动的设备不是设备栈的最底层，可以直接向下传递，跳过该请求</p>\n<p>跳过请求需要如下步骤：</p>\n<ol>\n<li>调用 <code>IoSkipCurrentIrpStackLocation</code> 确保下一个设备“看”到同样的 I/O stack location</li>\n<li>调用 <code>IoCallDriver </code> 传递低一层设备和IRP</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>调用 IoSkipCurrentIrpStackLocation 是一种优化，它会减少当前 I/O stack location 指针，随后被IoCallDriver增加回来</p></blockquote>\n<p><strong>完全处理IRP</strong>：</p>\n<p>不向下传递请求，处理完IRP后直接调用 <code>IoCompleteRequest</code></p>\n<p><strong>处理并向下传递</strong>：</p>\n<p>处理完请求后再向下传递</p>\n<p><strong>传递并接收通知</strong>：</p>\n<p>传递给底层设备，并在请求完成时接收通知</p>\n<p>通过在传递之前调用 <code>IoSetCompletionRoutine</code> 设置例程，该例程会在请求完成时被调用</p>\n<p><strong>启动异步IRP处理</strong>：</p>\n<p>在处理过程比较长的一些情况，可以将IRP标记为<code>pending</code></p>\n<p>需要调用<code>IoMarkIrpPending</code>和返回<code>STATUS_PENDING</code></p>\n<h3 id=\"7-3-IRP-和-IO-STACK-LOCATION\"><a href=\"#7-3-IRP-和-IO-STACK-LOCATION\" class=\"headerlink\" title=\"7.3 IRP 和 IO_STACK_LOCATION\"></a>7.3 IRP 和 IO_STACK_LOCATION</h3><p>IRP重要字段：</p>\n<p><img src=\"https://s4.ax1x.com/2022/02/25/bEkrSf.png\"></p>\n<ul>\n<li><strong>MdlAddress</strong>：MDL指针，与 <code>Direct I/O</code> 有关</li>\n<li><strong>AssociatedIrp</strong>：union<ul>\n<li><strong>MasterIrp</strong>：指向主IRP</li>\n<li><strong>IrpCount</strong>：对于 主IRP，指示与此 主IRP 关联的 关联IRP 数量</li>\n<li><strong>SystemBuffer</strong>：指向系统分配的非页池，与 <code>Buffered I/O</code> 有关</li>\n</ul>\n</li>\n<li><strong>IoStatus</strong>：包括<code>Status</code>和<code>Information</code>；<code>Information</code>是<code>ULONG_PTR</code>，是多态的，定义取决于IRP的类型</li>\n<li><strong>UserEvent</strong>：指向客户端提供的<code>KEVENT</code>，客户端可以在<code>OVERLAPPED</code>中提供该事件HANDLE，这是异步调用所必须的</li>\n<li><strong>UserBuffer</strong>：包含指向用户缓冲区的原始缓冲区指针</li>\n<li><strong>Cancel Routine</strong>：指向取消例程，比如R3调用<code>CancelIO</code>时，软件驱动通常不需要</li>\n</ul>\n<p>IO_STACK_LOCATION重要字段：</p>\n<p><img src=\"https://s4.ax1x.com/2022/02/25/bEky6S.png\"></p>\n<ul>\n<li><strong>MajorFunction</strong>：IRP的 major function (如IRP_MJ_CREATE，IRP_MJ_READ)</li>\n<li><strong>MinorFunction</strong>：IRP的 minor function (如 IRP_MJ_PNP，IRP_MJ_POWER)</li>\n<li><strong>Parameters</strong>：union，不同的操作对应不同的结构</li>\n<li><strong>FileObject</strong>：该IRP关联的 FILE_OBJECT</li>\n<li><strong>DeviceObject</strong>：该IRP关联的 设备对象</li>\n<li><strong>CompletionRoutine</strong>：由上层设置（<code>IoSetCompletionRoutine</code>）</li>\n<li><strong>Context</strong>：传递给 CompletionRoutine 的参数</li>\n</ul>\n<h4 id=\"观察IRP信息\"><a href=\"#观察IRP信息\" class=\"headerlink\" title=\"观察IRP信息\"></a>观察IRP信息</h4><p>[windbg]：<code>!irpfind</code> 查找或输出所有IRP</p>\n<p>[windbg]：<code>!irp</code> 对于特定的IRP，提供其内容的预览</p>\n<p>[windbg]：<code>dt</code>命令可以与<code>_IRP</code>类型一起使用来查看完整IRP结构</p>\n<h3 id=\"7-4-调度例程\"><a href=\"#7-4-调度例程\" class=\"headerlink\" title=\"7.4 调度例程\"></a>7.4 调度例程</h3><p>所有调度例程是同一个函数原型</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">NTSTATUS DRIVER_DISPATCH (\n    _In_ PDEVICE_OBJECT DeviceObject,\n    _Inout_ PIRP Irp\n);</code></pre>\n\n<p>通常运行在发起请求的线程的上下文<br>但位于该设备上层的过滤驱动可能在不同的上下文发送请求</p>\n<p>所有调度例程做以下事情：</p>\n<ol>\n<li>检查错误</li>\n<li>处理请求</li>\n</ol>\n<p>软件驱动常见调度例程：</p>\n<ul>\n<li>IRP_MJ_CREATE</li>\n<li>IRP_MJ_CLOSE</li>\n<li>IRP_MJ_READ</li>\n<li>IRP_MJ_WRITE</li>\n<li>IRP_MJ_DEVICE_CONTROL</li>\n<li>IRP_MJ_INTERNAL_DEVICE_CONTROL</li>\n</ul>\n<h4 id=\"完成请求\"><a href=\"#完成请求\" class=\"headerlink\" title=\"完成请求\"></a>完成请求</h4><p>当驱动处理完IRP（不再向下传递），需要完成请求<br>填写请求状态和其他信息后，调用<code>IoCompleteRequest</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">NTSTATUS MyDispatchRoutine(PDEVICE_OBJECT, PIRP Irp) &#123;\n    &#x2F;&#x2F; ...\n    \n    Irp-&gt;IoStatus.Status &#x3D; STATUS_XXX;\n    Irp-&gt;IoStatus.Information &#x3D; ; &#x2F;&#x2F; depends on request type\n    IoCompleteRequest(Irp, IO_NO_INCREMENT);\n    return STATUS_XXX;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>调度例程返回值和Irp-&gt;IoStatus.Status应该相同，但不能直接<code>return Irp-&gt;IoStatus.Status</code></p>\n<p>当IRP完成后，使用IRP中的数据是危险的</p></blockquote>\n<p>当发生错误，<code>Information</code>字段应该为0</p>\n<p>IoCompleteRequest的第二个参数为可选值，用于临时增加原始线程的优先级发起请求的线程）</p>\n<h3 id=\"7-5-访问R3缓冲区\"><a href=\"#7-5-访问R3缓冲区\" class=\"headerlink\" title=\"7.5 访问R3缓冲区\"></a>7.5 访问R3缓冲区</h3><p>调度例程首先接触到IRP</p>\n<p>当IRQL为0时，可以换页，所以指针在此上下文是有效的<br>但有可能其他线程会释放掉R3客户端提供的缓冲区</p>\n<p>但当IRQL为2时，无法换页；而执行DPC的可能为任意线程，可以换页但无法保证在正确上下文</p>\n<p>所以提供了两种种方法用于访问原始的R3缓冲区：Buffered I/O 和 Direct I/O</p>\n<h4 id=\"7-5-1-Bufferd-I-O\"><a href=\"#7-5-1-Bufferd-I-O\" class=\"headerlink\" title=\"7.5.1 Bufferd I/O\"></a>7.5.1 Bufferd I/O</h4><p>该方法最简单</p>\n<p>获取对于 Read 和 Write 操作的支持：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">DeviceObject-&gt;Flags |&#x3D; DO_BUFFERED_IO;</code></pre>\n\n\n\n<p>原理（I/O管理器的工作）：</p>\n<ol>\n<li>管理器在非页池分配缓冲区，大小与R3缓冲区一致<br>该非页池缓冲区指针存储在<code>AssociatedIrp.SystemBuffer</code></li>\n<li>如果Write，管理器复制R3缓冲区的内容到非页池缓冲区</li>\n<li>调度例程被调用</li>\n<li>完成操作后，管理器将非页池缓冲区的内容复制到R3缓冲区（Write也是一样）<br>复制的字节数取决于<code>IoStatus.Information</code></li>\n<li>最后，管理器释放非页池缓冲区</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>I/O管理器 将一个特殊的内核APC入队发出请求的线程中，完成复制回R3缓冲区的操作</p></blockquote>\n<p>Buffer I/O的特点：</p>\n<ul>\n<li>易于使用</li>\n<li>总是涉及副本（适用于传递的缓冲区较小的情况）</li>\n</ul>\n<h4 id=\"7-5-2-Direct-I-O\"><a href=\"#7-5-2-Direct-I-O\" class=\"headerlink\" title=\"7.5.2 Direct I/O\"></a>7.5.2 Direct I/O</h4><p>该方法的目的是允许在任何IRQL和任何线程上下文中访问R3缓冲区，而不要任何复制</p>\n<p>获取对于 Read 和 Write 操作的支持：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">DeviceObject-&gt;Flags |&#x3D; DO_DIRECT_IO;</code></pre>\n\n\n\n<p>原理（I/O管理器的工作）：</p>\n<ol>\n<li>管理器首先确认R3缓冲区是合法的，然后放入物理内存中</li>\n<li>然后将缓冲区锁定在内存中（将不会被换出）</li>\n<li>管理器构建一个MDL（描述缓冲区如何映射到内存），该MDL地址存在 IRP 的 MdlAddress字段中</li>\n<li>调度例程被调用，要使用锁定在内存中的缓冲区，需要先将缓冲区映射到系统地址<br>本质上，相对于将两个地址映射到同一个缓冲区（一个R3下特定上下文有效的地址，一个R0对所以上下文有效的地址）<br>映射到系统地址的API是<code>MmGetSystemAddressForMdlSafe</code></li>\n<li>驱动完成请求后，管理器将移除到系统地址的映射，释放MDL，解锁R3缓冲区</li>\n</ol>\n<h4 id=\"7-5-3-IRP-MJ-DEVICE-CONTROL\"><a href=\"#7-5-3-IRP-MJ-DEVICE-CONTROL\" class=\"headerlink\" title=\"7.5.3 IRP_MJ_DEVICE_CONTROL\"></a>7.5.3 IRP_MJ_DEVICE_CONTROL</h4><p>缓冲区的访问方式取决于控制代码（<code>DeviceIoControl()</code>第2个参数<code>dwIoControlCode</code>）</p>\n<p>下面是第四章给出的定义控制代码的宏</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define CTL_CODE( DeviceType, Function, Method, Access ) ( \\\n((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method))</code></pre>\n\n<p>Method的决定了访问缓冲区的方式：</p>\n<ul>\n<li><strong>METHOD_NEITHER</strong>：管理器将不会提供任何帮助，完全由驱动处理缓冲区<ul>\n<li>R3输入缓冲区指针将存储在当前<code>I/O stack location</code>的<code>Paramaters.DeviceIoControl.Type3InputBuffer</code>字段<br>R3输出缓冲区指针将存储在IRP的<code>UserBuffer</code>字段</li>\n</ul>\n</li>\n<li><strong>METHOD_BUFFERED</strong>：对于输入和输出都使用 Buffered I/O</li>\n<li><strong>METHOD_IN_DIRECT and METHOD_OUT_DIRECT</strong>：输入缓冲区用Buffered I/O，输出缓冲区用Direct I/O；区别是对于输出缓冲区，<code>IN</code>可读，<code>OUT</code>可写</li>\n</ul>\n<h4 id=\"7-5-x-总结\"><a href=\"#7-5-x-总结\" class=\"headerlink\" title=\"7.5.x 总结\"></a>7.5.x 总结</h4><p>Buffred I/O 使用 IRP 的 AssociatedIrp.SystemBuffer</p>\n<p>Directed I/O 使用 IRP 的 MdlAddress</p>\n<p>DeviceIoControl 的 NEITHER：<br>    Input：I/O stack location 的 Paramaters.DeviceIoControl.Type3InputBuffer<br>    Ouput：IRP 的 UserBuffer</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>In buf</th>\n<th>Out buf</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>METHOD_BUFFER</td>\n<td>Buffred</td>\n<td>Buffred</td>\n</tr>\n<tr>\n<td>METHOD_IN_DIRECT</td>\n<td>Buffred</td>\n<td>Direct（只读）</td>\n</tr>\n<tr>\n<td>METHOD_OUT_DIRECT</td>\n<td>Buffred</td>\n<td>Direct（只写）</td>\n</tr>\n</tbody></table>\n<h3 id=\"7-6-示例：Zero-驱动（S4）\"><a href=\"#7-6-示例：Zero-驱动（S4）\" class=\"headerlink\" title=\"7.6 示例：Zero 驱动（S4）\"></a>7.6 示例：Zero 驱动（S4）</h3><p>运用6、7章的内容，构建一个驱动：</p>\n<ul>\n<li>read操作：返回清零的缓冲区</li>\n<li>write操作：只是消耗提供的缓冲区，类似于经典的null设备</li>\n</ul>\n<p>使用Direct I/O</p>\n<p>（同样不需要INF文件，删除掉）</p>\n<h4 id=\"7-6-1-技巧：使用预编译头\"><a href=\"#7-6-1-技巧：使用预编译头\" class=\"headerlink\" title=\"7.6.1 技巧：使用预编译头\"></a>7.6.1 技巧：使用预编译头</h4><p>预编译头文件是 Visual Studio 的一项功能，有助于缩短编译时间</p>\n<p>创建预编译头的步骤：</p>\n<ul>\n<li><p>添加头文件到项目，名为pch.h：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; pch.h\n#pragma once\n#include &lt;ntddk.h&gt;</code></pre>\n</li>\n<li><p>添加源文件，名为pch.cpp：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; pch.cpp\n#include &quot;pch.h&quot;</code></pre>\n</li>\n<li><p>接下来使编译器知道这是个预编译头<br>打开项目属性，选择所有配置和所有平台<br>打开C/C++ -&gt; 预编译头，设置为使用，设置文件名为pch.h</p>\n</li>\n<li><p>pch.cpp需要设置为预编译头的创建者<br>右键该文件，打开C/C++ -&gt; 预编译头，设置为创建</p>\n</li>\n<li><p>现在，项目中的每个文件都必须先包含pch.h，否则不会被编译</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意，<code>#include &quot;pch.h&quot;</code>必须放在源文件最前面，这条包含语句之前的内容不会被编译</p></blockquote>\n<h4 id=\"7-6-2-DriverEntry-例程\"><a href=\"#7-6-2-DriverEntry-例程\" class=\"headerlink\" title=\"7.6.2 DriverEntry 例程\"></a>7.6.2 DriverEntry 例程</h4><p>技巧：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">do &#123;\n\tif(notSuccess)\n        break;\n&#125; while(false);</code></pre>\n\n\n\n<p>创建设备后，需要添加开启Direct IO代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; IoCreateDevice()\nDeviceObject-&gt;Flags |&#x3D; DO_DIRECT_IO;</code></pre>\n\n\n\n<h4 id=\"7-6-3-Read-调度例程\"><a href=\"#7-6-3-Read-调度例程\" class=\"headerlink\" title=\"7.6.3 Read 调度例程\"></a>7.6.3 Read 调度例程</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">NTSTATUS ZeroRead(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp) &#123;\n\tUNREFERENCED_PARAMETER(DeviceObject);\n\n\tauto stack &#x3D; IoGetCurrentIrpStackLocation(Irp);\n\tauto status &#x3D; STATUS_SUCCESS;\n\tULONG infomation &#x3D; 0;\n\t\n\tdo &#123;\n\t\tauto len &#x3D; stack-&gt;Parameters.Read.Length;\n\t\tif (len &#x3D;&#x3D; 0)\n\t\t\tbreak;\n\t\t\n\t\t&#x2F;&#x2F; get buffer\n\n\t\tauto buffer &#x3D; MmGetSystemAddressForMdlSafe(Irp-&gt;MdlAddress, NormalPagePriority);\n\t\tif (!buffer) &#123;\n\t\t\tstatus &#x3D; STATUS_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; work\n\n\t\tmemset(buffer, 0, len);\n\t\tinfomation &#x3D; len;\n\n\t&#125; while (false);\n\t\n\tIrp-&gt;IoStatus.Status &#x3D; status;\n\tIrp-&gt;IoStatus.Information &#x3D; infomation;\n\tIoCompleteRequest(Irp, IO_NO_INCREMENT);\n\treturn status;\n&#125;</code></pre>\n\n\n\n<h4 id=\"7-6-4-Write-调度例程\"><a href=\"#7-6-4-Write-调度例程\" class=\"headerlink\" title=\"7.6.4 Write 调度例程\"></a>7.6.4 Write 调度例程</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">NTSTATUS ZeroWrite(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp) &#123;\n\tUNREFERENCED_PARAMETER(DeviceObject);\n\n\tauto stack &#x3D; IoGetCurrentIrpStackLocation(Irp);\n\tauto status &#x3D; STATUS_SUCCESS;\n\tULONG infomation &#x3D; 0;\n\tauto len &#x3D; stack-&gt;Parameters.Write.Length;\n\n    &#x2F;&#x2F; get buffer\n    \n\tauto buffer &#x3D; MmGetSystemAddressForMdlSafe(Irp-&gt;MdlAddress, NormalPagePriority);\n\tinfomation &#x3D; len;\n    \n    &#x2F;&#x2F; work\n    \n    &#x2F;&#x2F; ...\n\n\tIrp-&gt;IoStatus.Status &#x3D; status;\n\tIrp-&gt;IoStatus.Information &#x3D; infomation;\n\tIoCompleteRequest(Irp, IO_NO_INCREMENT);\n\treturn status;\n&#125;</code></pre>\n\n\n\n<h4 id=\"7-6-5-R3测试程序\"><a href=\"#7-6-5-R3测试程序\" class=\"headerlink\" title=\"7.6.5 R3测试程序\"></a>7.6.5 R3测试程序</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">HANDLE hDevice &#x3D; CreateFile(L&quot;\\\\\\\\.\\\\S4Zero&quot;, GENERIC_READ | GENERIC_WRITE,\n                            0, nullptr, OPEN_EXISTING, 0, nullptr);\n\n&#x2F;&#x2F; read\nDWORD btr;\nReadFile(hDevice, buffer, sizeof(buffer), &amp;btr, nullptr);\n\n&#x2F;&#x2F; write\nDWORD btw;\nWriteFile(hDevice, buffer, sizeof(buffer), &amp;btw, nullptr);</code></pre>\n\n\n\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>6.6.7 Executive Resource，p144，Create appropriate C++ RAII wrappers for executive resources（见文中）</p>\n<p>6.7 高IRQL下的同步，p149，Write a C++ wrapper for a DISPATCH_LEVEL spin lock that works with the AutoLock RAII class defined earlier in this chapter.（todo）</p>\n<p>7.6.6，p185（todo）</p>\n<h2 id=\"勘误\"><a href=\"#勘误\" class=\"headerlink\" title=\"勘误\"></a>勘误</h2><h3 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6\"></a>6</h3><p>p133 的<strong>Interlocked Operations</strong>的 <code>IF</code> 应改为 <code>If</code></p>\n<p>p150 代码的 <code>viud</code> 应该为 <code>void</code></p>\n<h3 id=\"7\"><a href=\"#7\" class=\"headerlink\" title=\"7\"></a>7</h3><p>p167 <code>AssociatedIrp-&gt;SystemBuffer</code> 应改为 <code>AssociatedIrp.SystemBuffer</code></p>\n","text":"Windows Kernel Programming 笔记 6~7 内核机制与IRP6 内核机制关于windows内核提供的一些机制。这些机制，驱动开发会使用，或者有关。 6.1 中断优先级中断处理例程（Interrupt Service Routine，ISR） 中断优先级（I...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"18 mins."},"categories":[{"name":"Windows","slug":"Windows","count":17,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":17,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":19,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":3,"path":"api/tags/kernel.json"},{"name":"wkp","slug":"wkp","count":3,"path":"api/tags/wkp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Windows-Kernel-Programming-%E7%AC%94%E8%AE%B0-6-7-%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E4%B8%8EIRP\"><span class=\"toc-text\">Windows Kernel Programming 笔记 6~7 内核机制与IRP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">6 内核机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1-%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">6.1 中断优先级</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2-DPC\"><span class=\"toc-text\">6.2 DPC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3-APC\"><span class=\"toc-text\">6.3 APC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-4-SEH\"><span class=\"toc-text\">6.4 SEH</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-5-%E7%B3%BB%E7%BB%9F%E5%B4%A9%E6%BA%83\"><span class=\"toc-text\">6.5 系统崩溃</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-6-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">6.6 线程同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-6-1-Interlocked\"><span class=\"toc-text\">6.6.1 Interlocked</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-6-2-Dispatcher-Waitable-%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">6.6.2 Dispatcher&#x2F;Waitable 对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-6-3-Mutex\"><span class=\"toc-text\">6.6.3 Mutex</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-6-4-Fast-Mutex\"><span class=\"toc-text\">6.6.4 Fast Mutex</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-6-5-Semaphore\"><span class=\"toc-text\">6.6.5 Semaphore</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-6-6-Event\"><span class=\"toc-text\">6.6.6 Event</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-6-7-Executive-Resource\"><span class=\"toc-text\">6.6.7 Executive Resource</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-7-%E9%AB%98IRQL%E4%B8%8B%E7%9A%84%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">6.7 高IRQL下的同步</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-8-Work-Item\"><span class=\"toc-text\">6.8 Work Item</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-IRP\"><span class=\"toc-text\">7 IRP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-1-IRP%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">7.1 IRP简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-%E8%AE%BE%E5%A4%87%E6%A0%88\"><span class=\"toc-text\">7.2 设备栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#IRP-%E6%B5%81\"><span class=\"toc-text\">IRP 流</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-IRP-%E5%92%8C-IO-STACK-LOCATION\"><span class=\"toc-text\">7.3 IRP 和 IO_STACK_LOCATION</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9FIRP%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">观察IRP信息</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-4-%E8%B0%83%E5%BA%A6%E4%BE%8B%E7%A8%8B\"><span class=\"toc-text\">7.4 调度例程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%88%90%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">完成请求</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-5-%E8%AE%BF%E9%97%AER3%E7%BC%93%E5%86%B2%E5%8C%BA\"><span class=\"toc-text\">7.5 访问R3缓冲区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-5-1-Bufferd-I-O\"><span class=\"toc-text\">7.5.1 Bufferd I&#x2F;O</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-5-2-Direct-I-O\"><span class=\"toc-text\">7.5.2 Direct I&#x2F;O</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-5-3-IRP-MJ-DEVICE-CONTROL\"><span class=\"toc-text\">7.5.3 IRP_MJ_DEVICE_CONTROL</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-5-x-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">7.5.x 总结</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-6-%E7%A4%BA%E4%BE%8B%EF%BC%9AZero-%E9%A9%B1%E5%8A%A8%EF%BC%88S4%EF%BC%89\"><span class=\"toc-text\">7.6 示例：Zero 驱动（S4）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-6-1-%E6%8A%80%E5%B7%A7%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4\"><span class=\"toc-text\">7.6.1 技巧：使用预编译头</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-6-2-DriverEntry-%E4%BE%8B%E7%A8%8B\"><span class=\"toc-text\">7.6.2 DriverEntry 例程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-6-3-Read-%E8%B0%83%E5%BA%A6%E4%BE%8B%E7%A8%8B\"><span class=\"toc-text\">7.6.3 Read 调度例程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-6-4-Write-%E8%B0%83%E5%BA%A6%E4%BE%8B%E7%A8%8B\"><span class=\"toc-text\">7.6.4 Write 调度例程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-6-5-R3%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">7.6.5 R3测试程序</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">练习</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8B%98%E8%AF%AF\"><span class=\"toc-text\">勘误</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6\"><span class=\"toc-text\">6</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7\"><span class=\"toc-text\">7</span></a></li></ol></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"SFU Compilers class 笔记1","uid":"9e0e6e8e4af299f867f70b1bab4c4ab9","slug":"SFU-Compilers-1","date":"2022-02-27T04:00:00.000Z","updated":"2022-04-13T14:03:12.018Z","comments":true,"path":"api/articles/SFU-Compilers-1.json","keywords":null,"cover":null,"text":"SFU Compilers class 笔记1week1 hw0 Week 1 Introduction to CompilersIN1 Evangelize Compliers内容： Lexing-词法分析 Parsing-句法分析 Type analysis-类型分析 代码生...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"CS","slug":"CS","count":2,"path":"api/categories/CS.json"}],"tags":[{"name":"note","slug":"note","count":19,"path":"api/tags/note.json"},{"name":"cs","slug":"cs","count":2,"path":"api/tags/cs.json"},{"name":"compiler","slug":"compiler","count":2,"path":"api/tags/compiler.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"sctf21 BabyDriver 出题思路","uid":"5492b18e2fa4da93951bdc6ad9c6b6ae","slug":"sctf21-babydriver","date":"2021-12-26T04:00:00.000Z","updated":"2022-01-18T09:38:46.013Z","comments":true,"path":"api/articles/sctf21-babydriver.json","keywords":null,"cover":null,"text":"BabyDriver 出题思路这题是和0x太上一起出的，他提供了题目的框架和内核通信部分的代码，我负责其余的实现 0xTalShang (0x太上) (github.com) SycloverTeam/SCTF2021: SCTF 2021 (github.com) 有选手反馈R...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"CTF","slug":"CTF","count":7,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":7,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":10,"path":"api/tags/re.json"},{"name":"wp","slug":"wp","count":7,"path":"api/tags/wp.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}