{"title":"《逆向工程实战》实例J","uid":"a1005445484098080c05958ea32d43c1","slug":"practicalreJ","date":"2021-10-22T04:00:00.000Z","updated":"2022-04-13T13:57:09.139Z","comments":true,"path":"api/articles/practicalreJ.json","keywords":null,"cover":null,"content":"<h1 id=\"《逆向工程实战》实例J\"><a href=\"#《逆向工程实战》实例J\" class=\"headerlink\" title=\"《逆向工程实战》实例J\"></a>《逆向工程实战》实例J</h1><h2 id=\"DllMain-反编译\"><a href=\"#DllMain-反编译\" class=\"headerlink\" title=\"DllMain 反编译\"></a>DllMain 反编译</h2><p>尽量按汇编反编译结果（没有太多优化）：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">BOOL DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n&#123;\n    char[8] idtr;\n    unsigned int IDTBase;\n    PROCESSENTRY32 pe;\n    \n    &#x2F;&#x2F; Chunk 0:\n    \n    &#x2F;&#x2F; 10001C6A ~ 10001C6E\n    __sidt(&amp;idtr);\n    IDTBase &#x3D; *(unsigned int*)(idtr+2);\n    \n    &#x2F;&#x2F; 10001C71 ~ 10001C85\n    if((IDTBase &gt; 0x8003F400) &amp;&amp; (IDTBase &lt; 0x80047400)) &#123;\n        return 0;\n    &#125;\n    \n    &#x2F;&#x2F; Chunk 1:\n    \n    &#x2F;&#x2F; 10001C88 ~ 10001CA9\n    HANDLE hSnapshot &#x3D; CraeteToolhelp32Snapshot(2, 0); &#x2F;&#x2F; get thread message\n    memset(&amp;pe, 0, 0x128); &#x2F;&#x2F; 4+0x49*4\n    \n    &#x2F;&#x2F; 10001CAB ~ 10001CB6\n    if(hSnapshot &#x3D;&#x3D; -1) &#123;\n        &#x2F;&#x2F; invalid handle\n        return 0;\n    &#125;\n    \n    &#x2F;&#x2F; Chunk 2:\n    \n    &#x2F;&#x2F; 10001CB9 ~ 10001D22\n    pe.dwSize &#x3D; 0x128; &#x2F;&#x2F; &#x3D; sizeof(PROCESSENTRY32)\n    int flag &#x3D; Process32First(hSnapshot, &amp;pe);\n    while(flag) &#123;\n        if(stricmp(pe.szExeFile,&quot;explorer.exe&quot;) &#x3D;&#x3D; 0) &#123;\n        \t&#x2F;&#x2F; IsExplorer:\n            t1 &#x3D; pe.th32ParentProcessID;\n            t2 &#x3D; pe.th32ProcessID;\n            break;\n        &#125;\n        flag &#x3D; Process32Next(hSnapshot, &amp;pe);\n    &#125;\n    &#x2F;&#x2F; 10001D24 ~ 10001D27 (BreakWhileProc:)\n    int t1, t2;\n    if(flag &#x3D;&#x3D; 0) &#123;\n        t1 &#x3D; fdwReason;\n        t2 &#x3D; fdwReason;\n    &#125;\n    \n    &#x2F;&#x2F; 10001D2A ~ 10001D35 (CheckLoopResult:)\n    if(t1 &#x3D;&#x3D; t2)\n        return 0;\n    \n    &#x2F;&#x2F; Chunk3:\n    \n    &#x2F;&#x2F; 10001D38 ~ 10001D5C\n    if(fdwReason &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; DLL_PROCESS_ATTACH\n        CreateThread(0, 0, 0x100032D0, 0, 0, 0);\n    &#125;\n    return 1;\n&#125;</code></pre>\n\n<p>__sidt对应汇编指令<code>sidt</code>，作用是读取idtr寄存器到指定地址<br>idtr寄存器大小是6字节，高4字节是IDT基址</p>\n<p>开头检查IDT基址，每个处理器（核）的IDT都不同<br>win xp中只有0核的IDT基址是<code>0x8003F400</code>，后续版本IDT每次重启都会变<br>所以作用是检查是否运行在xp的0核中</p>\n<p>Chunk1到Chunk2：检查explorer.exe是否在运行，不在运行就退出</p>\n<p>Chunk3：创建一个线程</p>\n<h2 id=\"DllMain栈帧\"><a href=\"#DllMain栈帧\" class=\"headerlink\" title=\"DllMain栈帧\"></a>DllMain栈帧</h2><p>以下偏移是相对DllMain栈帧的ebp</p>\n<p>a开头是参数、v开头是局部变量</p>\n<table>\n<thead>\n<tr>\n<th>offset(base16)</th>\n<th>name</th>\n<th>size(base16)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-130</td>\n<td>v_pe</td>\n<td>128</td>\n</tr>\n<tr>\n<td>-8</td>\n<td>v_idtr</td>\n<td>6/8</td>\n</tr>\n<tr>\n<td>+0</td>\n<td>last_ebp</td>\n<td>4</td>\n</tr>\n<tr>\n<td>+4</td>\n<td>ret_addr</td>\n<td>4</td>\n</tr>\n<tr>\n<td>+8</td>\n<td>a0_hinstDLL</td>\n<td>4</td>\n</tr>\n<tr>\n<td>+C</td>\n<td>a1_fdwReason</td>\n<td>4</td>\n</tr>\n<tr>\n<td>+10</td>\n<td>a2_lpvReserved</td>\n<td>4</td>\n</tr>\n</tbody></table>\n","text":"《逆向工程实战》实例JDllMain 反编译尽量按汇编反编译结果（没有太多优化）： BOOL DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) &#123; char[8] idtr; unsigne...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"Windows","slug":"Windows","count":19,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":19,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":23,"path":"api/tags/note.json"},{"name":"practicalre","slug":"practicalre","count":5,"path":"api/tags/practicalre.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E5%AE%9E%E4%BE%8BJ\"><span class=\"toc-text\">《逆向工程实战》实例J</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DllMain-%E5%8F%8D%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">DllMain 反编译</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DllMain%E6%A0%88%E5%B8%A7\"><span class=\"toc-text\">DllMain栈帧</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"从0开始：某fpsgo简单透视制作","uid":"7081df1a25a0e63a8adb7b11423fb4be","slug":"fpsgoPerspective","date":"2021-11-08T12:54:00.000Z","updated":"2021-12-05T15:10:44.986Z","comments":true,"path":"api/articles/fpsgoPerspective.json","keywords":null,"cover":null,"text":"从0开始：某fpsgo简易透视制作摘要 前置知识： 线性代数知识：矩阵的基本运算 图形学知识：齐次坐标，仿射变换，MVP模型 （可选）旋转、四元数与欧拉角（我也不懂） 其他：CE的基本使用、C++、dll编写与注入、IMGUI 一些资源： frk1/hazedumper: up ...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"Hack","slug":"Hack","count":1,"path":"api/categories/Hack.json"}],"tags":[{"name":"hack","slug":"hack","count":1,"path":"api/tags/hack.json"},{"name":"fps","slug":"fps","count":1,"path":"api/tags/fps.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"逆向工程核心原理 R3静态反调试 笔记","uid":"2b002dec449ce21e3d8b7af026d74ae7","slug":"recoreR3StaAntiDebug","date":"2021-10-16T04:00:00.000Z","updated":"2021-11-05T11:43:17.496Z","comments":true,"path":"api/articles/recoreR3StaAntiDebug.json","keywords":null,"cover":null,"text":"逆向工程核心原理 R3静态反调试 笔记摘要主要是R3层面的静态反调试手段 参考逆向工程核心原理51章静态反调试 涉及的API： IsDebuggerPresent() NtQueryInformationProcess() NtQuerySystemInformation() N...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Windows","slug":"Windows","count":19,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":19,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":23,"path":"api/tags/note.json"},{"name":"reversecore","slug":"reversecore","count":4,"path":"api/tags/reversecore.json"},{"name":"antiDebug","slug":"antiDebug","count":2,"path":"api/tags/antiDebug.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}