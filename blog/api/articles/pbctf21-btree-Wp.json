{"title":"pbctf21 btree wp","uid":"37d6e393a967114c82f7d8a550ead81e","slug":"pbctf21-btree-Wp","date":"2021-10-09T04:00:00.000Z","updated":"2021-11-05T11:34:18.434Z","comments":true,"path":"api/articles/pbctf21-btree-Wp.json","keywords":null,"cover":null,"content":"<h1 id=\"PBCTF21-RE-BinaryTree-Beaengine-dijkstra解法\"><a href=\"#PBCTF21-RE-BinaryTree-Beaengine-dijkstra解法\" class=\"headerlink\" title=\"PBCTF21 RE BinaryTree Beaengine+dijkstra解法\"></a>PBCTF21 RE BinaryTree Beaengine+dijkstra解法</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>代码是动态解密的，简单的xor，解密一块执行一块。每一块结尾会设置rbx，rbx决定下一块被解密的代码。</p>\n<p>实际上每一块代码相当于一个节点，里面有一个根据输入的jz，决定下一个rbx以及一个cost，所以相当于一颗二叉树。</p>\n<p>每次经过一个节点都会累加cost。</p>\n<p>根节点对应的代码块会判断cost是否小于等于某个值，然后输出成功信息。</p>\n<p>如果只有唯一解那么显然是找最短路。</p>\n<p>解题思路是beaengine解析代码生成图，用dijkstra算法求最短路并输出路径。<br>事实上只有一条最短路，刚刚等于那个值。</p>\n<h2 id=\"beaengine提取图\"><a href=\"#beaengine提取图\" class=\"headerlink\" title=\"beaengine提取图\"></a>beaengine提取图</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;windows.h&gt;\n#include &lt;queue&gt;\n#include &lt;set&gt;\n#define BEA_ENGINE_STATIC\n#include &quot;BeaEngine.h&quot;\n#pragma comment(lib,&quot;legacy_stdio_definitions.lib&quot;)\n#pragma comment(lib, &quot;BeaEngine.lib&quot;)\n\nusing namespace std;\n\ntypedef struct Block &#123;\n\tint index;\n\tchar buf[32];\n&#125;;\n\nint path[25503][4] &#x3D; &#123; 0, &#125;; &#x2F;&#x2F; 0(path&#x2F;rbx,cost) 1(path&#x2F;rbx,cost)\n\nqueue&lt;pair&lt;int, Block*&gt;&gt; rbxs; &#x2F;&#x2F; rbx(xor offset), lastBlock\nint sa &#x3D; 0x176;\nBYTE* firstBlock;\nint blockNum &#x3D; 0;\nset&lt;int&gt; dised;\nBlock xorBlock &#x3D; &#123;\n\t0,\n\t0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x48,\n\t0xc7, 0xc7, 0x01, 0x00, 0x00, 0x00, 0x48, 0xc7,\n\t0xc2, 0x05, 0x00, 0x00, 0x00, 0x49, 0x81, 0xf9,\n\t0xda, 0x49, 0x00, 0x00, 0x7f, 0x07, 0x4c, 0x89\n&#125;;\n\nBlock* Xor(char* firstBlock, UInt64 offset, Block &amp;oldBlock)\n&#123;\n\tBlock* pB &#x3D; new Block();\n\tpB-&gt;index &#x3D; offset &gt;&gt; 5;\n\tblockNum++;\n\tchar* xorBuf &#x3D; firstBlock + offset;\n\tfor (int i &#x3D; 0; i &lt; 32; i++) &#123;\n\t\tpB-&gt;buf[i] &#x3D; xorBuf[i] ^ oldBlock.buf[i];\n\t&#125;\n\treturn pB;\n&#125;\n\nvoid Jmp(DISASM&amp; infos)\n&#123;\n\tUINT64 nextVA &#x3D; infos.Instruction.AddrValue;\n\tUINT64 curVA &#x3D; infos.VirtualAddr;\n\n\t&#x2F;&#x2F; jmp\n\tinfos.EIP +&#x3D; nextVA - curVA;\n\tinfos.VirtualAddr &#x3D; nextVA;\n&#125;\n\nvoid DisasmCode(char* stBuf, UINT64 stVA, Block* curBlock, int rbx, int branch)\n&#123;\n\tDISASM infos;\n\tsize_t len;\n\n\t&#x2F;&#x2F; init\n\tmemset(&amp;infos, 0, sizeof(DISASM));\n\tinfos.EIP &#x3D; (UINT64)stBuf;\n\tinfos.VirtualAddr &#x3D; (UINT64)stVA;\n\n\twhile (infos.Error &#x3D;&#x3D; 0) &#123;\n\t\t&#x2F;&#x2F; limit\n\t\tUInt64 offset &#x3D; infos.EIP - (UINT64)curBlock-&gt;buf;\n\t\tif (offset &lt; 0 || offset &gt;&#x3D; 32) &#123;\n\t\t\tbreak;\n\t\t&#125;\n\t\tif (infos.VirtualAddr &#x3D;&#x3D; 0x400080) &#123;&#x2F;&#x2F; xor\n\t\t\trbxs.push(make_pair(rbx, curBlock));\n\t\t\tbreak;\n\t\t&#125;\n\t\t\t\n\n\t\t&#x2F;&#x2F;disasm\n\t\tlen &#x3D; Disasm(&amp;infos);\n\t\tcout &lt;&lt; hex &lt;&lt; infos.VirtualAddr &lt;&lt; &quot; &quot; &lt;&lt; infos.CompleteInstr &lt;&lt; endl;\n\n\t\t&#x2F;&#x2F; jmp\n\t\tif (infos.Instruction.BranchType &#x3D;&#x3D; JmpType) &#123;\n\t\t\tif (infos.Instruction.AddrValue &#x3D;&#x3D; 0x400080) &#123; &#x2F;&#x2F; xor\n\t\t\t\trbxs.push(make_pair(rbx, curBlock));\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\t\n\t\t\tJmp(infos);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; jmp\n\t\tif (infos.Instruction.BranchType) &#123;\n\t\t\t&#x2F;&#x2F; false branch\n\t\t\tDisasmCode((char*)(infos.EIP + len), infos.VirtualAddr + len, curBlock, rbx, 0);\n\t\t\t&#x2F;&#x2F; true branch\n\t\t\tbranch &#x3D; 1;\n\t\t\tJmp(infos);\n\t\t\tcontinue;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; if modified rbx (0x8)\n\t\tif (((infos.Operand1.AccessMode &#x3D;&#x3D; WRITE) &amp;&amp; (infos.Operand1.Registers.gpr &amp; REG3))) &#123;\n\t\t\trbx +&#x3D; infos.Operand2.Memory.Displacement;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; if add r9 (0x200)\n\t\tif ((infos.Operand1.AccessMode &#x3D;&#x3D; 3) &amp;&amp; (infos.Operand1.Registers.gpr &amp; 0x200)) &#123;\n\t\t\tif (branch &gt;&#x3D; 0) &#123;\n\t\t\t\tpath[curBlock-&gt;index][branch * 2] &#x3D; rbx &gt;&gt; 5;\n\t\t\t\tpath[curBlock-&gt;index][branch * 2 + 1] &#x3D; infos.Instruction.Immediat;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; go on\n\t\tinfos.EIP +&#x3D; len;\n\t\tinfos.VirtualAddr +&#x3D; len;\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\tifstream fin;\n\tofstream fout;\n\tBYTE* fileBuf;\n\tBlock* lastBlock;\n\tBlock* pB;\n\n\t&#x2F;&#x2F; read file\n\n\tfin.open(&quot;E:\\\\works\\\\ctf\\\\21pbctf\\\\re_BinaryTree\\\\main.elf&quot;, ios::in | ios::binary);\n\n\tfin.seekg(0, ios::end);\n\tsize_t fileSize &#x3D; fin.tellg();\n\tfin.seekg(0, ios::beg);\n\tfileBuf &#x3D; (BYTE*)malloc(fileSize);\n\tfin.read((char*)fileBuf, fileSize);\n\n\tcout &lt;&lt; &quot;fileSize:&quot; &lt;&lt; dec &lt;&lt; fileSize &lt;&lt; endl;\n\tfin.close();\n\n\t&#x2F;&#x2F; disasm\n\n\tfirstBlock &#x3D; fileBuf + sa;\n\n\tcout &lt;&lt; &quot;rbx:0&quot; &lt;&lt; endl;\n\tpB &#x3D; Xor((char*)firstBlock, 0, xorBlock);\n\tdised.insert(0);\n\tDisasmCode(pB-&gt;buf, 0x4000AD, pB, 0, 0);\n\twhile (!rbxs.empty()) &#123;\n\t\tpair&lt;int, Block*&gt; t &#x3D; rbxs.front();\n\t\trbxs.pop();\n\n\t\tlastBlock &#x3D; t.second;\n\n\t\tcout &lt;&lt; &quot;num:&quot; &lt;&lt; dec &lt;&lt; blockNum &lt;&lt; endl; &#x2F;&#x2F; 0x639f * 2\n\t\t\n\t\tif (dised.insert(t.first).second) &#123;\n\t\t\t&#x2F;&#x2F; not disasm\n\t\t\tpB &#x3D; Xor((char*)firstBlock, t.first, *lastBlock);\n\t\t\t&#x2F;&#x2F; disasm\n\t\t\tDisasmCode(pB-&gt;buf, 0x4000AD, pB, 0, -1);\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; write file\n\n\tfout.open(&quot;E:\\\\works\\\\ctf\\\\21pbctf\\\\re_BinaryTree\\\\main_.elf&quot;, ios::out | ios::binary);\n\tfout.write((char*)fileBuf, fileSize);\n\tfout.close();\n\n\t&#x2F;&#x2F; write file\n\n\tfout.open(&quot;E:\\\\works\\\\ctf\\\\21pbctf\\\\re_BinaryTree\\\\path.txt&quot;, ios::out);\n\tfor (int i &#x3D; 0; i &lt; blockNum; i++) &#123;\n\t\tfout &lt;&lt; path[i][0] &lt;&lt; &quot; &quot; &lt;&lt; path[i][1] &lt;&lt; &quot; &quot; &lt;&lt; path[i][2] &lt;&lt; &quot; &quot; &lt;&lt; path[i][3] &lt;&lt; endl;\n\t&#125;\n\tfout.close();\n\n\tfout.open(&quot;E:\\\\works\\\\ctf\\\\21pbctf\\\\re_BinaryTree\\\\pathDij.txt&quot;, ios::out);\n\tint E &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; blockNum; i++) &#123;\n\t\tif (path[i][1]) &#123;\n\t\t\tfout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; path[i][0] &lt;&lt; &quot; &quot; &lt;&lt; path[i][1] &lt;&lt; endl;\n\t\t\tfout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; path[i][2] &lt;&lt; &quot; &quot; &lt;&lt; path[i][3] &lt;&lt; endl;\n\t\t\tE +&#x3D; 2;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tcout &lt;&lt; i &lt;&lt; &quot;,&quot;;\n\t\t&#125;\n\t&#125;\n\tcout &lt;&lt; endl;\n\tfout.close();\n\n\tcout &lt;&lt; &quot;N E\\n&quot;;\n\tcout &lt;&lt; dec &lt;&lt; blockNum &lt;&lt; &quot; &quot; &lt;&lt; E &lt;&lt; endl;\n\t&#x2F;&#x2F; 25503 50942 0\n\n\treturn 0;\n&#125;\n</code></pre>\n\n<h2 id=\"dijkstra算法\"><a href=\"#dijkstra算法\" class=\"headerlink\" title=\"dijkstra算法\"></a>dijkstra算法</h2><p>自己打oi时留下的板子，忘记有没有加优化了，不过这个版本比较方便记录path</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;*\n* 有向+无向，不能用于负权图\n*&#x2F;\n\n#pragma warning(disable:4996)\n\n#include &lt;stdio.h&gt;\n#include &lt;list&gt;\n#include &lt;set&gt;\n#include &lt;utility&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; TR;\nstruct Edge &#123;\n\tint v;\n\tint w;\n&#125;;\n\nint roots[] &#x3D; &#123; 1225,1226,1891,1892,3929,3930,4929,4930,6295,6296,9313,9314,9813,9814,15465,15466,15713,15714,17301,17302,18767,18768,18841,18842,19145,19146,19279,19280,19927,19928,22501,22502 &#125;;\nint path[50943];\nint path1[50943];\n\ninline bool min(int a, int b)\n&#123;\n\tif (a !&#x3D; -1 &amp;&amp; (a &lt; b || b &#x3D;&#x3D; -1))\n\t\treturn true;\n\telse\n\t\treturn false;\n&#125;\n\nint main()\n&#123;\n\tFILE* r &#x3D; freopen(&quot;E:\\\\works\\\\ctf\\\\21pbctf\\\\re_BinaryTree\\\\pathDij.txt&quot;, &quot;r&quot;, stdin);\n\n\tint i, j, u, v, w;\n\tEdge edge;\n\tlist&lt;Edge&gt;::iterator it;\n\tTR tr;\n\n\tint N, E, start, iMin, nMin;\n\tint* flag;\n\tset&lt;TR&gt; ds;\n\tint* d;\n\tlist&lt;Edge&gt;* es;\n\n\tscanf(&quot;%d %d&quot;, &amp;N, &amp;E);\n\tscanf(&quot;%d&quot;, &amp;start);\n\n\t&#x2F;&#x2F; 初始化\n\tflag &#x3D; new int[N];\n\td &#x3D; new int[N];\n\tfor (i &#x3D; 0; i &lt; N; i++) &#123;\n\t\tflag[i] &#x3D; 0;\n\t\td[i] &#x3D; -1;\n\t\tpath[i] &#x3D; -1;\n\t&#125;\n\tds.insert(make_pair(0, start));\n\td[start] &#x3D; 0;\n\n\t&#x2F;&#x2F; 读图\n\tes &#x3D; new list&lt;Edge&gt;[N];\n\tint boo &#x3D; 1;\n\tfor (i &#x3D; 0; i &lt; E; i++) &#123;\n\t\tscanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w);\n\t\tedge.v &#x3D; v;\n\t\tedge.w &#x3D; w;\n\t\tes[u].push_back(edge);\n\t\tif (boo) &#123;\n\t\t\tboo &#x3D; 0;\n\t\t\tpath1[u] &#x3D; v;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tboo &#x3D; 1;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; dij\n\twhile (!ds.empty()) &#123;\n\t\t&#x2F;&#x2F; 找最小未完成节点（确保d[iMin] !&#x3D; -1）\n\t\tiMin &#x3D; ds.begin()-&gt;second;\n\t\tnMin &#x3D; ds.begin()-&gt;first;\n\t\tds.erase(ds.begin());\n\n\t\t&#x2F;&#x2F; 标记完成\n\t\tu &#x3D; iMin;\n\t\tflag[u] &#x3D; 1;\n\n\t\t&#x2F;&#x2F; 依次松弛\n\t\tfor (it &#x3D; es[u].begin(); it !&#x3D; es[u].end(); it++) &#123;\n\t\t\tv &#x3D; it-&gt;v;\n\t\t\tw &#x3D; d[iMin] + it-&gt;w;\n\t\t\tif (w &#x3D;&#x3D; d[v])\n\t\t\t\tpath[v] &#x3D; u;\n\t\t\tif (min(w, d[v])) &#123;\n\t\t\t\td[v] &#x3D; w;\n\t\t\t\t&#x2F;&#x2F; 加入set\n\t\t\t\ttr &#x3D; make_pair(w, v);\n\t\t\t\tif (ds.find(tr) !&#x3D; ds.end()) ds.erase(tr);\n\t\t\t\tds.insert(tr);\n\t\t\t\tpath[v] &#x3D; u;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 输出结果\n\t&#x2F;&#x2F; for (i &#x3D; 0; i &lt; N; i++)\n\t&#x2F;&#x2F;\tprintf(&quot;%d:%d\\n&quot;, i, d[i]);\n\t&#x2F;&#x2F; putchar(10);\n\n\tcout &lt;&lt; &quot;\\nans:\\n&quot;;\n\tfor (i &#x3D; 0; i &lt; 32; i++) &#123;\n\t\tcout &lt;&lt; d[roots[i]] &lt;&lt; &quot; &quot;;\n\t&#125;\n\n\tcout &lt;&lt; &quot;\\nshortest:\\n&quot;;\n\tfor (i &#x3D; 0; i &lt; 32; i++) &#123;\n\t\tif (d[roots[i]] &lt;&#x3D; 0x49DA) &#123;\n\t\t\tcout &lt;&lt; roots[i] &lt;&lt; &quot;:&quot; &lt;&lt; d[roots[i]] &lt;&lt; &quot; &quot; &lt;&lt; endl;\n\t\t&#125;\n\t&#125;\n\n\tcout &lt;&lt; &quot;\\npath\\n&quot;;\n\ti &#x3D; 19279;\n\tdo &#123;\n\t\ti &#x3D; path[i];\n\t\tcout &lt;&lt; i &lt;&lt; &quot; &quot;;\n\t&#125; while (i);\n\n\tcout &lt;&lt; &quot;\\npath\\n&quot;;\n\ti &#x3D; 19279;\n\tdo &#123;\n\t\t&#x2F;&#x2F; path[i] -&gt; i\n\t\tif (path1[path[i]] &#x3D;&#x3D; i)\n\t\t\tcout &lt;&lt; 1;\n\t\telse\n\t\t\tcout &lt;&lt; 0;\n\t\ti &#x3D; path[i];\n\t&#125; while (i);\n\n\ti &#x3D; 0;\n\tj &#x3D; 0;\n\twhile (!es[i].empty()) &#123;\n\t\ti &#x3D; es[i].begin()-&gt;v;\n\t\tj++;\n\t&#125;\n\tcout &lt;&lt; &quot;\\nl:&quot; &lt;&lt; j &lt;&lt; endl;\n\n\t&#x2F;&#x2F; 释放内存\n\tdelete[] flag;\n\tdelete[] es;\n\n\treturn 0;\n&#125;\n</code></pre>\n\n<h2 id=\"long2bytes\"><a href=\"#long2bytes\" class=\"headerlink\" title=\"long2bytes\"></a>long2bytes</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from Crypto.Util.number import long_to_bytes\n\nans &#x3D; &#39;01111101001101110110010101100101011001100110001001100001001110000011000000110110001100100110001000110001011001100011011100110001001100000011100101100011001100110011000100110101011000110110000100111000001101110011010001100001001100100011001001100010011000100011000000110011011001010011000000110011011000110011010000110111011001010101111100100001001000010110010101100100011011110110001101011111011001110110111001101001011110010110011001101001011001000110111101101101001011010110011001101100011001010111001101011111011011100110100101011111011010000111010001100001011100000101111101110100011100110110010101110100011100100110111101101000011100110101111101100101011010000111010001011111011001110110111001101001011001000110111001101001011001100010000100100001011110110110011001110100011000110110001001110000&#39;\nans &#x3D; int(ans, 2)\nprint(long_to_bytes(ans)[::-1])</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>[<a href=\"https://bbs.pediy.com/thread-269815.htm\">原创]PBCTF21 RE BinaryTree Beaengine+dijkstra解法-bbs.pediy.com</a></p>\n","text":"PBCTF21 RE BinaryTree Beaengine+dijkstra解法思路代码是动态解密的，简单的xor，解密一块执行一块。每一块结尾会设置rbx，rbx决定下一块被解密的代码。 实际上每一块代码相当于一个节点，里面有一个根据输入的jz，决定下一个rbx以及一个co...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"CTF","slug":"CTF","count":7,"path":"api/categories/CTF.json"}],"tags":[{"name":"ctf","slug":"ctf","count":7,"path":"api/tags/ctf.json"},{"name":"re","slug":"re","count":10,"path":"api/tags/re.json"},{"name":"wp","slug":"wp","count":7,"path":"api/tags/wp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#PBCTF21-RE-BinaryTree-Beaengine-dijkstra%E8%A7%A3%E6%B3%95\"><span class=\"toc-text\">PBCTF21 RE BinaryTree Beaengine+dijkstra解法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#beaengine%E6%8F%90%E5%8F%96%E5%9B%BE\"><span class=\"toc-text\">beaengine提取图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#dijkstra%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">dijkstra算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#long2bytes\"><span class=\"toc-text\">long2bytes</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"逆向工程核心原理 R3静态反调试 笔记","uid":"2b002dec449ce21e3d8b7af026d74ae7","slug":"recoreR3StaAntiDebug","date":"2021-10-16T04:00:00.000Z","updated":"2021-11-05T11:43:17.496Z","comments":true,"path":"api/articles/recoreR3StaAntiDebug.json","keywords":null,"cover":null,"text":"逆向工程核心原理 R3静态反调试 笔记摘要主要是R3层面的静态反调试手段 参考逆向工程核心原理51章静态反调试 涉及的API： IsDebuggerPresent() NtQueryInformationProcess() NtQuerySystemInformation() N...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Windows","slug":"Windows","count":13,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":13,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":13,"path":"api/tags/note.json"},{"name":"reversecore","slug":"reversecore","count":4,"path":"api/tags/reversecore.json"},{"name":"antiDebug","slug":"antiDebug","count":3,"path":"api/tags/antiDebug.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"vmp2 (3) handler类型总结","uid":"796d9083672966112e1391db00c01e6d","slug":"vmp2-p3","date":"2021-09-28T04:00:00.000Z","updated":"2021-09-28T10:30:30.953Z","comments":true,"path":"api/articles/vmp2-p3.json","keywords":null,"cover":null,"text":"VMP2（3）handler类型总结摘要详细分析push、pop、计算类handler以及粗略分析其余handler后对handler进行分类并做一些总结。 字节码vm字节码结构有三种： opcode(1B) opcode(1B) + Imm(1~8B) opcode(1B) +...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"Re","slug":"Re","count":3,"path":"api/categories/Re.json"}],"tags":[{"name":"re","slug":"re","count":10,"path":"api/tags/re.json"},{"name":"vmp2","slug":"vmp2","count":3,"path":"api/tags/vmp2.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}