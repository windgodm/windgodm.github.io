{"title":"B站x64内核笔记2 PG","uid":"6b5e22753329d2c346dcd0a78d93034d","slug":"zh-patchguard","date":"2022-07-06T04:00:00.000Z","updated":"2022-09-26T10:27:16.767Z","comments":true,"path":"api/articles/zh-patchguard.json","keywords":null,"cover":null,"content":"<h1 id=\"PatchGuard\"><a href=\"#PatchGuard\" class=\"headerlink\" title=\"PatchGuard\"></a>PatchGuard</h1><h2 id=\"Step-1-设-BigPool-不可执行\"><a href=\"#Step-1-设-BigPool-不可执行\" class=\"headerlink\" title=\"Step 1 设 BigPool 不可执行\"></a>Step 1 设 BigPool 不可执行</h2><p>编写一个驱动，遍历BigPool信息，将可疑的BigPool设置为不可执行，等待蓝屏</p>\n<p>然后分析蓝屏信息得到context入口点，简要分析context入口点</p>\n<h3 id=\"1-查询所有BigPool\"><a href=\"#1-查询所有BigPool\" class=\"headerlink\" title=\"1 查询所有BigPool\"></a>1 查询所有BigPool</h3><p>使用<code>ZwQuerySystemInformation</code>获取所有BigPool的信息</p>\n<p><strong>细节：申请长度要比第一次查询长度大</strong></p>\n<p>第一次查询获取长度，第二次查询获取数据。</p>\n<p>因为第二次查询时分配的用于接收的空间也属于BigPool，也就说第二次查询时BigPool的数量可能比第一次的要多，除此以外也可能有新生成的。</p>\n<p>关键查询代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 获取数据长度\nstatus &#x3D; ZwQuerySystemInformation(SystemBigPoolInformation, pBigPoolInfo, sizeof(SYSTEM_BIGPOOL_INFORMATION), &amp;returnLength);\n&#x2F;&#x2F; 申请空间\npBigPoolInfo &#x3D;     (PSYSTEM_BIGPOOL_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, returnLength + 0x1000, &#39;tag&#39;);\n&#x2F;&#x2F; 获取数据\nZwQuerySystemInformation(SystemBigPoolInformation, pBigPoolInfo, returnLength + 0x1000, &amp;returnLength);</code></pre>\n\n\n\n<h3 id=\"2-设置BigPool不可执行（触发蓝屏）\"><a href=\"#2-设置BigPool不可执行（触发蓝屏）\" class=\"headerlink\" title=\"2 设置BigPool不可执行（触发蓝屏）\"></a>2 设置BigPool不可执行（触发蓝屏）</h3><p>需要获取BigPool起始地址的pte、pde，检查其属性</p>\n<p>检查内容：</p>\n<ul>\n<li>BigPool长度</li>\n<li>pde为4K页面（0x80 = 0）</li>\n<li>pte不是noExec（64位 = 0）</li>\n<li>pte页面存在（1位 = 1）</li>\n</ul>\n<p>关键判断代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">if (entry-&gt;SizeInBytes &gt;&#x3D; 0x8000) &#123;\n    if (!(pde &amp; 0x80)) &#123; &#x2F;&#x2F; 4K page\n        &#x2F;&#x2F; bitmap, 1:p, 64:noExec\n        if (((pte &amp; 0x8000000000000000) &#x3D;&#x3D; 0) &amp;&amp; (pte &amp; 1)) &#123;\n            &#x2F;&#x2F; 2.2 Set NoExec\n            count +&#x3D; 1;\n            KdPrint((&quot;[PG] va: 0x%llX size: 0x%X pte: 0x%llX\\n&quot;, va, entry-&gt;SizeInBytes, pte));\n            pte |&#x3D; 0x8000000000000000;\n            *ppte |&#x3D; pte;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>！！！最后记得释放<code>ExFreePool(pBigPoolInfo)</code></p>\n<h3 id=\"3-分析执行异常蓝屏（0xFC）\"><a href=\"#3-分析执行异常蓝屏（0xFC）\" class=\"headerlink\" title=\"3 分析执行异常蓝屏（0xFC）\"></a>3 分析执行异常蓝屏（0xFC）</h3><p>首先记得设置好dump，<strong>拍摄快照</strong>，然后运行驱动，2分钟左右会触发蓝屏，使用windbg分析</p>\n<p>驱动调试信息如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[PG] returnLength: 0x31A48\n[PG] returnLength: 0x31A60\n[PG] va: 0xFFFF8585AF113001 size: 0x6F000\n[PG] va: 0xFFFF8585B65AC001 size: 0x33000\n[PG] va: 0xFFFF8585AF182001 size: 0x43000</code></pre>\n\n<p>首先驱动输出了两次查询的数据长度</p>\n<p>然后输出了符合条件的BigPool的信息，可以看到设置了三个BigPool起始4k页面不可执行，其中第二个是BigPool信息那个数组。剩下两个可能是context。</p>\n<p>windbg的<code>!analyze -v</code>截取结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY (fc)\n\nArguments:\nArg1: ffff8585af1821fe, Virtual address for the attempted execute.\nArg2: 8a0000000405d963, PTE contents.\nArg3: fffff80105eb39e0, (reserved)\nArg4: 0000000000000000, (reserved)</code></pre>\n\n<p>错误为尝试执行NoExec的内存，然后看Arg1，确定就是由前面第3个被设为不可执行的BigPool触发的</p>\n<p>反汇编该地址（顺便给出运行到该地址时的RCX、RDX）：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">rcx&#x3D;ffff8585af1821fe rdx&#x3D;51ba0dd28a51cdb8\n\nkd&gt; u ffff8585af1821fe\nffff8585&#96;af1821fe 2e483111        xor     qword ptr cs:[rcx],rdx\nffff8585&#96;af182202 9a              ???\nffff8585&#96;af182203 3ceb            cmp     al,0EBh\nffff8585&#96;af182205 59              pop     rcx</code></pre>\n\n<p>这是一段自解密代码，搜索<code>1131482Eh</code>能找到其原本（这段是其加密后的副本），微软给的名称为<code>CmpAppendDllSection</code>，<code>ntoskrnl.exe</code>中的是异或加密前的内容</p>\n<h3 id=\"4-调试\"><a href=\"#4-调试\" class=\"headerlink\" title=\"4 调试\"></a>4 调试</h3><p>恢复快照，连上windbg，迅速在刚刚Arg1的地方下一个断点，再等两分钟（这次别运行驱动，让他能够正常执行）</p>\n<p>smc代码解密完自身以后，会解密其余部分：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">ffff8585&#96;af18227d 483184cac0000000 xor     qword ptr [rdx+rcx*8+0C0h],rax\nffff8585&#96;af182285 48d3c8          ror     rax,cl\nffff8585&#96;af182288 480fbbc0        btc     rax,rax\nffff8585&#96;af18228c e2ef            loop    ffff8585&#96;af18227d</code></pre>\n\n\n\n<p>解密完其余部分后，会执行<code>call rax</code>，一般都会去到同一个函数，能在<code>ntoskrnl.exe</code>中的<code>INITKDBG</code>段搜到其原本，有人称之为PG入口点</p>\n<p>下面是其开头的汇编，有点普通，建议往下再跟一点然后再去搜</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">kd&gt; p\nffff8585&#96;af18229b ffd0            call    rax\nkd&gt; r rax\nrax&#x3D;ffff8585af19c55f\nkd&gt; u ffff8585af19c55f\nffff8585&#96;af19c55f 488bc4          mov     rax,rsp\nffff8585&#96;af19c562 48895808        mov     qword ptr [rax+8],rbx\nffff8585&#96;af19c566 48897018        mov     qword ptr [rax+18h],rsi\nffff8585&#96;af19c56a 48897820        mov     qword ptr [rax+20h],rdi\nffff8585&#96;af19c56e 48895010        mov     qword ptr [rax+10h],rdx\nffff8585&#96;af19c572 55              push    rbp\nffff8585&#96;af19c573 4154            push    r12\nffff8585&#96;af19c575 4155            push    r13\n; ...\nffff8585&#96;af19c5cc 740b            je      ffff8585&#96;af19c5d9\nffff8585&#96;af19c5ce 448838          mov     byte ptr [rax],r15b\nffff8585&#96;af19c5d1 4903c4          add     rax,r12\nffff8585&#96;af19c5d4 83c1ff          add     ecx,0FFFFFFFFh</code></pre>\n\n\n\n<p><strong>更进一步（分析调用源）</strong></p>\n<p>刚触发断点的时候，可以尝试栈回溯，找到调用源</p>\n<h2 id=\"Step-2-接管页面异常\"><a href=\"#Step-2-接管页面异常\" class=\"headerlink\" title=\"Step 2 接管页面异常\"></a>Step 2 接管页面异常</h2><h3 id=\"1-接管页面异常\"><a href=\"#1-接管页面异常\" class=\"headerlink\" title=\"1 接管页面异常\"></a>1 接管页面异常</h3><p>接管页面异常，具体hook的方法八仙过海了，然后根据前面分析结果，context入口一般为<code>1131482Eh</code>这句自解密代码，以此为判断标准，决定是否接管</p>\n<p><strong>简述页面异常</strong></p>\n<p>处理页面异常的是0xE号中断，似乎是因为内核隔离，idt的0xE号中断对应为<code>KiPageFaultShadow</code>，这个函数只是个Stub，做切换cr3等工作，然后<code>jmp</code>（不是<code>call</code>）到<code>KiPageFault</code></p>\n<p>所以直接hook<code>KiPageFault</code>，比较省事</p>\n<p>给出刚进入<code>KiPageFault</code>时的栈：</p>\n<table>\n<thead>\n<tr>\n<th>rsp offset(hex)</th>\n<th>arg</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>00</td>\n<td>error code</td>\n</tr>\n<tr>\n<td>08</td>\n<td>rip</td>\n</tr>\n<tr>\n<td>10</td>\n<td>cs</td>\n</tr>\n<tr>\n<td>18</td>\n<td>rflags</td>\n</tr>\n<tr>\n<td>20</td>\n<td>rsp（原rsp）</td>\n</tr>\n<tr>\n<td>28</td>\n<td>ss（r0触发异常一般是一样的）</td>\n</tr>\n<tr>\n<td>+8</td>\n<td>Align（保证当前rsp16位对齐）</td>\n</tr>\n<tr>\n<td>+8</td>\n<td>返回地址（原rsp指向）</td>\n</tr>\n</tbody></table>\n<p><strong>判断标准</strong></p>\n<p>前面说了，根据目前分析的结果，满足一下条件就接管：</p>\n<ul>\n<li><code>error code == 11h</code>（10h执行异常 + 1页面存在）</li>\n<li><code>[rip] == 1131482Eh </code>（smc代码开头）</li>\n</ul>\n<p><strong>接管处理</strong></p>\n<p>直接恢复rflags、ss、rip，然后直接return（恢复rsp后，rsp就指向原返回地址了）</p>\n<p><strong>细节</strong></p>\n<p>注意栈的平衡，还有寄存器的使用。如果需要用到寄存器，建议先push。然后在还原rsp前pop，还原寄存器</p>\n<h3 id=\"2-加速蓝屏（由PG检查引发的）\"><a href=\"#2-加速蓝屏（由PG检查引发的）\" class=\"headerlink\" title=\"2 加速蓝屏（由PG检查引发的）\"></a>2 加速蓝屏（由PG检查引发的）</h3><p>Step1设置BigPool不可执行后，可能会有漏网之鱼。比如context是在Step1以后创建的；或者context原本就不在BigPool；或者Context在Step1时不可执行，执行前再设为可执行</p>\n<p>所以需要hook关键内存（PG频繁检查的地方），让漏网之鱼检查出现异常，然后触发蓝屏</p>\n<p>重启虚拟机，拍一个新快照：</p>\n<ul>\n<li>重启时不选择调试模式等，正常启动即可</li>\n<li>用DSEFix（<a href=\"https://github.com/hfiref0x/DSEFix\">hfiref0x/DSEFix(github.com)</a>）加载未签名驱动</li>\n<li>设置休眠时间为从不</li>\n<li>不要附加调试器</li>\n<li>拍摄快照</li>\n</ul>\n<p>驱动新增如下功能：</p>\n<ul>\n<li>驱动hook memmove</li>\n</ul>\n<p>其中使用DSE Fix和hook memmove都会加速蓝屏（PG错误）</p>\n<p>然后运行DSE Fix，加载驱动，等蓝屏</p>\n<p>获取NT_Base小技巧：先按上述步骤，加载驱动后马上蓝屏，因为重启后NT_Base变了，此时可以分析蓝屏文件获取BASE、或者系统函数的地址；修复函数的地址后，再恢复快照加载驱动，等PG蓝屏</p>\n<h3 id=\"3-分析PG蓝屏（0x109）\"><a href=\"#3-分析PG蓝屏（0x109）\" class=\"headerlink\" title=\"3 分析PG蓝屏（0x109）\"></a>3 分析PG蓝屏（0x109）</h3><p>我这里大概两分钟左右会触发蓝屏</p>\n<p>因为非调试模式没有办法在windbg中接收驱动的调试信息，然后又懒得在虚拟机中把log信息保存成文件，这里只记录了dump文件的信息</p>\n<p><strong>PG蓝屏</strong></p>\n<p>windbg的<code>!analyze -v</code>截取结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">CRITICAL_STRUCTURE_CORRUPTION (109)\n\nArguments:\nArg1: a39feeda0d18b86d, Reserved\nArg2: b3b6fb605f96f9a5, Reserved\nArg3: fffff8072d821cc0, Failure type dependent information\nArg4: 0000000000000000</code></pre>\n\n<p>109错误代表由PG错误；即context被调用，然后检查出被patch，接着触发蓝屏</p>\n<p>先看Arg3：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">kd&gt; u fffff8072d821cc0\nnt!memcpy:\nfffff807&#96;2d821cc0 488bc1          mov     rax,rcx</code></pre>\n\n<p>Arg3是PG或者说context发现被patch的地址</p>\n<p>正是我的驱动为了加速蓝屏所hook的memcpy，此时该函数已经被PG还原</p>\n<p>Arg1、Arg2需要减去两个魔数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Arg1: a39feeda0d18b86d - A3A03F5891C8B4E8 &#x3D; ffffaf81&#96;7b500385\nArg2: b3b6fb605f96f9a5 - B3B74BDEE4453415 &#x3D; ffffaf81&#96;7b51c590</code></pre>\n\n\n\n<p>先分析解密后的Arg1：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">kd&gt; u ffffaf81&#96;7b500385\nffffaf81&#96;7b500385 2e483111        xor     qword ptr cs:[rcx],rdx\nffffaf81&#96;7b500389 48315108        xor     qword ptr [rcx+8],rdx\nffffaf81&#96;7b50038d 48315110        xor     qword ptr [rcx+10h],rdx\nffffaf81&#96;7b500391 48315118        xor     qword ptr [rcx+18h],rdx</code></pre>\n\n<p>Arg1是context的smc起始地址</p>\n<p>然后截取一部分Arg2：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">kd&gt; dqs ffffaf81&#96;7b51c590\nffffaf81&#96;7b51c590  00000000&#96;00000000\nffffaf81&#96;7b51c598  fffff807&#96;2d821cc0 nt!memcpy ; 检测地址\nffffaf81&#96;7b51c5a0  52802a0c&#96;000002aa ; 检测0x2aa个字节，结果为52802a0c\nffffaf81&#96;7b51c5a8  00000000&#96;00000001\nffffaf81&#96;7b51c5b0  00000000&#96;00000000\nffffaf81&#96;7b51c5b8  00000000&#96;00000000</code></pre>\n\n<p>Arg2指向一个结构体数组的某一项，这个结构体数组记录了要检测的内容，此时Arg2指向数组中检查出错的那一项</p>\n<ul>\n<li>+8h(PVOID)：是校验的地址，对应前面的memcpy的起始地址</li>\n<li>+10h(UINT)：是校验的长度（以校验地址为起始）</li>\n<li>+14h(UINT)：是校验的结果</li>\n</ul>\n<p>PG会对校验地址处的数据执行一些运算，然后与校验结果比较判断是否被patch</p>\n<p><strong>非Big Pool地址</strong></p>\n<p>现在问题是Arg1所指向的地址，没有被设置为不可执行</p>\n<p>发现不是Big Pool：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">kd&gt; !pool ffffaf81&#96;7b500385\nPool page ffffaf817b500385 region is Unknown</code></pre>\n\n<p>发现在一片<code>SystemRange</code>中：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">kd&gt; !address ffffaf81&#96;7b500385\nUsage:                  \nBase Address:           ffff8000&#96;00000000\nEnd Address:            ffffc20b&#96;9fa00000\nRegion Size:            0000420b&#96;9fa00000\nVA Type:                SystemRange</code></pre>\n\n\n\n<h3 id=\"4-IndependentPages\"><a href=\"#4-IndependentPages\" class=\"headerlink\" title=\"4 IndependentPages\"></a>4 IndependentPages</h3><p>通过资料可知有如下API可以分配、修改、释放一片内存，且该内存不在Big Pool中</p>\n<ul>\n<li>MmAllocateIndependentPages<ul>\n<li>分配内存，初始属性为不可执行</li>\n</ul>\n</li>\n<li>SetPageProtection<ul>\n<li>设置内存属性</li>\n</ul>\n</li>\n<li>MmFreeIndependentPages<ul>\n<li>释放内存</li>\n</ul>\n</li>\n</ul>\n<p>通过对<code>MmAllocateIndependentPagesEx</code>交叉引用分析，可以发现该函数只被context的那个巨大函数所使用，顺便能找出一整套内存分配释放的函数，这几个函数都只被PG调用：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">INIT:FFFFF80103E1ED3D 48 8D 05 BC E4 D2 FF                    lea     rax, MmAllocateIndependentPages\nINIT:FFFFF80103E1ED44 49 89 86 20 02 00 00                    mov     [r14+220h], rax\nINIT:FFFFF80103E1ED4B 48 8D 05 EE 01 D3 FF                    lea     rax, MmFreeIndependentPages\nINIT:FFFFF80103E1ED52 49 89 86 28 02 00 00                    mov     [r14+228h], rax\nINIT:FFFFF80103E1ED59 48 8D 05 80 9F 95 FF                    lea     rax, MmSetPageProtection\nINIT:FFFFF80103E1ED60 49 89 86 30 02 00 00                    mov     [r14+230h], rax</code></pre>\n\n\n\n<p>网上只找到<code>MmAllocateIndependentPages</code>的定义（<a href=\"https://www.codewarrior.cn/ntdoc/wrk/mm/MmAllocateIndependentPages.htm\">MmAllocateIndependentPages (codewarrior.cn)</a>）：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">PVOID\nMmAllocateIndependentPages(\n  IN  SIZE_T NumberOfBytes,\n  IN  ULONG Node\n  );</code></pre>\n\n<p>该函数分配的内存为不可执行，也就是需要调用<code>SetPageProtection</code>后才能执行</p>\n<p>这就意味如果要拦截新生成的context，可以只hook修改属性的<code>SetPageProtection</code></p>\n<h2 id=\"Step-3-设置-Ind-Page-不可执行\"><a href=\"#Step-3-设置-Ind-Page-不可执行\" class=\"headerlink\" title=\"Step 3 设置 Ind. Page 不可执行\"></a>Step 3 设置 Ind. Page 不可执行</h2><h3 id=\"1-搜索-Ind-Page\"><a href=\"#1-搜索-Ind-Page\" class=\"headerlink\" title=\"1 搜索 Ind. Page\"></a>1 搜索 Ind. Page</h3><p>现在先拦截已经分配了的context，思路和BigPool类似，也是找大页面，然后设第一个4k页面为不可执行</p>\n<p>因为没有查询的API，所以只能一块一块暴力搜索，如果相邻的两块页面都是存在的，则当成是一起的，以此来判断其大小。这样可能会杀错，但不容易错过（他context总不能分开到两块不相邻的地址空间吧）</p>\n<h3 id=\"1-换页问题\"><a href=\"#1-换页问题\" class=\"headerlink\" title=\"1? 换页问题\"></a>1? 换页问题</h3><p>不确定Ind. Page会不会被换出，换出pte.valid似乎就为0了，就会漏掉；拦截换入可能需要修改页面异常的处理</p>\n<h3 id=\"2-测试结果\"><a href=\"#2-测试结果\" class=\"headerlink\" title=\"2 测试结果\"></a>2 测试结果</h3><p>（非调式都用了DSEfix）</p>\n<p><strong>没VT、非调试</strong></p>\n<p>测试了一个快照（刚开机），两个小时没错误</p>\n<p><strong>没VT、调试</strong></p>\n<p>换成调试模式，挂windbg，u了一下<code>MmAllocateIndependentPages</code>，全是问号，页面不存在</p>\n<p><strong>有VT、非调试</strong></p>\n<p>测试了一个快照（刚开机），两个小时没错误</p>\n<p><strong>有VT、调试</strong></p>\n<p>测试了一个快照（刚开机），1分钟左右炸了，死机，不关机也不蓝屏</p>\n<p>详情见下面错误分析</p>\n<h3 id=\"3-错误分析\"><a href=\"#3-错误分析\" class=\"headerlink\" title=\"3 错误分析\"></a>3 错误分析</h3><p>环境：开启VT + 调试模式<br>过1分钟左右会卡住不动，没有蓝屏、没有关机（连不连调试器都一样）</p>\n<p>截取连调试器后，蓝屏前的log：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">*** Fatal System Error: 0x00000109\n                       (0xA3A024E0D7EF077A,0xB3B731672A6D48B2,0xFFFFF80459416CC0,0x0000000000000000)</code></pre>\n\n<p>解密Arg1、2：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0xA3A024E0D7EF077A - 0xA3A03F5891C8B4E8 &#x3D; 0xFFFFE58846265292\n0xB3B731672A6D48B2 - 0xB3B74BDEE4453415 &#x3D; 0xFFFFE5884628149D\n0xFFFFF80459416CC0 !memcpy</code></pre>\n\n<p>arg1应该是smc起始地址，离之前设为NX的bigpool很近，猜测是个bigpool，但没有被设为NX，可能搜索后分配的或者搜索后设为可执行的</p>\n<p>（这里windbg也卡住了，没办法判断这个地址是什么）</p>\n<p>arg3应该是校验发现被patch的地址，通过log发现是为了加速蓝屏hook的memcpy</p>\n<h2 id=\"Step-4-接管内存分配、属性设置\"><a href=\"#Step-4-接管内存分配、属性设置\" class=\"headerlink\" title=\"Step 4 接管内存分配、属性设置\"></a>Step 4 接管内存分配、属性设置</h2><p>由上面错误可知可能是新big pool，或后来被设为可执行的</p>\n<p>所以顺便把Big Pool的分配，Ind. Page的属性设置都hook上</p>\n","feature":true,"text":"PatchGuardStep 1 设 BigPool 不可执行编写一个驱动，遍历BigPool信息，将可疑的BigPool设置为不可执行，等待蓝屏 然后分析蓝屏信息得到context入口点，简要分析context入口点 1 查询所有BigPool使用ZwQuerySystemIn...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[{"name":"Windows","slug":"Windows","count":19,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":19,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":23,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":5,"path":"api/tags/kernel.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#PatchGuard\"><span class=\"toc-text\">PatchGuard</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Step-1-%E8%AE%BE-BigPool-%E4%B8%8D%E5%8F%AF%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">Step 1 设 BigPool 不可执行</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89BigPool\"><span class=\"toc-text\">1 查询所有BigPool</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%AE%BE%E7%BD%AEBigPool%E4%B8%8D%E5%8F%AF%E6%89%A7%E8%A1%8C%EF%BC%88%E8%A7%A6%E5%8F%91%E8%93%9D%E5%B1%8F%EF%BC%89\"><span class=\"toc-text\">2 设置BigPool不可执行（触发蓝屏）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%88%86%E6%9E%90%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8%E8%93%9D%E5%B1%8F%EF%BC%880xFC%EF%BC%89\"><span class=\"toc-text\">3 分析执行异常蓝屏（0xFC）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">4 调试</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Step-2-%E6%8E%A5%E7%AE%A1%E9%A1%B5%E9%9D%A2%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">Step 2 接管页面异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%8E%A5%E7%AE%A1%E9%A1%B5%E9%9D%A2%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">1 接管页面异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8A%A0%E9%80%9F%E8%93%9D%E5%B1%8F%EF%BC%88%E7%94%B1PG%E6%A3%80%E6%9F%A5%E5%BC%95%E5%8F%91%E7%9A%84%EF%BC%89\"><span class=\"toc-text\">2 加速蓝屏（由PG检查引发的）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%88%86%E6%9E%90PG%E8%93%9D%E5%B1%8F%EF%BC%880x109%EF%BC%89\"><span class=\"toc-text\">3 分析PG蓝屏（0x109）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-IndependentPages\"><span class=\"toc-text\">4 IndependentPages</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Step-3-%E8%AE%BE%E7%BD%AE-Ind-Page-%E4%B8%8D%E5%8F%AF%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">Step 3 设置 Ind. Page 不可执行</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%90%9C%E7%B4%A2-Ind-Page\"><span class=\"toc-text\">1 搜索 Ind. Page</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%8D%A2%E9%A1%B5%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1? 换页问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">2 测试结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90\"><span class=\"toc-text\">3 错误分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Step-4-%E6%8E%A5%E7%AE%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E3%80%81%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">Step 4 接管内存分配、属性设置</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"SFU Compilers class 笔记4","uid":"4f7d6d0fadf06b2d208599f31c49d097","slug":"SFU-Compilers-4","date":"2022-07-29T04:00:00.000Z","updated":"2022-09-26T10:32:51.796Z","comments":true,"path":"api/articles/SFU-Compilers-4.json","keywords":null,"cover":null,"text":"SFU Compilers 笔记 4 语法分析2w7 hw2 Week 7 Syntax Directed TranslationLR6 Syntax Directed Translation for LR Parsers语法导向翻译（SDT）用于将解析树（Parse trees...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"CS","slug":"CS","count":4,"path":"api/categories/CS.json"}],"tags":[{"name":"note","slug":"note","count":23,"path":"api/tags/note.json"},{"name":"cs","slug":"cs","count":4,"path":"api/tags/cs.json"},{"name":"compiler","slug":"compiler","count":4,"path":"api/tags/compiler.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"B站x64内核笔记1","uid":"368d5d02963b1ddd739fe7288ce34859","slug":"zh-x64krnl","date":"2022-05-17T04:00:00.000Z","updated":"2022-09-26T10:26:34.355Z","comments":true,"path":"api/articles/zh-x64krnl.json","keywords":null,"cover":null,"text":"IA_32eExtended Feature Enable Register（IA32_EFER，MSR[0xC0000080]） vol-3a p69 2.2.1 Extended Feature Enable Register ![](E:\\documents\\note\\md...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"Windows","slug":"Windows","count":19,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":19,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":23,"path":"api/tags/note.json"},{"name":"kernel","slug":"kernel","count":5,"path":"api/tags/kernel.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}