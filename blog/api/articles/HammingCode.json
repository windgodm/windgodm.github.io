{"title":"HammingCode","uid":"9a514a805495433f4105a5ad7faec5ce","slug":"HammingCode","date":"2021-07-14T04:00:00.000Z","updated":"2021-08-11T08:56:20.570Z","comments":true,"path":"api/articles/HammingCode.json","keywords":null,"cover":null,"content":"<h1 id=\"Hamming-Code\"><a href=\"#Hamming-Code\" class=\"headerlink\" title=\"Hamming Code\"></a>Hamming Code</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>多次奇偶校验，下标为2<sup>n</sup>的位作为奇偶校验位，校验对象为所有位中小标第n位为1的位，显然包括了一半的数据。</p>\n<p>第0位一般弃置，或者作为奇偶校验位的奇偶校验位，这样就可以判断是否存在多个错误。</p>\n<p>每一个奇偶校验位都校验了一半的数据，通过检测哪些校验位是错的即可找到哪一位数据出错。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>三种理解思路：一是多组奇偶校验；二是异或；三是线性代数。</p>\n<p>只能纠错一个位，以及判断是否有多个错误，校验结果即为错误位。</p>\n<p>若奇偶校验位的个数为n：</p>\n<p>汉明码的位数：2<sup>n</sup> = 1 &lt;&lt; n</p>\n<p>数据位的位数：2<sup>n</sup>-n-1 = (1&lt;&lt;n)-n-1</p>\n<p>校验位按下标排序，错误的置一，其余置零，若结果不为0，得到的就是错误位的下标。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>该算法目前已经不常用。实际使用通常配合其他通信技巧使用。下面是我分别用python和c++实现的代码。实现方式为把原始数据分块再编码成汉明码。</p>\n<p><a href=\"https://github.com/windgodm/Algorithm/tree/master/HammingCode\">Algorithm/HammingCode at master · windgodm/Algorithm (github.com)</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.bilibili.com/video/BV1WK411N7kz\">https://www.bilibili.com/video/BV1WK411N7kz</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1pV411y7E8\">https://www.bilibili.com/video/BV1pV411y7E8</a></p>\n","text":"Hamming Code思路多次奇偶校验，下标为2n的位作为奇偶校验位，校验对象为所有位中小标第n位为1的位，显然包括了一半的数据。 第0位一般弃置，或者作为奇偶校验位的奇偶校验位，这样就可以判断是否存在多个错误。 每一个奇偶校验位都校验了一半的数据，通过检测哪些校验位是错的即可...","link":"","photos":[],"count_time":{"symbolsCount":554,"symbolsTime":"1 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":1,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"note","slug":"note","count":21,"path":"api/tags/note.json"},{"name":"Error_Correction","slug":"Error-Correction","count":1,"path":"api/tags/Error-Correction.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Hamming-Code\"><span class=\"toc-text\">Hamming Code</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"WX数据库自动解密（已失效）","uid":"b4fc70e59f23576dbde3f95657ed4ffe","slug":"WeChatDBDecrypt","date":"2021-07-22T04:00:00.000Z","updated":"2021-11-05T11:34:36.242Z","comments":true,"path":"api/articles/WeChatDBDecrypt.json","keywords":null,"cover":null,"text":"微信 PC端 数据库 自动解密摘要 环境: win10家庭中文版 10.0.19043 x64（本机） 微信 3.3.0.115 openssl-1.0.2r PC密码为32字节。 手动流程获取密码打开微信（不点登录）。 打开Odb附加WeChat.exe。 查找-&gt;可执行...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"Windows","slug":"Windows","count":18,"path":"api/categories/Windows.json"}],"tags":[{"name":"WX","slug":"WX","count":1,"path":"api/tags/WX.json"},{"name":"Database","slug":"Database","count":2,"path":"api/tags/Database.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"APIHook DLL注入实现代码钩取 笔记","uid":"5e05a9de597a39befc3bd53d02dc7c56","slug":"APIHookDllCodeHideProc","date":"2021-06-24T06:44:00.000Z","updated":"2021-09-28T10:22:14.123Z","comments":true,"path":"api/articles/APIHookDllCodeHideProc.json","keywords":null,"cover":null,"text":"APIHook - DLL注入实现代码钩取 笔记摘要 技术摘要： 动态修改进程内存中的代码。利用DLL注入修改代码开头跳转到补丁代码。 起源是逆向工程核心原理里面以任务管理器ZwQuerySystemInformation()API钩取为例讲解利用dll注入修改api的起始代码为...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"Windows","slug":"Windows","count":18,"path":"api/categories/Windows.json"}],"tags":[{"name":"windows","slug":"windows","count":18,"path":"api/tags/windows.json"},{"name":"note","slug":"note","count":21,"path":"api/tags/note.json"},{"name":"api_hook","slug":"api-hook","count":3,"path":"api/tags/api-hook.json"},{"name":"reversecore","slug":"reversecore","count":4,"path":"api/tags/reversecore.json"}],"author":{"name":"御史神风","slug":"御史神风","avatar":"/blog/imgs/child.jpg","link":"/","description":"芜湖~好耶!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}