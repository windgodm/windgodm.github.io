
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BraveTroops || 《Windows Kernel Programming》 笔记 1~5 内核开发入门</title>
    <meta name="author" content="御史神风">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/blog//blog/imgs/child.jpg">
    <link rel="stylesheet" href="/blog/css/antd.min.css">
    
    <link rel="stylesheet" href="/blog/css/maiden-theme.css">
    
    <script src="/blog/js/vue.js"></script>
    <script src="/blog/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/blog/rss2.xml" title="BraveTroops" type="application/rss+xml">
</head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/blog/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/blog/">
            <span class="title">BraveTroops</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/contact.html">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/making">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/blog/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/blog/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>BraveTroops</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/contact.html">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/making">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/blog/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/blog/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/blog/css/post-body.css">
<div class="article">
    <div>
        <h1>《Windows Kernel Programming》 笔记 1~5 内核开发入门 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/12/24
        </span>

        
        <span class="category">
            <a href="/blog/categories/Windows">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                Windows
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/blog/tags/windows" style=color:#1bccbc>
                    windows
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/blog/tags/note" style=color:#1bccbc>
                    note
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/blog/tags/kernel" style=color:#ff7d73>
                    kernel
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/blog/tags/wkp" style=color:#00bcd4>
                    wkp
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="Windows-Kernel-Programming-笔记-1-5-内核开发入门"><a href="#Windows-Kernel-Programming-笔记-1-5-内核开发入门" class="headerlink" title="Windows Kernel Programming 笔记 1~5 内核开发入门"></a>Windows Kernel Programming 笔记 1~5 内核开发入门</h1><h2 id="1-windows内部概况"><a href="#1-windows内部概况" class="headerlink" title="1 windows内部概况"></a>1 windows内部概况</h2><p>描述一些Windows内部工作中最重要、最基本的概念，部分概念将在后面的章节做更详细的研究</p>
<h3 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h3><p>进程不运行（Processes dont’t run - processes manage），线程才执行代码</p>
<p>进程拥有以下内容：</p>
<ul>
<li>一个可执行程序（PE文件），包括代码和数据</li>
<li>私有的虚拟内存空间</li>
<li>主令牌（primary token），是一个对象，存储进程默认安全上下文</li>
<li>对象（事件、信号、文件）句柄表</li>
<li>一个或多个线程（没有线程的用户态进程一般情况下会被内核销毁）</li>
</ul>
<h3 id="1-2-虚拟内存"><a href="#1-2-虚拟内存" class="headerlink" title="1.2 虚拟内存"></a>1.2 虚拟内存</h3><p>每个进程拥有自己的<strong>虚拟、私有、线性地址</strong>空间<br>（该地址空间初始时几乎为空，然后pe、ntdll.dll开始被影射，接着是其他子系统dll）</p>
<p>32位进程默认地址空间<strong>2GB</strong>，设置pe中的<code>LARGEADDRESSAWARE</code>标志可以增加到<strong>3GB</strong>（32位系统）或<strong>4GB</strong>（64位系统）</p>
<p>64位进程默认地址空间<strong>128TB</strong>（win8之前是8TB）</p>
<p>虚拟内存被映射到物理内存（RAM）或临时驻留在文件中（如page file）<br>如果不在物理内存，则触发page fault异常，并或取数据到物理内存中</p>
<p><strong>页（page）</strong>是内存管理的单位，默认大小为<strong>4KB</strong></p>
<h4 id="页状态"><a href="#页状态" class="headerlink" title="页状态"></a>页状态</h4><p>虚拟内存中的页处于三种状态之一</p>
<ul>
<li>Free：未分配</li>
<li>Committed：已分配，通常映射到RAM或文件（例如page file）</li>
<li>Reserved：未分配，对cpu而言与Free相似，自动分配将不会使用该页<br>一个例子是线程栈（thread stack）</li>
</ul>
<h4 id="系统内存"><a href="#系统内存" class="headerlink" title="系统内存"></a>系统内存</h4><p>系统空间与进程无关</p>
<p>系统空间就是内核</p>
<h3 id="1-3-线程"><a href="#1-3-线程" class="headerlink" title="1.3 线程"></a>1.3 线程</h3><p>实际执行代码的是线程</p>
<p>线程拥有的最重要的内容：</p>
<ul>
<li>当前访问模式（用户或内核）</li>
<li>执行上下文</li>
<li>一个或两个栈（stack）</li>
<li>Thread Local Storage（TLS）</li>
<li>基本优先级和当前（动态）优先级</li>
<li>处理器关联信息</li>
</ul>
<p>线程最常处于的状态：</p>
<ul>
<li>Running：在逻辑处理器运行中</li>
<li>Ready：等待运行（所有处理器在忙或不可用）</li>
<li>Waiting：等待某个事件，事件触发就变成Ready</li>
</ul>
<p>括号中的数字是状态号：</p>
<p>Running(2) =&gt; Waiting(5) =&gt; Deferred Ready(7), Ready(1) =&gt; Running(2)</p>
<h4 id="1-3-1-线程栈"><a href="#1-3-1-线程栈" class="headerlink" title="1.3.1 线程栈"></a>1.3.1 线程栈</h4><p>线程至少有一个位于内核空间的栈（32位系统12KB，64位系统24KB）</p>
<p>用户态的线程还有一个位于所属进程空间的栈（默认上限1MB）</p>
<p>线程<code>Running</code>或<code>Ready</code>时，内核栈驻留在RAM</p>
<p>栈初始时会尽可能少提交页（最少一页），剩下的页设置为<code>Reserved</code>，而最后一个<code>Committed</code>的页的下一页设置为<code>PAGE_GUARD</code></p>
<h3 id="1-4-系统调用（又名系统服务）"><a href="#1-4-系统调用（又名系统服务）" class="headerlink" title="1.4 系统调用（又名系统服务）"></a>1.4 系统调用（又名系统服务）</h3><p>原标题：System Services (a.k.a. System Calls)</p>
<p>R3代码通过系统调用完成一些只能在R0下完成的功能，如分配内存、打开文件、创建线程等</p>
<p>大致流程是：<br>调用subsystem dll（如kernel32.dll）中的文档化api（如CreateFile）<br>进入NTDLL中的 Native Api（如NtCreateFile）<br>进入内核中的系统服务分发函数<br>进入Native Api对应的内核中的函数</p>
<p>Native Api将调用号存入eax然后进入r0的系统服务分发函数，eax实际是SSDT（System Service Dispatch Table）的下标</p>
<h3 id="1-5-通用系统架构"><a href="#1-5-通用系统架构" class="headerlink" title="1.5 通用系统架构"></a>1.5 通用系统架构</h3><p><img src="https://s4.ax1x.com/2022/01/18/70IBlR.png"></p>
<h3 id="1-6-句柄和对象"><a href="#1-6-句柄和对象" class="headerlink" title="1.6 句柄和对象"></a>1.6 句柄和对象</h3><p>对象被引用计数，当计数为0时才会被释放</p>
<p>句柄是进程的对象表的索引</p>
<blockquote>
<p>注意：返回值为句柄的函数，大多数失败时返回<code>0</code>。有些返回<code>INVALID_HANDLE_VALUE (-1)</code>，比如<code>CreateFile</code></p>
</blockquote>
<p>句柄值是4的倍数，0不是有效句柄值</p>
<h4 id="1-6-1-对象名"><a href="#1-6-1-对象名" class="headerlink" title="1.6.1 对象名"></a>1.6.1 对象名</h4><p>某些类型的对象可以有名称，可用于通过合适的 Open 函数按名称打开对象。 </p>
<p>用户模式调用 Create 函数按名称创建对象，如果存在，则仅打开现有对象。</p>
<p>winObj中显示的名称有时不是对象的真实名称：</p>
<ul>
<li>进程和线程显示ID</li>
<li>文件对象显示文件名（或设备名），因为共享的原因，无法通过文件名获得文件对象句柄</li>
<li>（注册表）键对象与注册表的路径一起显示，原因同文件对象</li>
<li>目录对象显示路径，目录不是文件系统对象，而是对象管理器目录，可通过Sysinternals WinObj查看</li>
<li>令牌对象名称与存储在令牌中的用户名一起显示</li>
</ul>
<h4 id="1-6-2-访问现有对象"><a href="#1-6-2-访问现有对象" class="headerlink" title="1.6.2 访问现有对象"></a>1.6.2 访问现有对象</h4><p>Process Explorer 的句柄视图中的访问列显示用于打开或创建句柄的访问掩码</p>
<p>Process Explorer中显示的引用数（References）不是实际引用数（outstanding references）</p>
<p>[windbg]中用<code>!trueref</code>获取实际引用数（actual reference）</p>
<h2 id="2-内核开发入门"><a href="#2-内核开发入门" class="headerlink" title="2 内核开发入门"></a>2 内核开发入门</h2><p>本章主要是关于准备内核开发所需的环境，包括开发和调试的工具以及环境配置</p>
<p>以及启动和运行内核驱动的知识</p>
<p>然后写一个可以加载和卸载的驱动</p>
<h3 id="驱动开发准备工作"><a href="#驱动开发准备工作" class="headerlink" title="驱动开发准备工作"></a>驱动开发准备工作</h3><p>首先按 2.1安装工具 完成安装，然后为驱动开发配置虚拟机（未包括内核调试的配置）</p>
<p><strong>安装无签名驱动</strong></p>
<p>如果驱动没有签名，安装驱动需要以该模式启动系统</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> testsigning on</span><br></pre></td></tr></table></figure>



<p><strong>显示内核调试信息</strong></p>
<p>在<code>HKLM\SYSTEM\CurrentControlSet\Control\Session Manager</code>添加一个名为<code>Debug Print Filter</code>的键<br>在键中添加一个<code>DWORD</code>，名为<code>DEFAULT</code>，值为<code>8</code></p>
<p><strong>虚拟机文件共享</strong></p>
<p>实际操作时，安装在虚拟机中（避免本机崩溃），需要共享项目的文件给虚拟机</p>
<p>共享本机的 vs解决方案文件夹 给虚拟机，名称为<code>MyDriver</code></p>
<p>虚拟机中的debug输出路径为：<code>\\vmware-host\Shared Folders\MyDriver\x64\Debug</code></p>
<p><strong>驱动调试工具</strong></p>
<p>安装完WDK后，把<code>C:\Program Files (x86)\Windows Kits\10\Tools\x64</code>这个目录复制到虚拟机中，这个是x64下的驱动开发调试工具，比如用于查看内存池的poolmon</p>
<h3 id="2-1-安装工具"><a href="#2-1-安装工具" class="headerlink" title="2.1 安装工具"></a>2.1 安装工具</h3><p>需要vs2019、windows 10 sdk（vs2019中安装）、windows 10 driver kit（WDK）</p>
<p>以及 Sysinternals，该工具包含debug view、process monitor等一系列有用的工具</p>
<blockquote>
<p>在实际编译中发现，新版本的vs驱动项目默认开启缓解Spectre 漏洞</p>
<p>可以在c/c++、代码生成中关闭该项，或在vs installer中安装对应工具</p>
</blockquote>
<h3 id="2-2-创建一个驱动工程"><a href="#2-2-创建一个驱动工程" class="headerlink" title="2.2 创建一个驱动工程"></a>2.2 创建一个驱动工程</h3><p>vs2019中选择创建一个<code>Empty WDM Driver</code>，创建完成后有个<code>inf</code>后缀的文件，暂时不需要，删除掉</p>
<h3 id="2-3-DriverEntry-和-Unload-Routines"><a href="#2-3-DriverEntry-和-Unload-Routines" class="headerlink" title="2.3 DriverEntry 和 Unload Routines"></a>2.3 DriverEntry 和 Unload Routines</h3><p>DriverEntry 是驱动的默认入口点</p>
<p>系统线程以<code>IRQL_PASSIVE_LEVEL</code>(0)调用 DriverEntry</p>
<p>DriverEntry函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">NTSTATUS</span><br><span class="line">DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath);</span><br></pre></td></tr></table></figure>



<p>一个简单的驱动（sample.cpp）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SampleUnload</span><span class="params">(_In_ PDRIVER_OBJECT DriverObject)</span> </span>&#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">NTSTATUS</span><br><span class="line">DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) &#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    </span><br><span class="line">	DriverObject-&gt;DriverUnload = SampleUnload;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-安装驱动"><a href="#2-4-安装驱动" class="headerlink" title="2.4 安装驱动"></a>2.4 安装驱动</h3><p>安装驱动和安装用户态服务相似，需要调用Create Service API或使用工具</p>
<p>sc.exe（系统自带）是著名工具之一</p>
<p>安装驱动需要管理员权限</p>
<p>创建服务项：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> create sample <span class="built_in">type</span>= kernel binPath= <span class="string">&quot;\\vmware-host\Shared Folders\MyDriver\x64\Debug\sample.sys&quot;</span></span><br></pre></td></tr></table></figure>

<p>随后就能在注册表（regedit.exe）的<code>HKLM\System\CurrentControlSet\Services\Sample</code>中看到该项</p>
<blockquote>
<p>注册表项位置：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Sample</p>
<p>假设<code>binPath= c:\</code>，注册表项<code>ImagePath= \??\c:\</code></p>
<p>假设<code>binPaht= &quot;\\vmware-hots\&quot;</code>，注册表项<code>ImagePath= \??\UNC\vmware-hots\</code></p>
</blockquote>
<p>加载驱动（启动服务）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> <span class="built_in">start</span> sample</span><br></pre></td></tr></table></figure>

<p>在process explorer中，选择System进程，查看dll窗口，拉到最下面就能看到sample.sys</p>
<p>卸载驱动（停止服务）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> stop sample</span><br></pre></td></tr></table></figure>



<h3 id="2-5-简单跟踪（S1）"><a href="#2-5-简单跟踪（S1）" class="headerlink" title="2.5 简单跟踪（S1）"></a>2.5 简单跟踪（S1）</h3><p><code>KdPrint 宏</code>是<code>DbgPrint API</code>的包装</p>
<p>通过在每个函数开头加入<code>KdPrint((&quot;Debug messgae&quot;));</code>可以观察函数调用的发生</p>
<p>使用DebugView，选择capture Kernel可以看到内核调试信息</p>
<h3 id="2-6-练习：显示系统信息（E1）"><a href="#2-6-练习：显示系统信息（E1）" class="headerlink" title="2.6 练习：显示系统信息（E1）"></a>2.6 练习：显示系统信息（E1）</h3><p>创建一个驱动用于显示系统版本信息，使用<code>RtlGetVersion</code></p>
<p>code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get Version</span></span><br><span class="line">RTL_OSVERSIONINFOW versionInfo = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">versionInfo.dwOSVersionInfoSize = <span class="keyword">sizeof</span>(RTL_OSVERSIONINFOW);</span><br><span class="line">RtlGetVersion(&amp;versionInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print</span></span><br><span class="line">DbgPrint(<span class="string">&quot;[E1] Major:%d\n[E1] Minor:%d\n[E1] Build:%d&quot;</span>,</span><br><span class="line">	versionInfo.dwMajorVersion,</span><br><span class="line">	versionInfo.dwMinorVersion,</span><br><span class="line">	versionInfo.dwBuildNumber);</span><br></pre></td></tr></table></figure>

<p>shell:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> create E1_OSVersion <span class="built_in">type</span>= kernel binPath= <span class="string">&quot;\\vmware-host\Shared Folders\MyDriver\x64\Debug\E1_OSVersion.sys&quot;</span></span><br><span class="line"><span class="built_in">sc</span> <span class="built_in">start</span> E1_OSVersion</span><br><span class="line"><span class="built_in">sc</span> stop E1_OSVersion</span><br></pre></td></tr></table></figure>



<h2 id="3-内核编程基础"><a href="#3-内核编程基础" class="headerlink" title="3 内核编程基础"></a>3 内核编程基础</h2><p>研究一些内核的API、结构和定义，以及一些驱动程序中的机制</p>
<h3 id="3-1-通用内核编程指南"><a href="#3-1-通用内核编程指南" class="headerlink" title="3.1 通用内核编程指南"></a>3.1 通用内核编程指南</h3><p>用户模式和内核模式调试的重要区别</p>
<table>
<thead>
<tr>
<th></th>
<th>用户模式</th>
<th>内核模式</th>
</tr>
</thead>
<tbody><tr>
<td>未处理异常</td>
<td>进程崩溃</td>
<td>系统崩溃</td>
</tr>
<tr>
<td>终止</td>
<td>当进程终止，所有内存和资源都会被自动释放</td>
<td>当驱动卸载，如果没有手动释放，会造成泄露直到重启</td>
</tr>
<tr>
<td>返回值</td>
<td>API错误有时候会忽略</td>
<td>应该不忽略任何错误</td>
</tr>
<tr>
<td>IRQL</td>
<td>总是 PASSIVE_LEVEL (0)</td>
<td>可能为更高</td>
</tr>
<tr>
<td>错误代码</td>
<td>通常只会影响本进程</td>
<td>影响整个系统</td>
</tr>
<tr>
<td>测试和调试</td>
<td>通常在开发机器上调试</td>
<td>需要双机调试</td>
</tr>
<tr>
<td>库（Lib）</td>
<td>可以使用C/C++库（如STL、boost）</td>
<td>大多数标准库无法使用</td>
</tr>
<tr>
<td>异常处理</td>
<td>可以使用C++异常或SEH</td>
<td>只能使用SEH</td>
</tr>
<tr>
<td>C++支持</td>
<td>完全的C++支持</td>
<td>不支持C++ runtime</td>
</tr>
</tbody></table>
<h4 id="3-1-1-未处理异常"><a href="#3-1-1-未处理异常" class="headerlink" title="3.1.1 未处理异常"></a>3.1.1 未处理异常</h4><p>未处理异常会导致蓝屏，原因是防止继续执行代码、对系统造成不可逆转的伤害</p>
<p>内核代码不应该跳过任何细节或错误检查</p>
<h4 id="3-1-2-终止"><a href="#3-1-2-终止" class="headerlink" title="3.1.2 终止"></a>3.1.2 终止</h4><p>如果驱动程序卸载时仍保留分配的内存或打开的内核句柄，这些资源不会自动释放，只会在下次系统启动时释放</p>
<p>原因是驱动程序可以分配一些缓冲区，然后将其传递给另一个与之合作的驱动程序</p>
<h4 id="3-1-3-函数返回值"><a href="#3-1-3-函数返回值" class="headerlink" title="3.1.3 函数返回值"></a>3.1.3 函数返回值</h4><p>忽略内核API的返回值很危险，应该总是检查返回值</p>
<h4 id="3-1-4-IRQL"><a href="#3-1-4-IRQL" class="headerlink" title="3.1.4 IRQL"></a>3.1.4 IRQL</h4><p>中断请求级（Interrupt Request Level, IRQL）通常为0</p>
<p>用户模式下始终为0，内核模式下大部分时间为0</p>
<h4 id="3-1-5-C-使用"><a href="#3-1-5-C-使用" class="headerlink" title="3.1.5 C++使用"></a>3.1.5 C++使用</h4><p>没有C++ runtime</p>
<p>一些不支持的C++特性：</p>
<ul>
<li>不支持<code>new</code>和<code>delete</code>，这正常是在用户模式堆分配的</li>
<li>不会调用具有非默认构造函数的全局变量<ul>
<li>避免在构造函数中使用代码，创建一些要显式调用的Init函数</li>
<li>仅将指针分配为全局变量，动态创建实例</li>
</ul>
</li>
<li>不支持C++异常处理（<code>try</code>、<code>catch</code>、<code>throw</code>）</li>
<li>不可使用标准C++库，如<code>std::vector&lt;&gt;</code>、<code>std::wstring</code>等</li>
</ul>
<p>一些支持的C++特性：</p>
<ul>
<li><code>nullptr</code>关键字</li>
<li><code>auto</code>关键字</li>
<li>模板将在有意义时使用</li>
<li>重载new 和delete 运算符</li>
<li>构造函数和析构函数，尤其是用于构建 RAII 类型</li>
</ul>
<h4 id="3-1-6-测试和调试"><a href="#3-1-6-测试和调试" class="headerlink" title="3.1.6 测试和调试"></a>3.1.6 测试和调试</h4><p>内核调试需要双机调试，一台作为调试者、另一台作为被调试者运行驱动程序</p>
<h3 id="3-2-Debug-vs-Release-生成"><a href="#3-2-Debug-vs-Release-生成" class="headerlink" title="3.2 Debug vs. Release 生成"></a>3.2 Debug vs. Release 生成</h3><p>内核术语是 Checked（Debug）和 Free（Release）</p>
<p>Debug意味着可以使用DBG符号</p>
<h3 id="3-3-内核API"><a href="#3-3-内核API" class="headerlink" title="3.3 内核API"></a>3.3 内核API</h3><p>内核API常用前缀的意义：</p>
<ul>
<li>Ex：一般执行函数</li>
<li>Ke：一般内核函数</li>
<li>Mm：内存管理</li>
<li>Rtl：一般运行时库</li>
<li>FsRtl：文件系统运行时库</li>
<li>Flt：文件系统迷你过滤库</li>
<li>Ob：对象管理</li>
<li>Io：I/O管理</li>
<li>Se：安全</li>
<li>Ps：进程结构</li>
<li>Po：电源管理</li>
<li>Wmi：Windows管理工具</li>
<li>Zw：native API 包装</li>
<li>Hal：硬件抽象层</li>
<li>Cm：配置管理器（注册表）</li>
</ul>
<p>Nt前缀的内核函数对应NtDll.Dll的函数，会根据 KTHREAD 结构的标记（调用者是否来自内核）对参数进行检查</p>
<p>Zw前缀的内核函数先将调用者模式设为<code>KernelMode(0)</code>，然后调用Nt前缀的内核函数</p>
<h3 id="3-4-函数和错误代码"><a href="#3-4-函数和错误代码" class="headerlink" title="3.4 函数和错误代码"></a>3.4 函数和错误代码</h3><p>可以在<code>ntstatus.h</code>中找到<code>NTSTATUS</code>值的定义</p>
<p>大多数代码并不关心错误具体是什么，仅测试最高位即可，可以使用<code>NT_SUCCESS</code>宏</p>
<p>当返回到用户层时，会由<code>STATUS_xxx</code>转成<code>ERROR_yyy</code>，用户模式通过GetLastError可以得到这些错误</p>
<p>通常遇到错误时，会返回相同的 NTSTATUS 到调用函数</p>
<h3 id="3-5-字符串"><a href="#3-5-字符串" class="headerlink" title="3.5 字符串"></a>3.5 字符串</h3><p>内核使用<code>UNICODE_STRING</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">USHORT Length;</span><br><span class="line">USHORT MaximumLength;</span><br><span class="line">PWCH Buffer;</span><br><span class="line">&#125; UNICODE_STRING;</span><br><span class="line"><span class="keyword">typedef</span> UNICODE_STRING *PUNICODE_STRING;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> UNICODE_STRING *PCUNICODE_STRING;</span><br></pre></td></tr></table></figure>

<p><code>Length</code>是字符串的字节数（不包括\x00\x00结束符）</p>
<p><code>MaximumLength</code>是不需要重新分配内存的情况下、字符串字节数上限</p>
<p>需要注意的是，UNICODE_STRING并<strong>不总是有\x00\x00结尾</strong></p>
<p>一些常用的字符串操作函数：</p>
<ul>
<li>RtlInitUnicodeString</li>
<li>RtlCopyUnicodeString</li>
<li>RtlCompareUnicodeString </li>
<li>RtlEqualUnicodeString </li>
<li>RtlAppendUnicodeStringToString</li>
<li>RtlAppendUnicodeToString</li>
</ul>
<h3 id="3-6-动态内存分配（S2）"><a href="#3-6-动态内存分配（S2）" class="headerlink" title="3.6 动态内存分配（S2）"></a>3.6 动态内存分配（S2）</h3><p>内核提供两种通用内存池（general memory pools）给驱动使用：</p>
<ul>
<li>页池（Paged pool）：可能会被换出（paged out）的内存池</li>
<li>非页池（Non Paged Pool）：一直在RAM中的内存池</li>
</ul>
<p>枚举类型<code>POOL_TYPE</code>表示池类型，只有三种是可以用于驱动的：<br><code>PagedPool</code>、<code>NonPagedPool</code>、<code>NonPagedPoolNx</code><br>（non-page pool没有可执行权限）</p>
<p>常用内存池函数：</p>
<ul>
<li>ExAllocatePool（已过时，将被下面的函数取代）</li>
<li>ExAllocatePoolWithTag</li>
<li>ExAllocatePoolWithQuotaTag</li>
<li>ExFreePool</li>
</ul>
<p>tag是4字节的值</p>
<p>可以在PoolMon（WDK的Windows Kits中）中观察到有tag的内存池（tag以大端序字符串显示）</p>
<p>给ustring分配页池内存：</p>
<p>code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING strA;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="comment">// allocate</span></span><br><span class="line">strA.Buffer = (WCHAR*)ExAllocatePoolWithTag(PagedPool,</span><br><span class="line">	length, &#x27;dcba&#x27;);</span><br><span class="line"><span class="keyword">if</span> (strA.Buffer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    KdPrint((<span class="string">&quot;Failed to allocate memory\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">&#125;</span><br><span class="line">strA.MaximumLength = length;</span><br></pre></td></tr></table></figure>

<p>shell:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> create S2_DynMemAlloc <span class="built_in">type</span>= kernel binPath= <span class="string">&quot;\\vmware-host\Shared Folders\MyDriver\x64\Debug\S2_DynMemAlloc.sys&quot;</span></span><br><span class="line"><span class="built_in">sc</span> <span class="built_in">start</span> S2_DynMemAlloc</span><br><span class="line"><span class="built_in">sc</span> stop S2_DynMemAlloc</span><br></pre></td></tr></table></figure>



<h3 id="3-7-链表"><a href="#3-7-链表" class="headerlink" title="3.7 链表"></a>3.7 链表</h3><p>内核使用循环双向链表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span></span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY;</span><br></pre></td></tr></table></figure>



<p><code>CONTAINING_RECORD</code>宏执行适当的偏移计算并转换为实际数据类型<br><code>CONTAINING_RECORD(pvoid, type, entry_member_name)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyDataItem</span> &#123;</span></span><br><span class="line">    <span class="comment">// some data members</span></span><br><span class="line">    LIST_ENTRY Link;</span><br><span class="line">    <span class="comment">// more data members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyDataItem* <span class="title">GetItem</span><span class="params">(LIST_ENTRY* pEntry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> CONTAINING_RECORD(pEntry, MyDataItem, Link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>常用链表函数（时间复杂度都是常数）：</p>
<ul>
<li>InitializeListHead</li>
<li>InsertHeadList</li>
<li>InsertTailList</li>
<li>IsListEmpty</li>
<li>RemoveHeadList</li>
<li>RemoveTailList</li>
<li>RemoveEntryList</li>
<li>ExInterlockedInsertHeadList</li>
<li>ExInterlockedInsertTailList</li>
<li>ExInterlockedRemoveHeadList</li>
</ul>
<p>后三个关于自旋锁，在第6章详细讨论</p>
<h3 id="3-8-驱动对象（The-Driver-Object）"><a href="#3-8-驱动对象（The-Driver-Object）" class="headerlink" title="3.8 驱动对象（The Driver Object）"></a>3.8 驱动对象（The Driver Object）</h3><p>常用major function代码：</p>
<ul>
<li>IRP_MJ_CREATE (0) </li>
<li>IRP_MJ_CLOSE (2)</li>
<li>IRP_MJ_READ (3) </li>
<li>IRP_MJ_WRITE (4) </li>
<li>IRP_MJ_DEVICE_CONTROL (14) </li>
<li>IRP_MJ_INTERNAL_DEVICE_CONTROL (15)</li>
<li>IRP_MJ_PNP (31) </li>
<li>IRP_MJ_POWER (22)</li>
</ul>
<p><code>MajorFunction</code>数组由内核初始化指向内核内部例程<code>IopInvalidDeviceRequest</code>，该例程直接返回失败，表示不支持该操作</p>
<h3 id="3-9-设备对象（Device-Objects）"><a href="#3-9-设备对象（Device-Objects）" class="headerlink" title="3.9 设备对象（Device Objects）"></a>3.9 设备对象（Device Objects）</h3><p>驱动通过设备与r3代码通信，驱动应该至少创建一个设备对象并为其命名</p>
<p>CreateFile可以打开设备，第一个参数为设备对象名称</p>
<p>打开文件或设备的句柄会创建内核结构 FILE_OBJECT 的实例，这是个半文档化的结构。 </p>
<p>更准确的说，CreteFile接受一个<code>symbolic link</code>（符号链接）</p>
<p>对象管理器中名为<code>??</code>的目录下的符号链接都可被用户模式代码通过CreateFile或Createfile2调用</p>
<p>可以通过WinObj查看（WinObj中目录名为<code>Global??</code>）</p>
<p>使用符号链接的CreateFile的文件名（第一个参数），必须加上前缀<code>\\.\</code>（c++中是<code>&quot;\\\\.\\&quot;</code>）</p>
<p>如果创建了多个设备对象，将形成一个单向链表，添加设备时是头插法，所以第一个创建的设备在链表的最后</p>
<h2 id="4-驱动从头到尾（Driver-from-Start-to-Finish）（S3）"><a href="#4-驱动从头到尾（Driver-from-Start-to-Finish）（S3）" class="headerlink" title="4 驱动从头到尾（Driver from Start to Finish）（S3）"></a>4 驱动从头到尾（Driver from Start to Finish）（S3）</h2><p>将完成一个完整的驱动及客户端程序，利用驱动完成只能在内核模式下完成的功能（设置任意级别的线程优先级）</p>
<h3 id="4-1-绪论"><a href="#4-1-绪论" class="headerlink" title="4.1 绪论"></a>4.1 绪论</h3><p>线程优先级 = 进程优先级 + 相对线程优先级</p>
<p>用户模式下，设置进程优先级可以用<code>SetPriorityClass</code>，共有6个级别<br>设置相对线程优先级可以用<code>SetThreadPriority</code>，共有7个级别</p>
<p>下面是线程优先级合法值的表（通过windows api设置），据别的书说是个未文档化的东西，windows不建议开发时考虑线程优先级，该表的值随windows版本变化可能发生改变</p>
<table>
<thead>
<tr>
<th>进程优先级</th>
<th>-Sat</th>
<th>-2</th>
<th>-1</th>
<th>0</th>
<th>+1</th>
<th>+2</th>
<th>+sat</th>
</tr>
</thead>
<tbody><tr>
<td>Idle(low)</td>
<td>1</td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td>15</td>
</tr>
<tr>
<td>Below Normal</td>
<td>1</td>
<td></td>
<td></td>
<td>6</td>
<td></td>
<td></td>
<td>15</td>
</tr>
<tr>
<td>Normal</td>
<td>1</td>
<td></td>
<td></td>
<td>8</td>
<td></td>
<td></td>
<td>15</td>
</tr>
<tr>
<td>Above Normal</td>
<td>1</td>
<td></td>
<td></td>
<td>10</td>
<td></td>
<td></td>
<td>15</td>
</tr>
<tr>
<td>High</td>
<td>1</td>
<td></td>
<td></td>
<td>13</td>
<td></td>
<td></td>
<td>15</td>
</tr>
<tr>
<td>Real-time</td>
<td>16</td>
<td></td>
<td></td>
<td>24</td>
<td></td>
<td></td>
<td>31</td>
</tr>
</tbody></table>
<p>进程优先级枚举：级别+<code>_PRIORITY_CLASS</code></p>
<p>线程优先级枚举：<code>THREAD_PRIORITY_</code>+级别</p>
<h3 id="4-2-驱动初始化"><a href="#4-2-驱动初始化" class="headerlink" title="4.2 驱动初始化"></a>4.2 驱动初始化</h3><p>大多数驱动需要在DriverEntry中做如下操作：</p>
<ul>
<li>设置Unload例程</li>
<li>设置驱动支持的调度例程</li>
<li>创建一个设备对象</li>
<li>创建一个指向设备对象的符号链接</li>
</ul>
<p>所有驱动必须支持<code>IRP_MJ_CREATE</code>和<code>IRP_MJ_CLOSE</code>，不然无法打开一个驱动的设备的句柄，通常这两个调度例程是相同的</p>
<p>调度例程的函数原型：<code>NTSTATUS Function(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)</code></p>
<h4 id="4-2-1-将信息传给驱动"><a href="#4-2-1-将信息传给驱动" class="headerlink" title="4.2.1 将信息传给驱动"></a>4.2.1 将信息传给驱动</h4><p>用户模式客户端可用的三个基础函数：<code>WriteFile</code>、<code>ReadFile</code>、<code>DeviceIoControl</code></p>
<h4 id="4-2-2-客户端-驱动程序通信协议"><a href="#4-2-2-客户端-驱动程序通信协议" class="headerlink" title="4.2.2 客户端/驱动程序通信协议"></a>4.2.2 客户端/驱动程序通信协议</h4><p>必须使用<code>CTL_CODE</code>宏来构建控制代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTL_CODE( DeviceType, Function, Method, Access ) (                 \</span></span><br><span class="line">    ((DeviceType) &lt;&lt; <span class="number">16</span>) | ((Access) &lt;&lt; <span class="number">14</span>) | ((Function) &lt;&lt; <span class="number">2</span>) | (Method) \</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>DeviceType：设备类型标识，<code>FILE_DEVICE_xxx</code>，第三方应以0x8000开头</li>
<li>Function：指示特定操作的升序数字，第三方应该以0x800开头</li>
<li>Method：指示客户端提供的输入和输出缓冲区如何传递给驱动程序（将在第6章详细讨论）</li>
<li>Access：指示对驱动来说这个操作是什么？</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_DEVICE 0x800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_MY_OP CTL_CODE(\</span></span><br><span class="line">MY_DEVICE, <span class="number">0x800</span>, METHOD_NEITHER, FILE_ANY_ACCESS)</span><br></pre></td></tr></table></figure>



<h4 id="4-2-3-创建一个设备对象"><a href="#4-2-3-创建一个设备对象" class="headerlink" title="4.2.3 创建一个设备对象"></a>4.2.3 创建一个设备对象</h4><p><strong>创建设备名：</strong></p>
<p>在创建一个设备对象前，需要先创建一个<code>UNICODE_STRING</code>存储内部设备名称</p>
<p>下面是两种初始化方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plan A</span></span><br><span class="line">UNICODE_STRING devName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\YourName&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// plan B</span></span><br><span class="line">UNICODE_STRING devName;</span><br><span class="line">RtlInitUnicodeString(&amp;devName, <span class="string">L&quot;\\Device\\YourName&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>设备名称需要在设备对象管理器目录下</p>
<p>（RtlInitUnicodeString函数内部字符串的长度，RTL_CONSTANT_STRING宏在编译时计算长度）</p>
<p><strong>创建设备对象：</strong></p>
<p>创建设备对象需要调用<code>IoCreateDevice</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCreateDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ PDRIVER_OBJECT DriverObject,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ ULONG DeviceExtensionSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_opt_ PUNICODE_STRING DeviceName,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ DEVICE_TYPE DeviceType,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ ULONG DeviceCharacteristics,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ BOOLEAN Exclusive,</span></span></span><br><span class="line"><span class="function"><span class="params">    _Outptr_ PDEVICE_OBJECT *DeviceObject)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>创建设备完整示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING devName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\DEVICE\\devName&quot;</span>);</span><br><span class="line">PDEVICE_OBJECT devObj;</span><br><span class="line">status = IoCreateDevice(</span><br><span class="line">    DriverObject,        <span class="comment">// our driver object</span></span><br><span class="line">    <span class="number">0</span>,                   <span class="comment">// no need for extra bytes</span></span><br><span class="line">    &amp;devName,            <span class="comment">// the device name</span></span><br><span class="line">    FILE_DEVICE_UNKNOWN, <span class="comment">// device type</span></span><br><span class="line">    <span class="number">0</span>,                   <span class="comment">// characteristics flags</span></span><br><span class="line">    FALSE,               <span class="comment">// not exclusive</span></span><br><span class="line">    &amp;devObj              <span class="comment">// the resulting pointer</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    KdPrint((<span class="string">&quot;[] Failed to create device object (0x%08X)\n&quot;</span>, status));</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>创建符号链接：</strong></p>
<p>需要创建一个指向设备的符号链接，供r3调用</p>
<p>同样需要先创建一个字符串作为符号链接对象名称</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING symLink = RTL_CONSTANT_STRING(<span class="string">L&quot;\\??\\symLinkName&quot;</span>);</span><br><span class="line">status = IoCreateSymbolicLink(&amp;symLink, &amp;devName);</span><br><span class="line"><span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	KdPrint((<span class="string">&quot;[] Failed to create symbolic link (0x%08X)\n&quot;</span>, status));</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意：资源释放</strong></p>
<p>上面创建的字符串会自动释放（好像在函数的栈中）？但对象不会，需要（在unload例程中）手动删除</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unload</span><span class="params">(_In_ PDRIVER_OBJECT DriverObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// delete symbolic link</span></span><br><span class="line">    UNICODE_STRING symLink = RTL_CONSTANT_STRING(<span class="string">L&quot;\\??\\symLinkName&quot;</span>);</span><br><span class="line">    IoDeleteSymbolicLink(&amp;symLink);</span><br><span class="line">    <span class="comment">// delete device object</span></span><br><span class="line">    IoDeleteDevice(DriverObject-&gt;DeviceObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-客户端代码"><a href="#4-3-客户端代码" class="headerlink" title="4.3 客户端代码"></a>4.3 客户端代码</h3><p>将用<code>CTL_CODE</code>构造的控制代码放到一个头文件中，供驱动代码和用户模式客户端代码同时使用</p>
<p>通过符号链接获驱动的设备的句柄</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    HANDLE hDevice = CreateFile(<span class="string">L&quot;\\\\.\\symLinkName&quot;</span>, GENERIC_WRITE,</span><br><span class="line">        FILE_SHARE_WRITE, <span class="literal">nullptr</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE)</span><br><span class="line">        <span class="keyword">return</span> Error(<span class="string">&quot;Failed to open device&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Error</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s (error=%d)\n&quot;</span>, msg, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-4-Create和Close调度例程"><a href="#4-4-Create和Close调度例程" class="headerlink" title="4.4 Create和Close调度例程"></a>4.4 Create和Close调度例程</h3><p>该例程什么都不用做，直接返回成功即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PriorityBoosterCreateClose</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span> </span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DeviceObject);</span><br><span class="line">    </span><br><span class="line">    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">    Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    IoCompleteRequest(Irp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>IRP是半文档化结构，通常来自运行中的管理器：I/O Manager, Plug &amp; Play Manager or Power Manager</p>
<p>对驱动程序的每个请求总是包装在 IRP 中</p>
<p>IRP中有一个或多个<code>IO_STACK_LOCATION</code>结构</p>
<p>为了完成IRP，需要调用<code>IoCompleteRequest</code>，这个函数做很多东西，基本上理解为将IRP传播回创建者（通常是I/O管理器），然后由管理器通知客户端操作完成</p>
<h3 id="4-5-DeviceIoControl调度例程"><a href="#4-5-DeviceIoControl调度例程" class="headerlink" title="4.5 DeviceIoControl调度例程"></a>4.5 DeviceIoControl调度例程</h3><p>调用<code>IoGetCurrentIrpStackLocation</code>获取当前设备对应的<code>IO_STACK_LOCATION</code></p>
<p><code>IO_STACK_LOCATION</code>中有控制代码、输入输出buffer指针等</p>
<blockquote>
<p>调度例程运行在调用该例程的用户模式进程的上下文中</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD threadId;</span><br><span class="line">PETHREAD Thread;</span><br><span class="line">status = PsLookupThreadByThreadId(ULongToHandle(threadId), &amp;Thread);</span><br></pre></td></tr></table></figure>

<p>使用<code>ULongToHandle</code>（这实际上只是个casting）将pid转换成<code>HANDLE</code></p>
<p>线程和进程存在一个全局私有内核句柄表，句柄的“值”实际上就是ID</p>
<p>（HANDLE在64位系统是64位，线程ID始终是32位）</p>
<h3 id="4-6-安装和测试"><a href="#4-6-安装和测试" class="headerlink" title="4.6 安装和测试"></a>4.6 安装和测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sc create S3_PriorityBooster type&#x3D; kernel binPath&#x3D; &quot;\\vmware-host\Shared Folders\MyDriver\x64\Debug\S3_PriorityBooster.sys&quot;</span><br><span class="line">sc start S3_PriorityBooster</span><br><span class="line">sc stop S3_PriorityBooster</span><br><span class="line">sc delete S3_PriorityBooster</span><br></pre></td></tr></table></figure>



<p>start后可以在WinObj中的<code>Driver</code>目录下看到驱动、<code>GLOBAL??</code>目录下看到符号链接</p>
<p>可以在Process Explorer中查看进程的pid以及其线程的动态优先级</p>
<h2 id="5-调试"><a href="#5-调试" class="headerlink" title="5 调试"></a>5 调试</h2><p>关于使用WinDbg进行调试</p>
<h3 id="5-1-windows的调试工具"><a href="#5-1-windows的调试工具" class="headerlink" title="5.1 windows的调试工具"></a>5.1 windows的调试工具</h3><p>四个调试器：</p>
<ul>
<li>Cdb 和 Ntsd 是用户模式调试器，可以附加到进程上，是命令行界面，没有什么大的区别</li>
<li>Kd 是内核调试器，提供命令行界面，可以附加到本地内核或其他机器</li>
<li>WinDbg 是有图形化界面的调试器，可以调试用户和内核模式</li>
</ul>
<blockquote>
<p>WinDbg Preview是WinDbg的“最新版”，解决了一些WinDbg上的bug</p>
</blockquote>
<p>这些调试器都是基于<code>DbgEng.Dll</code></p>
<h3 id="5-2-WinDbg简介"><a href="#5-2-WinDbg简介" class="headerlink" title="5.2 WinDbg简介"></a>5.2 WinDbg简介</h3><p>虽然有GUI，实际上还是命令行，所有UI操作都会转成命令，显示在命令行窗口上</p>
<p>WinDbg支持三种类型的命令：</p>
<ul>
<li>标准命令(Intrinsic)：内置在调试器中，在被调试的目标上运行</li>
<li>元命令(Meta)：以<code>.</code>开头，作用于调试器(debugging process)本身，而不是直接作用于被调试目标</li>
<li>拓展命令：以<code>!</code>开头，提供调试器大部分功能，都在拓展DLL中实现</li>
</ul>
<h4 id="教程：用户模式调试基础"><a href="#教程：用户模式调试基础" class="headerlink" title="教程：用户模式调试基础"></a>教程：用户模式调试基础</h4><p><strong>符号信息：</strong></p>
<p>设置符号的方法1：<code>.symfix</code></p>
<p>设置符号的方法2：设置环境变量<br><code>_NT_SYMBOL_PATH</code>=<code>SRV*c:\Symbols*http://msdl.microsoft.com/download/symbols</code></p>
<p><code>lm</code>：显示进程加载的模块，以及各模块是否加载了符号</p>
<p><code>.reload /f modulename.dll</code>：强制加载模块的符号</p>
<p><code>!sym noisy</code>：记录符号加载尝试的详细信息</p>
<p><strong>线程：</strong></p>
<p><code>~</code>：显示调试进程中所有线程的信息<br>线程信息前的<code>.</code>表示当前线程，<code>#</code>表示触发中断的线程<br>输入提示冒号右边的数字是当前线程的索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0  Id: 874c.18068 Suspend: 1 Teb: 00000001&#96;2229d000 Unfrozen</span><br><span class="line">[下标] Id: [PID].[TID] Suspend: [挂起计数] Teb: [TEB地址] [是否冻结]</span><br></pre></td></tr></table></figure>



<p><code>~ns</code>：切换到索引为n的线程<br>可以组合命令<code>~nk</code>，这样可以在不切换线程的情况下，在别的线程执行操作（这里是显示别的线程的调用堆栈）</p>
<p><code>k</code>：当前线程的调用堆栈（stack trace）</p>
<p><code>!teb</code>：查看TEB的部分信息，默认当前线程的</p>
<p><strong>进制转换：</strong></p>
<p>16转10：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; ? 874c</span><br><span class="line">Evaluate expression: 34636 &#x3D; 0000874c</span><br></pre></td></tr></table></figure>

<p>10转16：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; ? 0n34636</span><br><span class="line">Evaluate expression: 34636 &#x3D; 0000874c</span><br></pre></td></tr></table></figure>



<p><strong>数据或结构的显示：</strong></p>
<p><code>dt [type]</code>：显示数据结构的定义（如显示_TEB：<code>dt ntdll!_teb</code>）</p>
<p><code>dt [type] [addr]</code>：显示数据结构的数据（如显示某个_TEB：<code> dt ntdll!_teb 000000`012229d000</code>）</p>
<p><code>r [reg]</code>：读取寄存器（如读取rcx：<code>r rcx</code>）</p>
<p><code>d&#123;a|b|c|d|D|f|p|q|u|w|W&#125;</code>：以指定类型显示指定地址的数据<br>a：ascii字符<br>b,w,d,q：字节<br>u：unicode<br>f：单精浮点<br>D：双精浮点</p>
<p><code>u</code>：显示反汇编，默认8句汇编指令</p>
<p><code>!error [error_code]</code>：显示错误信息</p>
<p><strong>断点和运行：</strong></p>
<p><code>bp [symbol]</code>：设置断点（如CreateFile：<code>bp kernel32!createfilew</code>）</p>
<p><code>bl</code>：显示当前设置的断点</p>
<p><code>bd</code>：禁用断点，禁用所有断点：<code>bd *</code></p>
<p><code>bc</code>：删除断点</p>
<p><code>g</code>(F5)：运行直到断点</p>
<p><code>p</code>(F10)：步过</p>
<p><code>t</code>(F11)：步进</p>
<h3 id="5-3-内核调试（本地）"><a href="#5-3-内核调试（本地）" class="headerlink" title="5.3 内核调试（本地）"></a>5.3 内核调试（本地）</h3><h4 id="本地内核调试"><a href="#本地内核调试" class="headerlink" title="本地内核调试"></a>本地内核调试</h4><p>修改启动项：<code>bcdedit /debug on</code></p>
<h4 id="本地内核调试教程"><a href="#本地内核调试教程" class="headerlink" title="本地内核调试教程"></a>本地内核调试教程</h4><p><code>!process 0 0</code>：显示所有进程的基本信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; !process 0 0</span><br><span class="line">**** NT ACTIVE PROCESS DUMP ****</span><br><span class="line">PROCESS ffff8d0e682a73c0</span><br><span class="line">    SessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000</span><br><span class="line">    DirBase: 001ad002 ObjectTable: ffffe20712204b80 HandleCount: 9542.</span><br><span class="line">    Image: System</span><br><span class="line">    </span><br><span class="line">(truncated)</span><br></pre></td></tr></table></figure>

<ul>
<li>PROCESS旁边的地址：EPROCESS的地址</li>
<li>SessionId：进程所处的对话</li>
<li>Cid：pid</li>
<li>Peb：PEB地址（在用户模式地址空间）</li>
<li>ParentCid：父进程pid</li>
<li>DirBase：进程主页目录的物理地址（x32是PDPT基址、x64是PML4基址）</li>
<li>ObjectTable：指向进程的私有句柄表的指针 </li>
<li>HandleCount：进程中的句柄数</li>
<li>Image：可执行文件名称，或与可执行文件无关的特殊进程名称 </li>
</ul>
<p><code>!process</code>指令后第一个数字是筛选特定进程，0表示所有进程；第二个数字是细节掩码，0表示最少细节；第三个参数是筛选可执行文件</p>
<p><code>.process /p [EPROCESS]</code>：切换到指定进程</p>
<p>peb在用户模式地址空间中，查看peb需要先设置正确的用户模式进程环境</p>
<p>不切换的做法：<code>.process /p ffff8d0e849df080; !peb e8a8c9c000</code></p>
<p>调用堆栈中，nt前缀表示内核</p>
<p><code>.reload /user</code>：加载用户模式符号</p>
<p>其余常用/有趣的内核模式调试指令：</p>
<ul>
<li><code>!pcr</code>：显示指定为附加索引的处理器的进程控制区域 (PCR)（如果未指定索引，则默认显示处理器 0）</li>
<li><code>!vm</code>：显示系统和进程的内存统计信息</li>
<li><code>!running</code>：显示有关在系统上所有处理器上运行的线程的信息</li>
</ul>
<h3 id="5-4-完全内核调试（双机）"><a href="#5-4-完全内核调试（双机）" class="headerlink" title="5.4 完全内核调试（双机）"></a>5.4 完全内核调试（双机）</h3><p>完全内核调试需要”双机“</p>
<p>最好的连接方式是通过网络，这需要主机和被调试目标系统版最少为Win8</p>
<p>另外一种方法是COM串口，大多数虚拟机支持虚拟串口而不需要真实（物理的）串口线</p>
<p>详细配置方式略过</p>
<h4 id="配置目标机器"><a href="#配置目标机器" class="headerlink" title="配置目标机器"></a>配置目标机器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdedit &#x2F;debug on</span><br><span class="line">bcdedit &#x2F;dbgsettings serial debugport:1 baudrate:115200</span><br></pre></td></tr></table></figure>



<h4 id="配置主机"><a href="#配置主机" class="headerlink" title="配置主机"></a>配置主机</h4><p>调试器需要设置调试端口映射和命名管道，与虚拟机上的相同</p>
<p>输入提示kd左边的数字是引起中断的处理器的索引</p>
<h3 id="5-5-内核驱动调试教程"><a href="#5-5-内核驱动调试教程" class="headerlink" title="5.5 内核驱动调试教程"></a>5.5 内核驱动调试教程</h3><p>可以设置未来断点（在运行程序前设置断点）</p>
<p>如设置驱动prioritybooster的入口点：<code>bu prioritybooster!driverentry</code></p>
<p>可以设置只在指定进程上中断：<code>bp /p [EPROCESS] [symbol]</code><br>如：<code> bp /p ffffdd06042e4080 prioritybooster!priorityboosterdevicecontrol</code></p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2016 - 2022 BraveTroops
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @御史神风
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/blog/js/highlight.min.js"></script>
<script src="/blog/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'windgodm',
        admin: ['windgodm'],
        language: 'zh-CN',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>