
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BraveTroops || APIHook 调试技术 笔记</title>
    <meta name="author" content="御史神风">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/blog//blog/imgs/child.jpg">
    <link rel="stylesheet" href="/blog/css/antd.min.css">
    
    <link rel="stylesheet" href="/blog/css/maiden-theme.css">
    
    <script src="/blog/js/vue.js"></script>
    <script src="/blog/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/blog/rss2.xml" title="BraveTroops" type="application/rss+xml">
</head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/blog/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/blog/">
            <span class="title">BraveTroops</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/contact.html">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/making">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/blog/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/blog/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>BraveTroops</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/contact.html">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/making">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/blog/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/blog/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/blog/css/post-body.css">
<div class="article">
    <div>
        <h1>APIHook 调试技术 笔记 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/6/17
        </span>

        
        <span class="category">
            <a href="/blog/categories/windows">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                windows
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/blog/tags/windows" style=color:#879cff>
                    windows
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/blog/tags/note" style=color:#ffa2c4>
                    note
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/blog/tags/api_hook" style=color:#879cff>
                    api_hook
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/blog/tags/reversecore" style=color:#ff7d73>
                    reversecore
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="APIHook-调试技术-笔记"><a href="#APIHook-调试技术-笔记" class="headerlink" title="APIHook-调试技术 笔记"></a>APIHook-调试技术 笔记</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote>
<p>技术摘要：</p>
<p><strong>动态</strong>修改<strong>进程内存</strong>中的<strong>代码</strong>。利用<strong>调试</strong>技术附加到目标进程钩取API。</p>
</blockquote>
<blockquote>
<p>术语：</p>
<p>debuger：调试器<br>debugee：被调试者</p>
</blockquote>
<p>起源是逆向工程核心原理里面以记事本WriteFile()API钩取为例讲解利用调试来实现API钩取。<br>该例子目标是在文件保存时把小写转成大写。</p>
<p>概括来说就是实现一个调试器，给对应api下断点。</p>
<p>以记事本WriteFile()API为例，大概流程是作为调试器附加到notepad上，然后给WriteFile()的起始地址下个int 3断点，这样控制流就能回到调试器，就可以读取栈获得api参数了。</p>
<p>大概流程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1: 作为调试器附加</span><br><span class="line">2: 进入调试循环</span><br><span class="line"></span><br><span class="line">判断是否为int3断点，且断点位置为目标api起始地址</span><br><span class="line">OnException:</span><br><span class="line">  1: unhook</span><br><span class="line">  2: get thread context</span><br><span class="line">  3: your patch</span><br><span class="line">  4: change ctx(eip&#x2F;rip)</span><br><span class="line">  5: continue debugee</span><br><span class="line">  Sleep(0)</span><br><span class="line">  6: hook</span><br><span class="line"></span><br><span class="line">对于其他异常，交回给debugee的seh处理</span><br></pre></td></tr></table></figure>

<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>首先是要注意32和64位的问题，然后可能需要获取Debug权限。</p>
<h2 id="实例：记事本WriteFile-API（x32）"><a href="#实例：记事本WriteFile-API（x32）" class="headerlink" title="实例：记事本WriteFile()API（x32）"></a>实例：记事本WriteFile()API（x32）</h2><p>该例子对象是win10的x32的notepad.exe。</p>
<h3 id="1-作为调试器附加"><a href="#1-作为调试器附加" class="headerlink" title="1 作为调试器附加"></a>1 作为调试器附加</h3><p>代码如下只有一行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DebugActiveProcess(dwPID);</span><br></pre></td></tr></table></figure>

<p>附加失败会返回0，通过GetLastError()可以获取错误代码，x32的debuger附加x64的debugee会失败并得到0x32这个错误代码。</p>
<p>成功后会发送一个CREATE_PROCESS_DEBUG_EVENT事件，可以被WaitForDebugEvent()获取。</p>
<p>还有另外一种方法是用CreateProcess()来创建并附加一个进程。</p>
<h3 id="2-调试循环"><a href="#2-调试循环" class="headerlink" title="2 调试循环"></a>2 调试循环</h3><p>附加成功后就要进入调试循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DEBUG_EVENT de;</span><br><span class="line">DWORD dwDECode;</span><br><span class="line">DWORD dwContinueStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for debug event</span></span><br><span class="line"><span class="keyword">while</span> (WaitForDebugEvent(&amp;de, INFINITE)) &#123;</span><br><span class="line">    dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;</span><br><span class="line">    dwDECode = de.dwDebugEventCode;</span><br><span class="line">    <span class="comment">// exception</span></span><br><span class="line">    <span class="keyword">if</span> (dwDECode == EXCEPTION_DEBUG_EVENT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (OnException(&amp;de))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// on create or attach debug event</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dwDECode == CREATE_PROCESS_DEBUG_EVENT) &#123;</span><br><span class="line">        OnCreate(&amp;de);</span><br><span class="line">        dwContinueStatus = DBG_CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debuggee exit</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dwDECode == EXIT_PROCESS_DEBUG_EVENT) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// continue to run debuggee</span></span><br><span class="line">    ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WaitForDebugEvent()用于等待调试事件。第一个参数用于接收调试信息；第二个为等待时间(ms)，如果等待时间为INFINITE(0xFFFFFFFF)则会一直等待直到有调试时间再返回，这时debugee会被挂起。</p>
<h3 id="3-处理调试事件"><a href="#3-处理调试事件" class="headerlink" title="3 处理调试事件"></a>3 处理调试事件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minwinbase.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_EVENT</span> &#123;</span></span><br><span class="line">    DWORD dwDebugEventCode;</span><br><span class="line">    DWORD dwProcessId;</span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        EXCEPTION_DEBUG_INFO Exception;</span><br><span class="line">        CREATE_THREAD_DEBUG_INFO CreateThread;</span><br><span class="line">        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;</span><br><span class="line">        EXIT_THREAD_DEBUG_INFO ExitThread;</span><br><span class="line">        EXIT_PROCESS_DEBUG_INFO ExitProcess;</span><br><span class="line">        LOAD_DLL_DEBUG_INFO LoadDll;</span><br><span class="line">        UNLOAD_DLL_DEBUG_INFO UnloadDll;</span><br><span class="line">        OUTPUT_DEBUG_STRING_INFO DebugString;</span><br><span class="line">        RIP_INFO RipInfo;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; DEBUG_EVENT, *LPDEBUG_EVENT;</span><br></pre></td></tr></table></figure>

<p><strong>EXCEPTION_DEBUG_EVENT</strong><br>(u.Exception = EXCEPTION_DEBUG_INFO)<br>为异常调试事件，<strong>int 3</strong>中断时会触发该事件，这时我们需要执行自己的代码，具体见“6 异常调试事件”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minwinbase.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_DEBUG_INFO</span> &#123;</span></span><br><span class="line">    EXCEPTION_RECORD ExceptionRecord;</span><br><span class="line">    DWORD dwFirstChance;</span><br><span class="line">&#125; EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;</span><br><span class="line"><span class="comment">// winnt.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span></span><br><span class="line">    DWORD    ExceptionCode;</span><br><span class="line">    DWORD ExceptionFlags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span></span><br><span class="line">    PVOID ExceptionAddress;</span><br><span class="line">    DWORD NumberParameters;</span><br><span class="line">    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure>

<p><strong>CREATE_PROCESS_DEBUG_EVENT</strong><br>(u.CreateProcessInfo = CREATE_PROCESS_DEBUG_INFO)<br>在<strong>刚附加</strong>到debugee时会触发，这时需要完成hook，具体见“5 首次hook”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minwinbase.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CREATE_PROCESS_DEBUG_INFO</span> &#123;</span></span><br><span class="line">    HANDLE hFile;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    LPVOID lpBaseOfImage;</span><br><span class="line">    DWORD dwDebugInfoFileOffset;</span><br><span class="line">    DWORD nDebugInfoSize;</span><br><span class="line">    LPVOID lpThreadLocalBase;</span><br><span class="line">    LPTHREAD_START_ROUTINE lpStartAddress;</span><br><span class="line">    LPVOID lpImageName;</span><br><span class="line">    WORD fUnicode;</span><br><span class="line">&#125; CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;</span><br></pre></td></tr></table></figure>

<p><strong>EXIT_PROCESS_DEBUG_EVENT</strong><br>(u.ExitProcess = EXIT_PROCESS_DEBUG_INFO)<br>在debugee退出时触发。</p>
<h3 id="4-继续运行debugee"><a href="#4-继续运行debugee" class="headerlink" title="4 继续运行debugee"></a>4 继续运行debugee</h3><p>处理完调试事件后，调用ContinueDebugEvent()以继续运行debugee。</p>
<p>ContinueDebugEvent第三个参数比较特殊，如果处理成功设置为DBG_CONTINUE即可，如果不能处理设置成DBG_EXCEPTION_NOT_HANDLED让seh来处理。</p>
<h3 id="5-首次hook"><a href="#5-首次hook" class="headerlink" title="5 首次hook"></a>5 首次hook</h3><p>该事件在刚附加时触发一次，这时我们需要完成对API的hook：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnCreate</span><span class="params">(DEBUG_EVENT* pde)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get api address</span></span><br><span class="line"></span><br><span class="line">    hKernel32 = GetModuleHandleW(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hKernel32 == <span class="number">0</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Get kernel32.dll failed.\n&quot;</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    pWriteFile = GetProcAddress(hKernel32, <span class="string">&quot;WriteFile&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pWriteFile == <span class="number">0</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Get WriteFile() failed.\n&quot;</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hook</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;cpdi, &amp;pde-&gt;u.CreateProcessInfo, <span class="keyword">sizeof</span>(CREATE_PROCESS_DEBUG_INFO));</span><br><span class="line">    ReadProcessMemory(cpdi.hProcess, pWriteFile, &amp;chOrigin, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chINT3, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kernel32在不同进程中加载到同样位置，直接在本进程GetModuleHandleW就行。</p>
<p>需要注意的是把CreateProcessInfo保存下来，其中有一些信息比如debugee的进程、线程id我们在接下来的再次hook时也需要使用。</p>
<h3 id="6-异常调试事件（补丁代码）"><a href="#6-异常调试事件（补丁代码）" class="headerlink" title="6 异常调试事件（补丁代码）"></a>6 异常调试事件（补丁代码）</h3><p>发生异常调试事件时触发，如果为int3且断点为目标api地址就执行我们的补丁，这里我们的补丁是把文本的小写字母转换成大写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnException</span><span class="params">(DEBUG_EVENT* pde)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CONTEXT ctx;</span><br><span class="line">    PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExceptionRecord;</span><br><span class="line">    DWORD dwBuffer, dwNum; <span class="comment">// WriteFile() param 2, 3</span></span><br><span class="line">    PBYTE lpBuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int 3</span></span><br><span class="line">    <span class="keyword">if</span> (per-&gt;ExceptionCode == EXCEPTION_BREAKPOINT) &#123;</span><br><span class="line">        <span class="comment">// breakpoint address</span></span><br><span class="line">        <span class="keyword">if</span> (per-&gt;ExceptionAddress == pWriteFile) &#123;</span><br><span class="line">            <span class="comment">// 1: unhook</span></span><br><span class="line">            WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chOrigin, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2: get thread context</span></span><br><span class="line">            ctx.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line">            GetThreadContext(cpdi.hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.1: get WriteFile() param 2, 3</span></span><br><span class="line">            ReadProcessMemory(cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="number">0x8</span>), &amp;dwBuffer, <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ReadProcessMemory(cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="number">0xC</span>), &amp;dwNum, <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2: malloc buffer</span></span><br><span class="line">            lpBuffer = (PBYTE)<span class="built_in">malloc</span>(dwNum + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">memset</span>(lpBuffer, <span class="number">0</span>, dwNum + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.3: copy to buffer</span></span><br><span class="line">            ReadProcessMemory(cpdi.hProcess, (LPVOID)dwBuffer, lpBuffer, dwNum, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nOrigin:\n&quot;</span> &lt;&lt; lpBuffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.4: Convert</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dwNum; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">                    lpBuffer[i] -= <span class="number">0x20</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nConverted:\n&quot;</span> &lt;&lt; lpBuffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.5: copy back</span></span><br><span class="line">            WriteProcessMemory(cpdi.hProcess, (LPVOID)dwBuffer, lpBuffer, dwNum, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">free</span>(lpBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4: change ctx(eip)</span></span><br><span class="line">            ctx.Eip = (DWORD)pWriteFile;</span><br><span class="line">            SetThreadContext(cpdi.hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5: run</span></span><br><span class="line">            ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE);</span><br><span class="line"></span><br><span class="line">            Sleep(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6: hook</span></span><br><span class="line">            WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chINT3, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程是unhook -&gt; 获取上下文 -&gt; 补丁 -&gt; 恢复eip/rip -&gt; 继续运行debugee -&gt; 恢复hook</p>
<p>在继续运行debugee之后需要Sleep(0)再恢复hook，是因为hook会修改内存中的代码，此时debugee也在运行同一段内存的代码，可能会发生内存访问异常。Sleep(0)可以释放当前线程的剩余时间，让cpu先去执行其他线程，然后再回来恢复hook。</p>
<p>其中需要用到api的参数，这里简单分析下此时的栈。此时刚刚进入函数，还未push ebp，所以esp指向旧的栈顶，也就是函数放回地址。32位以寄存器传参，第n的参数此时在esp+4*n的位置。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>逆向工程核心原理：part4-API钩取：第30章-记事本WriteFile()API钩取</p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2016 - 2021 BraveTroops
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @御史神风
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/blog/js/highlight.min.js"></script>
<script src="/blog/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'windgodm',
        admin: ['windgodm'],
        language: 'zh-CN',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>