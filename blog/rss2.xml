<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>BraveTroops</title>
    <link>https://windgodm.github.io/blog/</link>
    
    <atom:link href="https://windgodm.github.io/blog/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 17 Jan 2024 10:36:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>IA32e硬件与操作系统中断机制</title>
      <link>https://windgodm.github.io/blog/post/IA32e-exception.html</link>
      <guid>https://windgodm.github.io/blog/post/IA32e-exception.html</guid>
      <pubDate>Thu, 19 Jan 2023 04:00:00 GMT</pubDate>
      
      <description>关于IA32e中断机制的硬件与操作系统部分</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="IA32e中断"><a href="#IA32e中断" class="headerlink" title="IA32e中断"></a>IA32e中断</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>前置知识：</p><ul><li>IA32e 全局描述符表（GDT）<ul><li>平坦模式</li><li>描述符的字段</li></ul></li></ul><p>后置知识：</p><ul><li>TSS</li></ul></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>这部分内容主要为intel白皮书的笔记，主要关注64位和软件相关的信息，忽略了影子栈和32位下的情况，还有优先级</p><p>sdm-vol3(v77)：</p><ul><li><p>第6章：关于中断和异常处理</p><ul><li><p>6.1：概述</p></li><li><p>6.2：异常和中断向量</p></li><li><p>6.3：中断源</p></li><li><p>6.4：异常源</p></li><li><p>6.5：异常分类</p></li><li><p>6.8：启用和禁用中断</p></li><li><p>6.10：IDT 描述符</p></li><li><p>6.12：处理异常和中断</p></li><li><p>6.14：特定于<code>IA-32e模式</code>和<code>64位子模式</code>的信息</p></li></ul></li></ul></blockquote><h2 id="异常和中断概述"><a href="#异常和中断概述" class="headerlink" title="异常和中断概述"></a>异常和中断概述</h2><p>异常和中断：指示处理器有需要注意的事，通常会强制切换控制流</p><p>来源：随机发生，来自硬件的信号、软件的<code>INT n</code>指令、处理器错误（比如除0）</p><h2 id="异常和中断向量"><a href="#异常和中断向量" class="headerlink" title="异常和中断向量"></a>异常和中断向量</h2><p>向量号（vector number）：</p><ul><li>每个异常（exception）和中断条件（interrupt condition）分配一个唯一的数</li><li>作为中断描述符表（IDT）的索引</li><li>范围0~255<ul><li>0~31：IA-32架构保留</li><li>32~255：用户定义</li></ul></li></ul><h2 id="异常和中断源"><a href="#异常和中断源" class="headerlink" title="异常和中断源"></a>异常和中断源</h2><p>中断源：</p><ul><li>外部（硬件）中断</li><li>软件生成的中断<ul><li><code>INT n</code>指令强制隐式调用中断号为n的中断处理程序</li><li>0~255都可以作为指令参数</li><li>不会使用EFLAGS的IF标记</li></ul></li></ul><p>异常源：</p><ul><li>处理器检测 到 程序错误 异常</li><li>软件生成的异常<ul><li>通过<code>INT n</code>指令产生的异常不会把错误代码入栈；而异常处理程序会尝试弹出错误代码，可能会导致错误的返回位置</li></ul></li><li>机器检测异常</li></ul><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>按照产生的原因和处理的方式分类：</p><ul><li>faults：可以被改正的异常，改正后将返回到产生异常的指令（然后再次执行）</li><li>traps：返回到下一条指令</li><li>aborts：不允许产生异常的程序或任务继续运行</li></ul><h2 id="保护模式保留的异常和中断"><a href="#保护模式保留的异常和中断" class="headerlink" title="保护模式保留的异常和中断"></a>保护模式保留的异常和中断</h2><p>![vol-3a-t-6-1 Protected-Mode Exceptions and Interrupts](E:\documents\note\md\windows\sdm-figure\vol-3a-t-6-1 Protected-Mode Exceptions and Interrupts.jpg)</p><p>![vol-3a-t-6-1 Protected-Mode Exceptions and Interrupts (Contd.)](E:\documents\note\md\windows\sdm-figure\vol-3a-t-6-1 Protected-Mode Exceptions and Interrupts (Contd.).jpg)</p><h2 id="启用和禁用中断"><a href="#启用和禁用中断" class="headerlink" title="启用和禁用中断"></a>启用和禁用中断</h2><p>根据处理器的状态以及EFLAGS中的IF和RF，处理器抑制某些中断的产生</p><ul><li>RF：设置时，调试异常（#DB）将无法生成（更多信息：17.3.1.1）</li></ul><p>切换ss通常需要两条指令：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">MOV SS, AXMOV ESP, StackTop</code></pre><p>为了保护切换时的原子性，在MOV或POP修改SS时：</p><ul><li>下一条指令禁用指令断点（类似EFLAGS.RF=1）</li><li>数据断点将被抑制直到两条指令完成</li><li>在两条指令完成后交付单步陷阱</li><li>连续的加载SS只有第一条加载指令遵循以上规则</li></ul><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>如果出现多个中断，将按优先级处理</p><h2 id="中断描述符表（IDT）"><a href="#中断描述符表（IDT）" class="headerlink" title="中断描述符表（IDT）"></a>中断描述符表（IDT）</h2><p>IDTR寄存器保存着IDT的基址，8字节对齐</p><p>IDT存有有三种类型的门描述符（gate descriptor）：</p><ul><li>任务门描述符</li><li>中断门描述符</li><li>陷阱门描述符</li></ul><p>IA32 三种门描述符的格式</p><p>![vol-3a-f-6-2 IDT Gate Descriptors](E:\documents\note\md\windows\sdm-figure\vol-3a-f-6-2 IDT Gate Descriptors.jpg)</p><p>IA32e IDT表项由8字节拓展为16字节，以支持64位的地址偏移</p><p>![vol-3a-f-6-8 64-Bit IDT Gate Descriptors](E:\documents\note\md\windows\sdm-figure\vol-3a-f-6-8 64-Bit IDT Gate Descriptors.png)</p><p>TYPE字段同IA32</p><p>IST（Interrupt Stack Table）字段用于栈切换基址</p><h2 id="异常与中断流程"><a href="#异常与中断流程" class="headerlink" title="异常与中断流程"></a>异常与中断流程</h2><h3 id="找到处理函数"><a href="#找到处理函数" class="headerlink" title="找到处理函数"></a>找到处理函数</h3><p>根据中断向量，找到处理函数：</p><p>![vol-3a-f-6-3 Interrupt Procedure Call](E:\documents\note\md\windows\sdm-figure\vol-3a-f-6-3 Interrupt Procedure Call.jpg)</p><h3 id="IA32切换到处理函数"><a href="#IA32切换到处理函数" class="headerlink" title="IA32切换到处理函数"></a>IA32切换到处理函数</h3><p>IA32下，根据中断前特权级别和中断（描述符上）的特权级别，有两种情况：</p><ul><li>级别不变，在中断时的栈上，将相关寄存器入栈</li><li>级别改变，切换到处理函数的栈，再将相关寄存器入栈</li></ul><p>注意：</p><ul><li>级别改变时会先额外入栈SS、ESP</li><li>只有异常才会入栈Error Code（通过<code>int n</code>指令产生的不入栈）</li></ul><p>![vol-3a-f-6-4  Stack Usage on Transfers to Interrupt and Exception-Handling Routines](E:\documents\note\md\windows\sdm-figure\vol-3a-f-6-4  Stack Usage on Transfers to Interrupt and Exception-Handling Routines.jpg)</p><h3 id="IA32e切换到处理函数的不同"><a href="#IA32e切换到处理函数的不同" class="headerlink" title="IA32e切换到处理函数的不同"></a>IA32e切换到处理函数的不同</h3><p>栈元素由4字节变为8字节，入栈内容一样</p><p>新SS强制为0，从TSS中获取新RSP</p><h3 id="IA32e-中断栈表（IST）"><a href="#IA32e-中断栈表（IST）" class="headerlink" title="IA32e 中断栈表（IST）"></a>IA32e 中断栈表（IST）</h3><p>IA32e中可以使用IST机制替代前面的栈切换机制</p><p>中断描述符（IDT）的IST字段用于在TSS中索引（4位，范围0~7）</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>当IST为0时，新栈指针为TSS的RSP0，否则为对应的ISTn</p></blockquote><p>当使用影子栈时，处理器提供一个MSR<code>IA32_INTERRUPT_SSP_TABLE</code></p><p>![vol-3a-f-6-10 Interrupt Shadow Stack Table](E:\documents\note\md\windows\sdm-figure\vol-3a-f-6-10 Interrupt Shadow Stack Table.jpg)</p><h3 id="返回到中断或异常前代码"><a href="#返回到中断或异常前代码" class="headerlink" title="返回到中断或异常前代码"></a>返回到中断或异常前代码</h3><p>使用<code>iret</code>或<code>iretd</code>指令：将弹出切换时入栈的参数恢复对应寄存器，然后返回</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>官方文档<ul><li>sdm-vol3(v77)</li></ul></li><li>IA32中断异常的解说<ul><li><a href="https://zhuanlan.zhihu.com/p/57271206">IA-32的中断和异常处理 - 知乎 (zhihu.com)</a></li></ul></li><li>IA32e中断异常解说；在windows上使用windbg跟踪从32/64通过syscall进内核过程<ul><li><a href="https://blog.csdn.net/qq_41988448/article/details/123111860">Windows x64内核学习笔记（二）—— IA-32e模式_lzyddf的博客-CSDN博客</a></li></ul></li></ul><h1 id="IA32e系统调用硬件支持"><a href="#IA32e系统调用硬件支持" class="headerlink" title="IA32e系统调用硬件支持"></a>IA32e系统调用硬件支持</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>主要关注IA32e的系统调用，忽略兼容模式</p><p>sdm-vol3(v77)：</p><ul><li>2.2.1：IA32e 拓展特性启用寄存器</li><li>5.8.7：快速调用系统过程 与 SYSENTER SYSEXIT</li><li>5.8.8：64位模式的快速系统调用</li></ul></blockquote><p>IA32e为系统调用机制提供了一些支持，以便以受控制的方式从R3切换到R0</p><h2 id="SYSENTER-SYSEXIT"><a href="#SYSENTER-SYSEXIT" class="headerlink" title="SYSENTER SYSEXIT"></a>SYSENTER SYSEXIT</h2><p>该对指令目的是为了提供一个机制，允许快速调用操作系统或执行过程</p><p>SYSENTER可以在任意权限级别下进入R0</p><p>SYSEXIT用于在R0下返回</p><p>两条执行跳转时将从MSR寄存器和通用寄存器中获取所需的信息，以减少对内存的访问</p><p>所有信息需要由调用过程显式保存</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Nehalem微架构：</p><ul><li>IA32_SYSENTER_CS 174H</li><li>IA32_SYSENTER_ESP 175H</li><li>IA32_SYSENTER_EIP 176H</li></ul></blockquote><p>IA32：</p><ul><li><p>SYSENTER</p><ul><li><p>目标代码段：<code>msr[IA32_SYSENTER_CS]</code></p></li><li><p>目标指令：<code>msr[IA32_SYSENTER_EIP]</code></p></li><li><p>栈段：<code>msr[IA32_SYSENTER_CS] + 8</code></p></li><li><p>栈指针：<code>msr[IA32_SYSENTER_ESP]</code></p></li></ul></li><li><p>SYSEXIT</p><ul><li><p>目标代码段：<code>msr[IA32_SYSENTER_CS] + 16</code></p></li><li><p>目标指令：<code>EDX</code></p></li><li><p>栈段：<code>msr[IA32_SYSENTER_CS] + 24</code></p></li><li><p>栈指针：<code>ECX</code></p></li></ul></li></ul><p>IA32e（msr寄存器拓展到64位，使用时也是读64位）：</p><ul><li>SYSENTER<ul><li>目标代码段：<code>msr[IA32_SYSENTER_CS]</code>（非NULL选择子）</li><li>新CS属性：<code>base=0</code>, <code>limit=FFFFFFFFH</code></li><li>目标指令：<code>msr[IA32_SYSENTER_EIP]</code></li><li>栈段：<code>msr[IA32_SYSENTER_CS] + 8</code></li><li>新SS属性：<code>base=0</code>, <code>limit=FFFFFFFFH</code></li><li>栈指针：<code>msr[IA32_SYSENTER_ESP]</code></li></ul></li><li>SYSEXIT<ul><li>目标代码段：<code>msr[IA32_SYSENTER_CS] + 32</code></li><li>新CS属性：<code>L-bit=1</code>（强制到64位模式）</li><li>目标指令：<code>RDX</code></li><li>栈段：<code>msr[IA32_SYSENTER_CS] + 40</code></li><li>栈指针：<code>RCX</code></li></ul></li></ul><h2 id="快速系统调用"><a href="#快速系统调用" class="headerlink" title="快速系统调用"></a>快速系统调用</h2><p>MSR[<strong>IA32_EFER</strong>]（0xC0000080）的第0位指示是否支持<code>SYSCALL</code>和<code>SYSRET</code>指令</p><p><code>SYSCALL</code>、<code>SYSRET</code>是为平坦模式设计的，连同<code>SYSENTER</code>、<code>SYSEXIT</code>适用于IA-32e模式，但前面一对在兼容模式（或保护模式）下不支持</p><p>CPUID.80000001H.EDX[bit 11]指示是否支持<code>SYSCALL</code>、<code>SYSRET</code></p><p>SYSCALL用于在R3下进入R0</p><p>SYSRET用于在R0下返回到R3</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Nehalem微架构：</p><ul><li>IA32_EFER C0000080H</li><li>IA32_STAR C0000081H</li><li>IA32_LSTAR C0000082H</li><li>IA32_FMASK C0000084H</li></ul></blockquote><p>SYSCALL和SYSRET会保存和恢复RFLAGS寄存器</p><p>然后类似前面，也是使用MSR寄存器和通用寄存器</p><ul><li>SYSCALL<ul><li>由处理器将RFLAGS存入R11；下一条指令的RIP存入RCX（返回地址）</li><li>目标代码段：<code>msr[IA32_STAR][47:32]</code>（非NULL选择子）</li><li>目标指令：<code>msr[IA32_LSTAR]</code></li><li>栈段：<code>msr[IA32_STAR][47:32] + 8</code></li><li>RFLAGS：<code>RFLAGS &amp; msr[IA32_FMASK]</code></li></ul></li><li>SYSRET<ul><li>目标代码段：<code>msr[IA32_STAR][63:48] + 16</code>（非NULL选择子）</li><li>目标指令：<code>RCX</code></li><li>栈段：<code>msr[IA32_STAR][63:48] + 8</code></li><li>RFLAGS：<code>R11</code></li></ul></li></ul><p>操作系统应该保证这两条指令跳转时所切换的GDT/LDT表项内容的正确性</p><p>栈指针也不会被保存和恢复，栈的切换交由操作系统实现</p><p>上述所用MSR寄存器的布局</p><p>![vol-3a-f-5-14 MSRs Used by SYSCALL and SYSRET](E:\documents\note\md\windows\sdm-figure\vol-3a-f-5-14 MSRs Used by SYSCALL and SYSRET.jpg)</p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul><li>官方文档<ul><li>sdm-vol3(v77)</li><li>sdm-vol4(v78)</li></ul></li></ul><h1 id="windows系统调用概述"><a href="#windows系统调用概述" class="headerlink" title="windows系统调用概述"></a>windows系统调用概述</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>（指IA32架构下的windows系统）</p><p>系统调用的大致机制为：</p><p>通过硬件支持的中断或陷阱指令，进入到内核中的系统调用分发函数，然后再执行对应的系统调用处理函数</p><p>windows有两个服务表（SDT），存储了系统调用的信息，第二个表用于GUI程序：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _KSERVICE_TABLE_DESCRIPTOR&#123;    PULONG Base;   &#x2F;&#x2F; address or offsets&#39; array    PULONG Count;    ULONG Limit;   &#x2F;&#x2F; number of array    PUCHAR Number;    &#x2F;&#x2F; ...&#125; KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;       &#x2F;&#x2F; SDTKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow; &#x2F;&#x2F; SDTS (+gui)</code></pre><p>两个SDT的Base字段指向一个数组，存储了各个系统调用处理函数的地址，该数组又被称为SSDT</p><p>内核还维护着两个全局指针指向两个地址/偏移量数组（SSDT）：</p><p><code>KiServiceTable</code>，<code>W32pServiceTable</code></p><p>获取某个系统调用函数地址的方式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; x86addr[i] &#x3D; (DWORD*)KiServiceTable[i];&#x2F;&#x2F; x64addr[i] &#x3D; KiServiceTable + (DWORD*)KiServiceTable[i] &gt;&gt; 4;</code></pre><h2 id="进入内核的方式"><a href="#进入内核的方式" class="headerlink" title="进入内核的方式"></a>进入内核的方式</h2><p><strong>思路</strong></p><p>通过中断（int 2e）或者陷阱指令（sysenter、syscall），进入内核</p><p>通过指定进入内核的位置为系统调用分发函数，实现系统调用</p><p><strong>中断2E 实现（过时）</strong></p><p>通过中断<strong>INT 0x2E</strong>实现系统调用</p><p>IDT中0x2E表项对应<strong>KiSystemService</strong>，实现了系统调用的分发</p><p><strong>sysenter 实现（过时）</strong></p><p>通过IA32的快速调用指令<strong>SYSENTER/SYSEXIT</strong>实现（对硬件而言，32、64位都支持该指令）</p><p><code>msr[IA32_SYSENTER_CS]</code>（174H）为通过SYSENTER指令进入内核的位置</p><p>由windows系统初始化为<strong>KiFastCallEntry</strong></p><p><strong>syscall 实现（现用）</strong></p><p>通过IA32e的快速系统调用指令<strong>SYSCALL/SYSRET</strong>实现（对硬件而言只在<strong>64位</strong>下支持）</p><p><code>msr[IA32_LSTAR]</code>（C000_0082H）为通过SYSCALL指令进入内核的位置</p><p>由windows系统初始化为<strong>KiSystemCall64</strong></p><h2 id="win10进入内核"><a href="#win10进入内核" class="headerlink" title="win10进入内核"></a>win10进入内核</h2><p>win10版本号：21H2</p><p>处理器：AMD</p><p>简单跟踪程序对CreateFile系统调用的执行过程</p><h3 id="x64程序R3部分"><a href="#x64程序R3部分" class="headerlink" title="x64程序R3部分"></a>x64程序R3部分</h3><p>进入的过程：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; test64.exe maincall qword ptr ds:[&lt;&amp;CreateFileW&gt;]; kernel32.dll, CreateFileW, STUBjmp qword ptr ds:[&lt;&amp;CreateFileW&gt;]; kernelbase.dll, CreateFileW, 简单处理参数...call CreateFileInternal; kernelbase.dll, CreateFileInternal, 处理参数...call qword ptr ds:[&lt;&amp;NtCreateFile&gt;]; ntdll.dll, NtCreateFile...</code></pre><p>ntdll.dll NtCreateFile的代码，其他系统调用的代码也是一样的格式：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov r10, rcx ; 保存rcx，syscall会把下一条指令（返回）地址存在rcxmov eax, 55  ; 调用号test byte ptr ds:[7FFE0308h], 1 ; 检查是否支持syscalljne l_intsyscall ; 通过syscall进入内核retl_int:int 2E ; 通过中断进入内核ret</code></pre><h3 id="x64程序-系统调用-R0入口"><a href="#x64程序-系统调用-R0入口" class="headerlink" title="x64程序 系统调用 R0入口"></a>x64程序 系统调用 R0入口</h3><p>sysenter在64位内核中已被弃用</p><p><strong>syscall</strong>的系统调用分发函数 = <code>msr[IA32_LSTAR]</code>，windbg读出是<strong>KiSystemCall64</strong></p><pre class="line-numbers language-none"><code class="language-none">1: kd&gt; rdmsr C0000082msr[c0000082] &#x3D; fffff804&#96;33a0c2c01: kd&gt; u fffff804&#96;33a0c2c0 l1nt!KiSystemCall64:fffff804&#96;33a0c2c0 0f01f8          swapgs</code></pre><p>简单贴一下<code>KiSystemCall64</code>开头的汇编：</p><p>（21H2的 KPCR 大小为 178H，KPRCB 似乎因为对齐从 gs:180H开始）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">swapgs                   ; 切换gsmov     gs:10h, rsp      ; [gs+10h] _KPCR.UserRspmov     rsp, gs:1A8h     ; [gs+180h+28h] _KPRCB.RspBasepush    2Bhpush    qword ptr gs:10hpush    r11              ; syscall 之前的 rflagspush    33hpush    rcx              ; syscall 下一条指令的地址（返回到R3的地址）mov     rcx, r10         ; 恢复rcx寄存器</code></pre><p><strong>int 2E</strong>的系统调用分发函数，windbg读出是<strong>KiIsrThunk+0x170</strong></p><pre class="line-numbers language-none"><code class="language-none">1: kd&gt; dq idtr+10*2E l2ffff8780&#96;16f4d2e0  339f8e00&#96;0010d770 00000000&#96;fffff8041: kd&gt; u fffff804339fd770 l3nt!KiIsrThunk+0x170:fffff804&#96;339fd770 6a2e            push    2Ehfffff804&#96;339fd772 55              push    rbpfffff804&#96;339fd773 e999060000      jmp     nt!KiIsrLinkage (fffff804&#96;339fde11)</code></pre><h3 id="x32程序R3部分"><a href="#x32程序R3部分" class="headerlink" title="x32程序R3部分"></a>x32程序R3部分</h3><p>切换到x64之前的部分：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; test32.exe maincall qword ptr ds:[&lt;&amp;CreateFileW&gt;]; kernel32.dll, CreateFileW, STUBjmp qword ptr ds:[&lt;&amp;CreateFileW&gt;]; kernelbase.dll, CreateFileW, 简单处理参数...call CreateFileInternal; kernelbase.dll, CreateFileInternal, 处理参数...call qword ptr ds:[&lt;&amp;NtCreateFile&gt;]; ntdll.dll, NtCreateFile...call edx ; Wow64SystemServiceCall; ntdll.dll, Wow64SystemServiceCalljmp dword ptr ds:[&lt;Wow64Transition&gt;]</code></pre><p>ntdll.dll NtCreateFile的代码：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov     eax, 55h ; NtCreateFilemov     edx, offset _Wow64SystemServiceCall@0 ; Wow64SystemServiceCall()call    edx ; Wow64SystemServiceCall() ; Wow64SystemServiceCall()retn    2Ch</code></pre><p>这个<code>Wow64SystemServiceCall</code>在CE中识别为<code>KiFastSystemCall</code>，作用是切换到64位：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; x32 asm774F7000 | EA 09704F77 3300         | jmp far 33:774F7009; x64 asm774F7009 | 41 FF A7 F8000000        | jmp qword [r15 + 0xf8]</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>windows的系统调用机制大概为：</p><p>x64一般使用syscall指令陷入内核中的系统调用分发函数</p><p>x32先变成64位，再陷入</p><h2 id="中断请求级概述"><a href="#中断请求级概述" class="headerlink" title="中断请求级概述"></a>中断请求级概述</h2><p>windows使用IRQL（Interrupt ReQuest Level，中断请求级）管理中断优先级，这是一个IA32硬件支持的功能</p><p>windows为各优先级别赋予了意义：</p><ul><li>PASSIVE LEVEL（0）：最低级别，全部用户模式代码和大多数内核代码</li><li>APC LEVEL（1）：异步过程调用（APC）的级别</li><li>DISPATCH LEVEL（2）：最高级别的软件IRQL，线程分发器、延迟过程调用（DPC）的级别</li></ul><h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><ul><li>《逆向工程实战》（《Practical Reverse Engineering》）</li><li><a href="https://blog.csdn.net/qq_41988448/article/details/123111860">Windows x64内核学习笔记（二）—— IA-32e模式_lzyddf的博客-CSDN博客</a></li></ul><h1 id="linux系统调用概述"><a href="#linux系统调用概述" class="headerlink" title="linux系统调用概述"></a>linux系统调用概述</h1><p>（指IA32架构下的linux系统）</p><h2 id="给ubuntu2004添加系统调用"><a href="#给ubuntu2004添加系统调用" class="headerlink" title="给ubuntu2004添加系统调用"></a>给ubuntu2004添加系统调用</h2><p>虚拟机版本：VM 16.1.0</p><p>系统版本：ubuntu-20.04.1，VM便捷安装</p><p>查看内核版本（<code>uname -a</code>）：5.15.0-58</p><h3 id="修改内核"><a href="#修改内核" class="headerlink" title="修改内核"></a>修改内核</h3><p>下载内核源码（<a href="https://www.kernel.org/%EF%BC%89%EF%BC%8C%E9%80%89%E6%8B%A9">https://www.kernel.org/），选择</a> 5.15.90 版本（longterm）</p><p>解压到 <code>/usr/src</code></p><p>添加系统调用号</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo gedit arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscall_64.tbl</code></pre><p>第一部分的系统调用号为1~448，第二部分为512以后，在448和512之间都可以添加新系统调用</p><pre class="line-numbers language-none"><code class="language-none">44964hwsys_hw</code></pre><p>添加系统调用函数声明</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo gedit include&#x2F;linux&#x2F;syscalls.h </code></pre><p>在最后一个系统调用函数声明后添加</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage long sys_hw(int arg);</code></pre><p>添加系统调用函数定义</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo gedit kernel&#x2F;sys.c</code></pre><p>在最后添加</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage long sys_hw(int arg)&#123;printk(&quot;hello world, arg&#x3D;%d\n&quot;, arg);return 0;&#125;</code></pre><h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><p><strong>安装编译所需工具</strong></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo apt-get install makesudo apt-get install build-essential opensslsudo apt-get install libncurses5-dev libssl-devsudo apt-get install zlibc minizipsudo apt-get install libidn11-dev libidn11sudo apt-get install bison flexsudo apt-get install libelf-devsudo apt-get install dwarvessudo apt-get install zstd</code></pre><p>安装上面的几个似乎会附带安装下面这几个</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo apt-get install pkg-configsudo apt-get install libc6-dev</code></pre><p>删除编译生成文件、内核配置文件</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo make mrpropersudo make clean</code></pre><p><strong>配置</strong></p><p>使用旧配置，在<code>/boot</code>中</p><pre class="line-numbers language-none"><code class="language-none">cp &#x2F;boot&#x2F;config-5.15.0-58-generic .&#x2F;.config</code></pre><p>修改<code>.config</code>：</p><pre class="line-numbers language-none"><code class="language-none">CONFIG_SYSTEM_TRUSTED_KEYS&#x3D;&quot;&quot;CONFIG_SYSTEM_REVOCATION_KEYS&#x3D;&quot;&quot;CONFIG_DEBUG_INFO_BTF&#x3D;n</code></pre><p><strong>编译</strong></p><p>编译内核，大概7~8分钟</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo make bzImage -j8</code></pre><p>编译模块，</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo make modules -j8</code></pre><p><strong>启动文件</strong></p><p>备份</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo cp &#x2F;etc&#x2F;default&#x2F;grub &#x2F;etc&#x2F;default&#x2F;grub.bak</code></pre><p><strong>安装</strong></p><p>安装模块</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo make INSTALL_MOD_STRIPE&#x3D;1 modules_install</code></pre><p>安装内核 重启</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo make installsudo reboot</code></pre><h2 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/hhb442/article/details/106513084">Ubuntu上增加系统调用（需要编译内核）Peanutty的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/qq_45289233/article/details/106621835">Ubuntu20.04下添加自定义系统调用 编程菜玑的博客-CSDN博客</a></li><li><a href="https://www.jianshu.com/p/7547a58e68d3">在Ubuntu下添加系统调用 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/qq_36393978/article/details/118157426">内核错误: No rule to make target ‘debian/canonical-certs.pem‘, needed by ‘certs/x509_certificate_list‘ Imagine Miracle的博客-CSDN博客</a></li><li><a href="https://www.jianshu.com/p/061ec6c81ecf">在Ubuntu 18.04 下编译Linux内核 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/qq_40311939/article/details/127757299">Ubuntu虚拟机扩展磁盘空间 Vis-Lin的博客-CSDN博客</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/kernel/">kernel</category>
      
      
      <comments>https://windgodm.github.io/blog/post/IA32e-exception.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>VMP还原思路</title>
      <link>https://windgodm.github.io/blog/post/VMP-deobf.html</link>
      <guid>https://windgodm.github.io/blog/post/VMP-deobf.html</guid>
      <pubDate>Wed, 11 Jan 2023 04:00:00 GMT</pubDate>
      
      <description>记录一下VMP还原思路</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1 摘要"></a>1 摘要</h1><h2 id="1-1-关于代码优化与还原"><a href="#1-1-关于代码优化与还原" class="headerlink" title="1.1 关于代码优化与还原"></a>1.1 关于代码优化与还原</h2><p>关于还原，我认为难点是工作量大，需要自动化提升效率</p><p>还原和混淆是一对反义词，相同点是保证代码<strong>功能相近</strong>，不同是一个是使代码更<strong>易读</strong>，后者则相反</p><p>而代码优化非常类似，也要保证代码<strong>功能相近</strong>，不同是减少代码的<strong>体积</strong>或<strong>运行速度</strong></p><p>所以我感觉还原和代码优化有很多共通点</p><p>然后尝试了一下从编译的角度去做自动化还原，这里分享一下思路，算是画一个不太完美的句号吧</p><h2 id="1-2-还原流程"><a href="#1-2-还原流程" class="headerlink" title="1.2 还原流程"></a>1.2 还原流程</h2><p>我的还原流程简单来说就三步：</p><ol><li>识别汇编对应的语义（翻译虚拟机字节码）</li><li>虚拟指令转换成C</li><li>二次编译，利用编译器优化</li></ol><p>第三步可以针对性的实现一些优化，因为vmp是一个基于栈的虚拟机，编译器的优化效果有限</p><p>第一步是我做的比较多的一部分，在后面的实现过程会说具体思路</p><h1 id="2-实现过程"><a href="#2-实现过程" class="headerlink" title="2 实现过程"></a>2 实现过程</h1><h2 id="2-1-Handler语义识别"><a href="#2-1-Handler语义识别" class="headerlink" title="2.1 Handler语义识别"></a>2.1 Handler语义识别</h2><p>这一步说的是怎么判断Handler对应的虚拟机指令</p><h3 id="2-1-1-浅谈VMP的CFG"><a href="#2-1-1-浅谈VMP的CFG" class="headerlink" title="2.1.1 浅谈VMP的CFG"></a>2.1.1 浅谈VMP的CFG</h3><p>Handler识别首先绕不开一个问题，怎么找到Handler在哪</p><p>关于VMP 3.X的架构这里简单说一下</p><p>在VMP2中会有一个分发器，所有Handler的地址都存在一个数组中，很容易就能把所有Handler找出来；但到了3，分发方式变成从字节码中解码出下一条指令的地址</p><h3 id="2-1-2-模拟执行输出虚拟指令"><a href="#2-1-2-模拟执行输出虚拟指令" class="headerlink" title="2.1.2 模拟执行输出虚拟指令"></a>2.1.2 模拟执行输出虚拟指令</h3><p>目前分析到两种跳转方式：</p><pre class="line-numbers language-none"><code class="language-none">mov reg&#96;&#96;jmp reg</code></pre><p>或</p><pre class="line-numbers language-none"><code class="language-none">push reg&#96;&#96;ret</code></pre><p>我的思路是模拟执行，遇到<code>jmp reg</code>或者<code>push ; ret</code>时就代表一条Handler已经结束，reg中的是下一条Handler的地址</p><p>所以可以构建一个<code>Handler 虚拟地址</code>到<code>虚拟指令</code>的映射</p><p>模拟执行还有一个好处，对于不同的虚拟指令，在Handler中下断，让Handler自己解密字节码中的内容，然后提取出来</p><h3 id="2-1-3-Handler识别"><a href="#2-1-3-Handler识别" class="headerlink" title="2.1.3 Handler识别"></a>2.1.3 Handler识别</h3><p>关于Handler的语义是什么就省略了</p><p>根据<code>jmp reg</code>或<code>push ; ret</code>把Handler提取出来后，现在就需要识别其对应的虚拟机指令</p><p>两种思路：</p><ul><li>正则表达式匹配（速度块）</li><li>DAG或者数据流图匹配</li></ul><h4 id="2-1-3-1-正则匹配"><a href="#2-1-3-1-正则匹配" class="headerlink" title="2.1.3.1 正则匹配"></a>2.1.3.1 正则匹配</h4><p>这是我目前正在用的方案，对汇编代码使用正则表达式匹配</p><p>矛盾点是正则规则越严格，漏判越严重，规则越宽松，误判越严重</p><p>缓解方案是对汇编代码先进行一次优化，参考编译原理中的死代码消除，对寄存器的使用进行分析</p><p>以一个加法的Handler为例：</p><p>比如优化前的Handler：</p><p><img src="https://bbs.kanxue.com/upload/attach/202301/907036_G2YS7TP4CDYY2AD.png" alt="handler_add_asm"></p><p>其中4、5、10、11行连续对rdi寄存器进行了写入，显然前三条写入是无效的</p><p>优化后的Handler：</p><p><img src="https://bbs.kanxue.com/upload/attach/202301/907036_6R6Y43C4JE5B64Z.png" alt="handler_add_asm_deobf"></p><p>正则匹配：</p><p><img src="https://bbs.kanxue.com/upload/attach/202301/907036_FNATEPQC4HKKNKT.png" alt="handler_add_regex"></p><h4 id="2-1-3-2-DAG匹配"><a href="#2-1-3-2-DAG匹配" class="headerlink" title="2.1.3.2 DAG匹配"></a>2.1.3.2 DAG匹配</h4><p>这部分只是做一个尝试</p><p>同样是加法的例子，这是其DAG图（不太严格，因为x86复杂指令集有点麻烦）</p><p>蓝色下划线是从栈获取的操作数</p><p>绿色下划线是将结果和RFLAGS放回栈</p><p><img src="https://bbs.kanxue.com/upload/attach/202301/907036_EUQJ95E48BKJKPC.png" alt="handler_add_dag"></p><h3 id="2-1-4-识别结果"><a href="#2-1-4-识别结果" class="headerlink" title="2.1.4 识别结果"></a>2.1.4 识别结果</h3><p>模拟执行顺序执行的片段：</p><p><img src="https://bbs.kanxue.com/upload/attach/202301/907036_YBWT2VRM3J5AX8S.jpg" alt="vasm"></p><h2 id="2-2-控制流还原"><a href="#2-2-控制流还原" class="headerlink" title="2.2 控制流还原"></a>2.2 控制流还原</h2><h3 id="2-2-1-虚拟机指令DU分析"><a href="#2-2-1-虚拟机指令DU分析" class="headerlink" title="2.2.1 虚拟机指令DU分析"></a>2.2.1 虚拟机指令DU分析</h3><p>先分析每条虚拟机指令对栈的读写，然后构建DU链</p><p>接着利用DU链进行一次简单的优化，包括常量传播，折叠一些变量在VM栈和VM寄存器上的移动，还有简单的MBA表达式优化（简化接下来的判断分支等步骤）</p><h3 id="2-2-2-判断是否为分支"><a href="#2-2-2-判断是否为分支" class="headerlink" title="2.2.2 判断是否为分支"></a>2.2.2 判断是否为分支</h3><p>进行到这里就可以判断是jmp还是jcc</p><p>jmp的例子（左边是每条指令起始时VM字节码指针和VM栈指针）：</p><p><img src="https://bbs.kanxue.com/upload/attach/202301/907036_HDG7GCYNFEH56ED.jpg" alt="vasm_jmp"></p><p>jcc的例子：</p><p><img src="https://bbs.kanxue.com/upload/attach/202301/907036_F9KTV3UPHEYAP73.jpg" alt="vasm_jcc"></p><p>区别就是RET之前的一条语句PUSH的是否为一个立即数（依赖前面的常量传播优化）</p><h3 id="2-2-3-获取分支去向"><a href="#2-2-3-获取分支去向" class="headerlink" title="2.2.3 获取分支去向"></a>2.2.3 获取分支去向</h3><p>接下来就可以通过DU链，获取分支的两条去向分别是什么</p><p>依据是VMP的分支跳转伪代码为：</p><pre class="line-numbers language-none"><code class="language-none">mask &#96;&#96;&#x3D;&#96; &#96;-&#96;&#96;1&#96; &#96;+&#96; &#96;flag&#96;&#96;a1 &#96;&#96;&#x3D;&#96; &#96;mask &amp; FAddr&#96;&#96;a2 &#96;&#96;&#x3D;&#96; &#96;~mask &amp; TAddr&#96;&#96;jmp &#96;&#96;&#x3D;&#96; &#96;a1 &#96;&#96;+&#96; &#96;a2</code></pre><p>这里是识别的例子：</p><p><img src="https://bbs.kanxue.com/upload/attach/202301/907036_CQHRNYR7VPWQYAG.jpg" alt="vasm_du_jcc"></p><h3 id="2-2-4-获取分支条件（未完善）"><a href="#2-2-4-获取分支条件（未完善）" class="headerlink" title="2.2.4 获取分支条件（未完善）"></a>2.2.4 获取分支条件（未完善）</h3><p>这里我大致分成了两步：</p><ul><li>识别判断的rflags标志位</li><li>识别<code>~(~x+y)</code></li></ul><p>一个比较标准的<code>test x-y</code>，然后判断CF的例子</p><p>绿色框是上一步的跳转地址计算</p><p>黄色框是rflags标志位的判断</p><p>红色框是计算<code>x-y</code>的rflags</p><p><img src="https://bbs.kanxue.com/upload/attach/202301/907036_W7SVSEBDSZDH58H.jpg" alt="vasm_du_jcf"></p><p>一个<code>and x, x</code>，判断是否为0的例子</p><p>绿框是上一步的跳转地址计算</p><p>黄框是判断其ZF位</p><p>红框是读取内存，然后获取其<code>and x, x</code>的rflags，没识别到</p><p><img src="https://bbs.kanxue.com/upload/attach/202301/907036_KRKYJPTXN2VBC47.jpg" alt="vasm_du_jzf_nn"></p><h3 id="2-2-5-控制流还原杂谈"><a href="#2-2-5-控制流还原杂谈" class="headerlink" title="2.2.5 控制流还原杂谈"></a>2.2.5 控制流还原杂谈</h3><p>在前面Handler语义识别的时候，难免会有错漏，出现识别不了的语句</p><p>在模拟执行还原控制流时，妥协做法是停止该分支的分析</p><p>这里截取了一段控制流</p><p>每个圈圈是一个虚拟指令基本块</p><p>这里绿色箭头的是前面<code>flag=1</code>分支、红色箭头是前面<code>flag=0</code>的分支</p><p>红色圈圈的是遇到未知虚拟指令或模拟执行错误，停止分析的块</p><p><img src="https://bbs.kanxue.com/upload/attach/202301/907036_4X6BDFWVHKN5D5A.jpg" alt="vasm_bb"></p><h2 id="2-3-还原成C（做的不太好）"><a href="#2-3-还原成C（做的不太好）" class="headerlink" title="2.3 还原成C（做的不太好）"></a>2.3 还原成C（做的不太好）</h2><p>这一步随便水水了，只做了一部分，主要工作量太大了</p><p>将虚拟指令输出成对应的C语言代码，然后上编译器编译</p><p>给个加法的例子吧：</p><p><img src="https://bbs.kanxue.com/upload/attach/202301/907036_YBZ3YHGDBQXGYQP.jpg" alt="vasm_c_compile"></p><h1 id="3-结尾（欢迎指教）"><a href="#3-结尾（欢迎指教）" class="headerlink" title="3 结尾（欢迎指教）"></a>3 结尾（欢迎指教）</h1><h2 id="3-1-收获"><a href="#3-1-收获" class="headerlink" title="3.1 收获"></a>3.1 收获</h2><p>比较喜欢写代码吧，vmp代码还原的自动化又是个需要写很多代码的工程，就比较感兴趣，断断续续大学花了不少时间在这上面</p><p>最大的收获是经验吧，写的时候花了很多时间在debug上，实际写的时间根本没多少</p><p>我也明白，先设计好再写代码可以减少很多写代码和debug的时间，但缺乏还原经验，设计的时候无从入手，也考虑不周全，只能边写边想</p><p>算是积累了一些经验吧</p><p>然后实践了一下编译原理的入门知识，一个非常有意思的领域，希望以后有机会继续深入学习下去吧</p><h2 id="3-2-关于分析深度和还原难度"><a href="#3-2-关于分析深度和还原难度" class="headerlink" title="3.2 关于分析深度和还原难度"></a>3.2 关于分析深度和还原难度</h2><p>在还原的过程中，我发现对虚拟机架构的分析越多，获得更多关于壳的信息，就能写出更容易实现、更有针对性、更有效果的优化</p><p>有点类似窥孔优化的思路，牺牲通用性，以便实现和提高效果</p><h1 id="4-相关链接"><a href="#4-相关链接" class="headerlink" title="4 相关链接"></a>4 相关链接</h1><p>VMP架构与虚拟机指令：</p><p><a href="https://back.engineering/17/05/2021/#vm-handlers-specifications">VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture // Back Engineering</a></p><p>虚拟机分支分析：</p><p>[<a href="https://bbs.kanxue.com/thread-254445.htm">分享]VMP学习笔记之万用门（七）-加壳脱壳-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p><p><a href="https://bbs.kanxue.com/thread-274637.htm">vmp3.5模拟x86分支指令je、jne、jge和jl的分析-软件逆向-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p><p>编译原理（哪本书不记得了）：</p><ul><li>基本块的有向无环图表示</li><li>DU链</li></ul><p>加密与解密</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Re/">Re</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/vmp/">vmp</category>
      
      
      <comments>https://windgodm.github.io/blog/post/VMP-deobf.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Last Branch Record</title>
      <link>https://windgodm.github.io/blog/post/LBR.html</link>
      <guid>https://windgodm.github.io/blog/post/LBR.html</guid>
      <pubDate>Tue, 10 Jan 2023 04:00:00 GMT</pubDate>
      
      <description>Last Branch Record笔记</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Last-branch-record"><a href="#Last-branch-record" class="headerlink" title="Last branch record"></a>Last branch record</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>记录CPU产出的跳转指令，包括call、ret、jmp、中断、异常</p><p>当跳转发生时，会记录跳转指令地址（from）和目的地址（to）</p><p><strong>IA32_DEBUGCTL MSR</strong>位于01D9H</p><p>flag：</p><ul><li><strong>LBR (last branch/interrupt/exception) flag (bit 0)</strong><ul><li>设置该位后，开始记录最近的分支、中断、异常到LBR Stack</li></ul></li></ul><p>LBR Stack：由n对msr寄存器组成</p><p>LBR Top-of-Stack（TOS）Pointer：指示LBR Stack的栈顶</p><h2 id="文档书签"><a href="#文档书签" class="headerlink" title="文档书签"></a>文档书签</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>sdm-vol3</p><p>17.4 是概览</p><p>17.4.1 中提到LBR Stack的细节参考 17.5.1、17.9.1（分别对应不同处理器）</p><p>17.9 关于Nehalem微架构</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>不同处理器的LBR栈大小：</p><p>sdm-vol-17.4.8 LBR Stack</p><p>Table 17-4. LBR Stack Size and TOS Pointer Range</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>不同架构的相关寄存器定义：</p><p>sdm-vol4-2.8，Nehalem微架构，寄存器位置：</p><ul><li><strong>IA32_DEBUGCTL</strong> 1D9H</li><li><strong>MSR_LASTBRANCH_TOS</strong> 1C9H</li><li><strong>MSR_LASTBRANCH_N_FROM_IP</strong><ul><li>680H~68FH，16个</li><li><strong>MSR_LASTBRANCH_0_FROM_IP</strong> 680H</li></ul></li><li><strong>MSR_LASTBRANCH_N_TO_IP</strong><ul><li>6C0H~6CFH，16个</li><li><strong>MSR_LASTBRANCH_0_TO_IP</strong> 6C0H</li></ul></li></ul><p>sdm-vol4-2.22，P6 Family</p><ul><li><strong>DEBUGCTLMSR</strong> 1D9H</li><li><strong>LASTBRANCHFROMIP</strong> 1DBH</li><li><strong>LASTBRANCHTOIP</strong> 1DCH</li></ul></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Nehalem微架构，遍历大小为16的LBR栈：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">unsigned long long fromips[16];unsigned long long toips[16];for (int i &#x3D; 0; i &lt; 16; i++)    fromips[i] &#x3D; __readmsr(0x680 + i);for (int i &#x3D; 0; i &lt; 16; i++)    toips[i] &#x3D; __readmsr(0x6C0 + i);</code></pre><p>Nehalem微架构，获取最近的分支记录：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">tos &#x3D; _rdmsr[0x1C9]; &#x2F;&#x2F; MSR_LASTBRANCH_TOSlast_from_ip &#x3D; _rdmsr[0x680+tos]; &#x2F;&#x2F; MSR_LASTBRANCH_0_FROM_IP + TOSlast_to_ip &#x3D; _rdmsr[0x6C0+tos]; &#x2F;&#x2F; MSR_LASTBRANCH_0_TO_IP + TOS</code></pre><p>Family 6 获取最近的分支记录：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">last_from_ip &#x3D; _rdmsr[0x1DB]; &#x2F;&#x2F; LASTBRANCHFROMIPlast_to_ip &#x3D; _rdmsr[0x1DC]; &#x2F;&#x2F; LASTBRANCHTOIP</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_45030965/article/details/123716348">Intel x86_64 LBR &amp; BTS功能_小立爱学习的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_45030965/article/details/124167465">再谈Intel x86_64 LBR功能_小立爱学习的博客-CSDN博客</a></p><p>(v77)325384-sdm-vol3</p><p>(v77)325384-sdm-vol4</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/kernel/">kernel</category>
      
      
      <comments>https://windgodm.github.io/blog/post/LBR.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>angr-ctf</title>
      <link>https://windgodm.github.io/blog/post/angr-ctf.html</link>
      <guid>https://windgodm.github.io/blog/post/angr-ctf.html</guid>
      <pubDate>Thu, 27 Oct 2022 04:00:00 GMT</pubDate>
      
      <description>angr_ctf题解</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="angr-ctf"><a href="#angr-ctf" class="headerlink" title="angr_ctf"></a>angr_ctf</h1><p><a href="https://github.com/jakespringer/angr_ctf">jakespringer/angr_ctf (github.com)</a></p><p><a href="http://angr.oregonctf.org/">angr CTF (oregonctf.org)</a></p><p><a href="https://www.bilibili.com/video/BV167411o7WK/">angr符号执行练习 00_angr_find_哔哩哔哩_bilibili</a></p><p><a href="https://www.mrskye.cn/archives/74204420/">angr 学习 | SkYe231 Blog (mrskye.cn)</a></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>（给出每个level新增或目标知识点）</p><ul><li><p>00 find</p></li><li><p>01 avoid</p></li><li><p>02 find condition</p></li><li><p>03 symbolic registers</p><ul><li>指定开始地址</li><li>使用 symbolic bitvector</li><li>给 寄存器 赋 BVS</li></ul></li><li><p>04 symbolic stack</p><ul><li>模拟栈空间</li><li>push BVS 到栈上</li></ul></li><li><p>05 symbolic memory</p><ul><li>给内存赋 BVS</li><li>字符串转换</li></ul></li><li><p>06 symbolic dynamic memory</p><ul><li>简单假内存分配</li></ul></li><li><p>07 symbolic file</p><ul><li>构造 symbolic file，用BVS作为数据流</li></ul></li><li><p>08 constraints</p><ul><li>剪枝的思路</li><li>添加约束</li></ul></li><li><p>09 hooks</p><ul><li>hook 地址（调用位置）</li></ul></li><li><p>10 simprocedures</p><ul><li>hook 符号</li></ul></li><li><p>11 sim scanf</p><ul><li>global插件</li></ul></li><li><p>12 veritesting</p></li><li><p>13 static binary</p><ul><li>使用Angr预先写好的SimProcedures</li></ul></li><li><p>14 shared library</p></li></ul><p>00-05<br>06-09<br>10-14</p><h2 id="00-find"><a href="#00-find" class="headerlink" title="00 find"></a>00 find</h2><p>L52填的是<code>call puts</code>的地址，这是我们想到达的位置</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L35path_to_binary &#x3D; &quot;00_angr_find&quot;  # :string# L52print_good_address &#x3D; 0x08048694  # :integer (probably in hexadecimal)</code></pre><p>F5得到<code>b&#39;JXWVXRKX&#39;</code></p><h2 id="01-avoid"><a href="#01-avoid" class="headerlink" title="01 avoid"></a>01 avoid</h2><p>也是找到<code>puts(&quot;Good Job.&quot;)</code>的位置，在函数<code>maybe_good</code>中</p><p>同时<code>avoid_me()</code>这个函数名字就告诉我们是要避免的分支，这个函数会导致一定失败，添加avoid这个函数加速搜索</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L16-18print_good_address &#x3D; 0x080485E5will_not_succeed_address &#x3D; 0x080485A8simulation.explore(find&#x3D;print_good_address, avoid&#x3D;will_not_succeed_address)</code></pre><p>F5得到<code>b&#39;HUJOZMYS&#39;</code></p><h2 id="02-find-condition"><a href="#02-find-condition" class="headerlink" title="02 find condition"></a>02 find condition</h2><p>之前是知道<code>puts(&quot;Good Job.&quot;)</code>的位置，这次假设不知道地址，只知道有这个输出</p><p>（准确的说，之前是找达到<code>call puts</code>的状态；这次是找到标准输出为<code>Good Job.</code>的状态）</p><p>需要注意的是，<code>stdout_output</code>类型是<code>bytes</code>，另外输出里还包括输入提示等字符串</p><p>所以需要用<code>encode</code>和<code>in</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L24-30def is_successful(state):    stdout_output &#x3D; state.posix.dumps(sys.stdout.fileno())return &quot;Good Job.&quot;.encode() in stdout_output  # :boolean# L36-38def should_abort(state):    stdout_output &#x3D; state.posix.dumps(sys.stdout.fileno())    return &quot;Try again.&quot;.encode() in stdout_output  # :boolean</code></pre><p>F5得到<code>b&#39;HETOBRCU&#39;</code></p><h2 id="03-symbolic-registers"><a href="#03-symbolic-registers" class="headerlink" title="03 symbolic registers"></a>03 symbolic registers</h2><p>Angr 目前不支持用 scanf 读取多个东西（例如：<code>scanf(&quot;%u %u)</code>）在调用 scanf 之后，您必须告诉模拟引擎开始程序，并手动将符号注入寄存器。</p><p>应该在scanf以后开始</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L17-18start_address &#x3D; 0x08048980  # :integer (probably hexadecimal)initial_state &#x3D; project.factory.blank_state(addr&#x3D;start_address)</code></pre><p>创建 symbolic bitvector</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L28-33password0_size_in_bits &#x3D; 32  # :integerpassword0 &#x3D; claripy.BVS(&#39;password0&#39;, password0_size_in_bits)password1_size_in_bits &#x3D; 32  # :integerpassword1 &#x3D; claripy.BVS(&#39;password1&#39;, password1_size_in_bits)password2_size_in_bits &#x3D; 32  # :integerpassword2 &#x3D; claripy.BVS(&#39;password2&#39;, password2_size_in_bits)</code></pre><p>设置寄存器为符号值</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L48-50initial_state.regs.eax &#x3D; password0initial_state.regs.ebx &#x3D; password1initial_state.regs.edx &#x3D; password2</code></pre><p>求解</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L72-74solution0 &#x3D; solution_state.se.eval(password0)solution1 &#x3D; solution_state.se.eval(password1)solution2 &#x3D; solution_state.se.eval(password2)</code></pre><p>F5得到<code>0xB9FFD04E 0xCCF63FE8 0x8FD4D959</code></p><h2 id="04-symbolic-stack"><a href="#04-symbolic-stack" class="headerlink" title="04 symbolic stack"></a>04 symbolic stack</h2><p>同样是再scanf之后开始，这次scanf的内容被存在栈上</p><p>scanf的调用约定是<code>_cdecl</code>，由调用者传参，所以在调用者平衡栈以后再开始</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L41start_address &#x3D; 0x08048697</code></pre><p>地址最高（最接近ebp）的局部变量0xC，size为4字节</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L121padding_length_in_bytes &#x3D; 0xC - 4  # :integer</code></pre><p>理论上var_C先于var_10被分配到栈上（高地址、接近ebp先分配）</p><p>调用scanf时，var_C的地址后入栈，函数参数从右到左入栈，所以var_C对应第一个参数pw0</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L132-133initial_state.stack_push(password0)  # :bitvector (claripy.BVS, claripy.BVV, claripy.BV)initial_state.stack_push(password1)</code></pre><p>F5：<code>1704280884 2382341151</code></p><h2 id="05-symbolic-memory"><a href="#05-symbolic-memory" class="headerlink" title="05 symbolic memory"></a>05 symbolic memory</h2><p>将BVS赋值到内存（angr memory.store默认大端序，需要手动指定为小端序）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L24-25password0_address &#x3D; 0x0A1BA1C0initial_state.memory.store(password0_address, password0， endness&#x3D;project.arch.memory_endness)</code></pre><p><strong>bug</strong></p><p>因为python2中str就是字节流，python3中不一样，删掉<code>cast_to=str</code>否则会报错</p><p>需要从 int 转 bytes 转 str</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L49-50# solution0 &#x3D; solution_state.se.eval(password0,cast_to&#x3D;str)solution0 &#x3D; int.to_bytes(solution_state.se.eval(password0), 8, &#39;little&#39;).decode(&quot;utf-8&quot;)</code></pre><h2 id="06-symbolic-dynamic-memory"><a href="#06-symbolic-dynamic-memory" class="headerlink" title="06 symbolic dynamic memory"></a>06 symbolic dynamic memory</h2><p>将BVS赋值到动态分配的内存</p><p>这里提示到上节的问题，Angr默认使用大端序，需要手动指示使用内存序（<code>endness=project.arch.memory_endness</code>），x86的内存序就是小端序</p><p>第一步：填充假堆地址（与05相比多出来的一步）</p><p>fake_heap_address0是在紧挨着<code>extern</code>段之后的位置</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L27-30fake_heap_address0 &#x3D; 0xABCC8E0pointer_to_malloc_memory_address0 &#x3D; 0x0ABCC8A4initial_state.memory.store(0x0ABCC8A4, fake_heap_address0, endness&#x3D;project.arch.memory_endness)initial_state.memory.store(0x0ABCC8AC, fake_heap_address0 + 8, endness&#x3D;project.arch.memory_endness)</code></pre><p>第二步：填充假输入</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L35-36initial_state.memory.store(fake_heap_address0, password0, endness&#x3D;project.arch.memory_endness)initial_state.memory.store(fake_heap_address0 + 8, password1, endness&#x3D;project.arch.memory_endness)</code></pre><p>F5<code>UBDKLMBV UNOERNYS</code></p><h2 id="07-symbolic-file"><a href="#07-symbolic-file" class="headerlink" title="07 symbolic file"></a>07 symbolic file</h2><p>题目本意是从文件中读取密码，然后判断是否正确</p><p>为了和别的题目一致，会从控制台读取代码，然后写入文件，这部分应该忽略掉。接下来的代码才是需要分析的，会读取文件并判断是否正确</p><p>显然有许多种解法，而题目本意是学习模拟文件系统，用这种方法去解决</p><p>起始地址应在<code>ignore_me</code>之后（打开文件之前）</p><p>构造<code>symbolic file</code>，用BVS作为数据流（angr.storage.SimFile是大端序）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 构造 symbolic filepassword_file &#x3D; angr.storage.SimFile(filename,file_options,content&#x3D;password,    size&#x3D;symbolic_file_size_bytes)# 写入到状态initial_state.fs.insert(filename, password_file)</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>angr 已经不支持angr.state_plugins.SimSymbolicMemory()</p><p>直接向SimFile的content提供BVS即可</p><p>同时SimFile好像不支持file_options参数了，使用会报错</p></blockquote><p>F5<code>b&#39;AZOMMMZM\x00</code>，后面还杂数据，不知道什么问题</p><h2 id="08-constraints"><a href="#08-constraints" class="headerlink" title="08 constraints"></a>08 constraints</h2><p>处理路径爆炸的问题：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define REFERENCE_PASSWORD &#x3D; &quot;AABBCCDDEEFFGGHH&quot;;int check_equals_AABBCCDDEEFFGGHH(char* to_check, size_t length) &#123;    uint32_t num_correct &#x3D; 0;    for (int i&#x3D;0; i&lt;length; ++i) &#123;        if (to_check[i] &#x3D;&#x3D; REFERENCE_PASSWORD[i]) &#123;            num_correct +&#x3D; 1;        &#125;    &#125;    return num_correct &#x3D;&#x3D; length;&#125;</code></pre><p>懒得搞了，纯大端序，最后用<code>cast_to=bytes</code>即可得到正确顺序的字符串</p><p>将explore的find改为check_equals_AABBCCDDEEFFGGHH的地址</p><p>以便在比较之前停下来</p><p>然后提取要比较的内容</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L77-81constrained_parameter_address &#x3D; 0x0804A050 # func arg1 [ebp+8]constrained_parameter_size_bytes &#x3D; 0x10 # func arg2 [ebp+Ch]constrained_parameter_bitvector &#x3D; solution_state.memory.load(    constrained_parameter_address,    constrained_parameter_size_bytes)</code></pre><p>根据提示，函数名就是比较的目标，也可以动态调试获得</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L86constrained_parameter_desired_value &#x3D; &quot;AUPDNNPROEZRJWKB&quot; # :string</code></pre><p>F5<code>b&#39;LGCRCDGJHYUNGUJB&#39;</code></p><h2 id="09-hooks"><a href="#09-hooks" class="headerlink" title="09 hooks"></a>09 hooks</h2><p>用hook技术，hook调用比较函数的地方，代替前面那个导致路径爆炸的比较函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L26check_equals_called_address &#x3D; 0x080486B3# L34-35# 需要跳过的指令长度，这里只跳过call，所以是5instruction_to_skip_length &#x3D; 5@project.hook(check_equals_called_address, length&#x3D;instruction_to_skip_length)def skip_check_equals_(state):    # L40-41    user_input_buffer_address &#x3D; 0x0804A054 # :integer, probably hexadecimal    user_input_buffer_length &#x3D; 0x10    user_input_string &#x3D; state.memory.load(        user_input_buffer_address,         user_input_buffer_length    )        # L55    # 静态分析或动态调试获得    check_against_string &#x3D; &quot;XYMKBKUHNIQYNQXE&quot; # :string    state.regs.eax &#x3D; claripy.If(        user_input_string &#x3D;&#x3D; check_against_string,         claripy.BVV(1, 32),         claripy.BVV(0, 32)    )</code></pre><p>由angr处理输入，所以直接获取标准输入流</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L89solution &#x3D; solution_state.posix.dumps(sys.stdin.fileno())</code></pre><p>F5<code>b&#39;ZXIDRXEORJOTFFJNWUFAOUBLOGLQCCGK&#39;</code></p><h2 id="10-simprocedures"><a href="#10-simprocedures" class="headerlink" title="10 simprocedures"></a>10 simprocedures</h2><p>用hook技术，这次hook函数开头，而不是调用位置</p><p>定义一个继承自<code>angr.SimProcedure</code>的类，模拟被hook函数功能：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class ReplacementCheckEquals(angr.SimProcedure):    # L62    # 与函数原型一致    def run(self, to_check, length):        # L66-67        user_input_buffer_address &#x3D; to_check        user_input_buffer_length &#x3D; length        user_input_string &#x3D; self.state.memory.load(            user_input_buffer_address,            user_input_buffer_length        )        # L76        check_against_string &#x3D; &quot;ORSDDWXHZURJRBDH&quot;        # L81        # 返回值        return claripy.If(user_input_string &#x3D;&#x3D; check_against_string, claripy.BVV(1, 32), claripy.BVV(0, 32))</code></pre><p>hook check_equals 符号。Angr自动查找与符号相关的地址。或者，你可以使用<code>hook</code>代替<code>hook_symbol</code>并指定函数的地址</p><p>通过hook_symbol，替换目标函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">check_equals_symbol &#x3D; &quot;check_equals_ORSDDWXHZURJRBDH&quot; # :stringproject.hook_symbol(check_equals_symbol, ReplacementCheckEquals())</code></pre><p>F5<code>b&#39;MSWKNJNAVTTOZMRY&#39;</code></p><h2 id="11-sim-scanf"><a href="#11-sim-scanf" class="headerlink" title="11 sim scanf"></a>11 sim scanf</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># class angr.SimProcedure, def runself.state.globals[&#39;solution0&#39;] &#x3D; scanf0self.state.globals[&#39;solution1&#39;] &#x3D; scanf1stored_solutions0 &#x3D; solution_state.globals[&#39;solution0&#39;]stored_solutions1 &#x3D; solution_state.globals[&#39;solution1&#39;]</code></pre><p>F5<code>1448564819 1398294103</code></p><h2 id="12-veritesting"><a href="#12-veritesting" class="headerlink" title="12 veritesting"></a>12 veritesting</h2><p>复制11的代码，改一下scanf的模拟函数</p><p>修改创建 simulation manager 代码，开启veritesting</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">simulation &#x3D; project.factory.simgr(initial_state, veritesting&#x3D;True)</code></pre><p>F5<code>b&#39;OQSUWYACEGIKMOQSUWYACEGIKMOQSUWY&#39;</code></p><h2 id="13-static-binary"><a href="#13-static-binary" class="headerlink" title="13 static binary"></a>13 static binary</h2><p>这个挑战与第一个挑战完全相同，只是它被编译为静态二进制文件。通常情况下，Angr会自动用工作更快的simprocedure替换标准库函数。</p><p>下面是一些SimProcedures Angr已经为你写好了。它们实现标准库函数：</p><pre class="line-numbers language-none"><code class="language-none"># angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;malloc&#39;]# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;fopen&#39;]# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;fclose&#39;]# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;fwrite&#39;]# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;getchar&#39;]# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;strncmp&#39;]# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;strcmp&#39;]# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;scanf&#39;]# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;printf&#39;]# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;puts&#39;]# angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;exit&#39;]# angr.SIM_PROCEDURES[&#39;glibc&#39;][&#39;__libc_start_main&#39;]# As a reminder, you can hook functions with something similar to:# project.hook(malloc_address, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;malloc&#39;]())</code></pre><p>更多：</p><p><a href="https://github.com/angr/angr/tree/master/angr/procedures/libc">https://github.com/angr/angr/tree/master/angr/procedures/libc</a></p><p>复制01的代码，然后添加hook：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">project.hook(0x08048D10, angr.SIM_PROCEDURES[&#39;glibc&#39;][&#39;__libc_start_main&#39;]())project.hook(0x0804ED40, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;printf&#39;]())project.hook(0x0804ED80, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;scanf&#39;]())project.hook(0x0804F350, angr.SIM_PROCEDURES[&#39;libc&#39;][&#39;puts&#39;]())</code></pre><p>F5<code>b&#39;PNMXNMUD&#39;</code></p><h2 id="14-shared-library"><a href="#14-shared-library" class="headerlink" title="14 shared library"></a>14 shared library</h2><p>符号执行so文件</p><p>设置基址：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L20-25base &#x3D; 0project &#x3D; angr.Project(path_to_binary, load_options&#x3D;&#123;     &#39;main_opts&#39; : &#123;         &#39;custom_base_addr&#39; : base     &#125; &#125;)</code></pre><p>准备从目标函数开始模拟执行，获取其状态：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L29-31password_address &#x3D; claripy.BVV(base+0x3000, 32)password &#x3D; claripy.BVS(&#39;password&#39;, 8*8)pw_size &#x3D; claripy.BVV(8, 32)# L43-45validate_function_address &#x3D; base + 0x6D7initial_state &#x3D; project.factory.call_state(validate_function_address, password_address, pw_size)initial_state.memory.store(password_address, password)</code></pre><p><strong>方案一</strong>（<code>scaffold14.py</code>）</p><p>在return前hook，添加约束</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L54-56@project.hook(base + 0x77D, length&#x3D;0)def skip_check_equals_(state):    state.add_constraints(state.regs.eax !&#x3D; 0)</code></pre><p><strong>方案二</strong>（<code>scaffold14_2.py</code>）</p><p>到达return后，添加约束</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># L57-58success_address &#x3D; base + 0x783simulation.explore(find&#x3D;success_address)# L66-67solution_state.add_constraints(solution_state.regs.eax !&#x3D; 0)solution &#x3D; solution_state.se.eval(password, cast_to&#x3D;bytes)</code></pre><p>F5<code>b&#39;PGXSNWTS&#39;</code></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/angr/">angr</category>
      
      
      <comments>https://windgodm.github.io/blog/post/angr-ctf.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SFU Compilers class 笔记6</title>
      <link>https://windgodm.github.io/blog/post/SFU-Compilers-6.html</link>
      <guid>https://windgodm.github.io/blog/post/SFU-Compilers-6.html</guid>
      <pubDate>Fri, 23 Sep 2022 04:00:00 GMT</pubDate>
      
      <description>SFU Compilers class llvm-p hw3 hw4</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="SFU-Compilers-笔记-6-语义分析和代码生成2"><a href="#SFU-Compilers-笔记-6-语义分析和代码生成2" class="headerlink" title="SFU Compilers 笔记 6 语义分析和代码生成2"></a>SFU Compilers 笔记 6 语义分析和代码生成2</h1><p>llvm-p hw3 hw4</p><h1 id="Practice-LLVM"><a href="#Practice-LLVM" class="headerlink" title="Practice LLVM"></a>Practice LLVM</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>如何在不同环境使用<code>makefile</code>：</p><ol><li>CSIL Linux机器：<code>make llvmconfig=llvm-config-12 all</code>（似乎是SFU的在线环境）</li><li>macos或其他：<code>make all</code></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载页面：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;llvm.org&#x2F;releases&#x2F;download.html</code></pre><p>wsl2直接执行以下命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">apt-get updateapt-get install clang --fix-missingapt install llvm</code></pre><h2 id="Decaf标准库"><a href="#Decaf标准库" class="headerlink" title="Decaf标准库"></a>Decaf标准库</h2><p><code>decaf-stdlib.c</code>：包含Decaf的标准库，包含print_int等函数的实现</p><p><code>decaf-stdlib-test.cpp</code>：测试用的C++程序，使用Decaf的标准库</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>编译<code>helloword.ll</code>，一个<strong>LLVM汇编</strong>写的程序：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">llvmconfig&#x3D;llvm-configlli_bin&#x3D;&#96;$llvmconfig --bindir&#96;&#x2F;lli$lli_bin helloworld.ll</code></pre><p>前两行获取lli的路径<br>第3行使用<code>lli</code> 将 LLVM汇编 编译成 可执行文件</p><h2 id="使用Decaf的库函数"><a href="#使用Decaf的库函数" class="headerlink" title="使用Decaf的库函数"></a>使用Decaf的库函数</h2><p>编译<code>add.ll</code>，并使用Decaf的库函数：<br>（以下命令在<code>run-llvm-code.sh</code>中，makefile中也有）</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">llvmconfig&#x3D;llvm-config&#96;$llvmconfig --bindir&#96;&#x2F;llvm-as add.ll  # convert LLVM assembly to bitcode&#96;$llvmconfig --bindir&#96;&#x2F;llc add.bc   # convert LLVM bitcode to x86 assemblyclang add.s decaf-stdlib.c -o add </code></pre><p>第2行使用LLVM的 <code>llvm-as</code> 将 LLVM汇编 转成 LLVM字节码<br>第3行使用LLVM的 <code>llc</code> 将 字节码 转成 x86汇编<br>第4行使用 <code>clang</code> 将 汇编 转成 机器码（也就是“汇编”）</p><p>递归版加法函数，对应python如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def rec_add(a, b):    if a &#x3D;&#x3D; 0:        return b    else:        return rec_add(a-1, b+1)</code></pre><p>给出了框架：</p><pre class="line-numbers language-none"><code class="language-none">define i32 @add2(i32 %a, i32 %b) &#123;entry:  %tmp1 &#x3D; icmp eq i32 %a, 0  br i1 %tmp1, label %done, label %recurserecurse:  ; insert LLVM assembly here  done:  ; insert LLVM assembly here&#125;</code></pre><p><code>rec_add.ll</code>中是参考答案</p><h2 id="简单递归"><a href="#简单递归" class="headerlink" title="简单递归"></a>简单递归</h2><p>用LLVM汇编实现阶乘，参考答案在<code>factorial.ll</code></p><h2 id="LLVM-C-API-简介"><a href="#LLVM-C-API-简介" class="headerlink" title="LLVM C++ API 简介"></a>LLVM C++ API 简介</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>常用头文件：</p><pre class="line-numbers language-none"><code class="language-none">llvm&#x2F;IR&#x2F;DerivedTypes.hllvm&#x2F;IR&#x2F;LLVMContext.hllvm&#x2F;IR&#x2F;Module.hllvm&#x2F;IR&#x2F;Type.hllvm&#x2F;IR&#x2F;Verifier.hllvm&#x2F;IR&#x2F;IRBuilder.h</code></pre><p><code>IRBuilder.h</code>：包含构建 Decaf 编译器所需的几乎所有功能，返回值都是<code>llvm::Value</code></p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; this global variable contains all the generated codestatic llvm::Module *TheModule;static llvm::LLVMContext TheContext;&#x2F;&#x2F; this is the method used to construct the LLVM intermediate code (IR)static llvm::IRBuilder&lt;&gt; Builder(TheContext);</code></pre><p>生成LLVM汇编：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">TheModule-&gt;print(llvm::errs(), nullptr);</code></pre><h3 id="LLVM-Value"><a href="#LLVM-Value" class="headerlink" title="LLVM::Value"></a>LLVM::Value</h3><p>LLVM 中的几乎所有内容，包括类型、常量、函数等，都派生自基类<code>llvm::Value</code></p><h3 id="LLVM-Type"><a href="#LLVM-Type" class="headerlink" title="LLVM::Type"></a>LLVM::Type</h3><table><thead><tr><th>类型</th><th><code>llvm::Type*</code></th><th>解释</th></tr></thead><tbody><tr><td>void</td><td>Builder.getVoidTy()</td><td>just a void type</td></tr><tr><td>int</td><td>Builder.getInt32Ty()</td><td>assume 32 bit integers</td></tr><tr><td>bool</td><td>Builder.getInt1Ty()</td><td>a one bit integer</td></tr><tr><td>string</td><td>Builder.getInt8PtrTy()</td><td>pointer to array of bytes (int8)</td></tr></tbody></table><p>helper函数，为每种 Decaf 类型返回正确的 LLVM 类型：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum &#123; voidTy, intTy, boolTy, stringTy, &#125; decafType;llvm::Type *getLLVMType(decafType ty) &#123;     switch (ty) &#123;        case voidTy: return Builder.getVoidTy();        case intTy: return Builder.getInt32Ty();        case boolTy: return Builder.getInt1Ty();        case stringTy: return Builder.getInt8PtrTy(); default: throw runtime_error(&quot;unknown type&quot;);    &#125; &#125;</code></pre><h3 id="LLVM-Constant"><a href="#LLVM-Constant" class="headerlink" title="LLVM::Constant"></a>LLVM::Constant</h3><p>初始化为0的常量</p><table><thead><tr><th>类型</th><th>代码</th></tr></thead><tbody><tr><td>int32</td><td>Builder.getInt32(0)</td></tr><tr><td>bool</td><td>Builder.getInt1(0)</td></tr></tbody></table><h3 id="栈上存储"><a href="#栈上存储" class="headerlink" title="栈上存储"></a>栈上存储</h3><p>使用栈存储一些对象，比如变量、函数调用参数等（堆需要分配）</p><p>以下API创建一个新位置，返回指向该位置的指针：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; llvm::Type* TYPEllvm::AllocaInst *Alloca &#x3D; Builder.CreateAlloca(TYPE, 0, NAME);</code></pre><p>使用示例，在栈上创建一个32位整数：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">llvm::AllocaInst *Alloca;&#x2F;&#x2F; unlike CreateEntryBlockAlloca the following will&#x2F;&#x2F; create the alloca instr at the current insertion point &#x2F;&#x2F; rather than at the start of the blockAlloca &#x3D; llvm::Builder.CreateAlloca(llvm::IntegerType::get(TheContext, 32), 0, &quot;variable_name&quot;);</code></pre><p>当你想给这个位置赋值时，你可以使用<code>Alloca-&gt;getType()</code>访问指向类型 TYPE 的指针</p><p>给变量赋值（lvalue = rvalue）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 获取rvalue的指针的类型const llvm::PointerType *ptrTy &#x3D; rvalue-&gt;getType()-&gt;getPointerTo();&#x2F;&#x2F; 检查lvalue和rvalue的类型是否相等（检查两者的指针）ptrTy &#x3D;&#x3D; Alloca-&gt;getType()&#x2F;&#x2F; 赋值llvm::Value *val &#x3D; Builder.CreateStore(rvalue, Alloca);</code></pre><p>（Alloca是左值的指针，这里相当于检查<code>type(&amp;rvalue)==type(Alloca)</code>）</p><h3 id="算术和布尔运算"><a href="#算术和布尔运算" class="headerlink" title="算术和布尔运算"></a>算术和布尔运算</h3><p>比如加法是<code>Builder.CreateAdd</code></p><p>略</p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>函数定义：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">llvm::Type *returnTy;&#x2F;&#x2F; assign the correct Type to returnTystd::vector&lt;llvm::Type *&gt; args;&#x2F;&#x2F; fill up the args vector with typesllvm::Function *func &#x3D; llvm::Function::Create(    llvm::FunctionType::get(returnTy, args, false),    llvm::Function::ExternalLinkage,    Name,    TheModule);</code></pre><p>创建一个基本块来保存函数中的指令：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Create a new basic block which contains a sequence of LLVM instructionsllvm::BasicBlock *BB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;entry&quot;, func);&#x2F;&#x2F; insert &quot;entry&quot; into symbol table (not used in HW3 but useful in HW4)&#x2F;&#x2F; All subsequent calls to IRBuilder will place instructions in this locationBuilder.SetInsertPoint(BB);</code></pre><p>为函数生成代码时需要：</p><ol><li>为局部变量创建一个新的符号表</li><li>创建一个基本块<code>BB</code></li><li><code>Builder.SetInsertPoint(BB)</code></li><li>使用<code>arg_iterator</code>遍历函数参数，并在栈上分配空间</li></ol><p>一个参数的写法：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string name &#x3D; string(&quot;a&quot;);llvm::Function::arg_iterator AI &#x3D; func-&gt;arg_begin();AI-&gt;setName(name);llvm::AllocaInst *Alloca &#x3D; Builder.CreateAlloca(Builder.getInt32Ty(), nullptr, name.c_str());&#x2F;&#x2F; Store the initial value into the alloca.Builder.CreateStore(static_cast&lt;llvm::Value *&gt;(&amp;*AI), Alloca);&#x2F;&#x2F; Add to symbol tablesyms.enter_symtbl(name, Alloca);</code></pre><p>遍历写法：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (auto &amp;Arg : func-&gt;args()) &#123;  llvm::AllocaInst *Alloca &#x3D; CreateEntryBlockAlloca(func, Arg.getName());  &#x2F;&#x2F; Store the initial value into the alloca.  Builder.CreateStore(&amp;Arg, Alloca);  &#x2F;&#x2F; Add to symbol table  syms.enter_symtbl(Arg.getName(), Alloca);&#125;</code></pre><p>获取函数信息：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">llvm::BasicBlock *CurBB &#x3D; Builder.GetInsertBlock();&#x2F;&#x2F; gives you a link to the current basic blockllvm::Function *func &#x3D; Builder.GetInsertBlock()-&gt;getParent();&#x2F;&#x2F; gives you a pointer to the function definitionfunc-&gt;getReturnType()&#x2F;&#x2F; gives you the return type of the function</code></pre><p>返回值：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Builder.CreateRet(llvm::Value*)</code></pre><p>应该通过检测在哪个函数，然后获取其返回值类型，再赋值<br>而不是把返回值类型传递给函数的所有子AST节点<br>（参考上面的获取函数信息）</p><p>初始化返回值：</p><pre class="line-numbers language-none"><code class="language-none">typedef enum &#123; voidTy, intTy, boolTy, stringTy, &#125; decafType;llvm::Constant *getZeroInit(decafType ty) &#123;     switch (ty) &#123;        case intTy: return Builder.getInt32(0);        case boolTy: return Builder.getInt1(0);        default: throw runtime_error(&quot;unknown type&quot;);    &#125; &#125;</code></pre><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">llvm::Function *call;&#x2F;&#x2F; assign this to the pointer to the function to call, &#x2F;&#x2F; usually loaded from the symbol tablestd::vector&lt;llvm::Value *&gt; args;&#x2F;&#x2F; argvals are the values in the method call, &#x2F;&#x2F; e.g. foo(1) would have a vector of size one with value of 1 with type i32.bool isVoid &#x3D; call-&gt;getReturnType()-&gt;isVoidTy();llvm::Value *val &#x3D; Builder.CreateCall(    call,    args,    isVoid ? &quot;&quot; : &quot;calltmp&quot;);</code></pre><h3 id="类型提升-boolean"><a href="#类型提升-boolean" class="headerlink" title="类型提升 boolean"></a>类型提升 boolean</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">llvm::Value *promo &#x3D; Builder.CreateZExt(*i, Builder.getInt32Ty(), &quot;zexttmp&quot;);</code></pre><h3 id="全局字符串"><a href="#全局字符串" class="headerlink" title="全局字符串"></a>全局字符串</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">llvm::GlobalVariable *GS &#x3D; Builder.CreateGlobalString(s, &quot;globalstring&quot;);llvm::Value *stringConst &#x3D; Builder.CreateConstGEP2_32(GS-&gt;getValueType(), GS, 0, 0, &quot;cast&quot;);</code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证函数声明</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">llvm::verifyFunction(F);</code></pre><h2 id="剩下的（todo）"><a href="#剩下的（todo）" class="headerlink" title="剩下的（todo）"></a>剩下的（todo）</h2><p>需要hw3</p><p>todo</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p><strong>全局标量</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; declare a global variablellvm::GlobalVariable *Foo &#x3D; new llvm::GlobalVariable(    *TheModule,     Builder.getInt32Ty(),     false,  &#x2F;&#x2F; variable is mutable    llvm::GlobalValue::InternalLinkage,     Builder.getInt32(0),     &quot;Foo&quot;);&#x2F;&#x2F; usellvm::Value *footmp &#x3D; Builder.CreateLoad(Foo, &quot;footmp&quot;);</code></pre><p><strong>全局数组</strong></p><p>定义和标量基本一样，只是类型不同</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; array size &#x3D; 10llvm::ArrayType *arrayi32 &#x3D; llvm::ArrayType::get(Builder.getInt32Ty(), 10);&#x2F;&#x2F; zeroinitalizer: initialize array to all zeroesllvm::Constant *zeroInit &#x3D; llvm::Constant::getNullValue(arrayi32);&#x2F;&#x2F; declare a global variablellvm::GlobalVariable *Foo &#x3D; new llvm::GlobalVariable(*TheModule, arrayi32, false, llvm::GlobalValue::ExternalLinkage, zeroInit, &quot;Foo&quot;);</code></pre><p>读写</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; access Foo[8]llvm::Value *ArrayLoc &#x3D; Builder.CreateStructGEP(arrayi32, Foo, 0, &quot;arrayloc&quot;);llvm::Value *Index &#x3D; Builder.getInt32(8);llvm::Value *ArrayIndex &#x3D; Builder.CreateGEP(Builder.getInt32Ty(), ArrayLoc, Index, &quot;arrayindex&quot;);&#x2F;&#x2F; Foo[8] &#x3D; 1llvm::Value *ArrayStore &#x3D; Builder.CreateStore(Builder.getInt32(1), ArrayIndex);&#x2F;&#x2F; Value &#x3D; Foo[8]llvm::Value *Value &#x3D; Builder.CreateLoad(ArrayIndex, &quot;loadtmp&quot;);</code></pre><p>获取Array的元素的类型</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">llvm::ArrayType *arrayTy &#x3D; (llvm::ArrayType *)GV-&gt;getValueType();llvm::Type *Ty &#x3D; arrayTy-&gt;getArrayElementType();</code></pre><p>llvm::GlobalValue::InternalLinkage 和 ExternalLinkage 区别？</p><h1 id="Homework-3-Expr-Codegen"><a href="#Homework-3-Expr-Codegen" class="headerlink" title="Homework 3 Expr Codegen"></a>Homework 3 Expr Codegen</h1><p>前置条件：hw2, llvm-practice</p><p>目录：<code>decafexpr</code></p><p>修改include</p><p>修改<code>makefile</code></p><pre class="line-numbers language-none"><code class="language-none">yacclib&#x3D;yllvmlibs&#x3D;-lz -lncurses -ldl -lpthread -fcxx-exceptions</code></pre><p>改为</p><pre class="line-numbers language-none"><code class="language-none">yacclib&#x3D;mllvmlibs&#x3D;-lm -lncurses -ldl -lpthread -fcxx-exceptions</code></pre><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>目标是实现Decaf语言的变量、简单表达式和函数的代码生成器</p><p>输出是LLVM汇编，然后再编译成二进制文件</p><p>第一步是实现<code>symbol table</code></p><h2 id="任务-Step-1-符号表"><a href="#任务-Step-1-符号表" class="headerlink" title="任务 Step 1: 符号表"></a>任务 Step 1: 符号表</h2><p>实现一个符号表，跟踪 Decaf 中的变量和方法。</p><p>每个<code>symbol_table</code>对应一个基本块</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef map&lt;string, descriptor*&gt; symbol_table;typedef list&lt;symbol_table &gt; symbol_table_list;</code></pre><p>在HW2的基础上修改AST生成代码，实现符号表</p><p>目录<code>decafsym</code></p><p>ast(hw2) &gt; sym(hw3 step1)</p><pre class="line-numbers language-none"><code class="language-none">cp ..&#x2F;decafast&#x2F;answer&#x2F;default-defs.h .&#x2F;answer&#x2F;default-defs.hcp ..&#x2F;decafast&#x2F;answer&#x2F;decafast.cc .&#x2F;answer&#x2F;decafsym.cccp ..&#x2F;decafast&#x2F;answer&#x2F;decafast.lex .&#x2F;answer&#x2F;decafsym.lexcp ..&#x2F;decafast&#x2F;answer&#x2F;decafast.y .&#x2F;answer&#x2F;decafsym.y</code></pre><p>警告：</p><ul><li>class IdentifierAST<ul><li>成员Name暴露了</li></ul></li><li>class TypeAST<ul><li>新增了str2</li></ul></li></ul><p>妈的不做<code>decafsym</code>了：</p><ul><li>func(a int, b int)，他的顺序和我相反，懒得搞</li><li>要在每次use后面加注释，输出定义在哪行，好麻烦</li></ul><h2 id="任务-Step-2"><a href="#任务-Step-2" class="headerlink" title="任务 Step 2:"></a>任务 Step 2:</h2><p>为以下 Decaf 片段提供代码生成器：</p><ul><li>算术和布尔表达式<ul><li>警告：不要尝试将此作业的布尔表达式短路。</li></ul></li><li>函数调用</li><li>函数定义（包括递归函数）</li><li>外部函数（<code>extern func</code>）的声明（所有外部函数都在 decaf-stdlib.c 中定义）</li></ul><p>不要为字段（<code>field</code>）声明，即全局变量生成代码</p><p>sym(hw3 step1) &gt; expr(hw3 step2)</p><pre class="line-numbers language-none"><code class="language-none">cp ..&#x2F;..&#x2F;decafsym&#x2F;answer&#x2F;default-defs.h .&#x2F;default-defs.hcp ..&#x2F;..&#x2F;decafsym&#x2F;answer&#x2F;decafsym.cc .&#x2F;decafexpr.cccp ..&#x2F;..&#x2F;decafsym&#x2F;answer&#x2F;decafsym.lex .&#x2F;decafexpr.lexcp ..&#x2F;..&#x2F;decafsym&#x2F;answer&#x2F;decafsym.y .&#x2F;decafexpr.y</code></pre><p><strong>定义域</strong></p><p>decaf中什么时候会enter_scope（带*表示已经在Codegen中写好）</p><ul><li>program（root）*</li><li>package *</li><li>method_block *</li><li>block</li></ul><p><strong>Warning</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class BinaryOpASTpublic: enum BINARYOP Op;class UnaryOpASTpublic: int Op;class decafStmtListpublic: list&lt;decafAST *&gt; stmts;class TypeAST    public: int Type;tryCast 返回值可能为null？，调用该函数的地方并没有检测    class VariableExprAST    总是解引用class Method    总是在最后添加默认return</code></pre><p><strong>一元二元运算</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Value *L &#x3D; LHS-&gt;Codegen();Value *R &#x3D; RHS-&gt;Codegen();return Builder.CreateAdd(L, R, &quot;addtmp&quot;);</code></pre><p>除法</p><ul><li>SDIV：signed </li><li>UDIV：unsigned</li><li>FDIV：float</li></ul><p>一元操作</p><ul><li>Neg：一元减</li><li>Not：一元非</li></ul><p><strong>测试</strong></p><pre class="line-numbers language-none"><code class="language-none">clearrm decafexprmake decafexprcd ..&#x2F;python3 zipout.py -r decafexprpython3 check.py -l log.txt</code></pre><pre class="line-numbers language-none"><code class="language-none">rm decafexpr; make decafexpr.&#x2F;decafexpr &lt; ..&#x2F;testcases&#x2F;dev&#x2F;and.decaf</code></pre><h1 id="Homework-4-Decaf-Compiler"><a href="#Homework-4-Decaf-Compiler" class="headerlink" title="Homework 4 Decaf Compiler"></a>Homework 4 Decaf Compiler</h1><p>前置条件：hw3</p><p>目录：<code>decafcomp</code></p><p>复制<code>decafexpr</code>(hw3)为<code>decafcommp</code>(hw4)：</p><pre class="line-numbers language-none"><code class="language-none">cp ..&#x2F;..&#x2F;decafexpr&#x2F;answer&#x2F;decafexpr.cc .&#x2F;decafcomp.cccp ..&#x2F;..&#x2F;decafexpr&#x2F;answer&#x2F;decafexpr.lex .&#x2F;decafcomp.lexcp ..&#x2F;..&#x2F;decafexpr&#x2F;answer&#x2F;decafexpr.y .&#x2F;decafcomp.y</code></pre><p>并修改include</p><p>修改<code>makefile</code></p><pre class="line-numbers language-none"><code class="language-none">yacclib&#x3D;yllvmlibs&#x3D;-lz -lncurses -ldl -lpthread -fcxx-exceptions</code></pre><p>改为</p><pre class="line-numbers language-none"><code class="language-none">yacclib&#x3D;mllvmlibs&#x3D;-lm -lncurses -ldl -lpthread -fcxx-exceptions</code></pre><h2 id="挑战-1"><a href="#挑战-1" class="headerlink" title="挑战"></a>挑战</h2><p>写一个完整的Decaf语言编译器</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p><strong>warning</strong></p><pre class="line-numbers language-none"><code class="language-none">VariableExprAST没有做类型检查因为tAllocaInst和tGlobalVariable都是Builder.CreateLoad(Val)class FieldSizeAST    public: int Size;</code></pre><h3 id="Step-1-Global-Variables"><a href="#Step-1-Global-Variables" class="headerlink" title="Step 1: Global Variables"></a>Step 1: Global Variables</h3><p>即field variables</p><p>全局变量的定义：FieldDeclAST、AssignGlobalVarAST</p><p>数组：（右值）ArrayLocExprAST、（左值）AssignArrayLocAST</p><h3 id="Step-2-Zero-initialize-all-variables"><a href="#Step-2-Zero-initialize-all-variables" class="headerlink" title="Step 2: Zero initialize all variables"></a>Step 2: Zero initialize all variables</h3><p>VarDefAST 中在定义后进行0初始化</p><h3 id="Step-3-Control-flow-and-Loops"><a href="#Step-3-Control-flow-and-Loops" class="headerlink" title="Step 3: Control flow and Loops"></a>Step 3: Control flow and Loops</h3><p>循环AST中会新建一个scope，第一个目的是便于存放BB，用于break、continue</p><p>第二个目的是Condition中可能定义新变量（我不知道decaf支不支持，给出C的例子）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">for (int i &#x3D; 0; i &lt; 10; i++) j++;</code></pre><p>下面给出对应关系</p><ul><li>IfStmtAST<ul><li>不需要</li></ul></li><li>WhileStmtAST<ul><li>loop - continue</li><li>end - break</li></ul></li><li>ForStmtAST<ul><li>next - continue</li><li>end - break</li></ul></li></ul><h3 id="Step-4-Short-Circuit"><a href="#Step-4-Short-Circuit" class="headerlink" title="Step 4: Short Circuit"></a>Step 4: Short Circuit</h3><p><strong>测试样例</strong></p><ul><li><p>skct：可以静态解决</p></li><li><p>short-circuit-bool：只能运行时解决</p></li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; skctextern func print_int(int) void;extern func print_string(string) void;package foo &#123;    func foo() bool &#123;        print_string(&quot;foo&quot;);        return(false);    &#125;    func main() int &#123;        var flag bool;        flag &#x3D; true || foo() &amp;&amp; !true;        print_int(flag);    &#125;&#125;</code></pre><p>期望输出：1</p><p>我未处理前输出：foo1</p><p><strong>分析</strong></p><p>第11行代码整理如下（优先级：非&gt;与&gt;或）：</p><pre class="line-numbers language-none"><code class="language-none">flag &#x3D; true || (foo() &amp;&amp; (!true));</code></pre><p>首先，<code>true || any == true</code>，所以flag一定为true</p><p>如果把整个表达式都执行一遍，foo()会输出<code>&quot;foo&quot;</code>，然后输出flag<code>&quot;1&quot;</code></p><p>但Short Circuit的话，会把<code>||</code>后面的短路掉，foo()不会执行</p><p><strong>短路规则</strong></p><ul><li><p><code>1 or x == 1</code>、<code>0 or x == x</code></p></li><li><p><code>0 and x == 0</code>、<code>1 and x == x</code></p></li></ul><p><strong>短路思路</strong></p><p>1 编译时短路：</p><p>根据规则，将运算替换成常量。比如将<code>true || a</code>替换为<code>true</code></p><p>判断变量是否为整数常量，并获取其布尔值：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">llvm::Value *Valllvm::ConstantInt *C;if ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(Val))) &#123;    if(C-&gt;getValue().getBoolValue()) &#123;        return Builder.getInt1(true);    &#125;&#125;</code></pre><p>可以先新建两个BB存储L、R的expr，如果优化失败，最后再合并</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto CurBB &#x3D; Builder.GetInsertBlock();auto func &#x3D; CurBB-&gt;getParent();&#x2F;&#x2F; ... (gen LBB RBB)LBB-&gt;insertInto(func, CurBB);RBB-&gt;insertInto(func, CurBB);Builder.SetInsertPoint(CurBB);return Builder.CreateOr(L, R, &quot;ortmp&quot;);</code></pre><p>2 运行时短路：</p><p>将<code>a || b</code>改写成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">if (a) &#123;res &#x3D; true;&#125; else if (b) &#123;    res &#x3D; true;&#125;if (a) &#123;res &#x3D; true;&#125; else &#123;    res &#x3D; b;&#125;</code></pre><p>将<code>a &amp;&amp; b</code>（等价<code>~(~a || ~b)</code>）改写成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">if (!a) &#123;res &#x3D; false;&#125; else if (!b) &#123;    res &#x3D; false;&#125;if (!a) &#123;res &#x3D; false;&#125; else &#123;    res &#x3D; !b;&#125;</code></pre><p>缺点：假设a、b是变量，而不是函数调用，那么这个短路显然没有必要</p><p>3 优化（仅思路）：</p><p>思路1：先尝试静态短路，再使用动态短路</p><p>思路2：只使用运行时短路，然后使用常量传播、剪枝等优化，起到静态短路的剪枝效果</p><p><strong>实现1</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (Op-&gt;Op &#x3D;&#x3D; And) &#123;    &#x2F;&#x2F; static short circuit    llvm::ConstantInt* C;    if ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(L))) &#123;        if(!C-&gt;getValue().getBoolValue()) &#123;            auto bb &#x3D; llvm::BasicBlock::Create(TheContext);            Builder.SetInsertPoint(CurBB);            return Builder.getInt1(false);        &#125;    &#125;    if ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(R))) &#123;        if(!C-&gt;getValue().getBoolValue()) &#123;            Builder.SetInsertPoint(CurBB);            return Builder.getInt1(false);        &#125;    &#125;    LBB-&gt;insertInto(func, CurBB);    RBB-&gt;insertInto(func, CurBB);    Builder.SetInsertPoint(CurBB);    return Builder.CreateAnd(L, R, &quot;andtmp&quot;);&#125;if (Op-&gt;Op &#x3D;&#x3D; Or) &#123;    &#x2F;&#x2F; static short circuit    llvm::ConstantInt* C;    if ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(L))) &#123;        if(C-&gt;getValue().getBoolValue()) &#123;            auto bb &#x3D; llvm::BasicBlock::Create(TheContext);            Builder.SetInsertPoint(CurBB);            return Builder.getInt1(true);        &#125;    &#125;    if ((C &#x3D; llvm::dyn_cast&lt;llvm::ConstantInt&gt;(R))) &#123;        if(C-&gt;getValue().getBoolValue()) &#123;            Builder.SetInsertPoint(CurBB);            return Builder.getInt1(true);        &#125;    &#125;    LBB-&gt;insertInto(func, CurBB);    RBB-&gt;insertInto(func, CurBB);    Builder.SetInsertPoint(CurBB);    return Builder.CreateOr(L, R, &quot;ortmp&quot;);&#125;</code></pre><p><strong>实现2</strong></p><p>纯运行时短路</p><p>And和Or的区别只有<code>skct BB</code>结尾的<code>CreateCondBr</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (Op-&gt;Op &#x3D;&#x3D; And) &#123;    auto CurBB &#x3D; Builder.GetInsertBlock();    auto func &#x3D; CurBB-&gt;getParent();    &#x2F;&#x2F; dynamic short circuit    auto noskctBB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;noskct&quot;, func);    auto endBB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;endskct&quot;, func);    &#x2F;&#x2F; cur (skct)    auto L &#x3D; LeftValue-&gt;Codegen();    auto LBB &#x3D; Builder.GetInsertBlock(); &#x2F;&#x2F; LeftValue codegen maybe create new BB    Builder.CreateCondBr(L, noskctBB, endBB);    &#x2F;&#x2F; noskct    Builder.SetInsertPoint(noskctBB);    auto R &#x3D; RightValue-&gt;Codegen();    auto RBB &#x3D; Builder.GetInsertBlock(); &#x2F;&#x2F; RightValue codegen maybe create new BB    Builder.CreateBr(endBB);    &#x2F;&#x2F; endskct    Builder.SetInsertPoint(endBB);    llvm::PHINode *val &#x3D; Builder.CreatePHI(Builder.getInt1Ty(), 2, &quot;phival&quot;);    val-&gt;addIncoming(L, LBB);    val-&gt;addIncoming(R, RBB);    return val;&#125;if (Op-&gt;Op &#x3D;&#x3D; Or) &#123;    auto CurBB &#x3D; Builder.GetInsertBlock();    auto func &#x3D; CurBB-&gt;getParent();    &#x2F;&#x2F; dynamic short circuit    auto noskctBB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;noskct&quot;, func);    auto endBB &#x3D; llvm::BasicBlock::Create(TheContext, &quot;endskct&quot;, func);    &#x2F;&#x2F; cur (skct)    auto L &#x3D; LeftValue-&gt;Codegen();    auto LBB &#x3D; Builder.GetInsertBlock(); &#x2F;&#x2F; LeftValue codegen maybe create new BB    Builder.CreateCondBr(L, endBB, noskctBB);    &#x2F;&#x2F; noskct    Builder.SetInsertPoint(noskctBB);    auto R &#x3D; RightValue-&gt;Codegen();    auto RBB &#x3D; Builder.GetInsertBlock(); &#x2F;&#x2F; RightValue codegen maybe create new BB    Builder.CreateBr(endBB);    &#x2F;&#x2F; endskct    Builder.SetInsertPoint(endBB);    llvm::PHINode *val &#x3D; Builder.CreatePHI(Builder.getInt1Ty(), 2, &quot;phival&quot;);    val-&gt;addIncoming(L, LBB);    val-&gt;addIncoming(R, RBB);    return val;&#125;</code></pre><h3 id="Step-5-Semantics"><a href="#Step-5-Semantics" class="headerlink" title="Step 5: Semantics"></a>Step 5: Semantics</h3><p><strong>已实现语法检查</strong></p><p>按在代码中位置排序</p><p>[序号]. “[错误信息]”（[检查位置]）： [描述]</p><ol><li>“unknown type”（getLLVMType）：未知变量类型，无法返回对应的<code>llvm::Type</code></li><li>“unknown type when zero init”（getZeroInit）：该类型不支持零初始化，只支持Int和Bool</li><li>“promoting fail”（tryCast）：类型提升错误，只支持布尔到整型</li><li>“symbol ‘“ + ident +  “‘ not find”（access_symtbl）：没有在符号表中找到</li><li>“no package definition in decaf program”（ProgramAST）：没有Package</li><li>“expect return void, but return something”（ReturnStmtAST）：返回值类型错误</li><li>“expect return something, but return void”（ReturnStmtAST）：返回值类型错误</li><li>“no found symtbl break”（BreakStmtAST）：break失败，可能不在循环语句中</li><li>“no found symtbl continue”（ContinueStmtAST）：continue失败，可能不在循环语句中</li><li>“not a valid lvalue”（AssignVarAST）：左值类型不正确，应为位置，即<code>tAllocaInst</code>或<code>tGlobalVariable</code></li><li>“lvalue is not glboal array”（AssignArrayLocAST）：左值类型不正确，应为数组<code>tGlobalArray</code></li><li>“array index should be Integer”（AssignArrayLocAST）：数组下标应为整型</li><li>“too many argments”（MethodCallAST）：传入参数多于函数定义</li><li>“unknown binary op”（BinaryExprAST）：未知二元操作</li><li>“unknown unary op”（UnaryExprAST）：未知一元操作</li><li>“rvalue is not a array”（ArrayLocExprAST）：右值类型不正确，应为数组</li><li>“array index should be Integer”（ArrayLocExprAST）：数组下标应为整型</li></ol><p><strong>忽略（不抛出运行时错误）</strong></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>该列表参考 Decaf Spec - Decaf Semantics - Type Checking</p><p><a href="http://anoopsarkar.github.io/compilers-class/decafspec.html">SFU Compilers class: Decaf Specification (anoopsarkar.github.io)</a></p></blockquote><ul><li>算术运算符操作数只能是整型</li><li>逻辑运算符操作数只能是布尔型</li><li>相等运算符操作数类型必须相同</li><li>函数参数应类似于局部变量（已实现）</li><li>与和或运算使用short circuit（已实现）</li><li>If you have multiple return statements in one block then only the first is used, but the others should still be type checked.</li><li>省略了，写不下去了</li></ul><p><strong>注意</strong></p><p><code>tGlobalVariable</code>对应全局标量，对应llvm中的标量<code>GlobalVariable</code></p><p><code>tGlobalArray</code>对应全局数组，对应llvm中的数组<code>GlobalVariable</code></p><p><strong>测试样例</strong></p><ul><li>err-bool-index：<code>x = xs[true];</code>，数组下标不能为布尔值</li><li>if-scoping：我报错的原因是BlockAST继承自MethodBlockAST</li><li>err-return-type：类型提升的问题，整型不应该能提升为布尔型</li><li>undefined-return：我把语法错误信息输出到stdout里了</li></ul><h3 id="Step-6-Error-reporting"><a href="#Step-6-Error-reporting" class="headerlink" title="Step 6: Error reporting"></a>Step 6: Error reporting</h3><p>参考Step5里面的 <strong>已实现语法检查</strong> 列表</p><h3 id="Step-7-Code-optimization-可选-（todo）"><a href="#Step-7-Code-optimization-可选-（todo）" class="headerlink" title="Step 7: Code optimization (可选)（todo）"></a>Step 7: Code optimization (可选)（todo）</h3><p>可选实施以下优化：</p><ul><li>将使用堆栈（Alloca）转为使用寄存器（mem2reg）</li><li>简单的peephole优化（instruction combining pass）</li><li>Re-associate expresssions</li><li>Eliminate common sub-expressions (GVN)</li><li>简化CFG</li></ul><p>可以使用 LLVM <code>opt</code> 工具，该工具执行上述所有优化</p><p>也可以使用 LLVM API <code>FunctionPassManager</code> 实现优化pass，<a href="https://llvm.org/docs/WritingAnLLVMPass.html">Writing an LLVM Pass — LLVM 16.0.0git documentation</a></p><h3 id="Step8-Add-source-level-debug-info-可选-（todo）"><a href="#Step8-Add-source-level-debug-info-可选-（todo）" class="headerlink" title="Step8: Add source-level debug info (可选)（todo）"></a>Step8: Add source-level debug info (可选)（todo）</h3><p>todo</p><h2 id="更正（相对于hw3）"><a href="#更正（相对于hw3）" class="headerlink" title="更正（相对于hw3）"></a>更正（相对于hw3）</h2><p>BlockAST不再继承自MethodBlockAST</p><p>MethodBlockAST不再新建scope</p><p>现有enter_scope：</p><ul><li><p>ProgramAST（root scope）</p></li><li><p>PackageAST</p></li><li><p>MethodAST（在BodyCodegen()中）</p></li><li><p>BlockAST</p></li><li><p>WhileStmtAST</p></li><li><p>ForStmtAST</p></li></ul><p>取消：</p><ul><li><p>MethodBlockAST</p></li><li><p>IfStmtAST：</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CS/">CS</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/cs/">cs</category>
      
      <category domain="https://windgodm.github.io/blog/tags/compiler/">compiler</category>
      
      
      <comments>https://windgodm.github.io/blog/post/SFU-Compilers-6.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SFU Compilers class 笔记5</title>
      <link>https://windgodm.github.io/blog/post/SFU-Compilers-5.html</link>
      <guid>https://windgodm.github.io/blog/post/SFU-Compilers-5.html</guid>
      <pubDate>Mon, 19 Sep 2022 04:00:00 GMT</pubDate>
      
      <description>SFU Compilers class week8 week9 week10 week11</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="SFU-Compilers-笔记-5-语义分析和代码生成1"><a href="#SFU-Compilers-笔记-5-语义分析和代码生成1" class="headerlink" title="SFU Compilers 笔记 5 语义分析和代码生成1"></a>SFU Compilers 笔记 5 语义分析和代码生成1</h1><p>week8 week9 week10 week11</p><h2 id="Week-8-Semantics-and-Runtime-Support"><a href="#Week-8-Semantics-and-Runtime-Support" class="headerlink" title="Week 8 Semantics and Runtime Support"></a>Week 8 Semantics and Runtime Support</h2><h3 id="SEM1-Scoping"><a href="#SEM1-Scoping" class="headerlink" title="SEM1 Scoping"></a>SEM1 Scoping</h3><p><strong>语义分析的目标</strong></p><ul><li>确保程序有明确意义</li><li>验证前面两步分析中，没有捕获的程序的属性：<ul><li>所有变量在使用前声明</li><li>在表达式中使用正确类型</li><li>函数调用具有正确的参数和返回值</li></ul></li><li>其次，可能需要收集一些信息以生成代码：<ul><li>确定每个标识符（Id）所表示的变量</li><li>构建继承层次结构的内部表示</li><li>跟踪变量的作用域（确定每行代码的域包含哪些变量）</li></ul></li></ul><p><strong>语义分析的实现</strong></p><ul><li>属性语法<ul><li>扩充语法规则，在解析期间完成语义分析</li><li>Single-pass 语义分析</li></ul></li><li>递归遍历AST树<ul><li>在解析完生成AST树后，遍历AST</li></ul></li></ul><p><strong>标识符（Name/Identifier）</strong></p><ul><li><p>相同的标识符在程序不同的位置可能指代不同的东西</p></li><li><p>比如可能是个类名、类型、或是不同的变量等</p></li></ul><p><strong>域（scope）</strong></p><ul><li>一个实体的域，指的是程序中的一组指向该实体的标识符的位置</li><li>将新变量引入域可能会隐藏旧变量</li></ul><p><strong>符号表</strong></p><ul><li>将标识符映射到描述符</li><li>语义分析时，不断更新符号表，其中包含域的信息（记录什么在域内）</li><li>典型实现：栈</li><li>基本操作：<ul><li>push scope：进入新的域</li><li>pop scope：离开域，丢弃（该域的）所有声明</li><li>insert symbol：添加新标识符到当前域（入栈）</li><li>lookup symbol：寻找某标识符的描述符（从栈顶找第一个具有相同标识符的描述符）</li></ul></li></ul><p><strong>Spaghetti Stack</strong></p><p>每个栈对应一个域</p><p>每个栈有一个指针，指向上一个域</p><p>寻址标识符时，如果遍历到栈底，则向指针指向的栈顶继续遍历</p><p><img src="E:\documents\note\md\img\SEM1-SpaghettiStack.jpg"></p><p><strong>Single/Multi-pass 编译</strong></p><ul><li>Single pass编译：<ul><li>扫描一次输入，同时完成词法、语法、语义分析和代码生成</li><li>C，C++</li></ul></li><li>Multi pass编译：<ul><li>需要多次扫描输入</li><li>Java</li></ul></li></ul><p>有些语言的定义支持Single-Pass，而有些需要Multi-pass</p><p>有些语言比如python则需要动态（在程序运行时）分析作用域</p><p><strong>Multi-pass编译器中的作用域</strong></p><ul><li>第一次遍历：解析输入，生成AST</li><li>第二次遍历：遍历AST，获取类的信息</li><li>第三次遍历：遍历AST，做语义分析和代码生成</li></ul><h3 id="Runtime-Suport"><a href="#Runtime-Suport" class="headerlink" title="Runtime Suport"></a>Runtime Suport</h3><p>Activate Tree，讲控制流受数据流影响（递归函数的例子），讲为什么函数调用要用栈</p><p>栈帧讲的有点乱（纯栈实现调用），好像和传统C的调用约定不一样（可能我没听懂，还是C的舒服）</p><p>后面讲到可以用寄存器优化调用过程（包括栈帧建立）中的变量传递</p><h3 id="sem2-Type-Systems（todo）"><a href="#sem2-Type-Systems（todo）" class="headerlink" title="sem2 Type Systems（todo）"></a>sem2 Type Systems（todo）</h3><h2 id="Week-9-Intermediate-Representation-and-SSA-Form"><a href="#Week-9-Intermediate-Representation-and-SSA-Form" class="headerlink" title="Week 9 Intermediate Representation and SSA Form"></a>Week 9 Intermediate Representation and SSA Form</h2><h3 id="IR-Intermediate-Representation"><a href="#IR-Intermediate-Representation" class="headerlink" title="IR Intermediate Representation"></a>IR Intermediate Representation</h3><p><strong>IR</strong></p><p>前端生成AST，由AST生成IR，由IR生成机器码</p><p>IR独立于编程语言和机器码</p><p>后面讲了一些IR中的概念</p><p>还有条件、循环语句在llvm中的代码思路</p><p><strong>Basic Blocks</strong></p><ul><li>基本块（只能）从第一条语句进入，以分支结束</li><li>函数调用将控制流由调用者交给被调用函数</li></ul><p><strong>Backpatching</strong></p><p>在处理分支、循环语句的时候，使用类似占位符的机制</p><p>生成一个偏移随机的jmp，待目标地址的代码生成时，再填上jmp的偏移</p><p><strong>表示</strong></p><p>通常用3地址码（op，arg1，arg2，result）</p><p>或三元组（op，arg1，arg2）（指令序号作为隐性result）</p><h3 id="SSA1-Intro-to-SSA-Form"><a href="#SSA1-Intro-to-SSA-Form" class="headerlink" title="SSA1 Intro to SSA Form"></a>SSA1 Intro to SSA Form</h3><ul><li><p>Static Single Assignment Form</p></li><li><p>对每个变量，一处定义（赋值），多处使用</p></li><li><p>优点</p><ul><li>每个变量只有一个定义，更易于数据流分析和优化</li><li>如果变量有N处使用，M处定义（对应N+M条指令），其def-use链大小为（N*M）</li><li>SSA没有降低复杂度，但在定义数量上通常是线性的</li><li>简化了寄存器分配图（reg interference graph）</li></ul></li></ul><h2 id="Week-10-Creating-SSA-Form"><a href="#Week-10-Creating-SSA-Form" class="headerlink" title="Week 10 Creating SSA Form"></a>Week 10 Creating SSA Form</h2><h3 id="SSA2-Creating-SSA-Form"><a href="#SSA2-Creating-SSA-Form" class="headerlink" title="SSA2 Creating SSA Form"></a>SSA2 Creating SSA Form</h3><p>讲如何生成 使用phi函数最少的 SSA Form的 中间代码</p><p><strong>SSA Form</strong></p><ul><li>SSA生成算法：<ul><li>原始算法，by Cytron et al. 1986（这节课讲的）</li><li>Lengauer-Tarjan（龙书讲的）</li><li>Harel</li></ul></li></ul><p><strong>转换为SSA格式</strong></p><ul><li>简单思想：在每个join point添加每个变量的phi函数</li><li>join point：指CFG中，拥有不只一个前驱的节点</li><li>phi函数：（IR中的内容），决定某个变量来源于哪一个前驱</li><li>重点：存在浪费（其实不是每个变量都需要添加）</li></ul><p><strong>支配关系（的定义）</strong></p><p>（大写字母表示CFG中的一个节点，或者BB）</p><ul><li>X 支配 Y：从起点到Y，必须经过X；换而言之，X必要的影响着Y</li><li>D(X)：X 严格支配的节点的集合</li><li>X 严格支配 Y：X 支配 Y，且 X 不等于 Y</li></ul><p><img src="E:\documents\note\md\img\SSA2-D.jpg"></p><p><strong>支配的属性</strong></p><ul><li>SSA form的最根本的属性是：变量的定义 必须支配 变量的使用：<ul><li>如果a 通过phi函数 在X中使用，则定义a的块 支配X的前驱</li><li>如果a 不通过phi函数 在X中使用，则定义a的块 支配X</li></ul></li></ul><p>重点是：a在X定义，若 X 支配 Y，在Y中可以直接使用a，不需要phi</p><p><strong>支配前沿</strong></p><ul><li>Dominance Frontier，DF(X)是任意Y的集合：<ul><li>X支配Y的前驱，X不严格支配Y</li></ul></li></ul><p>（S(X)：X的后继的集合）</p><p>简单计算DF的方法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def DominanceFrontier(X):D_X &#x3D; Dominance(X)    # 1    DF_X &#x3D; Successor(X) - D_X    # 2.1    for Y in D:        DF_X |&#x3D; Successor(Y)    # 2.2    DF_X -&#x3D; D    return DF_X</code></pre><p><img src="E:\documents\note\md\img\SSA2-DF.jpg"></p><p>动态计算DF的方法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def DominanceFrontier(X):    if X in DF:        return DF[X]        D_X &#x3D; Dominance(X)    # Local(X)    Local_X &#x3D; Successor(X) - D_X    # Up(X)    Up_X &#x3D; set()    for K in D_X:        Up_X |&#x3D; DF(K) - D_X    # DF(X)    DF_X &#x3D; Local_X | Up_X    DF[X] &#x3D; DF_X    return DF_X</code></pre><ul><li>若 X 中定义 a，DF(X) 中若使用 a，必须用phi定义一个新的a</li></ul><p>我的理解是：若 Y 属于 DF(X)，则必须用phi定义一个新的a，以供Y和Y的后继使用</p><h3 id="SSA3-Creating-SSA-Form"><a href="#SSA3-Creating-SSA-Form" class="headerlink" title="SSA3 Creating SSA Form"></a>SSA3 Creating SSA Form</h3><p>上一课的延续，举了一些计算D()、DF()、插入phi的例子</p><p><strong>转换为SSA Form</strong></p><p>支配关系是嵌套的，可以表示为一棵树</p><p>（如果A支配B、B支配C，意味着起点到C一定经过B，而起点到B又一定经过A，所以起点到C必然先经过A，然后再经过B）</p><p><img src="E:\documents\note\md\img\SSA3-DT.jpg"></p><p>转换过程（下图中DF(2) = {2}）</p><p><img src="E:\documents\note\md\img\SSA3-C2SSA.jpg"></p><h2 id="Week-11-Register-Allocation-and-Code-Optimization"><a href="#Week-11-Register-Allocation-and-Code-Optimization" class="headerlink" title="Week 11 Register Allocation and Code Optimization"></a>Week 11 Register Allocation and Code Optimization</h2><h3 id="OPT1-Register-Allocation（todo）"><a href="#OPT1-Register-Allocation（todo）" class="headerlink" title="OPT1 Register Allocation（todo）"></a>OPT1 Register Allocation（todo）</h3><pre class="line-numbers language-none"><code class="language-none">- c_def+ c_use+ l_def</code></pre><h3 id="OPT2-Spilling-in-Register-Allocation（todo）"><a href="#OPT2-Spilling-in-Register-Allocation（todo）" class="headerlink" title="OPT2 Spilling in Register Allocation（todo）"></a>OPT2 Spilling in Register Allocation（todo）</h3><p>def-&gt;store</p><p>load-&gt;use</p><p>有个可以3色的算成4色</p><h3 id="OPT3-Linear-Scan-Register-Allocation（todo）"><a href="#OPT3-Linear-Scan-Register-Allocation（todo）" class="headerlink" title="OPT3 Linear Scan Register Allocation（todo）"></a>OPT3 Linear Scan Register Allocation（todo）</h3><h3 id="OPT4-Intro-to-Code-Optimization（todo）"><a href="#OPT4-Intro-to-Code-Optimization（todo）" class="headerlink" title="OPT4 Intro to Code Optimization（todo）"></a>OPT4 Intro to Code Optimization（todo）</h3><p>advanced compiler design and implement</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CS/">CS</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/cs/">cs</category>
      
      <category domain="https://windgodm.github.io/blog/tags/compiler/">compiler</category>
      
      
      <comments>https://windgodm.github.io/blog/post/SFU-Compilers-5.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SFU Compilers class 笔记4</title>
      <link>https://windgodm.github.io/blog/post/SFU-Compilers-4.html</link>
      <guid>https://windgodm.github.io/blog/post/SFU-Compilers-4.html</guid>
      <pubDate>Fri, 29 Jul 2022 04:00:00 GMT</pubDate>
      
      <description>SFU Compilers class week7 hw2</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="SFU-Compilers-笔记-4-语法分析2"><a href="#SFU-Compilers-笔记-4-语法分析2" class="headerlink" title="SFU Compilers 笔记 4 语法分析2"></a>SFU Compilers 笔记 4 语法分析2</h1><p>week7 hw2</p><h2 id="Week-7-Syntax-Directed-Translation"><a href="#Week-7-Syntax-Directed-Translation" class="headerlink" title="Week 7 Syntax Directed Translation"></a>Week 7 Syntax Directed Translation</h2><h3 id="LR6-Syntax-Directed-Translation-for-LR-Parsers"><a href="#LR6-Syntax-Directed-Translation-for-LR-Parsers" class="headerlink" title="LR6 Syntax Directed Translation for LR Parsers"></a>LR6 Syntax Directed Translation for LR Parsers</h3><p>语法导向翻译（SDT）用于将解析树（Parse trees）转成中间代码（IR）</p><p>个人感觉实际上就是讲了yacc中的属性语法的原理和作用</p><p><strong>属性语法</strong></p><ul><li>语法导向翻译 使用语法生成代码</li><li>使用上下文无关语法（CFG）</li><li>每个语法符号与一个属性关联</li><li>属性可以是字符串、数字、树等对象</li><li>属性语法将字符串与属性关联起来</li><li>Attribute grammars are a method to decorate or annotate the parse tree with the desired output attributes<br>  我的理解是：属性语法是解析树上的“装饰器”，随解析树的生成被调用；目的是为了利用解析树，构建我们所需的输出。</li></ul><h3 id="Decaf-and-LLVM"><a href="#Decaf-and-LLVM" class="headerlink" title="Decaf and LLVM"></a>Decaf and LLVM</h3><p>主要讲LLVM的一些基础概念，感觉讲的不完全</p><p>Control Flow in LLVM hw3不需要，hw4需要</p><h2 id="Homework-2-Parser-for-Decaf"><a href="#Homework-2-Parser-for-Decaf" class="headerlink" title="Homework 2 Parser for Decaf"></a>Homework 2 Parser for Decaf</h2><p>前置条件：yacc-practice</p><p>目录：<code>decafast</code></p><p>复制<code>default</code>为<code>decafast</code>：</p><pre class="line-numbers language-none"><code class="language-none">cp default.cc decafast.cccp default.lex decafast.lexcp default.y decafast.y</code></pre><p>并修改三个文件中的<code>include</code>：</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><code>decafast.cc</code> ： <code>#include &quot;default.tab.h&quot;</code> 改为 <code>#include &quot;decafast.tab.h&quot;</code></p><p><code>decafast.lex</code> ： <code>#include &quot;default.tab.h&quot;</code> 改为 <code>#include &quot;decafast.tab.h&quot;</code>.</p><p><code>decafast.y</code> ： <code>#include &quot;default.cc&quot;</code> 改为 <code>#include &quot;decafast.cc&quot;</code></p></blockquote><p>wsl2平台下需要修改makefile：</p><p>不需要<code>yacclib=y</code>以及<code>-l$(yacclib)</code></p><p>去掉或将其改为<code>l</code>或<code>m</code></p><ul><li><p>var a, b int;</p></li><li><p>op</p></li><li><p><code>return ()</code>，AST等价于<code>return</code>，但yyparse的返回值为1</p></li><li><p>VarDecls，在statement中间有VarDecls，AST等价于将定义放在statement前面，但yyparse的返回值为1</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CS/">CS</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/cs/">cs</category>
      
      <category domain="https://windgodm.github.io/blog/tags/compiler/">compiler</category>
      
      
      <comments>https://windgodm.github.io/blog/post/SFU-Compilers-4.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>B站x64内核笔记2 PG</title>
      <link>https://windgodm.github.io/blog/post/zh-patchguard.html</link>
      <guid>https://windgodm.github.io/blog/post/zh-patchguard.html</guid>
      <pubDate>Wed, 06 Jul 2022 04:00:00 GMT</pubDate>
      
      <description>x64内核笔记2 PG</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="PatchGuard"><a href="#PatchGuard" class="headerlink" title="PatchGuard"></a>PatchGuard</h1><h2 id="Step-1-设-BigPool-不可执行"><a href="#Step-1-设-BigPool-不可执行" class="headerlink" title="Step 1 设 BigPool 不可执行"></a>Step 1 设 BigPool 不可执行</h2><p>编写一个驱动，遍历BigPool信息，将可疑的BigPool设置为不可执行，等待蓝屏</p><p>然后分析蓝屏信息得到context入口点，简要分析context入口点</p><h3 id="1-查询所有BigPool"><a href="#1-查询所有BigPool" class="headerlink" title="1 查询所有BigPool"></a>1 查询所有BigPool</h3><p>使用<code>ZwQuerySystemInformation</code>获取所有BigPool的信息</p><p><strong>细节：申请长度要比第一次查询长度大</strong></p><p>第一次查询获取长度，第二次查询获取数据。</p><p>因为第二次查询时分配的用于接收的空间也属于BigPool，也就说第二次查询时BigPool的数量可能比第一次的要多，除此以外也可能有新生成的。</p><p>关键查询代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 获取数据长度status &#x3D; ZwQuerySystemInformation(SystemBigPoolInformation, pBigPoolInfo, sizeof(SYSTEM_BIGPOOL_INFORMATION), &amp;returnLength);&#x2F;&#x2F; 申请空间pBigPoolInfo &#x3D;     (PSYSTEM_BIGPOOL_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, returnLength + 0x1000, &#39;tag&#39;);&#x2F;&#x2F; 获取数据ZwQuerySystemInformation(SystemBigPoolInformation, pBigPoolInfo, returnLength + 0x1000, &amp;returnLength);</code></pre><h3 id="2-设置BigPool不可执行（触发蓝屏）"><a href="#2-设置BigPool不可执行（触发蓝屏）" class="headerlink" title="2 设置BigPool不可执行（触发蓝屏）"></a>2 设置BigPool不可执行（触发蓝屏）</h3><p>需要获取BigPool起始地址的pte、pde，检查其属性</p><p>检查内容：</p><ul><li>BigPool长度</li><li>pde为4K页面（0x80 = 0）</li><li>pte不是noExec（64位 = 0）</li><li>pte页面存在（1位 = 1）</li></ul><p>关键判断代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (entry-&gt;SizeInBytes &gt;&#x3D; 0x8000) &#123;    if (!(pde &amp; 0x80)) &#123; &#x2F;&#x2F; 4K page        &#x2F;&#x2F; bitmap, 1:p, 64:noExec        if (((pte &amp; 0x8000000000000000) &#x3D;&#x3D; 0) &amp;&amp; (pte &amp; 1)) &#123;            &#x2F;&#x2F; 2.2 Set NoExec            count +&#x3D; 1;            KdPrint((&quot;[PG] va: 0x%llX size: 0x%X pte: 0x%llX\n&quot;, va, entry-&gt;SizeInBytes, pte));            pte |&#x3D; 0x8000000000000000;            *ppte |&#x3D; pte;        &#125;    &#125;&#125;</code></pre><p>！！！最后记得释放<code>ExFreePool(pBigPoolInfo)</code></p><h3 id="3-分析执行异常蓝屏（0xFC）"><a href="#3-分析执行异常蓝屏（0xFC）" class="headerlink" title="3 分析执行异常蓝屏（0xFC）"></a>3 分析执行异常蓝屏（0xFC）</h3><p>首先记得设置好dump，<strong>拍摄快照</strong>，然后运行驱动，2分钟左右会触发蓝屏，使用windbg分析</p><p>驱动调试信息如下：</p><pre class="line-numbers language-none"><code class="language-none">[PG] returnLength: 0x31A48[PG] returnLength: 0x31A60[PG] va: 0xFFFF8585AF113001 size: 0x6F000[PG] va: 0xFFFF8585B65AC001 size: 0x33000[PG] va: 0xFFFF8585AF182001 size: 0x43000</code></pre><p>首先驱动输出了两次查询的数据长度</p><p>然后输出了符合条件的BigPool的信息，可以看到设置了三个BigPool起始4k页面不可执行，其中第二个是BigPool信息那个数组。剩下两个可能是context。</p><p>windbg的<code>!analyze -v</code>截取结果如下：</p><pre class="line-numbers language-none"><code class="language-none">ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY (fc)Arguments:Arg1: ffff8585af1821fe, Virtual address for the attempted execute.Arg2: 8a0000000405d963, PTE contents.Arg3: fffff80105eb39e0, (reserved)Arg4: 0000000000000000, (reserved)</code></pre><p>错误为尝试执行NoExec的内存，然后看Arg1，确定就是由前面第3个被设为不可执行的BigPool触发的</p><p>反汇编该地址（顺便给出运行到该地址时的RCX、RDX）：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">rcx&#x3D;ffff8585af1821fe rdx&#x3D;51ba0dd28a51cdb8kd&gt; u ffff8585af1821feffff8585&#96;af1821fe 2e483111        xor     qword ptr cs:[rcx],rdxffff8585&#96;af182202 9a              ???ffff8585&#96;af182203 3ceb            cmp     al,0EBhffff8585&#96;af182205 59              pop     rcx</code></pre><p>这是一段自解密代码，搜索<code>1131482Eh</code>能找到其原本（这段是其加密后的副本），微软给的名称为<code>CmpAppendDllSection</code>，<code>ntoskrnl.exe</code>中的是异或加密前的内容</p><h3 id="4-调试"><a href="#4-调试" class="headerlink" title="4 调试"></a>4 调试</h3><p>恢复快照，连上windbg，迅速在刚刚Arg1的地方下一个断点，再等两分钟（这次别运行驱动，让他能够正常执行）</p><p>smc代码解密完自身以后，会解密其余部分：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ffff8585&#96;af18227d 483184cac0000000 xor     qword ptr [rdx+rcx*8+0C0h],raxffff8585&#96;af182285 48d3c8          ror     rax,clffff8585&#96;af182288 480fbbc0        btc     rax,raxffff8585&#96;af18228c e2ef            loop    ffff8585&#96;af18227d</code></pre><p>解密完其余部分后，会执行<code>call rax</code>，一般都会去到同一个函数，能在<code>ntoskrnl.exe</code>中的<code>INITKDBG</code>段搜到其原本，有人称之为PG入口点</p><p>下面是其开头的汇编，有点普通，建议往下再跟一点然后再去搜</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">kd&gt; pffff8585&#96;af18229b ffd0            call    raxkd&gt; r raxrax&#x3D;ffff8585af19c55fkd&gt; u ffff8585af19c55fffff8585&#96;af19c55f 488bc4          mov     rax,rspffff8585&#96;af19c562 48895808        mov     qword ptr [rax+8],rbxffff8585&#96;af19c566 48897018        mov     qword ptr [rax+18h],rsiffff8585&#96;af19c56a 48897820        mov     qword ptr [rax+20h],rdiffff8585&#96;af19c56e 48895010        mov     qword ptr [rax+10h],rdxffff8585&#96;af19c572 55              push    rbpffff8585&#96;af19c573 4154            push    r12ffff8585&#96;af19c575 4155            push    r13; ...ffff8585&#96;af19c5cc 740b            je      ffff8585&#96;af19c5d9ffff8585&#96;af19c5ce 448838          mov     byte ptr [rax],r15bffff8585&#96;af19c5d1 4903c4          add     rax,r12ffff8585&#96;af19c5d4 83c1ff          add     ecx,0FFFFFFFFh</code></pre><p><strong>更进一步（分析调用源）</strong></p><p>刚触发断点的时候，可以尝试栈回溯，找到调用源</p><h2 id="Step-2-接管页面异常"><a href="#Step-2-接管页面异常" class="headerlink" title="Step 2 接管页面异常"></a>Step 2 接管页面异常</h2><h3 id="1-接管页面异常"><a href="#1-接管页面异常" class="headerlink" title="1 接管页面异常"></a>1 接管页面异常</h3><p>接管页面异常，具体hook的方法八仙过海了，然后根据前面分析结果，context入口一般为<code>1131482Eh</code>这句自解密代码，以此为判断标准，决定是否接管</p><p><strong>简述页面异常</strong></p><p>处理页面异常的是0xE号中断，似乎是因为内核隔离，idt的0xE号中断对应为<code>KiPageFaultShadow</code>，这个函数只是个Stub，做切换cr3等工作，然后<code>jmp</code>（不是<code>call</code>）到<code>KiPageFault</code></p><p>所以直接hook<code>KiPageFault</code>，比较省事</p><p>给出刚进入<code>KiPageFault</code>时的栈：</p><table><thead><tr><th>rsp offset(hex)</th><th>arg</th></tr></thead><tbody><tr><td>00</td><td>error code</td></tr><tr><td>08</td><td>rip</td></tr><tr><td>10</td><td>cs</td></tr><tr><td>18</td><td>rflags</td></tr><tr><td>20</td><td>rsp（原rsp）</td></tr><tr><td>28</td><td>ss（r0触发异常一般是一样的）</td></tr><tr><td>+8</td><td>Align（保证当前rsp16位对齐）</td></tr><tr><td>+8</td><td>返回地址（原rsp指向）</td></tr></tbody></table><p><strong>判断标准</strong></p><p>前面说了，根据目前分析的结果，满足一下条件就接管：</p><ul><li><code>error code == 11h</code>（10h执行异常 + 1页面存在）</li><li><code>[rip] == 1131482Eh </code>（smc代码开头）</li></ul><p><strong>接管处理</strong></p><p>直接恢复rflags、ss、rip，然后直接return（恢复rsp后，rsp就指向原返回地址了）</p><p><strong>细节</strong></p><p>注意栈的平衡，还有寄存器的使用。如果需要用到寄存器，建议先push。然后在还原rsp前pop，还原寄存器</p><h3 id="2-加速蓝屏（由PG检查引发的）"><a href="#2-加速蓝屏（由PG检查引发的）" class="headerlink" title="2 加速蓝屏（由PG检查引发的）"></a>2 加速蓝屏（由PG检查引发的）</h3><p>Step1设置BigPool不可执行后，可能会有漏网之鱼。比如context是在Step1以后创建的；或者context原本就不在BigPool；或者Context在Step1时不可执行，执行前再设为可执行</p><p>所以需要hook关键内存（PG频繁检查的地方），让漏网之鱼检查出现异常，然后触发蓝屏</p><p>重启虚拟机，拍一个新快照：</p><ul><li>重启时不选择调试模式等，正常启动即可</li><li>用DSEFix（<a href="https://github.com/hfiref0x/DSEFix">hfiref0x/DSEFix(github.com)</a>）加载未签名驱动</li><li>设置休眠时间为从不</li><li>不要附加调试器</li><li>拍摄快照</li></ul><p>驱动新增如下功能：</p><ul><li>驱动hook memmove</li></ul><p>其中使用DSE Fix和hook memmove都会加速蓝屏（PG错误）</p><p>然后运行DSE Fix，加载驱动，等蓝屏</p><p>获取NT_Base小技巧：先按上述步骤，加载驱动后马上蓝屏，因为重启后NT_Base变了，此时可以分析蓝屏文件获取BASE、或者系统函数的地址；修复函数的地址后，再恢复快照加载驱动，等PG蓝屏</p><h3 id="3-分析PG蓝屏（0x109）"><a href="#3-分析PG蓝屏（0x109）" class="headerlink" title="3 分析PG蓝屏（0x109）"></a>3 分析PG蓝屏（0x109）</h3><p>我这里大概两分钟左右会触发蓝屏</p><p>因为非调试模式没有办法在windbg中接收驱动的调试信息，然后又懒得在虚拟机中把log信息保存成文件，这里只记录了dump文件的信息</p><p><strong>PG蓝屏</strong></p><p>windbg的<code>!analyze -v</code>截取结果如下：</p><pre class="line-numbers language-none"><code class="language-none">CRITICAL_STRUCTURE_CORRUPTION (109)Arguments:Arg1: a39feeda0d18b86d, ReservedArg2: b3b6fb605f96f9a5, ReservedArg3: fffff8072d821cc0, Failure type dependent informationArg4: 0000000000000000</code></pre><p>109错误代表由PG错误；即context被调用，然后检查出被patch，接着触发蓝屏</p><p>先看Arg3：</p><pre class="line-numbers language-none"><code class="language-none">kd&gt; u fffff8072d821cc0nt!memcpy:fffff807&#96;2d821cc0 488bc1          mov     rax,rcx</code></pre><p>Arg3是PG或者说context发现被patch的地址</p><p>正是我的驱动为了加速蓝屏所hook的memcpy，此时该函数已经被PG还原</p><p>Arg1、Arg2需要减去两个魔数：</p><pre class="line-numbers language-none"><code class="language-none">Arg1: a39feeda0d18b86d - A3A03F5891C8B4E8 &#x3D; ffffaf81&#96;7b500385Arg2: b3b6fb605f96f9a5 - B3B74BDEE4453415 &#x3D; ffffaf81&#96;7b51c590</code></pre><p>先分析解密后的Arg1：</p><pre class="line-numbers language-none"><code class="language-none">kd&gt; u ffffaf81&#96;7b500385ffffaf81&#96;7b500385 2e483111        xor     qword ptr cs:[rcx],rdxffffaf81&#96;7b500389 48315108        xor     qword ptr [rcx+8],rdxffffaf81&#96;7b50038d 48315110        xor     qword ptr [rcx+10h],rdxffffaf81&#96;7b500391 48315118        xor     qword ptr [rcx+18h],rdx</code></pre><p>Arg1是context的smc起始地址</p><p>然后截取一部分Arg2：</p><pre class="line-numbers language-none"><code class="language-none">kd&gt; dqs ffffaf81&#96;7b51c590ffffaf81&#96;7b51c590  00000000&#96;00000000ffffaf81&#96;7b51c598  fffff807&#96;2d821cc0 nt!memcpy ; 检测地址ffffaf81&#96;7b51c5a0  52802a0c&#96;000002aa ; 检测0x2aa个字节，结果为52802a0cffffaf81&#96;7b51c5a8  00000000&#96;00000001ffffaf81&#96;7b51c5b0  00000000&#96;00000000ffffaf81&#96;7b51c5b8  00000000&#96;00000000</code></pre><p>Arg2指向一个结构体数组的某一项，这个结构体数组记录了要检测的内容，此时Arg2指向数组中检查出错的那一项</p><ul><li>+8h(PVOID)：是校验的地址，对应前面的memcpy的起始地址</li><li>+10h(UINT)：是校验的长度（以校验地址为起始）</li><li>+14h(UINT)：是校验的结果</li></ul><p>PG会对校验地址处的数据执行一些运算，然后与校验结果比较判断是否被patch</p><p><strong>非Big Pool地址</strong></p><p>现在问题是Arg1所指向的地址，没有被设置为不可执行</p><p>发现不是Big Pool：</p><pre class="line-numbers language-none"><code class="language-none">kd&gt; !pool ffffaf81&#96;7b500385Pool page ffffaf817b500385 region is Unknown</code></pre><p>发现在一片<code>SystemRange</code>中：</p><pre class="line-numbers language-none"><code class="language-none">kd&gt; !address ffffaf81&#96;7b500385Usage:                  Base Address:           ffff8000&#96;00000000End Address:            ffffc20b&#96;9fa00000Region Size:            0000420b&#96;9fa00000VA Type:                SystemRange</code></pre><h3 id="4-IndependentPages"><a href="#4-IndependentPages" class="headerlink" title="4 IndependentPages"></a>4 IndependentPages</h3><p>通过资料可知有如下API可以分配、修改、释放一片内存，且该内存不在Big Pool中</p><ul><li>MmAllocateIndependentPages<ul><li>分配内存，初始属性为不可执行</li></ul></li><li>SetPageProtection<ul><li>设置内存属性</li></ul></li><li>MmFreeIndependentPages<ul><li>释放内存</li></ul></li></ul><p>通过对<code>MmAllocateIndependentPagesEx</code>交叉引用分析，可以发现该函数只被context的那个巨大函数所使用，顺便能找出一整套内存分配释放的函数，这几个函数都只被PG调用：</p><pre class="line-numbers language-none"><code class="language-none">INIT:FFFFF80103E1ED3D 48 8D 05 BC E4 D2 FF                    lea     rax, MmAllocateIndependentPagesINIT:FFFFF80103E1ED44 49 89 86 20 02 00 00                    mov     [r14+220h], raxINIT:FFFFF80103E1ED4B 48 8D 05 EE 01 D3 FF                    lea     rax, MmFreeIndependentPagesINIT:FFFFF80103E1ED52 49 89 86 28 02 00 00                    mov     [r14+228h], raxINIT:FFFFF80103E1ED59 48 8D 05 80 9F 95 FF                    lea     rax, MmSetPageProtectionINIT:FFFFF80103E1ED60 49 89 86 30 02 00 00                    mov     [r14+230h], rax</code></pre><p>网上只找到<code>MmAllocateIndependentPages</code>的定义（<a href="https://www.codewarrior.cn/ntdoc/wrk/mm/MmAllocateIndependentPages.htm">MmAllocateIndependentPages (codewarrior.cn)</a>）：</p><pre class="line-numbers language-none"><code class="language-none">PVOIDMmAllocateIndependentPages(  IN  SIZE_T NumberOfBytes,  IN  ULONG Node  );</code></pre><p>该函数分配的内存为不可执行，也就是需要调用<code>SetPageProtection</code>后才能执行</p><p>这就意味如果要拦截新生成的context，可以只hook修改属性的<code>SetPageProtection</code></p><h2 id="Step-3-设置-Ind-Page-不可执行"><a href="#Step-3-设置-Ind-Page-不可执行" class="headerlink" title="Step 3 设置 Ind. Page 不可执行"></a>Step 3 设置 Ind. Page 不可执行</h2><h3 id="1-搜索-Ind-Page"><a href="#1-搜索-Ind-Page" class="headerlink" title="1 搜索 Ind. Page"></a>1 搜索 Ind. Page</h3><p>现在先拦截已经分配了的context，思路和BigPool类似，也是找大页面，然后设第一个4k页面为不可执行</p><p>因为没有查询的API，所以只能一块一块暴力搜索，如果相邻的两块页面都是存在的，则当成是一起的，以此来判断其大小。这样可能会杀错，但不容易错过（他context总不能分开到两块不相邻的地址空间吧）</p><h3 id="1-换页问题"><a href="#1-换页问题" class="headerlink" title="1? 换页问题"></a>1? 换页问题</h3><p>不确定Ind. Page会不会被换出，换出pte.valid似乎就为0了，就会漏掉；拦截换入可能需要修改页面异常的处理</p><h3 id="2-测试结果"><a href="#2-测试结果" class="headerlink" title="2 测试结果"></a>2 测试结果</h3><p>（非调式都用了DSEfix）</p><p><strong>没VT、非调试</strong></p><p>测试了一个快照（刚开机），两个小时没错误</p><p><strong>没VT、调试</strong></p><p>换成调试模式，挂windbg，u了一下<code>MmAllocateIndependentPages</code>，全是问号，页面不存在</p><p><strong>有VT、非调试</strong></p><p>测试了一个快照（刚开机），两个小时没错误</p><p><strong>有VT、调试</strong></p><p>测试了一个快照（刚开机），1分钟左右炸了，死机，不关机也不蓝屏</p><p>详情见下面错误分析</p><h3 id="3-错误分析"><a href="#3-错误分析" class="headerlink" title="3 错误分析"></a>3 错误分析</h3><p>环境：开启VT + 调试模式<br>过1分钟左右会卡住不动，没有蓝屏、没有关机（连不连调试器都一样）</p><p>截取连调试器后，蓝屏前的log：</p><pre class="line-numbers language-none"><code class="language-none">*** Fatal System Error: 0x00000109                       (0xA3A024E0D7EF077A,0xB3B731672A6D48B2,0xFFFFF80459416CC0,0x0000000000000000)</code></pre><p>解密Arg1、2：</p><pre class="line-numbers language-none"><code class="language-none">0xA3A024E0D7EF077A - 0xA3A03F5891C8B4E8 &#x3D; 0xFFFFE588462652920xB3B731672A6D48B2 - 0xB3B74BDEE4453415 &#x3D; 0xFFFFE5884628149D0xFFFFF80459416CC0 !memcpy</code></pre><p>arg1应该是smc起始地址，离之前设为NX的bigpool很近，猜测是个bigpool，但没有被设为NX，可能搜索后分配的或者搜索后设为可执行的</p><p>（这里windbg也卡住了，没办法判断这个地址是什么）</p><p>arg3应该是校验发现被patch的地址，通过log发现是为了加速蓝屏hook的memcpy</p><h2 id="Step-4-接管内存分配、属性设置"><a href="#Step-4-接管内存分配、属性设置" class="headerlink" title="Step 4 接管内存分配、属性设置"></a>Step 4 接管内存分配、属性设置</h2><p>由上面错误可知可能是新big pool，或后来被设为可执行的</p><p>所以顺便把Big Pool的分配，Ind. Page的属性设置都hook上</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/kernel/">kernel</category>
      
      
      <comments>https://windgodm.github.io/blog/post/zh-patchguard.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>B站x64内核笔记1</title>
      <link>https://windgodm.github.io/blog/post/zh-x64krnl.html</link>
      <guid>https://windgodm.github.io/blog/post/zh-x64krnl.html</guid>
      <pubDate>Tue, 17 May 2022 04:00:00 GMT</pubDate>
      
      <description>x64内核笔记</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="IA-32e"><a href="#IA-32e" class="headerlink" title="IA_32e"></a>IA_32e</h2><p><strong>Extended Feature Enable Register（IA32_EFER，MSR[0xC0000080]）</strong></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>vol-3a p69 2.2.1 Extended Feature Enable Register</p></blockquote><p>![](E:\documents\note\md\windows\sdm-figure\vol-3a-f-2-4 IA32_EFER MSR Layout.png)<br>第8位为1 就处于IA-32e模式</p><p>[windbg]<code>rdmsr C0000080</code></p><h2 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h2><p><strong>x64 CS描述符</strong></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>vol-3a p161 5.2.1 Code-Segment Descriptor in 64-bit Mode</p></blockquote><p>![](E:\documents\note\md\windows\sdm-figure\vol-3a-f-5-2 Descriptor Fields with Flags used in IA-32e Mode.png)</p><p>第12位（S）：1=DS/CS</p><p>第11位（Type的第3位）：0=DS，1=CS</p><p>当处于IA-32e模式：</p><table><thead><tr><th>CS.D(22)</th><th>CS.L(21)</th><th>bit</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>16</td></tr><tr><td>1</td><td>0</td><td>32</td></tr><tr><td>0</td><td>1</td><td>64</td></tr><tr><td>1</td><td>1</td><td>#GP fault</td></tr></tbody></table><p><strong>gdt</strong></p><p>段选择子（清掉低3位）刚好是相对gdtr的偏移</p><p>D L(G,D,L,AVL)，DPL(P,DPL, 1) ，Type(1,C,R,A)</p><table><thead><tr><th>段选择子</th><th>index</th><th>D L</th><th>DPL</th><th>Type</th><th>Flags</th></tr></thead><tbody><tr><td>10</td><td>2</td><td>x64(0010)</td><td>R0(1001)</td><td>Code(1011)</td><td>29b</td></tr><tr><td>18</td><td>3</td><td></td><td>R0(1001)</td><td>Data(0011)</td><td>493</td></tr><tr><td>20</td><td>4</td><td>x32(1100)</td><td>R3(1111)</td><td>Code(1011)</td><td>cfb</td></tr><tr><td>28</td><td>5</td><td></td><td>R3(1111)</td><td>Data(0011)</td><td>cf3</td></tr><tr><td>30</td><td>6</td><td>x64(0010)</td><td>R3(1111)</td><td>Code(1011)</td><td>2fb</td></tr><tr><td>38</td><td>7</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr></tbody></table><p>[gdtr+0x40] = TSS</p><p><strong>对比x32的描述符</strong></p><p>cs、ds使用64位描述符，强制平坦（段描述符基址永远是0，界限永远是最大）</p><p>32位的基址、界限等信息在64位中不再保留</p><p>[windbg]<code>dq gdtr</code></p><p>[windbg]<code>dg [off]</code>：解析<code>gdtf+off</code>处的描述符（按64位解析）</p><p><strong>tss段描述符 和 tss</strong></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>vol-3a p256 7.2.3 TSS Descriptor in 64-bit mode</p></blockquote><p>![](E:\documents\note\md\windows\sdm-figure\vol-3a-f-7-4 Format of TSS and LDT Descriptors in 64-bit Mode.png)</p><p>tss段描述符拓展到128位</p><p>![](E:\documents\note\md\windows\sdm-figure\vol-3a-f-7-11 64-Bit TSS Format.png)</p><h2 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h2><p><strong>x64 IDT</strong></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>vol-3a p211 6.14.1 64-Bit Mode IDT</p></blockquote><p>![](E:\documents\note\md\windows\sdm-figure\vol-3a-f-6-8 64-Bit IDT Gate Descriptors.png)</p><p>中断描述符拓展到128位</p><p><code>idt</code>表项的<code>ist</code>项选择使用tss中哪个rsp<br>比如<code>idt-&gt;ist=1</code>，使用的是<code>rsp=tss.ist1</code></p><p>[windbg]<code>idt</code>：查看所有中断</p><p>[windbg]<code>dq idtr</code>：查看中断描述符表idt</p><h2 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h2><p><strong>r3进r0</strong></p><p>IA32_FS_BASE MSR[0xC0000100]</p><p>IA32_GS_BASE MSR[0xC0000101]，当前GS（R3指向teb、R0指向kprc）</p><p>IA32_KERNEL_GS_BASE MSR[0xC0000102]，（R3指向kprc、R0指向teb）</p><p>gs r3指向teb，r0切换为kprc，<code>swapgs</code>，切换<code>IA32_GS_BASE</code> 和<code>IA32_KERNEL_GS_BASE</code></p><p><strong>系统调用</strong></p><ul><li>x64内核<ul><li>x64程序 syscall sysret</li><li>x32程序 r3转64</li></ul></li><li>x32内核<ul><li>sysentry</li></ul></li></ul><p><strong>x32转x64</strong></p><p>ntdll的切换方式（系统调用时）：改变cs</p><p>x32切换cs，0x0023（x32_R3_Code）变0x0033（x64_R3_Code）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">jmp far 33:00000000 ; (7) EA 00000000 3300</code></pre><p>x64回x32（tword 10字节）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; tword ptr [rax] &#x3D; 00000000 00000000 2300jmp far tword ptr ds:[rax] ; (3) 48 FF28</code></pre><p>win10 x32程序会初始化r15、r14、r13，在切换到x64后（进入r0之前）使用</p><p>x32程序可以在r12等切换不会用到的x64寄存器中藏数据</p><h2 id="SMEP和SMAP"><a href="#SMEP和SMAP" class="headerlink" title="SMEP和SMAP"></a><strong>SMEP和SMAP</strong></h2><p>三重错误会直接关机，不会蓝屏，也不会被windbg捕获</p><p>cr4标志位</p><p>[20] SMEP：r0不能执行r3代码页</p><p>[21] SMAP：r0不能读写r3内存页</p><p>可以通过修改cr4关闭这两个保护，也可以通过汇编指令绕过SMAP(内核int3中断例程的做法)：</p><p>stac作用是设置RFLAGS的AC标志，使得r0可以读写r3</p><p>clac清楚AC标志</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">stac ; 0f 01 CB</code></pre><p>此时(中断进r0，执行r3代码页)可以读写r0的：GDT、IDT、KVASCODE</p><p>读写r0其他的节会三重异常</p><h2 id="分页（pass）"><a href="#分页（pass）" class="headerlink" title="分页（pass）"></a>分页（pass）</h2><p>参照别的笔记</p><h2 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a>KPTI</h2><p>视频的实验结果：</p><p>刚进int例程时打印的，exe的user cr3=4<br>windbg看到的r3程序的，exe的kernel cr3=2，对r3代码页pml4e没有可执行标志</p><p>使用cr3=4，转换<code>(ntoskrnl.exe)KVASCODE</code>的地址，能得到正确结果<br>使用cr3=4，转换<code>(ntoskrnl.exe).text</code>，pde=0<br>使用cr3=2，转换<code>(ntoskrnl.exe).text</code>，能得到正确结果</p><p>导致r0下不能执行r3代码的两个机制：</p><ul><li>开启smep，r0权限不能执行r3代码页</li><li>切换到kernel的cr3，默认对r3代码页没有可执行标志（user cr3没有映射完整的内核）</li></ul><p>user cr3映射的区域：user space(RWE)、KVASCODE(RE)、GDT/IDT(RW)</p><p>kernel cr3映射的区域：user space(没有E)、完整kernel space</p><p>symbol type viewer可以把pdg转成.h，ida中可以prase c解析.h的结构体</p><h2 id="硬件漏洞-CFG"><a href="#硬件漏洞-CFG" class="headerlink" title="硬件漏洞 CFG"></a>硬件漏洞 CFG</h2><p><strong>幽灵熔断</strong></p><p>乱序执行对应的利用即为 Meltdown（熔断） ，而预测执行对应的利用即为 Spectre（幽灵）</p><p><strong>lfence指令</strong></p><p>保证读操作串行化</p><p>KiBreapPoint中的补丁代码：</p><pre class="line-numbers language-none"><code class="language-none">; ...0x00000000   4                 4883c408  add rsp, 80x00000004   5               e8eeffffff  call 0xfffffffffffffff70x00000009   4                 4883c408  add rsp, 80x0000000d   5               e8eeffffff  call 00x00000012   4                 4883c408  add rsp, 80x00000016   5               e8eeffffff  call 90x0000001b   4                 4883c408  add rsp, 80x0000001f   5               e8eeffffff  call 0x12; ...0x????????                     4883c408  add rsp, 8</code></pre><p><code>add rsp</code>相当于pop，连续的pop call，使rip上移，最后一个call会去到最下面，整段nop掉不会影响结果，只是用来修补硬件漏洞</p><p><strong>控制流保护（CFG）</strong></p><p><code>call _guard_dispatch_icall </code>等价于<code>call rax</code></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/kernel/">kernel</category>
      
      
      <comments>https://windgodm.github.io/blog/post/zh-x64krnl.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SFU Compilers class 笔记3</title>
      <link>https://windgodm.github.io/blog/post/SFU-Compilers-3.html</link>
      <guid>https://windgodm.github.io/blog/post/SFU-Compilers-3.html</guid>
      <pubDate>Mon, 09 May 2022 04:00:00 GMT</pubDate>
      
      <description>SFU Compilers class week4 p:yacc week5 week6</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="SFU-Compilers-笔记-3-语法分析1"><a href="#SFU-Compilers-笔记-3-语法分析1" class="headerlink" title="SFU Compilers 笔记 3 语法分析1"></a>SFU Compilers 笔记 3 语法分析1</h1><p>week4 p:yacc week5 week6</p><h2 id="Week-4-Context-Free-Grammars（lost）"><a href="#Week-4-Context-Free-Grammars（lost）" class="headerlink" title="Week 4 Context-Free Grammars（lost）"></a>Week 4 Context-Free Grammars（lost）</h2><h3 id="CFG1-Intro-to-CFGs"><a href="#CFG1-Intro-to-CFGs" class="headerlink" title="CFG1 Intro to CFGs"></a>CFG1 Intro to CFGs</h3><p>一个CFG包括：</p><ul><li>终止符集合：T（输入符号）</li><li>非终止符集合：N</li><li>开始符号：S ∈ N</li><li>规则集合</li></ul><p>应用规则：将规则左侧替换为规则右侧</p><p>以开始符号S作为起始，对非终止符应用规则进行拓展，直到没有非终止符</p><p>拓展过程可以化成一颗语法树，语法左侧为父节点</p><p><strong>最右和最左推导</strong></p><p>最右推导每次把最右边的非终止符应用规则拓展</p><p>两者生成相同的语法树</p><h3 id="CGF2-Ambiguity"><a href="#CGF2-Ambiguity" class="headerlink" title="CGF2 Ambiguity"></a>CGF2 Ambiguity</h3><p><strong>歧义</strong></p><ul><li>相同句子具有不同的语法树</li><li>编程语言不能接受该歧义<ul><li>无法确定给定的CFG是否有歧义</li><li>一些CFG本质上是具有歧义的（不存在无歧义的CFG）</li></ul></li></ul><p><strong>处理歧义</strong></p><ul><li>重写语法</li><li>使用优先级和关联性</li></ul><p><strong>关联性</strong></p><p>对于以下语法：</p><p>E -&gt; E + E<br>E -&gt; T<br>T -&gt; T * T<br>T -&gt; int</p><p>通过左或右递归消除歧义：</p><p>E -&gt; E + T<br>E -&gt; T<br>T -&gt; T * F<br>T -&gt; int</p><p>（tips：考虑T+T+T的情况，使用前者会有歧义，后者没有（歧义指语法树不同））</p><p><strong>yacc关联性定义</strong></p><p>yacc中的关联性定义（不需要重新定义语法）</p><p>对于：<code>E -&gt; E - E | int</code></p><p>只需增加关联性定义<code>%left -</code></p><p>等价于上面的<code>E -&gt; E + int E -&gt; int</code></p><p><strong>yacc优先级定义</strong></p><p>对于上面的语法，yacc中可以这样写：</p><pre class="line-numbers language-none"><code class="language-none">%left -%left &#x2F;E -&gt; E - E | E &#x2F; E | int</code></pre><p>写在后面的关联性定义具有更高的优先级（在语法树的更底层）</p><h3 id="CFG3-Push-down-Automata"><a href="#CFG3-Push-down-Automata" class="headerlink" title="CFG3 Push-down Automata"></a>CFG3 Push-down Automata</h3><p>对于每种regular语言有一个等效的FSA</p><p>对一个CFG语言有一个等效的pushdown automaton(pda)</p><p><strong>Push-down Automata</strong></p><p>包含：</p><ul><li>字母表（终止符）</li><li>栈符号（非终止符和终止符）</li><li>一个fsa</li><li>栈</li></ul><h2 id="Practice-Yacc（lost）"><a href="#Practice-Yacc（lost）" class="headerlink" title="Practice Yacc（lost）"></a>Practice Yacc（lost）</h2><p>蓝屏，笔记没了，不想补了</p><h2 id="Week-5-Parsing-1"><a href="#Week-5-Parsing-1" class="headerlink" title="Week 5 Parsing 1"></a>Week 5 Parsing 1</h2><h3 id="LR1-Shift-Reduce-Parsing"><a href="#LR1-Shift-Reduce-Parsing" class="headerlink" title="LR1 Shift-Reduce Parsing"></a>LR1 Shift-Reduce Parsing</h3><p><strong>自顶向下 与 自底向上</strong></p><p>自顶向下：按语法规则拓展</p><p>自底向上：语法规则反向reduce</p><p><strong>自底向上</strong></p><p>reduce最右边的非终止符，即rightmost推导</p><p><strong>Shift-Reduce</strong></p><p>自底向上的过程，只有两种操作：shift、reduce</p><p>shift对应于将待处理符号（输入的符号）入栈</p><p>reduce按规则（语法右边）出栈，并入栈新的符号（语法左边）</p><p><strong>冲突</strong></p><p>过程中某一步可能会出现允许多种可能操作的情况（不考虑最终结果）</p><ul><li>同时允许shift、reduce：<ul><li>可以修复（优先级、关联性）</li></ul></li><li>同于允许不同的reduce：<ul><li>可能语法本身具有歧义</li><li>通过前瞻修复</li></ul></li></ul><p><strong>可行前缀 和 Handle</strong></p><p>直觉：只执行能使我们到达起始符号的reduce</p><p>（不太懂）</p><p>handle总是在栈顶</p><p><strong>自底向上 Shift-Reduce 语法分析算法</strong></p><p>按算法可以处理的cfg语法集从大到小排序（上面的包含下面的）：</p><ul><li>LR(k)<ul><li>L：从左到右扫描输入</li><li>R：最右推导</li><li>k：前瞻token数</li></ul></li><li>LALR(k)</li><li>SLR(k)：simple LR，类似LR(0)，但使用Follow sets</li><li>LR(0)：0前瞻token</li></ul><h3 id="LR2-LR-0-Parsing"><a href="#LR2-LR-0-Parsing" class="headerlink" title="LR2 LR(0) Parsing"></a>LR2 LR(0) Parsing</h3><p><strong>LR 语法分析 概览</strong></p><ul><li>从终止符开始，寻找到起始符的路径</li><li>应用 shift 和 reduce 操作（尽可能延迟决定）</li><li>LR语法分析：<ul><li>L：从左到右分析</li><li>R：最右推导（自底向上）</li></ul></li><li>LR(0) -&gt; SLR(1) -&gt; LR(1) -&gt; LALR(1)</li></ul><p><strong>操作</strong></p><ul><li>Shift<ul><li>添加终止符到栈中</li></ul></li><li>Reduce<ul><li>如果栈顶是个可行前缀，则reduce</li></ul></li></ul><h4 id="基于表的Shift-Reduce语法分析"><a href="#基于表的Shift-Reduce语法分析" class="headerlink" title="基于表的Shift Reduce语法分析"></a>基于表的Shift Reduce语法分析</h4><p><img src="E:\documents\note\md\src\LR-table.jpg"></p><p>行号：状态</p><p>列号：终止符 或 非终止符</p><p>左边（终止符的列）是action表<br>右边（非终止符的列）是goto表</p><p>一个栈存储状态</p><p>表的使用：</p><ol><li>从输入读取一个字符（终止符）</li><li>跟据栈顶状态<code>s</code>、读取的字符<code>t</code>查 <code>action[s, t]</code></li></ol><p>如果<code>action[s, t]</code> = S5（5是一个状态，图中红色例子）：</p><ol start="3"><li>将 5 入栈</li></ol><p>如果<code>action[s, t]</code> = R4（4是一条规则，图中浅蓝、深蓝例子）：</p><ol start="3"><li>查找规则 4 为 <code>F -&gt; (T)</code></li><li>规则右边有3个符号，所以pop3次</li><li>根据栈顶状态<code>s=0</code>、规则左边非终止符<code>n=&#39;F&#39;</code>，查<code>goto[s, n]=1</code></li><li>将 <code>goto[s, n]=1</code> 入栈</li></ol><p>图中的表没有符号的格子代表语法错误</p><p>图中的表<code>action[2, &#39;$&#39;]=A</code>代表到达起始符号，即语法解析成功</p><h4 id="构建Action-Goto表的算法"><a href="#构建Action-Goto表的算法" class="headerlink" title="构建Action/Goto表的算法"></a>构建Action/Goto表的算法</h4><p><strong>配置集(Configuration/ item set)</strong></p><ul><li>每个集是一个语法状态</li><li>使用点规则<ul><li><code>T -&gt; T * • F</code></li></ul></li><li>点在F之前，预测所有F在左边的规则<ul><li><code>T -&gt; T * • F</code></li><li><code>F -&gt; • ( T )</code></li><li><code>F -&gt; • id</code></li></ul></li><li>这创建了一个配置集（就是求<code>T -&gt; T * • F</code>的闭包）</li></ul><p><strong>起始配置集</strong></p><ul><li>用<code>S&#39;</code>扩充语法，添加一条规则<code>S&#39; -&gt; S</code></li><li>求<code>closure(S&#39; -&gt; •  S)</code></li></ul><p>比如上述例子起始配置集<code>closure(S&#39; -&gt; • T)</code></p><p><strong>后继 Successor(I, X)</strong></p><p>意义：按符号X移动</p><ol><li>对于<code>I</code>中所有点后面为<code>X</code>的规则，点向右移动一位</li><li>删除其余规则（没有移动的规则）</li><li>计算（移动后的规则的）闭包</li></ol><p>得到的就是该后继配置集</p><p><strong>实例</strong></p><p><img src="E:\documents\note\md\src\LR-table-2.jpg"></p><p>每个集合对应一个表中的状态（一行）<br>如果是终止符得到的后继（左边的列），则<code>action[I, t] = Successor(I, n) </code><br>如果是非终止符得到的后继（右边的列），则<code>goto[I, n] = Successor(I, t) </code></p><p>其中有些集合有没有后继（点右边没有符号）的规则，则<code>action[I, 空着的t] = R</code><br>比如<code>action[1, 空着的t] = R1</code>、<code>action[4, 空着的t] = R2 </code><br>而集合2比较特殊，代表了成功结束，<code>action[2, &#39;$&#39;] = $Accept</code></p><p>以计算集合3的后继为例，<code>Successor(I3, &#39;(&#39;)</code>：</p><ol><li>集合3中点后面为<code>(</code>的只有一条规则（集合3中红色标记）</li><li>移动规则的点（集合5中红色标记的第一条规则）</li><li>计算闭包<ol><li>现在只有一条<code>F -&gt; ( • T )</code>，添加<code>T</code>在左边的规则到集合中（橙色左括号）</li><li>现在新增了<code>F</code>和<code>T</code>，<code>T</code>已经找过，添加<code>F</code>在左边的规则（黄色括号）</li><li>现在新增了<code>id</code>、<code>(</code>，没有这两者在左边的规则</li><li>计算闭包完毕</li></ol></li><li>该闭包即是<code>I5 = Successor(I3, &#39;(&#39;)</code></li></ol><p>集合5的后继有<code>T</code>、<code>F</code>、<code>id</code>、<code>(</code></p><p>假设按深度优先，接着计算<code>Successor(I5, &#39;T&#39;)</code>，和上面的步骤一样：</p><ol><li>选择集合5中点后面为<code>T</code>的所有规则，移动点构成新集合</li><li>得到<code>&#123;F -&gt; ( T • ), T -&gt; T • * F&#125;</code></li><li>计算该集合的闭包<ol><li>点后面有<code>)</code>、<code>*</code>，分别找出规则左边为这两符号的规则</li><li>刚好都没有，计算闭包完毕</li></ol></li><li>该闭包即是<code>I6 = Successor(I5, &#39;T&#39;) </code></li></ol><p>构建表的伪代码（广度优先）：</p><pre class="line-numbers language-none"><code class="language-none">function items(G’)    C &#x3D; &#123; closure(&#123;S’ -&gt; • S&#125;) &#125;; &#x2F;&#x2F; C &#x3D; &#123;起始配置集&#125;    do foreach I ∈ C do &#x2F;&#x2F; 遍历C中新添加的配置集        foreach X ∈ (N ∪ T) do &#x2F;&#x2F; 遍历集的所有后继        C &#x3D; C ∪ &#123; Successor(I, X) &#125;; &#x2F;&#x2F; 添加后继配置集到C中（去重）    while C changes;</code></pre><p><strong>冲突</strong></p><p>R/N（不构成冲突）：</p><p>集合中有点右边为非终止符的规则（对应非终止符后继），也有点右边什么都没有的规则（对应reduce）</p><p>reduce规则一定是前者求闭包得到的（reduce求闭包就是reduce本身）</p><p>action表（终止符后继）填充reduce，goto表（非终止符后继）填充对应后继</p><p>R/R 冲突：</p><p>集合中有一个以上的点右边什么都没有的规则（对应多个reduce）</p><p>R/T（未定义的行为）：</p><p>（这解决方式不在LR(0)的定义中）对于action表（终止符列），有后继的填后继，没有后继的，填充R</p><h2 id="Week-6-Parsing-2"><a href="#Week-6-Parsing-2" class="headerlink" title="Week 6 Parsing 2"></a>Week 6 Parsing 2</h2><h3 id="LR3-SLR-1-Parsing"><a href="#LR3-SLR-1-Parsing" class="headerlink" title="LR3 SLR(1) Parsing"></a>LR3 SLR(1) Parsing</h3><p>LR(0)：action[s, 空着t] = R</p><p>SLR(1)：action[s, follow(L)] = R，（L是规则的左边）解决部分冲突</p><p><strong>终止符集合：</strong></p><ul><li><p>First(N)：非终止符拓展的序列中，第一个的可能取值</p></li><li><p>Follow(N)：非终止符下一个可能的取值</p><ul><li>S是起始符，$ ∈ FOLLOW(S)</li><li>X -&gt; …Aa…，Follow(A)包括a</li><li>X -&gt; …AB…，Follow(A)包括First(B)</li><li>X -&gt; …A，Follow(A)包括Follow(X)</li></ul></li></ul><p>​    </p><p><strong>SLR(1)</strong></p><p>增加了检测follow的约束，只有满足follow的才会reduce，否则shift</p><h3 id="LR4-LR-1-Parsing"><a href="#LR4-LR-1-Parsing" class="headerlink" title="LR4 LR(1) Parsing"></a>LR4 LR(1) Parsing</h3><p>LR(1)解决R/T，R/R冲突</p><p>SLR(1)中可能存在follow(L)（Reduce）和shift（T）重合的情况</p><p>也可能存在两个不同L的follow相同的情况（RR冲突）</p><p>解决办法改变Follow的计算方法，同一个L，在不同闭包中的Follow是独立的</p><p>计算闭包时，把新L在旧R中后一个符号作为Follow(L)，并记录下来</p><p>例子1：</p><p>S -&gt; • Aa, $<br>A -&gt; • e, a</p><p>第二条从第一条拓展而来，第一条中A的后一个符号是a，则Follow(A)=a</p><p>例子2：</p><p>S -&gt; • A, =/$<br>A -&gt; • e, =/$</p><p>第二条从第一条拓展而来，第一条中A是规则右边的最后一个符号，则Follow(A) = Follow(S) = {=, $}</p><p><img src="E:\documents\note\md\src\LR1-table.png"></p><p>图中闭包0，标1的红色箭头就是按例子1的方式计算的follow<br>标2的绿色和橙色箭头就是按例子2的方式继承自前一条规则的follow</p><h3 id="LR5-Precedence-and-Associativity"><a href="#LR5-Precedence-and-Associativity" class="headerlink" title="LR5 Precedence and Associativity"></a>LR5 Precedence and Associativity</h3><p>优先级高的先reduce</p><p>比如<code>*</code>优先级高于<code>+</code>，当前栈中为<code>E+E</code>，预览下一个符号，如果为优先级更高的<code>*</code>则shift，如果下一个符号优先级更低就reduce</p><p>yacc/bison中使用%left、%right的列表来处理优先级（列表中的先后）和关联性（left还是right）</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CS/">CS</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/cs/">cs</category>
      
      <category domain="https://windgodm.github.io/blog/tags/compiler/">compiler</category>
      
      
      <comments>https://windgodm.github.io/blog/post/SFU-Compilers-3.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SFU Compilers class 笔记2</title>
      <link>https://windgodm.github.io/blog/post/SFU-Compilers-2.html</link>
      <guid>https://windgodm.github.io/blog/post/SFU-Compilers-2.html</guid>
      <pubDate>Tue, 15 Mar 2022 04:00:00 GMT</pubDate>
      
      <description>SFU Compilers class week2 wee3 p-lex hw1</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="SFU-Compilers-笔记2-词法分析"><a href="#SFU-Compilers-笔记2-词法分析" class="headerlink" title="SFU Compilers 笔记2 词法分析"></a>SFU Compilers 笔记2 词法分析</h1><p>week2 wee3 p-lex hw1</p><h2 id="Week-2-Lexical-Analysis-1"><a href="#Week-2-Lexical-Analysis-1" class="headerlink" title="Week 2 Lexical Analysis 1"></a>Week 2 Lexical Analysis 1</h2><h3 id="LEX1-Intro-to-Regexps"><a href="#LEX1-Intro-to-Regexps" class="headerlink" title="LEX1 Intro to Regexps"></a>LEX1 Intro to Regexps</h3><p><strong>词法分析</strong></p><p>将字符串转成tokens</p><p><strong>Token Attributes</strong></p><p>具有属性的例子：<code>T_IDENT (&quot;sqrt&quot;)</code>,<code>T_INTCONSTANT (&quot;1&quot;)</code></p><p>Token: <code>T_IDENT</code><br>Lexeme: <code>(&quot;sqrt&quot;)</code></p><p>不具有属性的例子：<code>T_WHILE</code></p><p><strong>实现Lexers：循环和swich扫描器</strong></p><ul><li>大量嵌套switch/case</li><li>大量getc()、ungetc()</li><li>容易出错</li><li>难以更改和添加关键字</li></ul><p>ad-hoc lexer源码：<a href="https://github.com/llvm/llvm-project/blob/3170d54842655d6d936aae32b7d0bc92fce7f22e/clang/lib/Lex/Lexer.cpp">LexTokenInternal in clang</a></p><p><strong>正则表达式</strong></p><p>大概介绍了下正则表达式</p><p>限制：在设计语言语法时要考虑正则语法，以便于构造正则表达式</p><h3 id="LEX2-Regular-Expresssions"><a href="#LEX2-Regular-Expresssions" class="headerlink" title="LEX2 Regular Expresssions"></a>LEX2 Regular Expresssions</h3><p>Integer：</p><pre class="line-numbers language-none"><code class="language-none">digit &#x3D; (0|1|2|3|4|5|6|7|8|9)&#123;digit&#125;+</code></pre><p>Identifier：</p><pre class="line-numbers language-none"><code class="language-none">digit &#x3D; [0-9]letter &#x3D; [a-zA-Z]&#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*</code></pre><p>Whitespace：</p><pre class="line-numbers language-none"><code class="language-none">(&quot; &quot;|&quot;\t&quot;|&quot;\n&quot;)+</code></pre><p>Pattern definition for numbers：</p><pre class="line-numbers language-none"><code class="language-none">digit &#x3D; [0-9]digits &#x3D; [0-9]+opt_frac &#x3D; (&quot;.&quot;&#123;digits&#125;)?opt_exp &#x3D; ((e|E)(\+|\-)?&#123;digits&#125;)?num &#x3D; &#123;digits&#125;&#123;opt_frac&#125;&#123;opt_exp&#125;345, 345.04 , 2e-7, 2e7, 2e+7, 3.14e5</code></pre><p>优先级：</p><ul><li>匹配长度</li><li>token顺序</li></ul><h2 id="Week-3-Lexical-Analysis-2"><a href="#Week-3-Lexical-Analysis-2" class="headerlink" title="Week 3 Lexical Analysis 2"></a>Week 3 Lexical Analysis 2</h2><h3 id="LEX3-Regexps-are-Trees"><a href="#LEX3-Regexps-are-Trees" class="headerlink" title="LEX3 Regexps are Trees"></a>LEX3 Regexps are Trees</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>参考链接：</p><p><a href="https://xkcd.com/208/">xkcd: Regular Expressions</a></p><p>有点类似于NFA的可视化：</p><p><a href="https://www.debuggex.com/">Debuggex: Online visual regex tester. JavaScript, Python, and PCRE.</a></p></blockquote><p><strong>正则优先级</strong>：</p><ol><li>()</li><li>一元运算符（unary op.）</li><li>用于连接的二元运算符（binary op. for concatenation）</li><li>间隔的二元运算符（binary op. for alternation）</li></ol><p><strong>正则表达式是一树</strong></p><p>使用左结合来得到唯一的树</p><p><strong>等价的正则表达式</strong></p><p>可以化简正则表达式</p><p>一些性质：</p><ul><li>结合律（Commutative，可交换的）</li><li>分配律</li><li>交换律</li><li>R | R == R</li><li>R*R* == (R*)* == RR*|e == R*</li></ul><h3 id="LEX4-Regexps-as-Automata"><a href="#LEX4-Regexps-as-Automata" class="headerlink" title="LEX4 Regexps as Automata"></a>LEX4 Regexps as Automata</h3><p>主要讲了有限状态机（FSA）、DFA、NFA的概念</p><p>还有NFA到DFA的转换思路</p><p><strong>DFA</strong></p><p>对于一个输入，其路径唯一，若能到达终点则为合法</p><p><strong>NFA</strong></p><p>对于一个输入，可能有多条路径，只要有一条能到达终点则为合法</p><p><strong>NFA 转 DFA</strong></p><p>把NFA状态的组合，当成DFA的状态</p><p><strong>DFA vs NFA</strong></p><ul><li>DFA不允许有歧义</li><li>DFA不允许无条件转移</li><li>DFA执行速度更快（NFA存在歧义可能需要搜索）</li><li>DFA通常情况状态比NFA少</li><li>最坏情况DFA的状态比NFA多（2的n次方倍，n为NFA的状态数量）</li></ul><h3 id="LEX5-Regexps-to-NFA"><a href="#LEX5-Regexps-to-NFA" class="headerlink" title="LEX5 Regexps to NFA"></a>LEX5 Regexps to NFA</h3><p><strong>Thompson构造法</strong></p><ul><li>Rule0（empty language）  <img src="E:\documents\note\md\笔记\ThompsonRule0.jpg" style="zoom:50%;" /></li><li>Rule1（x）  <img src="E:\documents\note\md\笔记\ThompsonRule1.jpg" style="zoom:50%;" /></li><li>Rule2（empty string，ε）  <img src="E:\documents\note\md\笔记\ThompsonRule2.jpg" style="zoom:50%;" /></li><li>Rule3（r1 | r2）  <img src="E:\documents\note\md\笔记\ThompsonRule3.jpg" style="zoom:50%;" /></li><li>Rule4（r1r2）  <img src="E:\documents\note\md\笔记\ThompsonRule4.jpg" style="zoom:50%;" /></li><li>Rule5（r*）  <img src="E:\documents\note\md\笔记\ThompsonRule5.jpg" style="zoom:50%;" /></li></ul><p>按照正则表达式树的后序遍历的顺序，根据Rule构造NFA</p><h3 id="lex6-NFA-to-DFA（todo）"><a href="#lex6-NFA-to-DFA（todo）" class="headerlink" title="lex6 NFA to DFA（todo）"></a>lex6 NFA to DFA（todo）</h3><p><strong>ε-closure</strong></p><p>ε-closure(s) = {s以及s开始所有能通过ε到达的点}</p><p><strong>转换</strong></p><p>（NFA中大写是状态的集合，小写是单个状态）</p><table><thead><tr><th></th><th>NFA</th><th>DFA</th></tr></thead><tbody><tr><td>States</td><td>S</td><td>{X | X ⊆ S}</td></tr><tr><td>start</td><td>q ∈ S</td><td>ε-closure(q)</td></tr><tr><td>Final</td><td>F ⊆ S</td><td>{X | X∩F ≠ ø}</td></tr><tr><td>transition</td><td>δ(x,a) = y</td><td>δ(X,a) = ε-closure(δ(x,a)), x∈X</td></tr></tbody></table><p><strong>最小化DFA</strong></p><p>合并所有转移条件及目标相同的点</p><p>对所有a，δ(X,a) = δ(Y,a)，合并X、Y</p><p><strong>NFA to DFA</strong></p><p>// todo</p><pre class="line-numbers language-pascal" data-language="pascal"><code class="language-pascal">states[0] &#x3D; e-closure(&#123;q0&#125;)p &#x3D; j &#x3D; 0while j &lt;&#x3D; p dofor each symbol c doe &#x3D; DFAedge(states[j], c)if e &#x3D;&#x3D; states[i] for some i &lt;&#x3D; pthen Dtrans[j, c] &#x3D; ielsep &#x3D; p+1states[p] &#x3D; eDtrans[j,c] &#x3D; p    j &#x3D; j+1</code></pre><h3 id="lex7-NFA-to-DFA-Complexity（pass）"><a href="#lex7-NFA-to-DFA-Complexity（pass）" class="headerlink" title="lex7 NFA to DFA Complexity（pass）"></a>lex7 NFA to DFA Complexity（pass）</h3><p>pass</p><h3 id="LEX8-Lexical-Analyzer"><a href="#LEX8-Lexical-Analyzer" class="headerlink" title="LEX8 Lexical Analyzer"></a>LEX8 Lexical Analyzer</h3><p><strong>使用DFA的词法分析</strong></p><ul><li>每个token定义成一个正则表达式</li><li>合并所有正则表达式成一个大的正则表达式</li><li>转换成NFA，DFA，最小化</li><li>DFA识别器必须找到左边一个匹配长度最长的token</li><li>如果两个匹配的token的长度相同的，优先选择token列表中更前面的</li></ul><p><strong>Lookahead operator</strong></p><p>r1后面必须跟着r2</p><p>匹配r1εr2，并记录下r1和r2结束的位置</p><p><strong>总结</strong></p><ul><li>Token =&gt; Pattern (LEX2)</li><li>Pattern =&gt; Regular Expression (LEX2)</li><li>Regular Expression =&gt; NFA (LEX5)<ul><li>Thompson’s Rules</li></ul></li><li>NFA =&gt; DFA (LEX4, lex6, lex7)<ul><li>Subset construction</li><li>DFA =&gt; minimal DFA</li></ul></li><li>DFA =&gt; Table-driven implementation of DFA (lex9)</li></ul><h3 id="lex9-Implementing-DFAs"><a href="#lex9-Implementing-DFAs" class="headerlink" title="lex9 Implementing DFAs"></a>lex9 Implementing DFAs</h3><p><strong>使用二维数组存储转移表</strong></p><p>T[state_idx, input_symbol] = next_state_idx</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">i &#x3D; 0;state &#x3D; 0;while(input[i]) &#123;    state &#x3D; T[state, input[i]];    i++;&#125;</code></pre><p><strong>压缩转移表</strong></p><p>二维数组占用空间大，且有很多重复元素；链表查询速度慢</p><p>一种解决办法是压缩二维数组，二维数组中有空位（T[i,a]=None），利用这些空位存储信息</p><p>再用一个额外的数组记录新表中每一格所属的状态</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; originnext_state &#x3D; T[state, input[i]];&#x2F;&#x2F; sparse tablesidx &#x3D; B[state] + anext_state &#x3D; check[idx] &#x3D;&#x3D; state ? ST[idx] : -1</code></pre><p>示例：</p><table><thead><tr><th>T(s\a)</th><th>a</th><th>b</th><th>c</th><th>d</th></tr></thead><tbody><tr><td>0</td><td>-</td><td>1</td><td>-</td><td>2</td></tr><tr><td>1</td><td>1</td><td>-</td><td>1</td><td>-</td></tr><tr><td>2</td><td>1</td><td>2</td><td>1</td><td>-</td></tr></tbody></table><table><thead><tr><th>Base(s\i)</th><th>idx</th></tr></thead><tbody><tr><td>0</td><td>2</td></tr><tr><td>1</td><td>4</td></tr><tr><td>2</td><td>0</td></tr></tbody></table><table><thead><tr><th>idx</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>s_0</td><td></td><td></td><td>-</td><td>1</td><td>-</td><td>2</td><td></td><td></td></tr><tr><td>s_1</td><td></td><td></td><td></td><td></td><td>1</td><td>-</td><td>1</td><td>-</td></tr><tr><td>s_2</td><td>1</td><td>2</td><td>1</td><td>-</td><td></td><td></td><td></td><td></td></tr><tr><td>ST[]</td><td>1</td><td>2</td><td>1</td><td>1</td><td>1</td><td>2</td><td>1</td><td>-</td></tr><tr><td>check[]</td><td>2</td><td>2</td><td>2</td><td>0</td><td>1</td><td>0</td><td>1</td><td>-</td></tr></tbody></table><h3 id="lex10-Regexp-to-DFA（pass）"><a href="#lex10-Regexp-to-DFA（pass）" class="headerlink" title="lex10 Regexp to DFA（pass）"></a>lex10 Regexp to DFA（pass）</h3><p>pass</p><h2 id="Practice-Lex"><a href="#Practice-Lex" class="headerlink" title="Practice Lex"></a>Practice Lex</h2><h3 id="Regexp"><a href="#Regexp" class="headerlink" title="Regexp"></a><strong>Regexp</strong></h3><p>让Σ = {0, 1}</p><ol><li>集合的元素个数：2</li><li>Σ3（三次方）：{000, 001, … , 110, 111}</li><li>Σ*：Σ0 + Σ1 + Σ2 + …</li><li>Σ*中所有等于十进制数字6的regexp：<code>0*110</code></li><li>Σ*中所有2的幂的regexp：<code>10*</code></li><li>Σ*中所有偶数的regexp：<code>[0|1]*0</code></li><li>Σ*中所有BCD码（包括空字符串）的regexp：<code>((0[01][01][01])|(100[01]))* </code></li></ol><p><code>(0[01][01][01])</code>=0<del>7，<code>(100[01]))</code>=8</del>9</p><h3 id="Simple-Tokenizer"><a href="#Simple-Tokenizer" class="headerlink" title="Simple Tokenizer"></a>Simple Tokenizer</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apt install makeapt install flexmake simpletok# compiling lex file: simpletok.lex# output file: simpletok# flex -osimpletok.c simpletok.lex# gcc -o .&#x2F;simpletok simpletok.c -ll# &#x2F;bin&#x2F;rm -f simpletok.c.&#x2F;simpletok90int  # type this in yourself upto the comment char# IDENTIFIER: 90int, LENGTH:5Ctrl-D # this terminates the standard input stream</code></pre><h3 id="Lexical-Analysis"><a href="#Lexical-Analysis" class="headerlink" title="Lexical Analysis"></a>Lexical Analysis</h3><p>要求手动预测一组token的识别结果</p><p>计算答案的lex代码在<code>tokenizer2.lex</code></p><p>Provide the tokenized output for the following input strings using the greedy longest match lexical analysis method. Provide the list of tokens and the lexeme values.</p><h3 id="Lexical-Analysis-using-lex"><a href="#Lexical-Analysis-using-lex" class="headerlink" title="Lexical Analysis using lex"></a>Lexical Analysis using <code>lex</code></h3><p>要求使用lex实现一组token的识别</p><p>标准答案在<code>tokenizer.lex</code></p><h3 id="Remove-Multi-line-Comments"><a href="#Remove-Multi-line-Comments" class="headerlink" title="Remove Multi-line Comments"></a>Remove Multi-line Comments</h3><p>目录：<code>rmcomments</code></p><p>匹配c语言风格多行注释</p><p>正则表达式：<code>\/\*((?!\*\/).|\n)*\*\/</code></p><p>lex不支持向前匹配的<code>?!</code>：</p><p>lex写法：<code>\/\*(\n|[^*]|[*]*[^*/])*[*]*\*\/</code></p><p>构造过程：</p><p>regexp_1：<code>\/\*[^*]*\*\/</code>，匹配非<code>*</code>字符（r1=<code>[^*]</code>）</p><p>能够匹配类型1：<code>/* 123 */</code>，无法匹配类型2的<code>***/</code>结尾的情况</p><p>regexp_2：<code>\/\*[^*]*[*]*\*\/</code>（r2=<code>[*]*</code>）</p><p>能够匹配类型2：<code>/* 123 *****/</code>，无法匹配类型3的中间有<code>*****</code>+非<code>*</code>字符的情况</p><p>regexp_3：<code>[*]*[^*/]</code>，用于匹配多个<code>*</code>接一个非<code>*</code>且非<code>/</code>的情况（r3=<code>[*]*[^*/]</code>）</p><p>类型3：<code>/* ***** */ </code></p><p>结合到一起：<code>\/\*(\n|&#123;r1&#125;|&#123;r3&#125;)*&#123;r2&#125;\*\/</code></p><p>最终方案：</p><pre class="line-numbers language-none"><code class="language-none">%%\&quot;[^\&quot;]*\&quot;  ECHO;\&#x2F;\&#x2F;.*&#123; &#125;\&#x2F;\*(\n|[^*]|[*]*[^*&#x2F;])*[*]*\*\&#x2F;  &#123; &#125;.|\nECHO;%%</code></pre><p>其他忽略多行注释的解决方案：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">%%\&#x2F;\*    comment();%%comment() &#123;    char c0, c1;loop:    while((c0 &#x3D; input()) !&#x3D; &#39;*&#39; &amp;&amp; c0 !&#x3D; 0) &#123;        &#x2F;&#x2F; putchar(c0);    &#125;        if ((c1 &#x3D; input()) !&#x3D; &#39;&#x2F;&#39; &amp;&amp; c0 !&#x3D; 0) &#123;        unput(c1);        goto loop;    &#125;    &#x2F;&#x2F; if(c0 !&#x3D; 0) putchar(c0);&#125;</code></pre><h3 id="Matching-a-Right-Context"><a href="#Matching-a-Right-Context" class="headerlink" title="Matching a Right Context"></a>Matching a Right Context</h3><p>要求手动预测一组右上下文相关的token的识别结果</p><pre class="line-numbers language-none"><code class="language-none">%%a*b+&#x2F;c+  &#123; printf(&quot;T_AB:%s\n&quot;, yytext); &#125;%%</code></pre><h3 id="Matching-a-Left-Context"><a href="#Matching-a-Left-Context" class="headerlink" title="Matching a Left Context"></a>Matching a Left Context</h3><p>要求实现左上下文相关的token的识别</p><p>标准答案在<code>leftcontext.lex</code>，需要修改makefile以编译该代码</p><pre class="line-numbers language-none"><code class="language-none">%%outputfile      BEGIN OUTPUT;&lt;OUTPUT&gt;\&quot;.*\&quot;  &#123; BEGIN 0; ECHO; printf(&quot; is the output file.\n&quot;); &#125;%%</code></pre><h3 id="Backtracking-in-Lex（todo）"><a href="#Backtracking-in-Lex（todo）" class="headerlink" title="Backtracking in Lex（todo）"></a>Backtracking in Lex（todo）</h3><p>// todo</p><h3 id="Counting-with-Lex（todo）"><a href="#Counting-with-Lex（todo）" class="headerlink" title="Counting with Lex（todo）"></a>Counting with Lex（todo）</h3><p>// todo</p><h2 id="Homework-1-Lexical-Analysis"><a href="#Homework-1-Lexical-Analysis" class="headerlink" title="Homework 1 Lexical Analysis"></a>Homework 1 Lexical Analysis</h2><p>前置条件：hw0、lex-practice</p><p>目录：<code>decaflex</code></p><p><code>./answer/default.lex</code>为未完成的作业，复制为<code>./answer/decaflex.lex</code>并完成</p><p><strong>规则编写</strong></p><p>参照语言的定义编写即可</p><p>把<code>Keywords</code>的定义放到最前面，不然会无法识别，其余按字母顺序好像也没问题</p><p>注意输出要求，对于<code>[\n\v\f]</code>要求输出其转义序列，而不是转义后的字符，<code>\r\n</code>（CRLF）输出一个<code>\n</code>即可</p><p>即对于<code>T_WHITESPACE</code>，忽略<code>\r</code>，为了简便直接循环处理：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">case T_WHITESPACE: &#123;    cout &lt;&lt; &quot;T_WHITESPACE &quot;;    for (i &#x3D; 0; i &lt; yyleng; i++)&#123;        switch(yytext[i])&#123;            case 9: cout &lt;&lt; &quot;\t&quot;; break;            case 10: cout &lt;&lt; &quot;\\n&quot;; break;            case 11: cout &lt;&lt; &quot;\\v&quot;; break;            case 12: cout &lt;&lt; &quot;\\f&quot;; break;            case 13: &#x2F;*cout &lt;&lt; &quot;\\r&quot;;*&#x2F; break;            case 32: cout &lt;&lt; &quot; &quot;; break;        &#125;    &#125;    cout &lt;&lt; endl;    break;&#125;</code></pre><p>对于<code>T_COMMENT</code>，其正则表达式为<code>\/\/.*[\n]</code>，简便处理，默认是CRLF：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">case T_COMMENT: &#123;    lexeme[yyleng-2] &#x3D; &#39;\\&#39;;    lexeme[yyleng-1] &#x3D; &#39;n&#39;;    cout &lt;&lt; &quot;T_COMMENT &quot; &lt;&lt; lexeme &lt;&lt; endl;    break;&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CS/">CS</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/cs/">cs</category>
      
      <category domain="https://windgodm.github.io/blog/tags/compiler/">compiler</category>
      
      
      <comments>https://windgodm.github.io/blog/post/SFU-Compilers-2.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《逆向工程实战》实例D</title>
      <link>https://windgodm.github.io/blog/post/practicalreD.html</link>
      <guid>https://windgodm.github.io/blog/post/practicalreD.html</guid>
      <pubDate>Fri, 11 Mar 2022 04:00:00 GMT</pubDate>
      
      <description>《逆向工程实战》实例D 分析</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="《逆向工程实战》实例D"><a href="#《逆向工程实战》实例D" class="headerlink" title="《逆向工程实战》实例D"></a>《逆向工程实战》实例D</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p><strong>基本信息</strong></p><p>x86</p><p>Device Name：<code>\Device\ProcPanama</code></p><p>SymbolLink Name：<code>\DosDevices\ProcPanama</code></p><p>IRP：Create、Close、DeviceIoCtrl</p><p>回调：进程</p><p><strong>函数分析结果</strong></p><ul><li><p>sub_10001019：进程通知回调</p></li><li><p>sub_10001277：Memcpy</p></li><li><p>sub_100012B0：修改cr0</p></li><li><p>sub_100012BC：修改cr0</p></li><li><p>sub_100012C8*：DeviceIoCtrl</p></li></ul><p><strong>功能摘要</strong></p><p>提供接口修改ssdt（CR0关WP）、写入shellcode、触发中断</p><p>功能与shellcode密切相关，没有R3的样本，不知道shellcode是什么</p><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><p>IOCTL_0_803 input buffer</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; size &gt;&#x3D; 0x20+  0  ssdtIdx        4+  4  aShellCode     char[0xa]+  E  unknown        2+ 10  hProc          HANDLE+ 14  desiredAccess  4+ 18  pid            4+ 1C  newBase        void*</code></pre><p>IOCTL_1_804 input buffer</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; size &#x3D; 0xC+ 0  ssdtIdx  4+ 4  newBase  void*+ 8  oldBase  void*</code></pre><h2 id="Memcpy"><a href="#Memcpy" class="headerlink" title="Memcpy"></a>Memcpy</h2><p>这个函数的功能就是memcpy</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Memcpy(char* Dst_, char* Src_, unsigned int size);</code></pre><p>书中问到第二个参数从何而来，是否有意义，不太确定是什么意思。<br>我猜测是优化使得对第二个参数的使用变得有点奇怪，比较不直观，详见下面的分析。</p><p>首先检查传入的第一个和第二个参数是否是合法地址</p><p>然后执行了memcpy的操作，有一些优化，所以比较难识别</p><p>反汇编：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; unsigned int i   (esi); char*        dst (eax)mov     esi, [ebp+size]    ; i &#x3D; sizetest    esi, esijbe     short L_end ; jmp if i &#x3D;&#x3D; 0:mov     eax, [ebp+Dst_]    ; eax &#x3D; Dst_mov     ecx, [ebp+Src_]sub     ecx, eax           ; const ecx &#x3D; Src_ - Dst_L_continue:mov     dl, [ecx+eax]mov     [eax], dl          ; *dst &#x3D; *(Src_-Dst_+dst)inc     eax                ; dst++dec     esi                ; i--jnz     short L_continueL_end:pop     esipop     ebpretn    0Ch</code></pre><p>反编译：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unsigned int i &#x3D; size;if(i)&#123;char* dst &#x3D; Dst_;do &#123;        *dst &#x3D; *(dst + Src_ - Dst_); &#x2F;&#x2F; Dst_[size-i] &#x3D; Src_[size-i]        ++dst;        --i;    &#125; while( i );&#125;</code></pre><h2 id="修改cr0"><a href="#修改cr0" class="headerlink" title="修改cr0"></a>修改cr0</h2><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">EnableCR0WP proc nearmov     eax, cr0or      eax, 10000h ; cr0 bit[16] &#x3D; 1mov     cr0, eaxretnsub_100012B0 endpDisableCR0WP proc nearmov     eax, cr0and     eax, 0FFFEFFFFh ; cr0 bit[16] &#x3D; 0mov     cr0, eaxretnsub_100012BC endp</code></pre><h2 id="DeviceIoCtrl"><a href="#DeviceIoCtrl" class="headerlink" title="DeviceIoCtrl"></a>DeviceIoCtrl</h2><p>5个控制码</p><p>都是METHOD_BUFFERED，有一个用了UserBuffer输出，有点迷惑</p><p>METHOD_NEITHER 用的是（In）Type3InputBuffer、（Out）UserBuffer</p><p>Read/Write的Buffer IO用的都是SystemBuffer</p><h3 id="IOCTL-0-803"><a href="#IOCTL-0-803" class="headerlink" title="IOCTL_0_803"></a><strong>IOCTL_0_803</strong></h3><p>修改了ssdt表项，然后又修改了新的服务例程前10个字节，然后调用打开进程句柄</p><p>最后恢复上面修改的两个东西</p><pre class="line-numbers language-none"><code class="language-none">Code 22E00CDeviceType 0x22 FILE_DEVICE_UNKNOWNFunction 0x803Method 0x0 METHOD_BUFFEREDAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS  </code></pre><p>部分反编译：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if( MmIsAddressValid(inBuf-&gt;newBase) ) &#123;    pSSDT_i &#x3D; (PVOID *)(KeServiceDescriptorTable[0] + 4 * inBuf-&gt;ssdtIdx);    if( MmIsAddressValid(pSSDT_i) ) &#123;        oldBase &#x3D; *pSSDT_i; &#x2F;&#x2F; save ssdt[i]        DisableCR0WP();        *pSSDT_i &#x3D; inBuf-&gt;newBase; &#x2F;&#x2F; change ssdt[i]        Memcpy(tempBuf, (char *)inBuf-&gt;newBase, 0xAu);&#x2F;&#x2F; save shellcode 0xA bytes        Memcpy((char *)inBuf-&gt;newBase, inBuf-&gt;aShellcode, 0xAu);&#x2F;&#x2F; change shellcode 0xA bytes        status &#x3D; ZwOpenProcess(&amp;inBuf-&gt;hProc, inBuf-&gt;desiredAccess, &amp;ObjectAttributes, &amp;ClientId);        Memcpy((char *)inBuf-&gt;newBase, tempBuf, 0xAu);&#x2F;&#x2F; re change shellcode 0xA bytes        *pSSDT_i &#x3D; oldBase; &#x2F;&#x2F; re change ssdt[i]        EnableCR0WP();    &#125;&#125;</code></pre><h3 id="IOCTL-1-804-set-ssdt"><a href="#IOCTL-1-804-set-ssdt" class="headerlink" title="IOCTL_1_804 set ssdt"></a><strong>IOCTL_1_804 set ssdt</strong></h3><p>设置ssdt表项，并保存旧的ssdt表项</p><pre class="line-numbers language-none"><code class="language-none">Code 22E010DeviceType 0x22 FILE_DEVICE_UNKNOWNFunction 0x804Method 0x0 METHOD_BUFFEREDAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS  </code></pre><p>部分反编译：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inBuf_1-&gt;oldBase &#x3D; *(PVOID *)(KeServiceDescriptorTable[0] + 4 * inBuf_1-&gt;ssdtIdx); &#x2F;&#x2F; save old ssdt[i]DisableCR0WP();*pSSDT_i &#x3D; inBuf_1-&gt;newBase; &#x2F;&#x2F; set ssdt[i]EnableCR0WP();</code></pre><h3 id="IOCTL-2-805-write-g-buffer"><a href="#IOCTL-2-805-write-g-buffer" class="headerlink" title="IOCTL_2_805 write g_buffer"></a>IOCTL_2_805 write g_buffer</h3><p>往一个全局指针分配页池内存，然后往该全局buffer里写入数据，然后对该全局buffer做了一些看不懂的操作</p><p>另外使用了UserBuffer</p><pre class="line-numbers language-none"><code class="language-none">Code 22E014DeviceType 0x22 FILE_DEVICE_UNKNOWNFunction 0x805Method 0x0 METHOD_BUFFEREDAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS  </code></pre><h3 id="IOCTL-3-806"><a href="#IOCTL-3-806" class="headerlink" title="IOCTL_3_806"></a>IOCTL_3_806</h3><p>对g_buffer进行了一些操作</p><pre class="line-numbers language-none"><code class="language-none">Code 22E018DeviceType 0x22 FILE_DEVICE_UNKNOWNFunction 0x806MMethod 0x0 METHOD_BUFFEREDAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS</code></pre><h3 id="IOCTL-4-807-add-pid"><a href="#IOCTL-4-807-add-pid" class="headerlink" title="IOCTL_4_807 add pid"></a>IOCTL_4_807 add pid</h3><p>往<code>ULONG g_pids[0x10]</code>插入</p><pre class="line-numbers language-none"><code class="language-none">Code 22E01CDeviceType 0x22 FILE_DEVICE_UNKNOWNFunction 0x807Method 0x0 METHOD_BUFFEREDAccess 0x3 FILE_READ&#x2F;WRITE_ACCESS</code></pre><p>反汇编：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">i &#x3D; Stack-&gt;Parameters.DeviceIoControl.IoControlCode - 0x22E01C;&#x2F;&#x2F; i&#x3D;0if ( Stack-&gt;Parameters.DeviceIoControl.IoControlCode &#x3D;&#x3D; 0x22E01C&amp;&amp; Stack-&gt;Parameters.DeviceIoControl.OutputBufferLength &#x3D;&#x3D; 4 ) &#123;&#x2F;&#x2F; !!!    while ( g_pids[i] ) &#123;        if ( (unsigned int)++i &gt;&#x3D; 0x10 )        break;                    &#x2F;&#x2F; g_pids is full    &#125;    g_pids[i] &#x3D; *(HANDLE *)Irp-&gt;AssociatedIrp.SystemBuffer;&#125;</code></pre><h2 id="进程通知回调"><a href="#进程通知回调" class="headerlink" title="进程通知回调"></a>进程通知回调</h2><p>只有g_buffer不为空时才执行功能</p><p>进程注销则将g_pids[]中对应元素清零</p><p>进程创建则大量的<code>int 2E</code>中断</p><p>进程创建分支的结构：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; void __stdcall OnProcessNotify(&#x2F;&#x2F;   PEPROCESS Process,&#x2F;&#x2F;   HANDLE ProcessId,&#x2F;&#x2F;   PS_CREATE_NOTIFY_INFO *Create)i &#x3D; 0;while(g_pids[i] !&#x3D; Process) &#123;    i +&#x3D; 4;    if(i &lt; 0x40) &#123;        continue;    &#125;else &#123;        if(ObOpenObjectByPointer()) &#123;            &#x2F;&#x2F; ...        &#125;        return;    &#125;&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/practicalre/">practicalre</category>
      
      
      <comments>https://windgodm.github.io/blog/post/practicalreD.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《逆向工程实战》实例B</title>
      <link>https://windgodm.github.io/blog/post/practicalreB.html</link>
      <guid>https://windgodm.github.io/blog/post/practicalreB.html</guid>
      <pubDate>Tue, 08 Mar 2022 04:00:00 GMT</pubDate>
      
      <description>《逆向工程实战》实例B 部分分析</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="《逆向工程实战》实例B（练习部分）"><a href="#《逆向工程实战》实例B（练习部分）" class="headerlink" title="《逆向工程实战》实例B（练习部分）"></a>《逆向工程实战》实例B（练习部分）</h1><p>参照书上对实例B<code>OnProcessNotify(sub_4045F8)</code>、<code>sub_4038F0</code>的分析<br>对实例B进行的一些分析记录</p><p>一个x64的驱动后门</p><p><strong>进程创建回调</strong>、<strong>sub_4038F0</strong>部分是根据书本分析过程复现的记录</p><h2 id="结构体还原"><a href="#结构体还原" class="headerlink" title="结构体还原"></a>结构体还原</h2><p>在40A590有一个结构体，根据api的调用尝试还原其结构的定义</p><p><strong>OnProcessNotify(sub_4045F8)</strong></p><p>由循环可以确定+0处是结构体指针next，是一个链表</p><p>根据循环结束处的处理，猜测+8是结构体指针last，是一个双向链表</p><p>实际上+0就是<code>LIST_ENTRY</code>，后面有类似<code>RemoveEntryListmacro</code>的代码</p><p>根据其中用到的Mm系列api，可以推出部分结构</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; hex+   0  next              struc*+   8  last              struc*+  10  pid               4+  14  unknown           0xC+  20  strImageFilename  char[0x70]+  90  resource          ERESOURCE+  F8  unknown           0xF78+1070  pMdl              MDL*+1078  addr1             void*+1080  unknown           0x30+10B0  addr2             void*</code></pre><p><code>addr1</code>是通过<code>Mdl</code>重新映射的，<code>addr2</code>是通过<code>ExPoolWithTag</code>分配的</p><p>其中有如下代码，不太确定其意义：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(i &#x3D; stru_40A590.next; ;) &#123;    if() &#123;        &#x2F;&#x2F; ...        if ( i-&gt;addr2 )            ExFreePoolWithTag(i-&gt;addr2, &#39;ssss&#39;);        &#x2F;&#x2F; ...        ExFreePoolWithTag(i, &#39;ssss&#39;);        &#x2F;&#x2F; ...    &#125;&#125;</code></pre><h2 id="进程创建回调"><a href="#进程创建回调" class="headerlink" title="进程创建回调"></a>进程创建回调</h2><p>DriverEntry中注册了进程回调函数：<code>OnProcessNotify(sub_4045F8)</code></p><p>只有在进程注销的时候才执行</p><p>进入<code>CriticalRegion</code>并请求<code>ExAcquireResourceExclusiveLite</code></p><p>然后通过遍历一个双向链表<code>stru_40A590</code>，找到与当前（准备注销的进程）相关（imageFileName和pid相同）的表项，释放表项占用的内存并移出链表</p><p>表项中有一个使用Mdl重映射的地址，会解除该映射</p><p>还有一个通过tag分配的内存（不确定是页池还是非页池），表项本身也是通过tag分配的</p><p>两者都会通过<code>ExFreePoolWithTag(&#39;ssss&#39;)</code>释放</p><h2 id="DeleteFileByIrp-sub-4038F0"><a href="#DeleteFileByIrp-sub-4038F0" class="headerlink" title="DeleteFileByIrp(sub_4038F0)"></a>DeleteFileByIrp(sub_4038F0)</h2><p>该函数的功能是构造一个IRP删除指定的文件，传递IRP后会一直等待直到IRP被处理完成</p><p>（通过交叉引用发现该函数最终被用于删除<code>mbam.sys</code>）</p><p>先是通过<code>Stack = pirp-&gt;Tail.Overlay.CurrentStackLocation</code>获取当前的堆栈</p><p>然后通过<code>Stack[-1]</code>对下一层堆栈进行填充（可能是编译器优化掉了获取下一层堆栈的代码）</p><p>最后调用<code>IofCallDriver</code>把Irp传给别的设备处理（书中猜测是文件系统）</p><p>根据<code>Stack[-1].MajorFunction = IRP_MJ_SET_INFORMATION; // 6</code>可以判断出下面union的是<code>SetFile</code>字段</p><p>填充的比较重要的内容如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">buf &#x3D; 1;pirp-&gt;AssociatedIrp.SystemBuffer &#x3D; &amp;buf;&#x2F;&#x2F; ...Stack[-1].Parameters.SetFile.DeleteHandle &#x3D; hFile;Stack[-1].Parameters.SetFile.FileObject &#x3D; pFileObj;Stack[-1].Parameters.SetFile.FileInformationClass &#x3D; FileDispositionInformation;Stack[-1].Parameters.SetFile.Length &#x3D; 1;</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>IRP_MJ_SET_INFORMATION</strong></p><p>Parameters.SetFile.FileInformationClass：SystemBuffer指向的结构体的类型</p><p>Parameters.SetFile.Length：SystemBuffer指向结构体的长度</p><p>AssociatedIrp.SystemBuffer：指向包含新信息设置的缓冲区</p><p><strong>NtSetInformationFile function (ntifs.h)</strong></p><p>FileDispositionInformation (13) 请求在文件关闭时将其删除</p><p><strong>FILE_DISPOSITION_INFORMATION_EX structure (ntddk.h)</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct _FILE_DISPOSITION_INFORMATION_EX &#123;ULONG Flags;&#125; FILE_DISPOSITION_INFORMATION_EX, *PFILE_DISPOSITION_INFORMATION_EX;</code></pre><table><thead><tr><th>Flag Name</th><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>FILE_DISPOSITION_DELETE</td><td>0x00000001</td><td>Specifies the system should delete a file.</td></tr></tbody></table></blockquote><p>根据以上信息，<code>FileDispositionInformation</code>指示<code>SystemBuffer</code>的类型为<code>_FILE_DISPOSITION_INFORMATION_EX</code><br>而该结构体内容为<code>Flags=1</code>，即删除文件的意思</p><p>给IRP添加了一个完成例程<code>Stack_1[-1].CompletionRoutine = CompletaRoutine</code>（sub_4038B4）</p><p>该完成例程会设置IRP的Event，用于通知上一层处理函数（即<code>sub_4038F0</code>）IRP已完成</p><p>在<code>sub_4038F0</code>会等待该事件：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if ( IofCallDriver(pDevObj_, pirp_1) &#x3D;&#x3D; 0x103 )&#x2F;&#x2F; STATUS_PENDING    KeWaitForSingleObject(&amp;Event, Executive, 0, 1u, 0i64);&#x2F;&#x2F; Event will be set in CompletionRoutinereturn (unsigned int)pirp_1-&gt;IoStatus.Status;</code></pre>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/practicalre/">practicalre</category>
      
      
      <comments>https://windgodm.github.io/blog/post/practicalreB.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《逆向工程实战》实例A</title>
      <link>https://windgodm.github.io/blog/post/practicalreA.html</link>
      <guid>https://windgodm.github.io/blog/post/practicalreA.html</guid>
      <pubDate>Mon, 07 Mar 2022 04:00:00 GMT</pubDate>
      
      <description>《逆向工程实战》实例A分析</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="《逆向工程实战》实例A"><a href="#《逆向工程实战》实例A" class="headerlink" title="《逆向工程实战》实例A"></a>《逆向工程实战》实例A</h1><p>参照书上对实例A的分析过程，对实例A的完整分析记录</p><p>一个挺短的驱动后门（x86），用于支持R3程序修改SSDT，估计是xp或者win7时代的</p><h2 id="DriverEntry-amp-DriverUnload"><a href="#DriverEntry-amp-DriverUnload" class="headerlink" title="DriverEntry &amp; DriverUnload"></a>DriverEntry &amp; DriverUnload</h2><p><code>DosDevices</code>是<code>??</code>的别名</p><p><strong>DriverEntry</strong></p><p>只是正常的初始化</p><p>IRP：支持Create、Close、DeviceIoControl：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov     ecx, [ebp+DriverObject] ; ecx &#x3D; pDriverObj; 0,MJ_CREATEmov     dword ptr [ecx+38h], offset MJ_Create_Close_Ioctlmov     edx, [ebp+DriverObject]; 2,MJ_CLOSEmov     dword ptr [edx+40h], offset MJ_Create_Close_Ioctlmov     eax, [ebp+DriverObject]; 0xE,MJ_DEVICE_CONTROLmov     dword ptr [eax+70h], offset MJ_Create_Close_Ioctlmov     ecx, [ebp+DriverObject]; pDriverObj-&gt;DriverUnloadmov     dword ptr [ecx+34h], offset DriverUnload</code></pre><p>支持DriverUnload</p><p>先尝试删除符号链接再重新创建</p><p><strong>DriverUnload</strong></p><p>也是正常的卸载</p><p>删除了符号链接和设备</p><p>从传入的驱动对象中获取设备指针：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov     eax, [ebp+DriverObject] ; pDriverObjmov     ecx, [eax+4]    ; pDriverObj-&gt;DeviceObjectpush    ecx             ; DeviceObjectcall    ds:IoDeleteDevice</code></pre><h2 id="IRP处理函数"><a href="#IRP处理函数" class="headerlink" title="IRP处理函数"></a>IRP处理函数</h2><p>Create、Close、DeviceIoCtrl都在同一个函数中</p><p>首先是初始化IRP的返回状态，并获取IRP的类型：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov     eax, [ebp+Irp]mov     ecx, [ebp+status]mov     [eax+18h], ecx  ; Irp-&gt;IoStatus.Status &#x3D; status &#x3D; 0mov     edx, [ebp+Irp]mov     dword ptr [edx+1Ch], 0 ; Irp-&gt;IoStatus.Information &#x3D; 0mov     eax, [ebp+Irp]mov     ecx, [eax+60h]  ; ecx &#x3D; Irp-&gt;Tail.Overlay.CurrentStackLocationmov     [ebp+stack], ecxmov     edx, [ebp+stack]movzx   eax, byte ptr [edx] ; eax &#x3D; stack-&gt;MajorFunction</code></pre><p>IoGetCurrentIrpStackLocation是内联的：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">PIO_STACK_LOCATION IoGetCurrentIrpStackLocation(PIRP Irp) &#123;    return Irp-&gt;Tail.Overlay.CurrentStackLocation; &#x2F;&#x2F; ret [pIrp + 0x60]&#125;</code></pre><p>整个处理逻辑是如果为Create、Close则直接返回成功</p><p>如果为DeviceIoCtrl则检测CTL_CODE</p><p><strong>DeviceIoCtrl</strong></p><p>这一段汇编主要都是对结构体的操作，参照着结构体的定义就行</p><p>需要注意的是，IO_STACK_LOCATION中有个union，要根据IRP的类型选择对应的结构</p><p>这里贴一下实例中用到的偏移：</p><pre class="line-numbers language-none"><code class="language-none">IO_STACK_LOCATION  0xC  Parameters.DeviceIoControl.IoControlCodeIRP  0xC  AssociatedIrp.SystemBuffer  0x18 IoStatus.Status  0x1C IoStatus.Information</code></pre><p>会判断<code>CTL_CODE</code>是否为<code>0x22C004</code></p><p>如果不是则返回<code>0xC0000010(STATUS_INVALID_OPERATION)</code></p><p>如果是则调用<code>sub_103B0</code></p><h2 id="DeviceIoCtrl处理函数"><a href="#DeviceIoCtrl处理函数" class="headerlink" title="DeviceIoCtrl处理函数"></a>DeviceIoCtrl处理函数</h2><p><code>IOCTL_handler(sub_103B0)</code>是处理<code>CTL_CODE=0x22C004</code>的函数（只有一个控制码）</p><pre class="line-numbers language-none"><code class="language-none">CTL_CODE 0x22C004DeviceType 0x22 FILE_DEVICE_UNKNOWN (def in ntifs.h DEVICE TYPE)Function  0x1Method    0x0   METHOD_NEITHERAccess    0x3   FILE_ACCESS_ANY</code></pre><p>其中会调用到<code>sub_10460</code>和<code>sub_10550</code>，这两个是一对的函数</p><p><strong>MapLockedMdl(sub_10460)</strong></p><p>这个就是创建一个Mdl、以写权限锁定页面，映射</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">*pPMdl &#x3D; IoAllocateMdl(VirtualAddress, Length, 0, 0, 0);MmProbeAndLockPages(*pPMdl, KernelMode, IoWriteAccess);newAddr &#x3D; MmMapLockedPagesSpecifyCache(*pPMdl, KernelMode, MmNonCached, 0, 0, NormalPagePriority);&#x2F;&#x2F; KernelMode 0&#x2F;&#x2F; NormalPagePriority 0x10</code></pre><p>MmProbeAndLockPages需要在try中执行，在函数开头会有一段相关的汇编：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">push    ebpmov     ebp, esp                ; stack framepush    0FFFFFFFFh              ; ???push    offset stru_10748       ; ???push    offset _except_handler3 ; NewSEH.Handlermov     eax, large fs:0push    eax                     ; NewSEH.Next &#x3D; pOldSEHmov     large fs:0, esp         ; pSEH &#x3D; &amp;NewSEHadd     esp, 0FFFFFFF0hpush    ebxpush    esipush    edimov     [ebp+ms_exc.old_esp], esp</code></pre><p><strong>UnmapLockedMdl(sub_10550)</strong></p><p>这个函数就是解除锁定页面映射、解锁页面，释放Mdl</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void __stdcall UnmapMdl(PMDL MemoryDescriptorList, PVOID BaseAddress)&#123;  MmUnmapLockedPages(BaseAddress, MemoryDescriptorList);  MmUnlockPages(MemoryDescriptorList);  IoFreeMdl(MemoryDescriptorList);&#125;</code></pre><p><strong>IOCTL_handler(sub_103B0)</strong></p><p>现在回到<code>IOCTL_handler(sub_103B0)</code></p><p>整个函数IRQL处于DpcLevel中，会屏蔽掉线程分发器</p><p>SDT的结构体：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct _KSERVICE_TABLE_DESCRIPTOR&#123;    PULONG Base;   &#x2F;&#x2F; address or SSDT    PULONG Count;    ULONG Limit;   &#x2F;&#x2F; number of SSDT    PUCHAR Number;    &#x2F;&#x2F; ...&#125; KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</code></pre><p>首先通过<code>MapLockedMdl(sub_10460)</code>创建了一个SSDT的写入权限映射：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">pSSDT &#x3D; (UINT32 *)MapLockedMdl(    &amp;MemoryDescriptorList,    KeServiceDescriptorTable.Base,    4 * KeServiceDescriptorTable.Limit;)</code></pre><p>然后修改SSDT（符号：KiServiceTable）</p><p>反编译：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for ( i &#x3D; 0; i &lt; *newSSDT; ++i ) &#123;    if ( newSSDT[i + 1] ) &#123;        if ( pSSDT[i] !&#x3D; newSSDT[i + 1] )    _InterlockedExchange(pSSDT[i], newSSDT[i + 1]);    &#125;&#125;</code></pre><p>核心部分反汇编：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov     edx, [ebp+var_8]mov     eax, [ebp+newSSDT]mov     ecx, [eax+edx*4+4] ; ecx &#x3D; newSSDT[i+1]mov     edx, [ebp+var_8]mov     eax, [ebp+pSSDT]lea     edx, [eax+edx*4] ; edx &#x3D; &amp;pSSDT[i]xchg    ecx, [edx]      ; swap(newSSDT[i+1], pSSDT[i])</code></pre><p>得到输入缓冲区的结构如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int SYSCALL_NUM;struct INBUF &#123;    int number &#x3D; SYSCALL_NUM;    void* syscalls[SYSCALL_NUM];&#125;</code></pre><p>最后是释放与还原环境</p><h2 id="思考题与总结"><a href="#思考题与总结" class="headerlink" title="思考题与总结"></a>思考题与总结</h2><p>win10这种办法应该是不行的，ssdt是只读的<br>对只读内存，MmProbeAndLockPages(IoWriteAccess)会导致蓝屏</p><p><strong>书中题目</strong></p><p>（1）这个驱动程序能工作于多核系统吗？</p><p>在《windows kernel programing》中关于高IRQL同步的章节有讲到，提高IRQL不能应对多核情况的线程同步，原因是IRQL是于cpu核心关联的</p><p>即使驱动线程所在的cpu核心的irql等级禁用了中断，另外一个核心的irql可能是0，仍然可以触发低等级的中断</p><p>（2）为什么作者认为需要把IRQL提示到DISPATCH_LEVEL？是否有必要？</p><p>我猜作者的目的是保护SSDT读写过程</p><p>通常R3通过中断进入R0，并传入一个SSDT的索引，指定要执行的SSDT表项</p><p>而DISPATCH_LEVEL是软件中断的最高级别，没有找到系统调用相关的信息，但系统调用也是通过软件中断实现的，猜测是禁用中断来达到禁止系统调用的目的</p><p>（3）普通用户如何通过这个驱动在R0上下文任意执行代码？</p><p>首先需要申请一块非页池内存，写入shellcode</p><p>然后利用该驱动把shellcode的地址写入SSDT</p><p>最后在R3触发对应的中断，就会进入R0并执行shellcode</p><p>（4）假定作者想要通过用户空间的自定义替换某些系统调用，可能会遇到哪些问题？</p><p>首先原系统调用的功能如何保留是个问题，有可能别的程序需要原功能</p><p>然后就是win10直接尝试写入SSDT会蓝屏，MmProbeAndLockPages(IoWriteAccess)也会蓝</p><p>另外shellcode需要在非页池内存中，如果在用户空间或页池中，可能会出现上下文不同或者换出的问题</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/practicalre/">practicalre</category>
      
      
      <comments>https://windgodm.github.io/blog/post/practicalreA.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《Windows Kernel Programming》 笔记 8~9 回调</title>
      <link>https://windgodm.github.io/blog/post/wkp8-9.html</link>
      <guid>https://windgodm.github.io/blog/post/wkp8-9.html</guid>
      <pubDate>Tue, 01 Mar 2022 04:00:00 GMT</pubDate>
      
      <description>《Windows Kernel Programming》 笔记 8~9 回调</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Windows-Kernel-Programming-笔记-8-9-回调"><a href="#Windows-Kernel-Programming-笔记-8-9-回调" class="headerlink" title="Windows Kernel Programming 笔记 8~9 回调"></a>Windows Kernel Programming 笔记 8~9 回调</h1><h2 id="8-进程、线程通知（S5）"><a href="#8-进程、线程通知（S5）" class="headerlink" title="8 进程、线程通知（S5）"></a>8 进程、线程通知（S5）</h2><p>内核驱动一种重要的机制：在某些重要活动发生时通知驱动</p><p>这章主要关于进程、线程的创建和销毁，还有映像的加载</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>使用这些回调的驱动程序必须在PE头中有 IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY 标志</p><p>没有它，注册函数的调用返回 STATUS_ACCESS_DENIED </p><p>需要在 链接器-&gt;命令行 中添加 <code>/integritycheck</code></p></blockquote><h3 id="8-1-进程通知"><a href="#8-1-进程通知" class="headerlink" title="8.1 进程通知"></a>8.1 进程通知</h3><p>驱动可以在进程创建或销毁时收到通知</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>windows还提供另一种通知机制ETW，来记录进程的创建或销毁，这些通知可以被R3的进程接收</p><p>但ETW有固定的1~3s的延迟</p></blockquote><p>注册进程通知：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">NTSTATUSPsSetCreateProcessNotifyRoutineEx (_In_ PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine,_In_ BOOLEAN Remove);typedef void(*PCREATE_PROCESS_NOTIFY_ROUTINE_EX) (_Inout_ PEPROCESS Process,_In_ HANDLE ProcessId,_Inout_opt_ PPS_CREATE_NOTIFY_INFO CreateInfo);</code></pre><p>进程退出通知的<code>CreateInfo</code>为<code>NULL</code></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>目前系统范围限制为 64 次注册，因此理论上注册功能可能会失败。 </p></blockquote><p>当进程创建时，回调函数运行在<strong>创建进程的线程</strong>的上下文</p><p>当进程退出时，回调函数运行在<strong>the last thread to exit the process</strong>的上下文</p><p>回调函数都运行在<code>critical region</code>（normal kernel APCs disabled）</p><p>提供给回调函数的参数的结构体：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct _PS_CREATE_NOTIFY_INFO &#123;    _In_ SIZE_T Size;    union &#123;        _In_ ULONG Flags;        struct &#123;            _In_ ULONG FileOpenNameAvailable : 1;            _In_ ULONG IsSubsystemProcess : 1;            _In_ ULONG Reserved : 30;        &#125;;    &#125;;    _In_ HANDLE ParentProcessId;             &#x2F;&#x2F; 父进程    _In_ CLIENT_ID CreatingThreadId;         &#x2F;&#x2F; 创建进程的调用方    _Inout_ struct _FILE_OBJECT *FileObject;    _In_ PCUNICODE_STRING ImageFileName;    _In_opt_ PCUNICODE_STRING CommandLine;    _Inout_ NTSTATUS CreationStatus;         &#x2F;&#x2F; 返回给调用者&#125; PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;</code></pre><p>ImageFileName：如果设置了标志 FileOpenNameAvailable 则可用 </p><p>CreationStatus：设置为失败状态可以使进程创建失败（比如<code>STATUS_ACCESS_DENIED</code>）</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>win10 1607开始，提供了另外一个函数<code>PsSetCreateProcessNotifyRoutineEx2</code></p><p>与之前的类似但<code>invoked on Pico processes</code>，用于WSL</p></blockquote><h3 id="8-2-实现进程通知"><a href="#8-2-实现进程通知" class="headerlink" title="8.2 实现进程通知"></a>8.2 实现进程通知</h3><p>实现一个驱动记录所有进程的创建和销毁到一个链表中<br>使用fast mutex保证链表的安全</p><p>结构体定义：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; common.henum class RecordType : short &#123;    None,    ProcessCreate,    ProcessExit&#125;;struct RecordHeader &#123;    RecordType type;    USHORT size;    LARGE_INTEGER time;&#125;;struct ProcessCreateInfo : RecordHeader &#123;    ULONG pid;    ULONG parentPid;    USHORT cmdLength;    USHORT cmdOffset;&#125;;struct ProcessExitInfo : RecordHeader &#123;    ULONG pid;&#125;;&#x2F;&#x2F; driver.htemplate&lt;typename T&gt;struct RecordEntry &#123;LIST_ENTRY Entry;T Data;&#125;;struct RecordLinks &#123;LIST_ENTRY head;int count;MyFastMutex mutex;&#125;;</code></pre><p>回调函数：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void OnProcessNotify(    PEPROCESS Process,    HANDLE ProcessId,PPS_CREATE_NOTIFY_INFO CreateInfo) &#123;    if (CreateInfo) &#123;    &#x2F;&#x2F; process create    &#125;    else &#123;    &#x2F;&#x2F; process exit    &#125;&#125;</code></pre><h3 id="8-3-提供数据给用户模式"><a href="#8-3-提供数据给用户模式" class="headerlink" title="8.3 提供数据给用户模式"></a>8.3 提供数据给用户模式</h3><p>详情看代码吧</p><h3 id="8-4-线程通知"><a href="#8-4-线程通知" class="headerlink" title="8.4 线程通知"></a>8.4 线程通知</h3><p>内核提供线程创建和销毁的回调机制</p><p>API：<code>PsSetCreateThreadNotifyRoutine</code>、<code>PsRemoveCraeteThreadNotifyRoutine</code></p><p>回调函数：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void OnThreadNotify(HANDLE ProcessId, HANDLE ThreadId, BOOLEAN Create) &#123;&#x2F;&#x2F; ...&#125;</code></pre><h3 id="8-5-映像加载通知"><a href="#8-5-映像加载通知" class="headerlink" title="8.5 映像加载通知"></a>8.5 映像加载通知</h3><p>API：<code>PsSetLoadImageNotifyRoutine</code>、<code>PsRemoveLoadImageNotifyRoutine</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef void (*PLOAD_IMAGE_NOTIFY_ROUTINE)(    _In_opt_ PUNICODE_STRING FullImageName,    _In_ HANDLE ProcessId, &#x2F;&#x2F; pid into which image is being mapped    _In_ PIMAGE_INFO ImageInfo);typedef struct _IMAGE_INFO &#123;    union &#123;        ULONG Properties;        struct &#123;            ULONG ImageAddressingMode : 8; &#x2F;&#x2F; Code addressing mode            ULONG SystemModeImage : 1; &#x2F;&#x2F; System mode image            ULONG ImageMappedToAllPids : 1; &#x2F;&#x2F; Image mapped into all processes            ULONG ExtendedInfoPresent : 1; &#x2F;&#x2F; IMAGE_INFO_EX available            ULONG MachineTypeMismatch : 1; &#x2F;&#x2F; Architecture type mismatch            ULONG ImageSignatureLevel : 4; &#x2F;&#x2F; Signature level            ULONG ImageSignatureType : 3; &#x2F;&#x2F; Signature type            ULONG ImagePartialMap : 1; &#x2F;&#x2F; Nonzero if entire image is not mapped            ULONG Reserved : 12;        &#125;;    &#125;;    PVOID ImageBase;    ULONG ImageSelector;    SIZE_T ImageSize;    ULONG ImageSectionNumber;&#125; IMAGE_INFO, *PIMAGE_INFO;</code></pre><p>ExtendedInfoPresent：如果该标志位被设置，则<code>IMAGE_INFO</code>是<code>IMAGE_INFO_EX</code>的一部分</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>没有映像卸载的回调机制</p></blockquote><p>ProcessId是加载该映像的进程的pid. 对于驱动程序（内核映像），此值为零。</p><h3 id="8-6-练习"><a href="#8-6-练习" class="headerlink" title="8.6 练习"></a>8.6 练习</h3><ol><li>创建一个驱动，监控进程创建；并提供一个客户端用于设置可执行路径黑名单（todo）</li><li>创建一个驱动 （或给S5_SysMon添加功能)），检测远程线程创建（进程中的第一个线程总是“远程”创建的），并通知客户端。写一个测试程序，使用<code>CreateRemoteThread</code>。</li></ol><p><strong>2、检测远程线程创建：</strong></p><p>思路：OnThreadNotify的在调用方上下文，检查当前上下文的进程的pid和创建线程的pid是否一致</p><p>通过EPROCESS获取pid比通过pid获取EPROCESS简单一点:</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">PsGetProcessId  proc near    mov     rax, [rcx+440h] ; PEPROCESS-&gt;UniqueProcessId    retnPsGetProcessId  endp</code></pre><p>检测代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void OnThreadNotify(HANDLE ProcessId, HANDLE ThreadId, BOOLEAN Create) &#123;if (Create) &#123;auto curPid &#x3D; PsGetCurrentProcessId();if (curPid !&#x3D; ProcessId) &#123;KdPrint((&quot;Detect remote thread create pid:%u tid:%u rpid:%u&quot;,HandleToULong(ProcessId),HandleToULong(ThreadId),HandleToULong(curPid)));&#125;&#125;&#125;</code></pre><p>测试结果：</p><pre class="line-numbers language-none"><code class="language-none">被注入进程pid：3480注入器pid：5336&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;18:00:59.568: Thread Createpid:3480 tid:3164&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;18:00:59.569: Image Loadpid:3480 ImageBase:0x6FC30000FullImageName:\Device\HarddiskVolume3\Users\wind\Desktop\MyDll.dll&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Detect remote thread create pid:3480 tid:3164 rpid:5336</code></pre><h2 id="9-对象、注册表通知"><a href="#9-对象、注册表通知" class="headerlink" title="9 对象、注册表通知"></a>9 对象、注册表通知</h2><h3 id="9-1-对象通知"><a href="#9-1-对象通知" class="headerlink" title="9.1 对象通知"></a>9.1 对象通知</h3><p>驱动可以在打开或复制某些对象的句柄时，收到通知。这些对象的类型可以是进程、线程、Desktop(win10)</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Desktop 对象</p><p>一个desktop包括windows、menus、hooks（SetWindowsHookEx）</p><p>当一个用户登录，两个desktop会被创建。</p><p>一个由<code>Winlogon.exe</code>创建名为<code>Winlogon</code>，就是<code>Secure Attention Sequence（Ctrl+Alt+Del）</code>时的桌面</p><p>一个名为<code>default</code>，就是平常看到的桌面</p><p>使用<code>SwitchDesktop()</code>切换desktop</p><p><a href="https://scorpiosoftware.net/2019/02/17/windows-10-desktops-vs-sysinternals-desktops/">https://scorpiosoftware.net/2019/02/17/windows-10-desktops-vs-sysinternals-desktops/</a></p></blockquote><p>注册对象回调相关定义：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">NTSTATUS ObRegisterCallbacks (    _In_ POB_CALLBACK_REGISTRATION CallbackRegistration,    _Outptr_ PVOID *RegistrationHandle);typedef struct _OB_CALLBACK_REGISTRATION &#123;    _In_ USHORT Version;    _In_ USHORT OperationRegistrationCount;    _In_ UNICODE_STRING Altitude;    _In_ PVOID RegistrationContext;    _In_ OB_OPERATION_REGISTRATION *OperationRegistration;&#125; OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;typedef struct _OB_OPERATION_REGISTRATION &#123;    _In_ POBJECT_TYPE *ObjectType;    _In_ OB_OPERATION Operations;    _In_ POB_PRE_OPERATION_CALLBACK PreOperation;    _In_ POB_POST_OPERATION_CALLBACK PostOperation;&#125; OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION</code></pre><p><strong>OB_CALLBACK_REGISTRATION：</strong></p><p><code>Version</code>：必须设为<code>OB_FLT_REGISTRATION_VERSION</code></p><p><code>Altitude</code>：字符串格式的数字，是回调执行的顺序（越小越先执行），必须不能与别的重复（增加随机的小数点后数字）</p><p>Altitude重复会返回<code>STATUS_FLT_INSTANCE_ALTITUDE_COLLISION</code></p><p><code>RegistrationContext</code>：驱动定义的传递给回调函数的值</p><p><strong>OB_OPERATION_REGISTRATION：</strong></p><p><code>ObjectType</code>：指向全局变量<code>PsProcessType</code>、<code>PsThreadType</code>、<code>ExDesktopObjectType</code></p><p><code>Operations</code>：create/open(<code>OB_OPERATION_HANDLE_CREATE</code>)，duplicate(<code>OB_OPERATION_HANDLE_DUPLICATE</code>)</p><h4 id="9-1-1-Pre-Operation-回调"><a href="#9-1-1-Pre-Operation-回调" class="headerlink" title="9.1.1 Pre-Operation 回调"></a>9.1.1 Pre-Operation 回调</h4><p>在craete/open/duplicate之前</p><p>回调函数会接收到如下结构体：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 回调函数定义OB_PREOP_CALLBACK_STATUS OnPreOpenProcess(    PVOID RegistrationContext,    POB_PRE_OPERATION_INFORMATION Info)typedef struct _OB_PRE_OPERATION_INFORMATION &#123;    _In_ OB_OPERATION Operation; &#x2F;&#x2F; craete&#x2F;open&#x2F;duplicate    union &#123;        _In_ ULONG Flags;        struct &#123;            _In_ ULONG KernelHandle:1;            _In_ ULONG Reserved:31;        &#125;;    &#125;;    _In_ PVOID Object;    _In_ POBJECT_TYPE ObjectType;    _Out_ PVOID CallContext; &#x2F;&#x2F; &lt;&#x3D;RegistrationContext    _In_ POB_PRE_OPERATION_PARAMETERS Parameters;&#125; OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;typedef union _OB_PRE_OPERATION_PARAMETERS &#123;    _Inout_ OB_PRE_CREATE_HANDLE_INFORMATION CreateHandleInformation;    _Inout_ OB_PRE_DUPLICATE_HANDLE_INFORMATION DuplicateHandleInformation;&#125; OB_PRE_OPERATION_PARAMETERS, *POB_PRE_OPERATION_PARAMETERS;typedef struct _OB_PRE_CREATE_HANDLE_INFORMATION &#123;    _Inout_ ACCESS_MASK DesiredAccess;    _In_ ACCESS_MASK OriginalDesiredAccess;&#125; OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;typedef struct _OB_PRE_DUPLICATE_HANDLE_INFORMATION &#123;    _Inout_ ACCESS_MASK DesiredAccess;    _In_ ACCESS_MASK OriginalDesiredAccess;    _In_ PVOID SourceProcess;    _In_ PVOID TargetProcess;&#125; OB_PRE_DUPLICATE_HANDLE_INFORMATION, *POB_PRE_DUPLICATE_HANDLE_INFORMATION;</code></pre><h4 id="9-1-2-Post-Operation-回调"><a href="#9-1-2-Post-Operation-回调" class="headerlink" title="9.1.2 Post-Operation 回调"></a>9.1.2 Post-Operation 回调</h4><p>在操作完成后，不能修改任何东西，只能看结果</p><p>回调函数接收以下结构体：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct _OB_POST_OPERATION_INFORMATION &#123;    _In_ OB_OPERATION Operation; &#x2F;&#x2F; craete&#x2F;open&#x2F;duplicate    union &#123;        _In_ ULONG Flags;        struct &#123;            _In_ ULONG KernelHandle:1;            _In_ ULONG Reserved:31;        &#125;;    &#125;;    _In_ PVOID Object;    _In_ POBJECT_TYPE ObjectType;    _In_ PVOID CallContext; &#x2F;&#x2F; &lt;&#x3D;RegistrationContext    _In_ NTSTATUS ReturnStatus;    _In_ POB_POST_OPERATION_PARAMETERS Parameters;&#125; OB_POST_OPERATION_INFORMATION,*POB_POST_OPERATION_INFORMATION;</code></pre><h3 id="9-2-进程保护驱动（S6）"><a href="#9-2-进程保护驱动（S6）" class="headerlink" title="9.2 进程保护驱动（S6）"></a>9.2 进程保护驱动（S6）</h3><p>保护进程不被注销（禁止打开具有对应权限的句柄）</p><p>修改进程对象的DesiredAccess即可</p><p>也可以去掉Read、Write的Access，达到禁止读写的目的</p><p>初始化：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">OB_OPERATION_REGISTRATION objOps[] &#x3D; &#123;    &#123;        PsProcessType,        OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE,        OnPreOpenProcess, &#x2F;&#x2F; pre        nullptr           &#x2F;&#x2F; post    &#125;&#125;;OB_CALLBACK_REGISTRATION objCallback &#x3D; &#123;    OB_FLT_REGISTRATION_VERSION,    1, &#x2F;&#x2F; count    RTL_CONSTANT_STRING(L&quot;12345.114514&quot;), &#x2F;&#x2F; altitude    nullptr, &#x2F;&#x2F; context    objOps&#125;;status &#x3D; ObRegisterCallbacks(&amp;objCallback, &amp;g_data.regHandle);if (status &lt; 0) break;</code></pre><p>卸载：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(g_data.regHandle)ObUnRegisterCallbacks(g_data.regHandle);</code></pre><p>回调函数：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">OB_PREOP_CALLBACK_STATUS OnPreOpenProcess(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION Info) &#123;UNREFERENCED_PARAMETER(RegistrationContext);if (Info-&gt;KernelHandle)return OB_PREOP_SUCCESS;auto proc &#x3D; (PEPROCESS)Info-&gt;Object;auto pid &#x3D; HandleToULong(PsGetProcessId(proc));AutoLock&lt;MyFastMutex&gt; lock(g_data.mutex);if (FindProcess(pid)) &#123;Info-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess &amp;&#x3D; (~PROCESS_TERMINATE);&#125;return OB_PREOP_SUCCESS;&#125;</code></pre><h3 id="9-3-注册表通知"><a href="#9-3-注册表通知" class="headerlink" title="9.3 注册表通知"></a>9.3 注册表通知</h3><p>API：<code>CmRegisterCallbackEx</code>、<code>CmUnRegisterCallback</code></p><p>回调函数说明（MSDN上的全一点）：<a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nc-wdm-ex_callback_function">EX_CALLBACK_FUNCTION (wdm.h) - Windows drivers | Microsoft Docs</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">NTSTATUS RegistryCallback (    _In_ PVOID CallbackContext,    _In_opt_ PVOID Argument1,    _In_opt_ PVOID Argument2);</code></pre><p>部分内容：</p><table><thead><tr><th>Notification(Arg1)</th><th>Associated structure(Arg2)</th></tr></thead><tbody><tr><td>RegNtPreDeleteKey</td><td>REG_DELETE_KEY_INFORMATION</td></tr><tr><td>RegNtPostDeleteKey</td><td>REG_POST_OPERATION_INFORMATION</td></tr><tr><td>RegNtPreSetValueKey</td><td>REG_SET_VALUE_KEY_INFORMATION</td></tr><tr><td>RegNtPostSetValueKey</td><td>REG_POST_OPERATION_INFORMATION</td></tr><tr><td>RegNtPreCreateKey</td><td>REG_PRE_CREATE_KEY_INFORMATION</td></tr><tr><td>RegNtPostCreateKey</td><td>REG_POST_CREATE_KEY_INFORMATION</td></tr></tbody></table><p><strong>Pre</strong></p><p>回调函数可以做的事：</p><ul><li>返回<code>STATUS_SUCCESS</code>，让配置管理器继续处理注册表操作</li><li>返回一些错误状态，让配置管理器不执行操作，并将该错误状态返回给调用方</li><li>处理请求，并返回<code>STATUS_CALLBACK_BYPASS</code>，配置管理器不执行任何操作，并将返回成功状态</li></ul><p><strong>Post</strong></p><p>回调函数可以做的事：</p><ul><li>监视操作结果</li><li>修改返回给调用方的状态（<code>ReturnStatus</code>），然后回调函数返回<code>STATUS_CALLBACK_BYPASS</code></li><li>修改返回的参数（<code>REG_xxx_KEY_INFORMATION </code>），然后回调函数返回<code>STATUS_SUCCESS</code></li></ul><p><strong>性能注意事项</strong></p><p>注册表的读操作经常发生，驱动应避免处理读操作<br>如果确实需要处理读操作，应限制只处理某些key</p><p>写和创建操作相对比较少</p><p>底线很简单：为尽可能少的键做尽可能少的事情 </p><h3 id="9-4-实现注册表通知"><a href="#9-4-实现注册表通知" class="headerlink" title="9.4 实现注册表通知"></a>9.4 实现注册表通知</h3><p>拓展S5_SysMon，记录<code>RegNtPostSetValueKey</code>且在<code>HKEY_LOCAL_MACHINE</code>目录下的注册表操作</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; registerUNICODE_STRING altitude &#x3D; RTL_CONSTANT_STRING(L&quot;7657.114514&quot;);status &#x3D; CmRegisterCallbackEx(    OnRegistryNotify,    &amp;altitude,    g_data.pDriverObj,    nullptr,    &amp;g_data.regCookie,    nullptr);&#x2F;&#x2F; unregisterstatus &#x3D; CmUnRegisterCallback(g_data.regCookie);&#x2F;&#x2F; callbackNTSTATUS OnRegistryNotify(_In_ PVOID CallbackContext, _In_opt_ PVOID Argument1, _In_opt_ PVOID Argument2) &#123;UNREFERENCED_PARAMETER(CallbackContext);static const WCHAR machine[] &#x3D; L&quot;\\REGISTRY\\MACHINE\\&quot;;auto status &#x3D; STATUS_SUCCESS;switch ((REG_NOTIFY_CLASS)(ULONG_PTR)Argument1) &#123;case RegNtPostSetValueKey: &#123;auto args &#x3D; (PREG_POST_OPERATION_INFORMATION)Argument2;if (!args) break;if (args-&gt;Status &lt; 0) break;PCUNICODE_STRING name &#x3D; nullptr;status &#x3D; CmCallbackGetKeyObjectIDEx(&amp;g_data.regCookie, args-&gt;Object, nullptr, &amp;name, 0);if (status &lt; 0) break;if (wcsncmp(name-&gt;Buffer, machine, ARRAYSIZE(machine) - 1) &#x3D;&#x3D; 0) &#123;auto preInfo &#x3D; (PREG_SET_VALUE_KEY_INFORMATION)args-&gt;PreInformation;&#x2F;&#x2F;if (!preInfo) break;&#x2F;&#x2F; allocauto allocSize &#x3D; sizeof(RecordEntry&lt;RegistrySetValueInfo&gt;);auto recordEntry &#x3D; (RecordEntry&lt;RegistrySetValueInfo&gt;*)ExAllocatePoolWithTag(PagedPool,allocSize,DRIVER_TAG);if (recordEntry &#x3D;&#x3D; nullptr) break;RtlZeroMemory(recordEntry, allocSize);auto&amp; record &#x3D; recordEntry-&gt;Data;record.type &#x3D; RecordType::RegistrySetValue;record.size &#x3D; sizeof(RegistrySetValueInfo);KeQuerySystemTimePrecise(&amp;record.time);record.pid &#x3D; HandleToULong(PsGetCurrentProcessId());record.tid &#x3D; HandleToULong(PsGetCurrentThreadId());wcsncpy_s(record.keyName, name-&gt;Buffer, name-&gt;Length &#x2F; sizeof(WCHAR) - 1);wcsncpy_s(record.valueName, preInfo-&gt;ValueName-&gt;Buffer, preInfo-&gt;ValueName-&gt;Length &#x2F; sizeof(WCHAR) - 1);record.dataType &#x3D; preInfo-&gt;Type;record.dataSize &#x3D; preInfo-&gt;DataSize;memcpy(record.data, preInfo-&gt;Data, min(record.dataSize, sizeof(record.data)));PushRecord(&amp;recordEntry-&gt;Entry);&#125;CmCallbackReleaseKeyObjectIDEx(name);break;&#125;default:break;&#125;return status;&#125;</code></pre><h3 id="9-5-练习"><a href="#9-5-练习" class="headerlink" title="9.5 练习"></a>9.5 练习</h3><ol><li><p>实现一个驱动程序，除非目标进程正在被调试，否则不允许被线程注入。（todo）</p></li><li><p>实现一个驱动程序，保护注册表不被修改。客户端可以选择被保护的键。（todo）</p></li><li><p>实现一个驱动程序，如果它们访问 HKEY_LOCAL_MACHINE，则将来自选定进程（由客户端选择）的注册表写入操作重定向到它们自己的私钥。 如果应用程序正在写入数据，它会转到其私有存储。如果是读取数据，首先检查私有存储，如果没有值，则转到真正的注册表项。这是应用程序沙盒的一个方面。（todo）</p></li></ol><h2 id="总结：通知的注册与注销"><a href="#总结：通知的注册与注销" class="headerlink" title="总结：通知的注册与注销"></a>总结：通知的注册与注销</h2><p>这里直接使用9.4中的练习：添加 I/O control codes 来 enable/disable 通知类型</p><p>使用了bitmap来选择开启或关闭的通知</p><p>这里整个函数都在互斥锁中（和记录通知的LIST_ENTRY用的同一个<code>FAST_MUTEX</code>），也就是不能同时修改bitmap，同时修改bitmap时、也无法向LIST_ENTRY中插入新记录的通知</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void SetNotify(UINT8 newBmNotify) &#123;AutoLock&lt;MyFastMutex&gt; lock(g_data.mutex);NTSTATUS status;UINT8 dif &#x3D; g_data.bmNotify ^ newBmNotify;do &#123;&#x2F;&#x2F; process notification if (dif &amp; SYS_MON_PROCESS_NOTIFY) &#123;if (newBmNotify &amp; SYS_MON_PROCESS_NOTIFY)&#123;KdPrint((&quot;[s5]Process On&quot;));status &#x3D; PsSetCreateProcessNotifyRoutineEx(OnProcessNotify, false);&#125;else &#123;KdPrint((&quot;[s5]Process Off&quot;));status &#x3D; PsSetCreateProcessNotifyRoutineEx(OnProcessNotify, true);&#125;&#125;&#x2F;&#x2F; thread notificationif (dif &amp; SYS_MON_THREAD_NOTIFY) &#123;if (newBmNotify &amp; SYS_MON_THREAD_NOTIFY) &#123;KdPrint((&quot;[s5]Thread On&quot;));status &#x3D; PsSetCreateThreadNotifyRoutine(OnThreadNotify);&#125;else &#123;KdPrint((&quot;[s5]Thread Off&quot;));status &#x3D; PsRemoveCreateThreadNotifyRoutine(OnThreadNotify);&#125;&#125;&#x2F;&#x2F; image load notificationif (dif &amp; SYS_MON_IMAGE_LOAD_NOTIFY) &#123;if (newBmNotify &amp; SYS_MON_IMAGE_LOAD_NOTIFY) &#123;KdPrint((&quot;[s5]Image Load On&quot;));status &#x3D; PsSetLoadImageNotifyRoutine(OnImageNotify);&#125;else&#123;KdPrint((&quot;[s5]Image Load Off&quot;));status &#x3D; PsRemoveLoadImageNotifyRoutine(OnImageNotify);&#125;&#125;&#x2F;&#x2F; register notificationif (dif &amp; SYS_MON_REGISTRY_SET_VALUE_NOTIFY) &#123;if (newBmNotify &amp; SYS_MON_REGISTRY_SET_VALUE_NOTIFY) &#123;KdPrint((&quot;[s5]Registry Set Value On&quot;));UNICODE_STRING altitude &#x3D; RTL_CONSTANT_STRING(L&quot;7657.114514&quot;);status &#x3D; CmRegisterCallbackEx(OnRegistryNotify,&amp;altitude,g_data.pDriverObj,nullptr,&amp;g_data.regCookie,nullptr);&#125;else &#123;KdPrint((&quot;[s5]Registry Set Value Off&quot;));status &#x3D; CmUnRegisterCallback(g_data.regCookie);&#125;&#125;&#125; while (false);g_data.bmNotify &#x3D; newBmNotify;&#125;</code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>8，p196，使用注册表来设置保存的信息的最大数量（todo）</p><p>8，p199，添加映像文件名到进程创建信息结构中（见S5_SysMon）</p><p>8，p207，给客户端添加功能：显示线程创建和销毁时所属的进程的映像名（todo）</p><p>8，p209，给驱动添加功能：只记录R3的映像加，客户端显示映像路径、pid、基址（见S5_SysMon）</p><p>8.6，p209，Exercises（todo）</p><p>9.2，p226，添加允许查询当前受保护进程的控制代码（todo）</p><p>9.4，p235，改进 S5_SysMon， 添加 I/O control codes 来 enable/disable 通知类型（见总结：通知的注册与注销）</p><p>9.5，p235，Exercises（todo）</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>8.6练习，如何通知R3客户端</p><h2 id="勘误"><a href="#勘误" class="headerlink" title="勘误"></a>勘误</h2><p>8</p><p>p207，<code>PsRemoveImageNotifyRoutine</code>应该为<code>PsRemoveLoadImageNotifyRoutine</code></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/kernel/">kernel</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wkp/">wkp</category>
      
      
      <comments>https://windgodm.github.io/blog/post/wkp8-9.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SFU Compilers class 笔记1</title>
      <link>https://windgodm.github.io/blog/post/SFU-Compilers-1.html</link>
      <guid>https://windgodm.github.io/blog/post/SFU-Compilers-1.html</guid>
      <pubDate>Sun, 27 Feb 2022 04:00:00 GMT</pubDate>
      
      <description>SFU Compilers class week1 hw0</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="SFU-Compilers-笔记1-简介"><a href="#SFU-Compilers-笔记1-简介" class="headerlink" title="SFU Compilers 笔记1 简介"></a>SFU Compilers 笔记1 简介</h1><p>week1 hw0</p><h2 id="Week-1-Introduction-to-Compilers"><a href="#Week-1-Introduction-to-Compilers" class="headerlink" title="Week 1 Introduction to Compilers"></a>Week 1 Introduction to Compilers</h2><h3 id="IN1-Evangelize-Compliers"><a href="#IN1-Evangelize-Compliers" class="headerlink" title="IN1 Evangelize Compliers"></a>IN1 Evangelize Compliers</h3><p>内容：</p><ul><li>Lexing-词法分析</li><li>Parsing-句法分析</li><li>Type analysis-类型分析</li><li>代码生成和优化</li></ul><p>分析下面这两段代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void send (char *to, char *from, int count)&#123;     while (count-- &gt; 0)    *to++ &#x3D; *from++;&#125;void send2 (char *to, char *from, int count)&#123;     int n &#x3D; (count+7)&#x2F;8;     switch (count % 8) &#123;     case 0: do &#123; *to++ &#x3D; *from++;     case 7:  *to++ &#x3D; *from++;     case 6:  *to++ &#x3D; *from++;     case 5:  *to++ &#x3D; *from++;     case 4:  *to++ &#x3D; *from++;     case 3:  *to++ &#x3D; *from++;     case 2:  *to++ &#x3D; *from++;     case 1:  *to++ &#x3D; *from++;    &#125; while(--n &gt; 0);     &#125;&#125;</code></pre><p>第二个switch实际上就是一个goto，跳到do-while循环里</p><h3 id="IN2-Trusting-Trust"><a href="#IN2-Trusting-Trust" class="headerlink" title="IN2 Trusting Trust"></a>IN2 Trusting Trust</h3><p>Quine是一个生成自身源代码的程序</p><p>c语言例子，源代码编译出来的可执行程序会输出源代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int main()&#123;char *c&#x3D;&quot;#include &lt;stdio.h&gt;%cint main()&#123;char *c&#x3D;%c%s%c;printf(c,10,34,c,34,10);&#125;%c&quot;;printf(c,10,34,c,34,10);&#125;</code></pre><p>编译器也有源代码，也需要编译器的编译器来把编译器的源代码编译成编译器</p><p>源代码 不等于 编译出来的可执行文件</p><p>编译器可以插入恶意二进制指令到编译结果中<br>这时编译器的源码是恶意的，而被编译程序的源码是正常的</p><p>更进一步的，编译器的编译器可能会恶意插入指令到编译器中<br>既编译器的源码是正常的，但编译出来的编译器被插入了恶意指令</p><h3 id="IN3-What-is-a-Compiler"><a href="#IN3-What-is-a-Compiler" class="headerlink" title="IN3 What is a Compiler"></a>IN3 What is a Compiler</h3><p><strong>编译器的需求</strong></p><ul><li>支持高级语言特性</li><li>易读的错误信息</li><li>编译速度</li><li>可执行文件速度</li></ul><p><strong>Bootstrapping a Compiler</strong></p><ul><li>先使用机器代码</li><li>制作语言的简单的子集，为其写编译器</li><li>用子集完成语言剩余部分</li><li>解释器：用低级语言写编译器（比如python解释器用C语言编写）</li><li>交叉编译</li></ul><p><strong>Modern challenges</strong></p><ul><li>指令并行性（乱序执行、分支预测）</li><li>并行算法（网格计算、多核计算机）</li><li>内存层级结构：寄存器、缓存、内存</li><li>新架构：GPU、量子计算机、DNA计算机</li><li>硬件级优化（终端内循环优化）</li></ul><h3 id="IN4-Stages-of-a-Compiler"><a href="#IN4-Stages-of-a-Compiler" class="headerlink" title="IN4 Stages of a Compiler"></a>IN4 Stages of a Compiler</h3><p><strong>Building a compiler</strong></p><p>编译器的编译器：</p><ul><li>yacc = yet another compiler compiler</li><li>bison = yacc的一个版本，GNU项目</li></ul><p><strong>Stages of a Compiler</strong></p><ul><li>分析（前端）<ul><li>词法分析（Lexing）</li><li>语法分析（Sytax、Parsing）</li><li>语义分析（类型检查）</li></ul></li><li>合成（后端）<ul><li>中间代码生成</li><li>代码优化</li><li>代码生成</li></ul></li></ul><h2 id="hw0"><a href="#hw0" class="headerlink" title="hw0"></a>hw0</h2><h3 id="windows配置"><a href="#windows配置" class="headerlink" title="windows配置"></a>windows配置</h3><p>获取作业文件：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git clone https:&#x2F;&#x2F;github.com&#x2F;anoopsarkar&#x2F;compilers-class-hw.git</code></pre><p><code>rmprefix</code>目录中有用于测试的python脚本</p><p><code>answer/default.cc</code>为未完成的作业，复制为<code>answer/rmprefix.cc</code>并完成</p><p><code>python zipout.py</code>：在测试集上运行，并得到结果</p><p><code>python check.py</code>：检测结果的正确率</p><p><strong>windows平台操作指南：</strong></p><p>在<code>answer</code>目录下使用powshell编译</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">g++ rmprefix.cc -o rmprefix.</code></pre><p>在<code>rmprefix</code>目录下使用wsl</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">python3 zipout.pypython3 check.py</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方案1：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">line.erase(0, line.find_first_not_of(&#39;\t&#39;));line.erase(0, line.find_first_not_of(&#39; &#39;));</code></pre><p>解决方案2：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int fn &#x3D; 0;for (fn &#x3D; 0; line[fn]; fn++)&#123;    if(line[fn] &#x3D;&#x3D; &#39; &#39;)    continue;    if(line[fn] &#x3D;&#x3D; &#39;\t&#39;)    continue;    break;&#125;line.erase(0, fn);</code></pre>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CS/">CS</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/cs/">cs</category>
      
      <category domain="https://windgodm.github.io/blog/tags/compiler/">compiler</category>
      
      
      <comments>https://windgodm.github.io/blog/post/SFU-Compilers-1.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《Windows Kernel Programming》 笔记 6~7 内核机制与IRP</title>
      <link>https://windgodm.github.io/blog/post/wkp6-7.html</link>
      <guid>https://windgodm.github.io/blog/post/wkp6-7.html</guid>
      <pubDate>Sun, 02 Jan 2022 04:00:00 GMT</pubDate>
      
      <description>《Windows Kernel Programming》 笔记 6~7 内核机制与IRP</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Windows-Kernel-Programming-笔记-6-7-内核机制与IRP"><a href="#Windows-Kernel-Programming-笔记-6-7-内核机制与IRP" class="headerlink" title="Windows Kernel Programming 笔记 6~7 内核机制与IRP"></a>Windows Kernel Programming 笔记 6~7 内核机制与IRP</h1><h2 id="6-内核机制"><a href="#6-内核机制" class="headerlink" title="6 内核机制"></a>6 内核机制</h2><p>关于windows内核提供的一些机制。这些机制，驱动开发会使用，或者有关。</p><h3 id="6-1-中断优先级"><a href="#6-1-中断优先级" class="headerlink" title="6.1 中断优先级"></a>6.1 中断优先级</h3><p>中断处理例程（Interrupt Service Routine，ISR）</p><p>中断优先级（Interrupt Request Level，IRQL）：每个硬件中断关联的一个优先级</p><p>每个处理器有自身的IRQL</p><p>IRQL可以等价于CPU的一个寄存器</p><p>所有ISR都运行在发生中断前的线程的上下文中</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>The interrupted thread does not get its quantum reduced because of these “interruptions”. It’s not its fault, so to speak.</p></blockquote><p>IRQL：</p><ul><li>PASSIVE_LEVEL（0）：R3及大多数R0代码工作于此优先级。可以线程调度。</li><li>APC_LEVEL（1）：特殊的内核APC。可以线程调度。</li><li>DISPATCH_LEVEL（2）：调度器被屏蔽；页池(Paged memory)不能访问；不允许等待内核对象（这回造成系统崩溃）</li><li>Device IRQL：硬件中断</li><li>HIGH_LEVEL：屏蔽所有中断；通常用于处理链表的API（原子性）</li></ul><p>当 IRQL &gt;= 2：</p><ul><li>访问页池是危险的，应只使用非页池内存</li><li>等待内核对象会导致系统崩溃（如果等待超时为0则被允许，用于同步）</li></ul><p>调度器“运行”在IRQL2，IRQL&gt;=2时调度器将被屏蔽</p><p>[windbg]：<code>! irql</code>查看当前cpu IRQL</p><p>[windbg]：<code>! idt </code>查看已注册的中断</p><p><strong>提高和降低IRQL</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">KIRQL oldIrql;KeRaiseIrql(DISPATCH_LEVEL, &amp;oldIrql);&#x2F;&#x2F; passKeLowerIrql(oldIrql);</code></pre><p><strong>线程优先级与IRQL</strong></p><p>IRQL是处理器的属性</p><p>线程优先级只有在IRQL&lt;2时才有意义</p><p>任务管理器中以伪进程 系统中断 显示IRQL&gt;=2的运行时间</p><h3 id="6-2-DPC"><a href="#6-2-DPC" class="headerlink" title="6.2 DPC"></a>6.2 DPC</h3><p>延迟过程调用，Deferred Procedure Calls，DPC</p><p>硬件中断的IRQl&gt;2，IoCompleteRequest只能在<code>IRQL&lt;=DISPATCH_LEVEL(2)</code>时调用</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>如果不用DPC，而是选择降低IRQL调用IoCompleteRequest，再提升回去，会造成死锁，原因见 Spin Lock 章节</p></blockquote><p>DPC机制用于允许ISR尽快调用IoCompleteRequest</p><p>每个cpu有一个DPC队列，KeInsertQueueDpc默认把DPC入队当前CPU</p><p>当ISR返回时，在IRQL降为0前，会检测DPC队列</p><p>如果DPC队列不为空，则IRQL降到2，然后处理DPC队列直到为空</p><p>执行完再降IRQL为0并返回到中断前的代码</p><p><strong>带定时器的DPC</strong></p><p>不是所有的DPC都是由ISR创建的，有些系统机制也会创建DPC，比如内核计时器（KTIMER）</p><p>以下代码是将定时器关联到DPC的示例</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">KTimer Timer;KDPC TimerDpc;void InitAndStartTimer(ULONG msec) &#123;    KeInitializeTimer(&amp;Timer);    KeInitializeDpc(&amp;TimerDpc,                    OnTimerExpired, &#x2F;&#x2F; callback                    nullptr);       &#x2F;&#x2F; passed to callback as &quot;context&quot;        &#x2F;&#x2F; relative interval is in 100nsec units (and must be negative)    LARGE_INTEGER interval;    interval.QuadPart &#x3D; -10000LL * msec;    KeSetTimer(&amp;Timer, interval, &amp;TimerDpc);&#125;void OnTimerExpried(KDPC* Dpc, PVOID context, PVOID, PVOID) &#123;    UNREFERENCED_PARAMETER(Dpc);    UNREFERENCED_PARAMETER(context);        &#x2F;&#x2F; pass&#125;</code></pre><h3 id="6-3-APC"><a href="#6-3-APC" class="headerlink" title="6.3 APC"></a>6.3 APC</h3><p>异步过程调用，Asynchronous Procedure Calls，APC</p><p>每个线程都有一个关联的APC队列</p><p>APC类型：</p><ul><li>R3 APC：在R3下，只有在线程进入alertable state时，以<code>PASSIVE_LEVEL</code>运行<br>通常通过调用API实现，如：SleepEx、WaitForSingleObjectEx或类似的API等<br>这些函数最后一个参数可以设置线程于alertable state，这时线程会检测APC队列直到为空</li><li>正常R0 APC：在R0下，以<code>PASSIVE_LEVEL</code>运行并抢占R3代码和R3 APC</li><li>特殊R0 APC：在R0下，以<code>APC_LEVEL</code>抢占R3代码、R3 APC、普通R0 APC<br>这些APC被IO系统用于完成IO操作</li></ul><p><strong>Critical Regions and Guarded Regions</strong></p><p>Critical Region 阻止 R3、正常R0 APC 运行</p><p><code>KeEnterCriticalRegion</code>，<code>KeLeaveCriticalRegion</code></p><p>Guarded Region 阻止所有 APC 运行</p><p><code>KeEnterGuardedRegion</code>，<code>KeLeaveGuardedRegion</code></p><h3 id="6-4-SEH"><a href="#6-4-SEH" class="headerlink" title="6.4 SEH"></a>6.4 SEH</h3><p>结构化异常处理，Structured Exception Handling，SEH</p><p>由指令引起CPU错误会触发异常</p><p>异常类似于中断，区别是异常是同步、可重现的，中断是异步且随时发生的<br>（这里应该是说异常的发生与代码的执行有关，比如坏的闹钟每个早上都不会响<br>而中断是突发的，比如突然发生了地震）</p><p>异常的例子：除0(0)、断点(3)、无效指令(6)、换页错误(14)、栈溢出</p><p>内核异常处理基于IDT（中断调用表，Interrupt Dispatch Table）</p><p>低编号的 中断向量 实际上是 异常处理程序</p><p>引发异常后，会在异常发生的地方搜索处理函数（除了透明处理的异常，如断点）<br>如果找不到，就会向上搜索调用堆栈，直到系统崩溃</p><p>驱动、R3都可以用SEH机制来抛出自定义异常</p><p>使用（c++）RAII包装来确保资源被正确释放</p><h3 id="6-5-系统崩溃"><a href="#6-5-系统崩溃" class="headerlink" title="6.5 系统崩溃"></a>6.5 系统崩溃</h3><p>如果内核发生未处理的异常，系统就会崩溃<br>通常称为蓝屏（Blue Screen of Death，BSOD）</p><p>蓝屏是一种保护机制，防止崩溃后执行非预期操作修改系统如注册表等、造成不可逆错误</p><p>可以设置系统在系统崩溃时执行一些操作（win10改了设置不知道怎么搞233）</p><p><strong>崩溃转储信息</strong></p><p>[windbg]：<code>!analyze -v</code>，最常用的初步分析dump的指令</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>帮助诊断此类问题的一种方法是使用 Driver Verifier。 将在模块 11 中了解 Driver Verifier</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>获得故障转储代码后，查看主题为“Bugcheck Code Reference”的windbg文档会很有帮助</p></blockquote><p><strong>分析转储文件</strong></p><p>转储文件是系统的快照</p><p><code>!process</code>、<code>!thread</code>、<code>lm</code>、<code>k</code>等指仍能正常使用</p><p>[windbg]：<code>~ns</code>，切换cpu，n是cpu索引（R3是切换线程）</p><p>[windbg]：<code>!running</code>，列出崩溃时所有cpu上的线程；<code>-t</code>，显示线程的调用堆栈</p><p>[windbg]：<code>!stack</code>，列出所有线程的调用堆栈；<code>!stack 0 str </code>，列出模块或函数名中包含str的线程调用堆栈</p><p><strong>系统挂起</strong></p><p>有时候系统会死循环，不崩溃。系统内核工具<code>NotMyFault</code>可以强制系统崩溃，进而生成转储文件</p><p>如果系统无响应但连接了调试器，且事先在注册表中配置，可以通过组合键产生崩溃<br>这种情况崩溃代码是0xe2（MANUALLY_INITIATED_CRASH）</p><h3 id="6-6-线程同步"><a href="#6-6-线程同步" class="headerlink" title="6.6 线程同步"></a>6.6 线程同步</h3><p>驱动可能被多个客户端调用，必须以原子方式操作链表 </p><p>内核提供几个原语（primitive）帮助同步，保护数据的并发访问</p><h4 id="6-6-1-Interlocked"><a href="#6-6-1-Interlocked" class="headerlink" title="6.6.1 Interlocked"></a>6.6.1 Interlocked</h4><p>Interlocked 函数集由硬件提供原子性，非常高效，尽量使用这些函数</p><p>一些驱动使用的Interlocked函数：</p><ul><li>InterlockedIncrement/16/ /64</li><li>InterlockedDecrement/16/ /64</li><li>InterlockedAdd/ /64</li><li>InterlockedExchange/8/16/ /64</li><li>InterlockedCompareExchange/ /64/128</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>InterlockedCompareExchange用于无锁编程，无需使用软件对象实现复杂原子操作</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Interlocked函数在R3下也可用，本质上这些是特殊的CPU指令</p></blockquote><h4 id="6-6-2-Dispatcher-Waitable-对象"><a href="#6-6-2-Dispatcher-Waitable-对象" class="headerlink" title="6.6.2 Dispatcher/Waitable 对象"></a>6.6.2 Dispatcher/Waitable 对象</h4><p>内核提供了一组称为 Dispatcher Objects 的原语，也称为 Waitable Objects</p><p>这些对象有一个状态称为有信号和无信号 </p><p>常见 Disapatcher 对象的 signaled 和 nonsignaled 的含义：</p><table><thead><tr><th>对象类型</th><th>Signal</th><th>Non-Signal</th></tr></thead><tbody><tr><td>Process</td><td>进程已终止</td><td>进程尚未终止</td></tr><tr><td>Thread</td><td>线程已终止</td><td>线程尚未终止</td></tr><tr><td>Mutex</td><td>free</td><td>held</td></tr><tr><td>Event</td><td>set</td><td>reset</td></tr><tr><td>Semaphore</td><td>计数大于0</td><td>计数为0</td></tr><tr><td>Timer</td><td>已过期</td><td>未过期</td></tr><tr><td>File</td><td>异步IO完成</td><td>异步IO处理中</td></tr></tbody></table><h4 id="6-6-3-Mutex"><a href="#6-6-3-Mutex" class="headerlink" title="6.6.3 Mutex"></a>6.6.3 Mutex</h4><p>互斥锁在空闲时设为有信号</p><p>当一个线程调用一个等待函数等待互斥对象，等待结束后（互斥锁空闲、有信号），互斥锁会马上上锁（无信号），此时该线程成为互斥锁的持有者</p><p>使用示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">KMUTEX myMutex;LIST_ENTRY data;void Init() &#123;    KeInitializeMutex(&amp;myMutex, 0);&#125;void DoWork() &#123;    &#x2F;&#x2F; wait for mutex to be free, then held the mutex automatically    KeWaitForSingleObject(&amp;myMutex, Executive, KernelMode, FALSE, nullptr);        __try &#123;    &#x2F;&#x2F; access data    &#125;    __finally &#123;        &#x2F;&#x2F; release    KeReleaseMutex(&amp;myMutex, false);    &#125;&#125;</code></pre><p>RAII包装：</p><p>首先包装mutex，提供初始化、上锁、解锁的接口：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; mutex wrapperstruct MyMutex &#123;    void Init() &#123;        KeInitializeMutex(&amp;_mutex, false);    &#125;        void Lock()&#123;        KeWaitForSingleObject(&amp;_mutex, Executive, KernelMode, FALSE, nullptr);    &#125;        void Unlock()&#123;        KeReleaseMutex(&amp;_mutex, false);    &#125;    private:    KMUTEX _mutex;&#125;</code></pre><p>然后包装一个自动锁类型，自动上锁、解锁：<br>（利用变量的自动初始化和析构）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; lock wrappertemplate&lt;typename TLock&gt;struct AutoLock &#123;    AutoLock(TLock&amp; lock) : _lock(lock) &#123;        lock.Lock();    &#125;        ~AutoLock() &#123;        _lock.Unlock();    &#125;private:    TLock&amp; _lock;&#125;;</code></pre><p>使用示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MyMutex myMutex;void Init() &#123;    myMutex.Init();&#125;void DoWork() &#123;    AutoLock&lt;MyMutex&gt; autolock(myMutex);        &#x2F;&#x2F; access data&#125;</code></pre><h4 id="6-6-4-Fast-Mutex"><a href="#6-6-4-Fast-Mutex" class="headerlink" title="6.6.4 Fast Mutex"></a>6.6.4 Fast Mutex</h4><p>Fast Mutex 是 Mutex 的替代，不一样的特点如下：</p><ul><li>无法递归获取，这会造成死锁</li><li>当获取 Fast Mutex 时，IRQL被提升到APC_LEVEL(1)</li><li>Fast Mutex 只能无限期等待，无法指定超时时限</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>fast mutex只能在R0使用，R3只能用mutex</p></blockquote><p>RAII包装示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyFastMutex &#123;public:    void Init();    void Lock();    void Unlock();private:    FAST_MUTEX _mutex;&#125;;void MyFastMutex::Init() &#123;    ExInitializeFastMutex(&amp;_mutex);&#125;void MyFastMutex::Lock() &#123;    ExAcquireFastMutex(&amp;_mutex);&#125;void MyFastMutex::Unlock() &#123;    ExReleaseFastMutex(&amp;_mutex);&#125;&#123;    &#x2F;&#x2F; init    MyFastMutex myFastMutex;    myFastMute.Init();        &#x2F;&#x2F; auto lock and unlock    &#123;        AutoLock&lt;MyFastMutex&gt; autolock(myFastMutex);    &#125;&#125;</code></pre><h4 id="6-6-5-Semaphore"><a href="#6-6-5-Semaphore" class="headerlink" title="6.6.5 Semaphore"></a>6.6.5 Semaphore</h4><p>信号量的主要目标是限制某些东西，例如队列的长度</p><p>当它的内部计数大于零时，信号量设为有信号 </p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">KeInitializeSemaphore();KeWaitForSingleObject(); &#x2F;&#x2F; Semaphore -1KeReleaseSemaphore(); &#x2F;&#x2F; Semaphore +</code></pre><h4 id="6-6-6-Event"><a href="#6-6-6-Event" class="headerlink" title="6.6.6 Event"></a>6.6.6 Event</h4><p>一个事件封装了一个布尔值，表示是否有信号</p><p>事件在初始化时可以设为手动或自动重置</p><ul><li>手动重置：当事件有信号，且被等待成功后，仍然有信号，所以等待线程都会被唤醒</li><li>自动重置：当事件有信号，且被等待成功后，会变成无信号，只有一个等待线程会被唤醒</li></ul><p>通过在非页池中分配 <code>KEVENT</code> 来创建事件</p><h4 id="6-6-7-Executive-Resource"><a href="#6-6-7-Executive-Resource" class="headerlink" title="6.6.7 Executive Resource"></a>6.6.7 Executive Resource</h4><p>互斥锁本质上是并发杀手（原文），因为一次只能执行一个线程</p><p>对于读写操作分开的情况，内核提供另一种原语，称为单写入器、多读取器</p><p>这个对象是<code>Executive Resource</code>，这不是一个<code>dispatcher</code>对象</p><p>通过在非页池中分配 <code>ERESOURCE</code> 并调用 <code>ExInitializeResourceLite()</code> 来初始化</p><p>获取排他锁（写锁）<code>ExAcquireResourceExclusiveLite()</code></p><p>获取共享锁（读锁）<code>ExAcquireResourceSharedLite()</code></p><p>获取和释放锁都需要屏蔽 普通R0APC（Critical Region）</p><p>示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ERESOURCE resource;void WriteData() &#123;    KeEnterCriticalRegion();    ExAcquireResourceExclusiveLite(&amp;resource, TRUE);        &#x2F;&#x2F; write data        ExReleaseResourceLite(&amp;resource);    KeLeaveCriticalRegion();&#125;void WriteData() &#123;    ExEnterCriticalRegionAndAcquireResourceExclusive(&amp;resource, TRUE);        &#x2F;&#x2F; write data        ExReleaseResourceAndLeaveCriticalRegion(&amp;resource);&#125;</code></pre><p>（练习）RAII包装示例：// todo</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyResource &#123;public:    void Init();    void ReadLock();    void WriteLock();    void Unlock();private:    ERESOURCE _resource;&#125;void MyResource::Init() &#123;    ExInitializeResourceLite(&amp;_resource);&#125;void MyResource::ReadLock() &#123;    ExEnterCriticalRegionAndAcquireSharedExclusive(&amp;_resource， TRUE);&#125;void MyResource::WriteLock() &#123;    ExEnterCriticalRegionAndAcquireResourceExclusive(&amp;_resource， TRUE);&#125;void MyResource::Unlock() &#123;    ExReleaseResourceAndLeaveCriticalRegion(&amp;_resource);&#125;template&lt;typename TLock&gt;struct AutoLockEx &#123;    AutuLock(TLock&amp; lock, BOOL isWrite) : _lock(lock) &#123;        if(isWrite)        lock.WriteLock();        else            lock.ReadLock();    &#125;        ~AutoLock() &#123;        _lock.Unlock();    &#125;private:    TLock&amp; _lock;&#125;</code></pre><h3 id="6-7-高IRQL下的同步"><a href="#6-7-高IRQL下的同步" class="headerlink" title="6.7 高IRQL下的同步"></a>6.7 高IRQL下的同步</h3><p>当 IRQL&gt;=2（DISPATCH_LEVEL或更高）时线程不能等待，意味着不能用上面的东西来实现同步</p><p>比如IRQL0的代码和DPC共用一个资源，或者两个cpu的DPC同时使用一个资源的时候</p><p>前者在IRQL0的代码中临时提升IRQL到2可以避免DPC的干扰</p><p>在多CPU系统中需要使用 Spin Lock</p><p><strong>Spin Lock</strong></p><p>自旋锁是内存中的一个简单位，它通过 API 提供原子测试和修改操作 </p><p>创建自旋锁需要在非页池中分配 <code>KSPIN_LOCK</code></p><p>获取自旋锁有两步：提升IRQL到合适级别；获取自旋锁</p><p>（合适级别指所有使用该资源的代码的最高级别）</p><p>获取和释放自旋锁的API会执行上述两个步骤</p><table><thead><tr><th>IRQL</th><th>获取</th><th>释放</th><th></th></tr></thead><tbody><tr><td>2</td><td>KeAcquireSpinLock</td><td>KeReleaseSpinLock</td><td></td></tr><tr><td>2</td><td>KeAcquireSpinLockAtDpcLevel</td><td>KeReleaseSpinLockFromDpcLevel</td><td>(1)</td></tr><tr><td>Device IRQL</td><td>KeAcquireInterruptSpinLock</td><td>KeReleaseInterruptSpinLock</td><td>(2)</td></tr><tr><td>HIGH_LEVEL</td><td>ExInterlockedXxx</td><td>(none)</td><td>(3)</td></tr></tbody></table><p>(1) 只可以在IRQL=2的时候调用（API只获取或释放锁，不修改IRQL）</p><p>(2) 用于将 ISR 与任何其他功能同步。 具有中断源的基于硬件的驱动程序使用这些例程。参数是一个中断对象——自旋锁是它的一部分</p><p>(3) 用于操作基于 LIST_ENTRY 的链表的 3 个函数。这些函数使用提供的自旋锁并将 IRQL 提升到 HIGH_LEVEL。由于高 IRQL，这些例程可以在任何情况下使用，且总是安全的</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>确保自旋锁在同一个函数获取和释放，否则会造成死锁</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Cancel 自旋锁是一个特例，由内核在调用驱动的取消例程之前获取，由驱动释放</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>通常当多个CPU竞争一个自旋锁，电子速度快的CPU获胜。</p><p>内核提供另一种队列自旋锁用于处理这种竞争</p><p>KeAcquireInStackQueuedSpinLock</p><p>KeReleaseInStackQueuedSpinLock</p></blockquote><h3 id="6-8-Work-Item"><a href="#6-8-Work-Item" class="headerlink" title="6.8 Work Item"></a>6.8 Work Item</h3><p>内核提供了创建单独运行的线程的函数：PsCreateSystemThread、IoCreateSystemThread<br>如果驱动程序需要在后台长时间运行代码，这些函数是合适的</p><p>对于有时间限制的操作，最好使用内核提供的线程池，它将在某个系统工作线程上执行您的代码</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>首选 IoCreateSystemThread，因为它允许将设备或驱动程序对象与线程相关联</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>驱动程序创建的线程必须调用 PsTerminateSystemThread 来终止自身。 如果成功，此函数永远不会返回。 </p></blockquote><p>Work Item 描述的是一些在系统线程池队列中的函数</p><p>看起来与DPC非常相似，主要区别是Work Item总是在IRQL 0<br>这意味着当DPC需要执行IRQL2不能执行的操作时，可以使用 work item</p><p>创建和初始化一个work item的两种方法：</p><ul><li>使用 <code>IoAllocateWorkItem()</code> 分配和初始化work item<br>该函数返回 <code>IO_WORKITEM</code> 结构体的指针<br>work item完成后必须使用 <code>IoFreeWorkItem()</code></li><li>根据 <code>IoSizeofWorkItem()</code> 动态分配一个 <code>IO_WORKITEM</code><br>然后调用 <code>IoInitializeWorkItem()</code><br>work item完成后必须使用 <code>IoUninitializeWorkItem()</code></li></ul><p>使用 <code>IoQueueWorkItem()</code> 查询已有 work item：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void IoQueueWorkItem(    _Inout_ PIO_WORKITEM IoWorkItem,         &#x2F;&#x2F; the work item    _In_ PIO_WORKITEM_ROUTINE WorkerRoutine, &#x2F;&#x2F; the function to be called    _In_ WORK_QUEUE_TYPE QueueType,          &#x2F;&#x2F; queue type    _In_opt_ PVOID Context);                 &#x2F;&#x2F; driver-defined value</code></pre><p><code>IO_WORKITEM_ROUTINE</code> 回调函数：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void WorkerRoutine(    _In_ PDEVICE_OBJECT DeviceObject,    _In_opt_ PVOID Context);</code></pre><p>系统线程池有多个队列，基于不同的线程优先级，<code>WORK_QUEUE_TYPE</code> 枚举：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum _WORK_QUEUE_TYPE &#123;    CriticalWorkQueue,      &#x2F;&#x2F; priority 13    DelayedWorkQueue,       &#x2F;&#x2F; priority 12    HyperCriticalWorkQueue, &#x2F;&#x2F; priority 15    NormalWorkQueue,        &#x2F;&#x2F; priority 8    BackgroundWorkQueue,    &#x2F;&#x2F; priority 7    RealTimeWorkQueue,      &#x2F;&#x2F; priority 18    SuperCriticalWorkQueue, &#x2F;&#x2F; priority 14    MaximumWorkQueue,    CustomPriorityWorkQueue &#x3D; 32&#125; WORK_QUEUE_TYPE;</code></pre><p>文档表明必须使用 <code>DelayedWorkQueue</code>，但实际上可以使用任意支持的级别</p><h2 id="7-IRP"><a href="#7-IRP" class="headerlink" title="7 IRP"></a>7 IRP</h2><p>典型的驱动在 DriverEntry 中完成初始化后，其主要工作是处理请求</p><p>这些请求被打包为半文档化的 I/O Request Packet（IRP）结构</p><p>本章关于了解IRP，及驱动如何处理常见的IRP</p><h3 id="7-1-IRP简介"><a href="#7-1-IRP简介" class="headerlink" title="7.1 IRP简介"></a>7.1 IRP简介</h3><p>IRP在非页池</p><p><code>allocated by one of the “managers” in  the Executive(I/O Manager, Plug &amp; Play Manager, Power Manager) </code>，也可以由驱动分配，用于将请求传递给另外一个驱动</p><p>IRP通常伴随着一个或多个 <code>IO_STACK_LOCATION</code></p><p>分配IRP时必须指定由多少个 <code>IO_STACK_LOCATION</code></p><p><code>IO_STACK_LOCATION</code> 的数量 = 设备堆栈中设备对象的数量</p><p>使用宏 <code>IoGetCurrentIrpStackLocation </code> 获取当前的 <code>IO_STACK_LOCATION</code></p><h3 id="7-2-设备栈"><a href="#7-2-设备栈" class="headerlink" title="7.2 设备栈"></a>7.2 设备栈</h3><p>IO系统以设备为中心：</p><ul><li>可以命名设备对象并且可以打开设备对象的句柄<br>CreateFile 函数接受指向设备对象名称的符号链接<br>CreateFile 不能接受驱动程序的名称作为参数</li><li>设备可以堆叠，发送到较低设备的请求将先到达最上层</li></ul><p>堆叠的一组设备称为设备栈（device stack）或设备节点（device node）</p><pre class="line-numbers language-none"><code class="language-none">设备栈例子：（上层）FiDOFiDOFDOFiDOFiDOPDO（底层）</code></pre><p>FiDO（Filter Device Object）：可选的过滤驱动创建的过滤设备</p><p>FDO（Functional Device Object）：由“真正”的驱动创建的；这些驱动通常由硬件供应商提供</p><p>PDO（Physical Device Object）：由总线驱动(bus driver，负责特定总线，例如PCI、USB)创建；该设备对象表示该总线上的插槽中存在某个设备</p><p>例子：</p><p>P&amp;P管理器（Plug &amp; Play manager）负责从底部开始加载驱动</p><p>创建设备栈的事件序列总结如下：</p><ol><li>PCI总线驱动程序 (pci.sys) 识别出插槽中存在硬件，创建一个PDO (IoCreateDevice)</li><li>PCI总线企业的程序 通知 P&amp;P管理器 它的总线发生了变化</li><li>P&amp;P管理器 向 总线驱动 请求PDO链表，该链表包括新PDO</li><li>准备找到并加载新PDO的正确的驱动程序，它将向 总线驱动 查询完整的硬件设备ID</li><li>P&amp;P管理器 根据硬件ID，在注册表中查找<code>HKLM\System\ CurrentControlSet\Enum\PCI\(HardwareID)</code><br>如果驱动已经加载，将注册并加载</li><li>驱动加载并创建FDO，通过附加调用 IoAttachDeviceToDeviceStack 将自身附加到（通常是PDO）前一层</li></ol><h4 id="IRP-流"><a href="#IRP-流" class="headerlink" title="IRP 流"></a>IRP 流</h4><p>驱动在处理IRP时有如下几种选择：</p><p><strong>向下传递</strong>：</p><p>如果驱动的设备不是设备栈的最底层，可以直接向下传递，跳过该请求</p><p>跳过请求需要如下步骤：</p><ol><li>调用 <code>IoSkipCurrentIrpStackLocation</code> 确保下一个设备“看”到同样的 I/O stack location</li><li>调用 <code>IoCallDriver </code> 传递低一层设备和IRP</li></ol><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>调用 IoSkipCurrentIrpStackLocation 是一种优化，它会减少当前 I/O stack location 指针，随后被IoCallDriver增加回来</p></blockquote><p><strong>完全处理IRP</strong>：</p><p>不向下传递请求，处理完IRP后直接调用 <code>IoCompleteRequest</code></p><p><strong>处理并向下传递</strong>：</p><p>处理完请求后再向下传递</p><p><strong>传递并接收通知</strong>：</p><p>传递给底层设备，并在请求完成时接收通知</p><p>通过在传递之前调用 <code>IoSetCompletionRoutine</code> 设置例程，该例程会在请求完成时被调用</p><p><strong>启动异步IRP处理</strong>：</p><p>在处理过程比较长的一些情况，可以将IRP标记为<code>pending</code></p><p>需要调用<code>IoMarkIrpPending</code>和返回<code>STATUS_PENDING</code></p><h3 id="7-3-IRP-和-IO-STACK-LOCATION"><a href="#7-3-IRP-和-IO-STACK-LOCATION" class="headerlink" title="7.3 IRP 和 IO_STACK_LOCATION"></a>7.3 IRP 和 IO_STACK_LOCATION</h3><p>IRP重要字段：</p><p><img src="https://s4.ax1x.com/2022/02/25/bEkrSf.png"></p><ul><li><strong>MdlAddress</strong>：MDL指针，与 <code>Direct I/O</code> 有关</li><li><strong>AssociatedIrp</strong>：union<ul><li><strong>MasterIrp</strong>：指向主IRP</li><li><strong>IrpCount</strong>：对于 主IRP，指示与此 主IRP 关联的 关联IRP 数量</li><li><strong>SystemBuffer</strong>：指向系统分配的非页池，与 <code>Buffered I/O</code> 有关</li></ul></li><li><strong>IoStatus</strong>：包括<code>Status</code>和<code>Information</code>；<code>Information</code>是<code>ULONG_PTR</code>，是多态的，定义取决于IRP的类型</li><li><strong>UserEvent</strong>：指向客户端提供的<code>KEVENT</code>，客户端可以在<code>OVERLAPPED</code>中提供该事件HANDLE，这是异步调用所必须的</li><li><strong>UserBuffer</strong>：包含指向用户缓冲区的原始缓冲区指针</li><li><strong>Cancel Routine</strong>：指向取消例程，比如R3调用<code>CancelIO</code>时，软件驱动通常不需要</li></ul><p>IO_STACK_LOCATION重要字段：</p><p><img src="https://s4.ax1x.com/2022/02/25/bEky6S.png"></p><ul><li><strong>MajorFunction</strong>：IRP的 major function (如IRP_MJ_CREATE，IRP_MJ_READ)</li><li><strong>MinorFunction</strong>：IRP的 minor function (如 IRP_MJ_PNP，IRP_MJ_POWER)</li><li><strong>Parameters</strong>：union，不同的操作对应不同的结构</li><li><strong>FileObject</strong>：该IRP关联的 FILE_OBJECT</li><li><strong>DeviceObject</strong>：该IRP关联的 设备对象</li><li><strong>CompletionRoutine</strong>：由上层设置（<code>IoSetCompletionRoutine</code>）</li><li><strong>Context</strong>：传递给 CompletionRoutine 的参数</li></ul><h4 id="观察IRP信息"><a href="#观察IRP信息" class="headerlink" title="观察IRP信息"></a>观察IRP信息</h4><p>[windbg]：<code>!irpfind</code> 查找或输出所有IRP</p><p>[windbg]：<code>!irp</code> 对于特定的IRP，提供其内容的预览</p><p>[windbg]：<code>dt</code>命令可以与<code>_IRP</code>类型一起使用来查看完整IRP结构</p><h3 id="7-4-调度例程"><a href="#7-4-调度例程" class="headerlink" title="7.4 调度例程"></a>7.4 调度例程</h3><p>所有调度例程是同一个函数原型</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">NTSTATUS DRIVER_DISPATCH (    _In_ PDEVICE_OBJECT DeviceObject,    _Inout_ PIRP Irp);</code></pre><p>通常运行在发起请求的线程的上下文<br>但位于该设备上层的过滤驱动可能在不同的上下文发送请求</p><p>所有调度例程做以下事情：</p><ol><li>检查错误</li><li>处理请求</li></ol><p>软件驱动常见调度例程：</p><ul><li>IRP_MJ_CREATE</li><li>IRP_MJ_CLOSE</li><li>IRP_MJ_READ</li><li>IRP_MJ_WRITE</li><li>IRP_MJ_DEVICE_CONTROL</li><li>IRP_MJ_INTERNAL_DEVICE_CONTROL</li></ul><h4 id="完成请求"><a href="#完成请求" class="headerlink" title="完成请求"></a>完成请求</h4><p>当驱动处理完IRP（不再向下传递），需要完成请求<br>填写请求状态和其他信息后，调用<code>IoCompleteRequest</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">NTSTATUS MyDispatchRoutine(PDEVICE_OBJECT, PIRP Irp) &#123;    &#x2F;&#x2F; ...        Irp-&gt;IoStatus.Status &#x3D; STATUS_XXX;    Irp-&gt;IoStatus.Information &#x3D; ; &#x2F;&#x2F; depends on request type    IoCompleteRequest(Irp, IO_NO_INCREMENT);    return STATUS_XXX;&#125;</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>调度例程返回值和Irp-&gt;IoStatus.Status应该相同，但不能直接<code>return Irp-&gt;IoStatus.Status</code></p><p>当IRP完成后，使用IRP中的数据是危险的</p></blockquote><p>当发生错误，<code>Information</code>字段应该为0</p><p>IoCompleteRequest的第二个参数为可选值，用于临时增加原始线程的优先级发起请求的线程）</p><h3 id="7-5-访问R3缓冲区"><a href="#7-5-访问R3缓冲区" class="headerlink" title="7.5 访问R3缓冲区"></a>7.5 访问R3缓冲区</h3><p>调度例程首先接触到IRP</p><p>当IRQL为0时，可以换页，所以指针在此上下文是有效的<br>但有可能其他线程会释放掉R3客户端提供的缓冲区</p><p>但当IRQL为2时，无法换页；而执行DPC的可能为任意线程，可以换页但无法保证在正确上下文</p><p>所以提供了两种种方法用于访问原始的R3缓冲区：Buffered I/O 和 Direct I/O</p><h4 id="7-5-1-Bufferd-I-O"><a href="#7-5-1-Bufferd-I-O" class="headerlink" title="7.5.1 Bufferd I/O"></a>7.5.1 Bufferd I/O</h4><p>该方法最简单</p><p>获取对于 Read 和 Write 操作的支持：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">DeviceObject-&gt;Flags |&#x3D; DO_BUFFERED_IO;</code></pre><p>原理（I/O管理器的工作）：</p><ol><li>管理器在非页池分配缓冲区，大小与R3缓冲区一致<br>该非页池缓冲区指针存储在<code>AssociatedIrp.SystemBuffer</code></li><li>如果Write，管理器复制R3缓冲区的内容到非页池缓冲区</li><li>调度例程被调用</li><li>完成操作后，管理器将非页池缓冲区的内容复制到R3缓冲区（Write也是一样）<br>复制的字节数取决于<code>IoStatus.Information</code></li><li>最后，管理器释放非页池缓冲区</li></ol><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>I/O管理器 将一个特殊的内核APC入队发出请求的线程中，完成复制回R3缓冲区的操作</p></blockquote><p>Buffer I/O的特点：</p><ul><li>易于使用</li><li>总是涉及副本（适用于传递的缓冲区较小的情况）</li></ul><h4 id="7-5-2-Direct-I-O"><a href="#7-5-2-Direct-I-O" class="headerlink" title="7.5.2 Direct I/O"></a>7.5.2 Direct I/O</h4><p>该方法的目的是允许在任何IRQL和任何线程上下文中访问R3缓冲区，而不要任何复制</p><p>获取对于 Read 和 Write 操作的支持：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">DeviceObject-&gt;Flags |&#x3D; DO_DIRECT_IO;</code></pre><p>原理（I/O管理器的工作）：</p><ol><li>管理器首先确认R3缓冲区是合法的，然后放入物理内存中</li><li>然后将缓冲区锁定在内存中（将不会被换出）</li><li>管理器构建一个MDL（描述缓冲区如何映射到内存），该MDL地址存在 IRP 的 MdlAddress字段中</li><li>调度例程被调用，要使用锁定在内存中的缓冲区，需要先将缓冲区映射到系统地址<br>本质上，相对于将两个地址映射到同一个缓冲区（一个R3下特定上下文有效的地址，一个R0对所以上下文有效的地址）<br>映射到系统地址的API是<code>MmGetSystemAddressForMdlSafe</code></li><li>驱动完成请求后，管理器将移除到系统地址的映射，释放MDL，解锁R3缓冲区</li></ol><h4 id="7-5-3-IRP-MJ-DEVICE-CONTROL"><a href="#7-5-3-IRP-MJ-DEVICE-CONTROL" class="headerlink" title="7.5.3 IRP_MJ_DEVICE_CONTROL"></a>7.5.3 IRP_MJ_DEVICE_CONTROL</h4><p>缓冲区的访问方式取决于控制代码（<code>DeviceIoControl()</code>第2个参数<code>dwIoControlCode</code>）</p><p>下面是第四章给出的定义控制代码的宏</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define CTL_CODE( DeviceType, Function, Method, Access ) ( \((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method))</code></pre><p>Method的决定了访问缓冲区的方式：</p><ul><li><strong>METHOD_NEITHER</strong>：管理器将不会提供任何帮助，完全由驱动处理缓冲区<ul><li>R3输入缓冲区指针将存储在当前<code>I/O stack location</code>的<code>Paramaters.DeviceIoControl.Type3InputBuffer</code>字段<br>R3输出缓冲区指针将存储在IRP的<code>UserBuffer</code>字段</li></ul></li><li><strong>METHOD_BUFFERED</strong>：对于输入和输出都使用 Buffered I/O</li><li><strong>METHOD_IN_DIRECT and METHOD_OUT_DIRECT</strong>：输入缓冲区用Buffered I/O，输出缓冲区用Direct I/O；区别是对于输出缓冲区，<code>IN</code>可读，<code>OUT</code>可写</li></ul><h4 id="7-5-x-总结"><a href="#7-5-x-总结" class="headerlink" title="7.5.x 总结"></a>7.5.x 总结</h4><p>Buffred I/O 使用 IRP 的 AssociatedIrp.SystemBuffer</p><p>Directed I/O 使用 IRP 的 MdlAddress</p><p>DeviceIoControl 的 NEITHER：<br>    Input：I/O stack location 的 Paramaters.DeviceIoControl.Type3InputBuffer<br>    Ouput：IRP 的 UserBuffer</p><table><thead><tr><th>Method</th><th>In buf</th><th>Out buf</th></tr></thead><tbody><tr><td>METHOD_BUFFER</td><td>Buffred</td><td>Buffred</td></tr><tr><td>METHOD_IN_DIRECT</td><td>Buffred</td><td>Direct（只读）</td></tr><tr><td>METHOD_OUT_DIRECT</td><td>Buffred</td><td>Direct（只写）</td></tr></tbody></table><h3 id="7-6-示例：Zero-驱动（S4）"><a href="#7-6-示例：Zero-驱动（S4）" class="headerlink" title="7.6 示例：Zero 驱动（S4）"></a>7.6 示例：Zero 驱动（S4）</h3><p>运用6、7章的内容，构建一个驱动：</p><ul><li>read操作：返回清零的缓冲区</li><li>write操作：只是消耗提供的缓冲区，类似于经典的null设备</li></ul><p>使用Direct I/O</p><p>（同样不需要INF文件，删除掉）</p><h4 id="7-6-1-技巧：使用预编译头"><a href="#7-6-1-技巧：使用预编译头" class="headerlink" title="7.6.1 技巧：使用预编译头"></a>7.6.1 技巧：使用预编译头</h4><p>预编译头文件是 Visual Studio 的一项功能，有助于缩短编译时间</p><p>创建预编译头的步骤：</p><ul><li><p>添加头文件到项目，名为pch.h：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; pch.h#pragma once#include &lt;ntddk.h&gt;</code></pre></li><li><p>添加源文件，名为pch.cpp：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; pch.cpp#include &quot;pch.h&quot;</code></pre></li><li><p>接下来使编译器知道这是个预编译头<br>打开项目属性，选择所有配置和所有平台<br>打开C/C++ -&gt; 预编译头，设置为使用，设置文件名为pch.h</p></li><li><p>pch.cpp需要设置为预编译头的创建者<br>右键该文件，打开C/C++ -&gt; 预编译头，设置为创建</p></li><li><p>现在，项目中的每个文件都必须先包含pch.h，否则不会被编译</p></li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>注意，<code>#include &quot;pch.h&quot;</code>必须放在源文件最前面，这条包含语句之前的内容不会被编译</p></blockquote><h4 id="7-6-2-DriverEntry-例程"><a href="#7-6-2-DriverEntry-例程" class="headerlink" title="7.6.2 DriverEntry 例程"></a>7.6.2 DriverEntry 例程</h4><p>技巧：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">do &#123;if(notSuccess)        break;&#125; while(false);</code></pre><p>创建设备后，需要添加开启Direct IO代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; IoCreateDevice()DeviceObject-&gt;Flags |&#x3D; DO_DIRECT_IO;</code></pre><h4 id="7-6-3-Read-调度例程"><a href="#7-6-3-Read-调度例程" class="headerlink" title="7.6.3 Read 调度例程"></a>7.6.3 Read 调度例程</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">NTSTATUS ZeroRead(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp) &#123;UNREFERENCED_PARAMETER(DeviceObject);auto stack &#x3D; IoGetCurrentIrpStackLocation(Irp);auto status &#x3D; STATUS_SUCCESS;ULONG infomation &#x3D; 0;do &#123;auto len &#x3D; stack-&gt;Parameters.Read.Length;if (len &#x3D;&#x3D; 0)break;&#x2F;&#x2F; get bufferauto buffer &#x3D; MmGetSystemAddressForMdlSafe(Irp-&gt;MdlAddress, NormalPagePriority);if (!buffer) &#123;status &#x3D; STATUS_INSUFFICIENT_RESOURCES;break;&#125;&#x2F;&#x2F; workmemset(buffer, 0, len);infomation &#x3D; len;&#125; while (false);Irp-&gt;IoStatus.Status &#x3D; status;Irp-&gt;IoStatus.Information &#x3D; infomation;IoCompleteRequest(Irp, IO_NO_INCREMENT);return status;&#125;</code></pre><h4 id="7-6-4-Write-调度例程"><a href="#7-6-4-Write-调度例程" class="headerlink" title="7.6.4 Write 调度例程"></a>7.6.4 Write 调度例程</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">NTSTATUS ZeroWrite(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp) &#123;UNREFERENCED_PARAMETER(DeviceObject);auto stack &#x3D; IoGetCurrentIrpStackLocation(Irp);auto status &#x3D; STATUS_SUCCESS;ULONG infomation &#x3D; 0;auto len &#x3D; stack-&gt;Parameters.Write.Length;    &#x2F;&#x2F; get buffer    auto buffer &#x3D; MmGetSystemAddressForMdlSafe(Irp-&gt;MdlAddress, NormalPagePriority);infomation &#x3D; len;        &#x2F;&#x2F; work        &#x2F;&#x2F; ...Irp-&gt;IoStatus.Status &#x3D; status;Irp-&gt;IoStatus.Information &#x3D; infomation;IoCompleteRequest(Irp, IO_NO_INCREMENT);return status;&#125;</code></pre><h4 id="7-6-5-R3测试程序"><a href="#7-6-5-R3测试程序" class="headerlink" title="7.6.5 R3测试程序"></a>7.6.5 R3测试程序</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">HANDLE hDevice &#x3D; CreateFile(L&quot;\\\\.\\S4Zero&quot;, GENERIC_READ | GENERIC_WRITE,                            0, nullptr, OPEN_EXISTING, 0, nullptr);&#x2F;&#x2F; readDWORD btr;ReadFile(hDevice, buffer, sizeof(buffer), &amp;btr, nullptr);&#x2F;&#x2F; writeDWORD btw;WriteFile(hDevice, buffer, sizeof(buffer), &amp;btw, nullptr);</code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>6.6.7 Executive Resource，p144，Create appropriate C++ RAII wrappers for executive resources（见文中）</p><p>6.7 高IRQL下的同步，p149，Write a C++ wrapper for a DISPATCH_LEVEL spin lock that works with the AutoLock RAII class defined earlier in this chapter.（todo）</p><p>7.6.6，p185（todo）</p><h2 id="勘误"><a href="#勘误" class="headerlink" title="勘误"></a>勘误</h2><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>p133 的<strong>Interlocked Operations</strong>的 <code>IF</code> 应改为 <code>If</code></p><p>p150 代码的 <code>viud</code> 应该为 <code>void</code></p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>p167 <code>AssociatedIrp-&gt;SystemBuffer</code> 应改为 <code>AssociatedIrp.SystemBuffer</code></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/kernel/">kernel</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wkp/">wkp</category>
      
      
      <comments>https://windgodm.github.io/blog/post/wkp6-7.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>sctf21 BabyDriver 出题思路</title>
      <link>https://windgodm.github.io/blog/post/sctf21-babydriver.html</link>
      <guid>https://windgodm.github.io/blog/post/sctf21-babydriver.html</guid>
      <pubDate>Sun, 26 Dec 2021 04:00:00 GMT</pubDate>
      
      <description>sctf21 BabyDriver 出题思路</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="BabyDriver-出题思路"><a href="#BabyDriver-出题思路" class="headerlink" title="BabyDriver 出题思路"></a>BabyDriver 出题思路</h1><p>这题是和0x太上一起出的，他提供了题目的框架和内核通信部分的代码，我负责其余的实现</p><p><a href="https://github.com/0xTalShang">0xTalShang (0x太上) (github.com)</a></p><p><a href="https://github.com/SycloverTeam/SCTF2021">SycloverTeam/SCTF2021: SCTF 2021 (github.com)</a></p><p>有选手反馈R3部分出得不太好，确实没有很好的把驱动的考点和R3的加密结合在一起，下次加油吧</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>题目有一个R3的客户端<code>babydriver.exe</code>和一个驱动<code>sctf.sys</code></p><p>客户端会要求输入一个flag，并读取文件<code>key.bin</code>，然后对flag进行运算</p><p>运算的结果会传给驱动</p><p>驱动进行第二次运算，然后与目标值比较</p><p>客户端再向驱动查询比较结果是否正确</p><h3 id="babydriver-exe"><a href="#babydriver-exe" class="headerlink" title="babydriver.exe"></a>babydriver.exe</h3><p>客户端会要求输入一个flag，并读取文件<code>key.bin</code>。</p><p>flag的输入格式限制为只能用64个字符</p><p>然后对flag进行一个类似base64解密的过程，把输入的20个字节的flag转换成15字节的数据</p><p>这个过程按每两位的移动，拆分成了60个位移函数。一共有60*60共3600个函数用于移动。</p><p>程序根据<code>key.bin</code>决定使用哪些位移函数（实际上就是3600取60）。</p><p>每个位移函数会有一个<code>费用</code>，总<code>费用</code>必须为3100</p><h3 id="内核通信"><a href="#内核通信" class="headerlink" title="内核通信"></a>内核通信</h3><p>驱动程序会注册一个时间回调函数，客户端修改时间会触发该回调函数。</p><p>整个通讯流程是客户端把要传输的数据写入PE文件头，然后修改时间触发回调进入内核。回调函数再从PE头文件中读写数据，并做处理。</p><h3 id="sctf-sys"><a href="#sctf-sys" class="headerlink" title="sctf.sys"></a>sctf.sys</h3><p>驱动要手动启动，该驱动负责实现和注册回调函数，并对传输给内核的数据做校验。</p><p>驱动对传入数据的处理是将传入的15字节分成4组，每组进行一个模乘，比较结果是否为目标值</p><h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p>babydriver.exe中利用VEH添加了一些call 0和除0语句，以触发异常<br>其中除0异常用于跳转到位移函数</p><p>驱动中在接收数据后，会对后3字节做一些处理，将后3字节左移一个字节，然后填充一个10h，模乘校验完后再还原回去</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="key-bin"><a href="#key-bin" class="headerlink" title="key.bin"></a>key.bin</h3><p>位移函数格式如下（实际上是无参的）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void name() &#123;    char x &#x3D; inBuf[iIdx] &gt;&gt; (iSh * 2);    x &#x3D; x &amp; 3;    x &#x3D; x &lt;&lt; (oSh * 2);    outBuf[oIdx] |&#x3D; x;    totalC -&#x3D; cost;&#125;</code></pre><p>首先需要提取3600个位移函数的参数</p><p>已知约束是cost的和必须为3100</p><p>根据题意得到隐含的约束条件是要选择其中的60个函数，每个函数会从输入中选2个位，复制到输出中，输入的偏移和输出的偏移不能相同</p><p>然后用动态规划算法找出解</p><p>和为3100且选择了60个的解有多个。但完全覆盖输入和输出所有位的解只有1个</p><p>这里给出python版本的参考代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def ReadMM(name, n, w):    mm &#x3D; [[0 for j in range(w)] for i in range(n)]    with open(&#39;&#123;&#125;_&#123;&#125;_&#123;&#125;.txt&#39;.format(name, n, w), &#39;r&#39;) as f:        lines &#x3D; f.readlines()        i &#x3D; 0        for line in lines:            j &#x3D; 0            for w in line.split():                mm[i][j] &#x3D; int(w)                j +&#x3D; 1            i +&#x3D; 1                    return mmdef msOrd2wsOrd(ms_ord):    a &#x3D; ms[ms_ord][0]*3+ms[ms_ord][1]    b &#x3D; ms[ms_ord][2]*4+ms[ms_ord][3]    return a * 60 + bdef dp3(ii, ww):    if ww &lt; 0:        return 0    ans &#x3D; 0    if mm3[ii][ww] !&#x3D; -1:        return mm3[ii][ww]    # take ws[n]    if ii &#x3D;&#x3D; 59:        for n in range(ii*60, (ii+1)*60):            print(n)            new_w &#x3D; ww - ws[n]            ans +&#x3D; dp3(ii-1, new_w)    else:        for n in range(ii*60, (ii+1)*60):            new_w &#x3D; ww - ws[n]            ans +&#x3D; dp3(ii-1, new_w)    mm3[ii][ww] &#x3D; ans    return ansopos &#x3D; [0]*60cur_ans &#x3D; []def findPath(ii, ww):    total_ans &#x3D; []    if ii &#x3D;&#x3D; 0:        for oo in range(60):            if ws[oo] &#x3D;&#x3D; ww:                total_ans &#x3D; [cur_ans[:] + [oo]]                break        return total_ans    n &#x3D; ii*60    for oo in range(60):        if opos[oo]:            n +&#x3D; 1            continue        new_w &#x3D; ww - ws[n]        if new_w &gt;&#x3D; 0 and mm3[ii-1][new_w] &gt; 0:            opos[oo] &#x3D; 1            cur_ans.append(n)            new_ans &#x3D; findPath(ii-1, new_w)            total_ans +&#x3D; new_ans            del cur_ans[-1]            opos[oo] &#x3D; 0        # continue        n +&#x3D; 1        return total_answ &#x3D; 3100ms &#x3D; ReadMM(&#39;ms&#39;, 3600, 5)wsOrd2msOrd &#x3D; [0]*3600ws &#x3D; [0]*3600for msOrd in range(3600):    wsOrd &#x3D; msOrd2wsOrd(msOrd)    wsOrd2msOrd[wsOrd] &#x3D; msOrd    ws[wsOrd] &#x3D; ms[msOrd][4]# step 1 dpmm3 &#x3D; [[-1 for i in range(w+1)] for j in range(60)]for ww in range(w+1):    mm3[0][ww] &#x3D; 0for oo in range(60):    mm3[0][ws[oo]] &#x3D; 1dp3(59, w)print(mm3[59][w])# step 2 dfsansWsOrds &#x3D; findPath(59, w)[0]ansMsOrds &#x3D; [wsOrd2msOrd[ord] for ord in ansWsOrds]print(ansMsOrds)# step 3 keyans &#x3D; [0]*3600for ord in ansMsOrds:    ans[ord] &#x3D; 1s &#x3D; &#39;&#39;for x in ans:    s +&#x3D; str(x)with open(&#39;.&#x2F;key.bin&#39;, &#39;wb&#39;) as f:    for i in range(0, 3600, 8):        f.write(int(s[i:i+8][::-1], 2).to_bytes(1, &#39;little&#39;))</code></pre><h3 id="一元同余方程"><a href="#一元同余方程" class="headerlink" title="一元同余方程"></a>一元同余方程</h3><p>这个比较简单就不说了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>求出一元同余方程的解，得到变形base64的输出。然后求出key.bin得到base64的规则，逆推出输入。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      
      <comments>https://windgodm.github.io/blog/post/sctf21-babydriver.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《Windows Kernel Programming》 笔记 1~5 内核开发入门</title>
      <link>https://windgodm.github.io/blog/post/wkp1-5.html</link>
      <guid>https://windgodm.github.io/blog/post/wkp1-5.html</guid>
      <pubDate>Fri, 24 Dec 2021 04:00:00 GMT</pubDate>
      
      <description>《Windows Kernel Programming》 笔记 1~5 内核开发入门</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Windows-Kernel-Programming-笔记-1-5-内核开发入门"><a href="#Windows-Kernel-Programming-笔记-1-5-内核开发入门" class="headerlink" title="Windows Kernel Programming 笔记 1~5 内核开发入门"></a>Windows Kernel Programming 笔记 1~5 内核开发入门</h1><h2 id="1-windows内部概况"><a href="#1-windows内部概况" class="headerlink" title="1 windows内部概况"></a>1 windows内部概况</h2><p>描述一些Windows内部工作中最重要、最基本的概念，部分概念将在后面的章节做更详细的研究</p><h3 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h3><p>进程不运行（Processes dont’t run - processes manage），线程才执行代码</p><p>进程拥有以下内容：</p><ul><li>一个可执行程序（PE文件），包括代码和数据</li><li>私有的虚拟内存空间</li><li>主令牌（primary token），是一个对象，存储进程默认安全上下文</li><li>对象（事件、信号、文件）句柄表</li><li>一个或多个线程（没有线程的用户态进程一般情况下会被内核销毁）</li></ul><h3 id="1-2-虚拟内存"><a href="#1-2-虚拟内存" class="headerlink" title="1.2 虚拟内存"></a>1.2 虚拟内存</h3><p>每个进程拥有自己的<strong>虚拟、私有、线性地址</strong>空间<br>（该地址空间初始时几乎为空，然后pe、ntdll.dll开始被影射，接着是其他子系统dll）</p><p>32位进程默认地址空间<strong>2GB</strong>，设置pe中的<code>LARGEADDRESSAWARE</code>标志可以增加到<strong>3GB</strong>（32位系统）或<strong>4GB</strong>（64位系统）</p><p>64位进程默认地址空间<strong>128TB</strong>（win8之前是8TB）</p><p>虚拟内存被映射到物理内存（RAM）或临时驻留在文件中（如page file）<br>如果不在物理内存，则触发page fault异常，并或取数据到物理内存中</p><p><strong>页（page）</strong>是内存管理的单位，默认大小为<strong>4KB</strong></p><h4 id="页状态"><a href="#页状态" class="headerlink" title="页状态"></a>页状态</h4><p>虚拟内存中的页处于三种状态之一</p><ul><li>Free：未分配</li><li>Committed：已分配，通常映射到RAM或文件（例如page file）</li><li>Reserved：未分配，对cpu而言与Free相似，自动分配将不会使用该页<br>一个例子是线程栈（thread stack）</li></ul><h4 id="系统内存"><a href="#系统内存" class="headerlink" title="系统内存"></a>系统内存</h4><p>系统空间与进程无关</p><p>系统空间就是内核</p><h3 id="1-3-线程"><a href="#1-3-线程" class="headerlink" title="1.3 线程"></a>1.3 线程</h3><p>实际执行代码的是线程</p><p>线程拥有的最重要的内容：</p><ul><li>当前访问模式（用户或内核）</li><li>执行上下文</li><li>一个或两个栈（stack）</li><li>Thread Local Storage（TLS）</li><li>基本优先级和当前（动态）优先级</li><li>处理器关联信息</li></ul><p>线程最常处于的状态：</p><ul><li>Running：在逻辑处理器运行中</li><li>Ready：等待运行（所有处理器在忙或不可用）</li><li>Waiting：等待某个事件，事件触发就变成Ready</li></ul><p>括号中的数字是状态号：</p><p>Running(2) =&gt; Waiting(5) =&gt; Deferred Ready(7), Ready(1) =&gt; Running(2)</p><h4 id="1-3-1-线程栈"><a href="#1-3-1-线程栈" class="headerlink" title="1.3.1 线程栈"></a>1.3.1 线程栈</h4><p>线程至少有一个位于内核空间的栈（32位系统12KB，64位系统24KB）</p><p>用户态的线程还有一个位于所属进程空间的栈（默认上限1MB）</p><p>线程<code>Running</code>或<code>Ready</code>时，内核栈驻留在RAM</p><p>栈初始时会尽可能少提交页（最少一页），剩下的页设置为<code>Reserved</code>，而最后一个<code>Committed</code>的页的下一页设置为<code>PAGE_GUARD</code></p><h3 id="1-4-系统调用（又名系统服务）"><a href="#1-4-系统调用（又名系统服务）" class="headerlink" title="1.4 系统调用（又名系统服务）"></a>1.4 系统调用（又名系统服务）</h3><p>原标题：System Services (a.k.a. System Calls)</p><p>R3代码通过系统调用完成一些只能在R0下完成的功能，如分配内存、打开文件、创建线程等</p><p>大致流程是：<br>调用subsystem dll（如kernel32.dll）中的文档化api（如CreateFile）<br>进入NTDLL中的 Native Api（如NtCreateFile）<br>进入内核中的系统服务分发函数<br>进入Native Api对应的内核中的函数</p><p>Native Api将调用号存入eax然后进入r0的系统服务分发函数，eax实际是SSDT（System Service Dispatch Table）的下标</p><h3 id="1-5-通用系统架构"><a href="#1-5-通用系统架构" class="headerlink" title="1.5 通用系统架构"></a>1.5 通用系统架构</h3><p><img src="https://s4.ax1x.com/2022/01/18/70IBlR.png"></p><h3 id="1-6-句柄和对象"><a href="#1-6-句柄和对象" class="headerlink" title="1.6 句柄和对象"></a>1.6 句柄和对象</h3><p>对象被引用计数，当计数为0时才会被释放</p><p>句柄是进程的对象表的索引</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>注意：返回值为句柄的函数，大多数失败时返回<code>0</code>。有些返回<code>INVALID_HANDLE_VALUE (-1)</code>，比如<code>CreateFile</code></p></blockquote><p>句柄值是4的倍数，0不是有效句柄值</p><h4 id="1-6-1-对象名"><a href="#1-6-1-对象名" class="headerlink" title="1.6.1 对象名"></a>1.6.1 对象名</h4><p>某些类型的对象可以有名称，可用于通过合适的 Open 函数按名称打开对象。 </p><p>用户模式调用 Create 函数按名称创建对象，如果存在，则仅打开现有对象。</p><p>winObj中显示的名称有时不是对象的真实名称：</p><ul><li>进程和线程显示ID</li><li>文件对象显示文件名（或设备名），因为共享的原因，无法通过文件名获得文件对象句柄</li><li>（注册表）键对象与注册表的路径一起显示，原因同文件对象</li><li>目录对象显示路径，目录不是文件系统对象，而是对象管理器目录，可通过Sysinternals WinObj查看</li><li>令牌对象名称与存储在令牌中的用户名一起显示</li></ul><h4 id="1-6-2-访问现有对象"><a href="#1-6-2-访问现有对象" class="headerlink" title="1.6.2 访问现有对象"></a>1.6.2 访问现有对象</h4><p>Process Explorer 的句柄视图中的访问列显示用于打开或创建句柄的访问掩码</p><p>Process Explorer中显示的引用数（References）不是实际引用数（outstanding references）</p><p>[windbg]中用<code>!trueref</code>获取实际引用数（actual reference）</p><h2 id="2-内核开发入门"><a href="#2-内核开发入门" class="headerlink" title="2 内核开发入门"></a>2 内核开发入门</h2><p>本章主要是关于准备内核开发所需的环境，包括开发和调试的工具以及环境配置</p><p>以及启动和运行内核驱动的知识</p><p>然后写一个可以加载和卸载的驱动</p><h3 id="驱动开发准备工作"><a href="#驱动开发准备工作" class="headerlink" title="驱动开发准备工作"></a>驱动开发准备工作</h3><p>首先按 2.1安装工具 完成安装，然后为驱动开发配置虚拟机（未包括内核调试的配置）</p><p><strong>安装无签名驱动</strong></p><p>如果驱动没有签名，安装驱动需要以该模式启动系统</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">bcdedit &#x2F;set testsigning on</code></pre><p><strong>显示内核调试信息</strong></p><p>在<code>HKLM\SYSTEM\CurrentControlSet\Control\Session Manager</code>添加一个名为<code>Debug Print Filter</code>的键<br>在键中添加一个<code>DWORD</code>，名为<code>DEFAULT</code>，值为<code>8</code></p><p><strong>虚拟机文件共享</strong></p><p>实际操作时，安装在虚拟机中（避免本机崩溃），需要共享项目的文件给虚拟机</p><p>共享本机的 vs解决方案文件夹 给虚拟机，名称为<code>MyDriver</code></p><p>虚拟机中的debug输出路径为：<code>\\vmware-host\Shared Folders\MyDriver\x64\Debug</code></p><p><strong>驱动调试工具</strong></p><p>安装完WDK后，把<code>C:\Program Files (x86)\Windows Kits\10\Tools\x64</code>这个目录复制到虚拟机中，这个是x64下的驱动开发调试工具，比如用于查看内存池的poolmon</p><h3 id="2-1-安装工具"><a href="#2-1-安装工具" class="headerlink" title="2.1 安装工具"></a>2.1 安装工具</h3><p>需要vs2019、windows 10 sdk（vs2019中安装）、windows 10 driver kit（WDK）</p><p>以及 Sysinternals，该工具包含debug view、process monitor等一系列有用的工具</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>在实际编译中发现，新版本的vs驱动项目默认开启缓解Spectre 漏洞</p><p>可以在c/c++、代码生成中关闭该项，或在vs installer中安装对应工具</p></blockquote><h3 id="2-2-创建一个驱动工程"><a href="#2-2-创建一个驱动工程" class="headerlink" title="2.2 创建一个驱动工程"></a>2.2 创建一个驱动工程</h3><p>vs2019中选择创建一个<code>Empty WDM Driver</code>，创建完成后有个<code>inf</code>后缀的文件，暂时不需要，删除掉</p><h3 id="2-3-DriverEntry-和-Unload-Routines"><a href="#2-3-DriverEntry-和-Unload-Routines" class="headerlink" title="2.3 DriverEntry 和 Unload Routines"></a>2.3 DriverEntry 和 Unload Routines</h3><p>DriverEntry 是驱动的默认入口点</p><p>系统线程以<code>IRQL_PASSIVE_LEVEL</code>(0)调用 DriverEntry</p><p>DriverEntry函数原型：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">extern &quot;C&quot;NTSTATUSDriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath);</code></pre><p>一个简单的驱动（sample.cpp）：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;ntddk.h&gt;void SampleUnload(_In_ PDRIVER_OBJECT DriverObject) &#123;UNREFERENCED_PARAMETER(DriverObject);&#125;extern &quot;C&quot;NTSTATUSDriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) &#123;UNREFERENCED_PARAMETER(RegistryPath);    DriverObject-&gt;DriverUnload &#x3D; SampleUnload;    return STATUS_SUCCESS;&#125;</code></pre><h3 id="2-4-安装驱动"><a href="#2-4-安装驱动" class="headerlink" title="2.4 安装驱动"></a>2.4 安装驱动</h3><p>安装驱动和安装用户态服务相似，需要调用Create Service API或使用工具</p><p>sc.exe（系统自带）是著名工具之一</p><p>安装驱动需要管理员权限</p><p>创建服务项：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">sc create sample type&#x3D; kernel binPath&#x3D; &quot;\\vmware-host\Shared Folders\MyDriver\x64\Debug\sample.sys&quot;</code></pre><p>随后就能在注册表（regedit.exe）的<code>HKLM\System\CurrentControlSet\Services\Sample</code>中看到该项</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>注册表项位置：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Sample</p><p>假设<code>binPath= c:\</code>，注册表项<code>ImagePath= \??\c:\</code></p><p>假设<code>binPaht= &quot;\\vmware-hots\&quot;</code>，注册表项<code>ImagePath= \??\UNC\vmware-hots\</code></p></blockquote><p>加载驱动（启动服务）：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">sc start sample</code></pre><p>在process explorer中，选择System进程，查看dll窗口，拉到最下面就能看到sample.sys</p><p>卸载驱动（停止服务）：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">sc stop sample</code></pre><h3 id="2-5-简单跟踪（S1）"><a href="#2-5-简单跟踪（S1）" class="headerlink" title="2.5 简单跟踪（S1）"></a>2.5 简单跟踪（S1）</h3><p><code>KdPrint 宏</code>是<code>DbgPrint API</code>的包装</p><p>通过在每个函数开头加入<code>KdPrint((&quot;Debug messgae&quot;));</code>可以观察函数调用的发生</p><p>使用DebugView，选择capture Kernel可以看到内核调试信息</p><h3 id="2-6-练习：显示系统信息（E1）"><a href="#2-6-练习：显示系统信息（E1）" class="headerlink" title="2.6 练习：显示系统信息（E1）"></a>2.6 练习：显示系统信息（E1）</h3><p>创建一个驱动用于显示系统版本信息，使用<code>RtlGetVersion</code></p><p>code:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Get VersionRTL_OSVERSIONINFOW versionInfo &#x3D; &#123; 0, &#125;;versionInfo.dwOSVersionInfoSize &#x3D; sizeof(RTL_OSVERSIONINFOW);RtlGetVersion(&amp;versionInfo);&#x2F;&#x2F; PrintDbgPrint(&quot;[E1] Major:%d\n[E1] Minor:%d\n[E1] Build:%d&quot;,versionInfo.dwMajorVersion,versionInfo.dwMinorVersion,versionInfo.dwBuildNumber);</code></pre><p>shell:</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">sc create E1_OSVersion type&#x3D; kernel binPath&#x3D; &quot;\\vmware-host\Shared Folders\MyDriver\x64\Debug\E1_OSVersion.sys&quot;sc start E1_OSVersionsc stop E1_OSVersion</code></pre><h2 id="3-内核编程基础"><a href="#3-内核编程基础" class="headerlink" title="3 内核编程基础"></a>3 内核编程基础</h2><p>研究一些内核的API、结构和定义，以及一些驱动程序中的机制</p><h3 id="3-1-通用内核编程指南"><a href="#3-1-通用内核编程指南" class="headerlink" title="3.1 通用内核编程指南"></a>3.1 通用内核编程指南</h3><p>用户模式和内核模式调试的重要区别</p><table><thead><tr><th></th><th>用户模式</th><th>内核模式</th></tr></thead><tbody><tr><td>未处理异常</td><td>进程崩溃</td><td>系统崩溃</td></tr><tr><td>终止</td><td>当进程终止，所有内存和资源都会被自动释放</td><td>当驱动卸载，如果没有手动释放，会造成泄露直到重启</td></tr><tr><td>返回值</td><td>API错误有时候会忽略</td><td>应该不忽略任何错误</td></tr><tr><td>IRQL</td><td>总是 PASSIVE_LEVEL (0)</td><td>可能为更高</td></tr><tr><td>错误代码</td><td>通常只会影响本进程</td><td>影响整个系统</td></tr><tr><td>测试和调试</td><td>通常在开发机器上调试</td><td>需要双机调试</td></tr><tr><td>库（Lib）</td><td>可以使用C/C++库（如STL、boost）</td><td>大多数标准库无法使用</td></tr><tr><td>异常处理</td><td>可以使用C++异常或SEH</td><td>只能使用SEH</td></tr><tr><td>C++支持</td><td>完全的C++支持</td><td>不支持C++ runtime</td></tr></tbody></table><h4 id="3-1-1-未处理异常"><a href="#3-1-1-未处理异常" class="headerlink" title="3.1.1 未处理异常"></a>3.1.1 未处理异常</h4><p>未处理异常会导致蓝屏，原因是防止继续执行代码、对系统造成不可逆转的伤害</p><p>内核代码不应该跳过任何细节或错误检查</p><h4 id="3-1-2-终止"><a href="#3-1-2-终止" class="headerlink" title="3.1.2 终止"></a>3.1.2 终止</h4><p>如果驱动程序卸载时仍保留分配的内存或打开的内核句柄，这些资源不会自动释放，只会在下次系统启动时释放</p><p>原因是驱动程序可以分配一些缓冲区，然后将其传递给另一个与之合作的驱动程序</p><h4 id="3-1-3-函数返回值"><a href="#3-1-3-函数返回值" class="headerlink" title="3.1.3 函数返回值"></a>3.1.3 函数返回值</h4><p>忽略内核API的返回值很危险，应该总是检查返回值</p><h4 id="3-1-4-IRQL"><a href="#3-1-4-IRQL" class="headerlink" title="3.1.4 IRQL"></a>3.1.4 IRQL</h4><p>中断请求级（Interrupt Request Level, IRQL）通常为0</p><p>用户模式下始终为0，内核模式下大部分时间为0</p><h4 id="3-1-5-C-使用"><a href="#3-1-5-C-使用" class="headerlink" title="3.1.5 C++使用"></a>3.1.5 C++使用</h4><p>没有C++ runtime</p><p>一些不支持的C++特性：</p><ul><li>不支持<code>new</code>和<code>delete</code>，这正常是在用户模式堆分配的</li><li>不会调用具有非默认构造函数的全局变量<ul><li>避免在构造函数中使用代码，创建一些要显式调用的Init函数</li><li>仅将指针分配为全局变量，动态创建实例</li></ul></li><li>不支持C++异常处理（<code>try</code>、<code>catch</code>、<code>throw</code>）</li><li>不可使用标准C++库，如<code>std::vector&lt;&gt;</code>、<code>std::wstring</code>等</li></ul><p>一些支持的C++特性：</p><ul><li><code>nullptr</code>关键字</li><li><code>auto</code>关键字</li><li>模板将在有意义时使用</li><li>重载new 和delete 运算符</li><li>构造函数和析构函数，尤其是用于构建 RAII 类型</li></ul><h4 id="3-1-6-测试和调试"><a href="#3-1-6-测试和调试" class="headerlink" title="3.1.6 测试和调试"></a>3.1.6 测试和调试</h4><p>内核调试需要双机调试，一台作为调试者、另一台作为被调试者运行驱动程序</p><h3 id="3-2-Debug-vs-Release-生成"><a href="#3-2-Debug-vs-Release-生成" class="headerlink" title="3.2 Debug vs. Release 生成"></a>3.2 Debug vs. Release 生成</h3><p>内核术语是 Checked（Debug）和 Free（Release）</p><p>Debug意味着可以使用DBG符号</p><h3 id="3-3-内核API"><a href="#3-3-内核API" class="headerlink" title="3.3 内核API"></a>3.3 内核API</h3><p>内核API常用前缀的意义：</p><ul><li>Ex：一般执行函数</li><li>Ke：一般内核函数</li><li>Mm：内存管理</li><li>Rtl：一般运行时库</li><li>FsRtl：文件系统运行时库</li><li>Flt：文件系统迷你过滤库</li><li>Ob：对象管理</li><li>Io：I/O管理</li><li>Se：安全</li><li>Ps：进程结构</li><li>Po：电源管理</li><li>Wmi：Windows管理工具</li><li>Zw：native API 包装</li><li>Hal：硬件抽象层</li><li>Cm：配置管理器（注册表）</li></ul><p>Nt前缀的内核函数对应NtDll.Dll的函数，会根据 KTHREAD 结构的标记（调用者是否来自内核）对参数进行检查</p><p>Zw前缀的内核函数先将调用者模式设为<code>KernelMode(0)</code>，然后调用Nt前缀的内核函数</p><h3 id="3-4-函数和错误代码"><a href="#3-4-函数和错误代码" class="headerlink" title="3.4 函数和错误代码"></a>3.4 函数和错误代码</h3><p>可以在<code>ntstatus.h</code>中找到<code>NTSTATUS</code>值的定义</p><p>大多数代码并不关心错误具体是什么，仅测试最高位即可，可以使用<code>NT_SUCCESS</code>宏</p><p>当返回到用户层时，会由<code>STATUS_xxx</code>转成<code>ERROR_yyy</code>，用户模式通过GetLastError可以得到这些错误</p><p>通常遇到错误时，会返回相同的 NTSTATUS 到调用函数</p><h3 id="3-5-字符串"><a href="#3-5-字符串" class="headerlink" title="3.5 字符串"></a>3.5 字符串</h3><p>内核使用<code>UNICODE_STRING</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct _UNICODE_STRING &#123;USHORT Length;USHORT MaximumLength;PWCH Buffer;&#125; UNICODE_STRING;typedef UNICODE_STRING *PUNICODE_STRING;typedef const UNICODE_STRING *PCUNICODE_STRING;</code></pre><p><code>Length</code>是字符串的字节数（不包括\x00\x00结束符）</p><p><code>MaximumLength</code>是不需要重新分配内存的情况下、字符串字节数上限</p><p>需要注意的是，UNICODE_STRING并<strong>不总是有\x00\x00结尾</strong></p><p>一些常用的字符串操作函数：</p><ul><li>RtlInitUnicodeString</li><li>RtlCopyUnicodeString</li><li>RtlCompareUnicodeString </li><li>RtlEqualUnicodeString </li><li>RtlAppendUnicodeStringToString</li><li>RtlAppendUnicodeToString</li></ul><h3 id="3-6-动态内存分配（S2）"><a href="#3-6-动态内存分配（S2）" class="headerlink" title="3.6 动态内存分配（S2）"></a>3.6 动态内存分配（S2）</h3><p>内核提供两种通用内存池（general memory pools）给驱动使用：</p><ul><li>页池（Paged pool）：可能会被换出（paged out）的内存池</li><li>非页池（Non Paged Pool）：一直在RAM中的内存池</li></ul><p>枚举类型<code>POOL_TYPE</code>表示池类型，只有三种是可以用于驱动的：<br><code>PagedPool</code>、<code>NonPagedPool</code>、<code>NonPagedPoolNx</code><br>（non-page pool没有可执行权限）</p><p>常用内存池函数：</p><ul><li>ExAllocatePool（已过时，将被下面的函数取代）</li><li>ExAllocatePoolWithTag</li><li>ExAllocatePoolWithQuotaTag</li><li>ExFreePool</li></ul><p>tag是4字节的值</p><p>可以在PoolMon（WDK的Windows Kits中）中观察到有tag的内存池（tag以大端序字符串显示）</p><p>给ustring分配页池内存：</p><p>code:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">UNICODE_STRING strA;int length;&#x2F;&#x2F; allocatestrA.Buffer &#x3D; (WCHAR*)ExAllocatePoolWithTag(PagedPool,length, &#39;dcba&#39;);if (strA.Buffer &#x3D;&#x3D; nullptr) &#123;    KdPrint((&quot;Failed to allocate memory\n&quot;));    return STATUS_INSUFFICIENT_RESOURCES;&#125;strA.MaximumLength &#x3D; length;</code></pre><p>shell:</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">sc create S2_DynMemAlloc type&#x3D; kernel binPath&#x3D; &quot;\\vmware-host\Shared Folders\MyDriver\x64\Debug\S2_DynMemAlloc.sys&quot;sc start S2_DynMemAllocsc stop S2_DynMemAlloc</code></pre><h3 id="3-7-链表"><a href="#3-7-链表" class="headerlink" title="3.7 链表"></a>3.7 链表</h3><p>内核使用循环双向链表：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct _LIST_ENTRY &#123;    struct _LIST_ENTRY *Flink;    struct _LIST_ENTRY *Blink;&#125; LIST_ENTRY, *PLIST_ENTRY;</code></pre><p><code>CONTAINING_RECORD</code>宏执行适当的偏移计算并转换为实际数据类型<br><code>CONTAINING_RECORD(pvoid, type, entry_member_name)</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct MyDataItem &#123;    &#x2F;&#x2F; some data members    LIST_ENTRY Link;    &#x2F;&#x2F; more data members&#125;;MyDataItem* GetItem(LIST_ENTRY* pEntry) &#123;return CONTAINING_RECORD(pEntry, MyDataItem, Link);&#125;</code></pre><p>常用链表函数（时间复杂度都是常数）：</p><ul><li>InitializeListHead</li><li>InsertHeadList</li><li>InsertTailList</li><li>IsListEmpty</li><li>RemoveHeadList</li><li>RemoveTailList</li><li>RemoveEntryList</li><li>ExInterlockedInsertHeadList</li><li>ExInterlockedInsertTailList</li><li>ExInterlockedRemoveHeadList</li></ul><p>后三个关于自旋锁，在第6章详细讨论</p><h3 id="3-8-驱动对象（The-Driver-Object）"><a href="#3-8-驱动对象（The-Driver-Object）" class="headerlink" title="3.8 驱动对象（The Driver Object）"></a>3.8 驱动对象（The Driver Object）</h3><p>常用major function代码：</p><ul><li>IRP_MJ_CREATE (0) </li><li>IRP_MJ_CLOSE (2)</li><li>IRP_MJ_READ (3) </li><li>IRP_MJ_WRITE (4) </li><li>IRP_MJ_DEVICE_CONTROL (14) </li><li>IRP_MJ_INTERNAL_DEVICE_CONTROL (15)</li><li>IRP_MJ_PNP (31) </li><li>IRP_MJ_POWER (22)</li></ul><p><code>MajorFunction</code>数组由内核初始化指向内核内部例程<code>IopInvalidDeviceRequest</code>，该例程直接返回失败，表示不支持该操作</p><h3 id="3-9-设备对象（Device-Objects）"><a href="#3-9-设备对象（Device-Objects）" class="headerlink" title="3.9 设备对象（Device Objects）"></a>3.9 设备对象（Device Objects）</h3><p>驱动通过设备与r3代码通信，驱动应该至少创建一个设备对象并为其命名</p><p>CreateFile可以打开设备，第一个参数为设备对象名称</p><p>打开文件或设备的句柄会创建内核结构 FILE_OBJECT 的实例，这是个半文档化的结构。 </p><p>更准确的说，CreteFile接受一个<code>symbolic link</code>（符号链接）</p><p>对象管理器中名为<code>??</code>的目录下的符号链接都可被用户模式代码通过CreateFile或Createfile2调用</p><p>可以通过WinObj查看（WinObj中目录名为<code>Global??</code>）</p><p>使用符号链接的CreateFile的文件名（第一个参数），必须加上前缀<code>\\.\</code>（c++中是<code>&quot;\\\\.\\&quot;</code>）</p><p>如果创建了多个设备对象，将形成一个单向链表，添加设备时是头插法，所以第一个创建的设备在链表的最后</p><h2 id="4-驱动从头到尾（Driver-from-Start-to-Finish）（S3）"><a href="#4-驱动从头到尾（Driver-from-Start-to-Finish）（S3）" class="headerlink" title="4 驱动从头到尾（Driver from Start to Finish）（S3）"></a>4 驱动从头到尾（Driver from Start to Finish）（S3）</h2><p>将完成一个完整的驱动及客户端程序，利用驱动完成只能在内核模式下完成的功能（设置任意级别的线程优先级）</p><h3 id="4-1-绪论"><a href="#4-1-绪论" class="headerlink" title="4.1 绪论"></a>4.1 绪论</h3><p>线程优先级 = 进程优先级 + 相对线程优先级</p><p>用户模式下，设置进程优先级可以用<code>SetPriorityClass</code>，共有6个级别<br>设置相对线程优先级可以用<code>SetThreadPriority</code>，共有7个级别</p><p>下面是线程优先级合法值的表（通过windows api设置），据别的书说是个未文档化的东西，windows不建议开发时考虑线程优先级，该表的值随windows版本变化可能发生改变</p><table><thead><tr><th>进程优先级</th><th>-Sat</th><th>-2</th><th>-1</th><th>0</th><th>+1</th><th>+2</th><th>+sat</th></tr></thead><tbody><tr><td>Idle(low)</td><td>1</td><td></td><td></td><td>4</td><td></td><td></td><td>15</td></tr><tr><td>Below Normal</td><td>1</td><td></td><td></td><td>6</td><td></td><td></td><td>15</td></tr><tr><td>Normal</td><td>1</td><td></td><td></td><td>8</td><td></td><td></td><td>15</td></tr><tr><td>Above Normal</td><td>1</td><td></td><td></td><td>10</td><td></td><td></td><td>15</td></tr><tr><td>High</td><td>1</td><td></td><td></td><td>13</td><td></td><td></td><td>15</td></tr><tr><td>Real-time</td><td>16</td><td></td><td></td><td>24</td><td></td><td></td><td>31</td></tr></tbody></table><p>进程优先级枚举：级别+<code>_PRIORITY_CLASS</code></p><p>线程优先级枚举：<code>THREAD_PRIORITY_</code>+级别</p><h3 id="4-2-驱动初始化"><a href="#4-2-驱动初始化" class="headerlink" title="4.2 驱动初始化"></a>4.2 驱动初始化</h3><p>大多数驱动需要在DriverEntry中做如下操作：</p><ul><li>设置Unload例程</li><li>设置驱动支持的调度例程</li><li>创建一个设备对象</li><li>创建一个指向设备对象的符号链接</li></ul><p>所有驱动必须支持<code>IRP_MJ_CREATE</code>和<code>IRP_MJ_CLOSE</code>，不然无法打开一个驱动的设备的句柄，通常这两个调度例程是相同的</p><p>调度例程的函数原型：<code>NTSTATUS Function(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)</code></p><h4 id="4-2-1-将信息传给驱动"><a href="#4-2-1-将信息传给驱动" class="headerlink" title="4.2.1 将信息传给驱动"></a>4.2.1 将信息传给驱动</h4><p>用户模式客户端可用的三个基础函数：<code>WriteFile</code>、<code>ReadFile</code>、<code>DeviceIoControl</code></p><h4 id="4-2-2-客户端-驱动程序通信协议"><a href="#4-2-2-客户端-驱动程序通信协议" class="headerlink" title="4.2.2 客户端/驱动程序通信协议"></a>4.2.2 客户端/驱动程序通信协议</h4><p>必须使用<code>CTL_CODE</code>宏来构建控制代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \    ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \)</code></pre><ul><li>DeviceType：设备类型标识，<code>FILE_DEVICE_xxx</code>，第三方应以0x8000开头</li><li>Function：指示特定操作的升序数字，第三方应该以0x800开头</li><li>Method：指示客户端提供的输入和输出缓冲区如何传递给驱动程序（将在第6章详细讨论）</li><li>Access：指示对驱动来说这个操作是什么？</li></ul><p>示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MY_DEVICE 0x800#define IOCTL_MY_OP CTL_CODE(\MY_DEVICE, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)</code></pre><h4 id="4-2-3-创建一个设备对象"><a href="#4-2-3-创建一个设备对象" class="headerlink" title="4.2.3 创建一个设备对象"></a>4.2.3 创建一个设备对象</h4><p><strong>创建设备名：</strong></p><p>在创建一个设备对象前，需要先创建一个<code>UNICODE_STRING</code>存储内部设备名称</p><p>下面是两种初始化方式：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; plan AUNICODE_STRING devName &#x3D; RTL_CONSTANT_STRING(L&quot;\\Device\\YourName&quot;); &#x2F;&#x2F; plan BUNICODE_STRING devName;RtlInitUnicodeString(&amp;devName, L&quot;\\Device\\YourName&quot;);</code></pre><p>设备名称需要在设备对象管理器目录下</p><p>（RtlInitUnicodeString函数内部字符串的长度，RTL_CONSTANT_STRING宏在编译时计算长度）</p><p><strong>创建设备对象：</strong></p><p>创建设备对象需要调用<code>IoCreateDevice</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">NTSTATUS IoCreateDevice(    _In_ PDRIVER_OBJECT DriverObject,    _In_ ULONG DeviceExtensionSize,    _In_opt_ PUNICODE_STRING DeviceName,    _In_ DEVICE_TYPE DeviceType,    _In_ ULONG DeviceCharacteristics,    _In_ BOOLEAN Exclusive,    _Outptr_ PDEVICE_OBJECT *DeviceObject);</code></pre><p><strong>创建设备完整示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">UNICODE_STRING devName &#x3D; RTL_CONSTANT_STRING(L&quot;\\DEVICE\\devName&quot;);PDEVICE_OBJECT devObj;status &#x3D; IoCreateDevice(    DriverObject,        &#x2F;&#x2F; our driver object    0,                   &#x2F;&#x2F; no need for extra bytes    &amp;devName,            &#x2F;&#x2F; the device name    FILE_DEVICE_UNKNOWN, &#x2F;&#x2F; device type    0,                   &#x2F;&#x2F; characteristics flags    FALSE,               &#x2F;&#x2F; not exclusive    &amp;devObj              &#x2F;&#x2F; the resulting pointer);if (status &lt; 0) &#123;    KdPrint((&quot;[] Failed to create device object (0x%08X)\n&quot;, status));    return status;&#125;</code></pre><p><strong>创建符号链接：</strong></p><p>需要创建一个指向设备的符号链接，供r3调用</p><p>同样需要先创建一个字符串作为符号链接对象名称</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">UNICODE_STRING symLink &#x3D; RTL_CONSTANT_STRING(L&quot;\\??\\symLinkName&quot;);status &#x3D; IoCreateSymbolicLink(&amp;symLink, &amp;devName);if (status &lt; 0) &#123;KdPrint((&quot;[] Failed to create symbolic link (0x%08X)\n&quot;, status));    return status;&#125;</code></pre><p><strong>注意：资源释放</strong></p><p>上面创建的字符串会自动释放（好像在函数的栈中）？但对象不会，需要（在unload例程中）手动删除</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Unload(_In_ PDRIVER_OBJECT DriverObject) &#123;    &#x2F;&#x2F; delete symbolic link    UNICODE_STRING symLink &#x3D; RTL_CONSTANT_STRING(L&quot;\\??\\symLinkName&quot;);    IoDeleteSymbolicLink(&amp;symLink);    &#x2F;&#x2F; delete device object    IoDeleteDevice(DriverObject-&gt;DeviceObject);&#125;</code></pre><h3 id="4-3-客户端代码"><a href="#4-3-客户端代码" class="headerlink" title="4.3 客户端代码"></a>4.3 客户端代码</h3><p>将用<code>CTL_CODE</code>构造的控制代码放到一个头文件中，供驱动代码和用户模式客户端代码同时使用</p><p>通过符号链接获驱动的设备的句柄</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#123;    HANDLE hDevice &#x3D; CreateFile(L&quot;\\\\.\\symLinkName&quot;, GENERIC_WRITE,        FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);    if (hDevice &#x3D;&#x3D; INVALID_HANDLE_VALUE)        return Error(&quot;Failed to open device&quot;);&#125;    int Error(const char* msg) &#123;    printf(&quot;%s (error&#x3D;%d)\n&quot;, msg, GetLastError());    return 1;&#125;</code></pre><h3 id="4-4-Create和Close调度例程"><a href="#4-4-Create和Close调度例程" class="headerlink" title="4.4 Create和Close调度例程"></a>4.4 Create和Close调度例程</h3><p>该例程什么都不用做，直接返回成功即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">NTSTATUS PriorityBoosterCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp) &#123;    UNREFERENCED_PARAMETER(DeviceObject);        Irp-&gt;IoStatus.Status &#x3D; STATUS_SUCCESS;    Irp-&gt;IoStatus.Information &#x3D; 0;    IoCompleteRequest(Irp, IO_NO_INCREMENT);    return STATUS_SUCCESS;&#125;</code></pre><p>IRP是半文档化结构，通常来自运行中的管理器：I/O Manager, Plug &amp; Play Manager or Power Manager</p><p>对驱动程序的每个请求总是包装在 IRP 中</p><p>IRP中有一个或多个<code>IO_STACK_LOCATION</code>结构</p><p>为了完成IRP，需要调用<code>IoCompleteRequest</code>，这个函数做很多东西，基本上理解为将IRP传播回创建者（通常是I/O管理器），然后由管理器通知客户端操作完成</p><h3 id="4-5-DeviceIoControl调度例程"><a href="#4-5-DeviceIoControl调度例程" class="headerlink" title="4.5 DeviceIoControl调度例程"></a>4.5 DeviceIoControl调度例程</h3><p>调用<code>IoGetCurrentIrpStackLocation</code>获取当前设备对应的<code>IO_STACK_LOCATION</code></p><p><code>IO_STACK_LOCATION</code>中有控制代码、输入输出buffer指针等</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>调度例程运行在调用该例程的用户模式进程的上下文中</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">DWORD threadId;PETHREAD Thread;status &#x3D; PsLookupThreadByThreadId(ULongToHandle(threadId), &amp;Thread);</code></pre><p>使用<code>ULongToHandle</code>（这实际上只是个casting）将pid转换成<code>HANDLE</code></p><p>线程和进程存在一个全局私有内核句柄表，句柄的“值”实际上就是ID</p><p>（HANDLE在64位系统是64位，线程ID始终是32位）</p><h3 id="4-6-安装和测试"><a href="#4-6-安装和测试" class="headerlink" title="4.6 安装和测试"></a>4.6 安装和测试</h3><pre class="line-numbers language-none"><code class="language-none">sc create S3_PriorityBooster type&#x3D; kernel binPath&#x3D; &quot;\\vmware-host\Shared Folders\MyDriver\x64\Debug\S3_PriorityBooster.sys&quot;sc start S3_PriorityBoostersc stop S3_PriorityBoostersc delete S3_PriorityBooster</code></pre><p>start后可以在WinObj中的<code>Driver</code>目录下看到驱动、<code>GLOBAL??</code>目录下看到符号链接</p><p>可以在Process Explorer中查看进程的pid以及其线程的动态优先级</p><h2 id="5-调试"><a href="#5-调试" class="headerlink" title="5 调试"></a>5 调试</h2><p>关于使用WinDbg进行调试</p><h3 id="5-1-windows的调试工具"><a href="#5-1-windows的调试工具" class="headerlink" title="5.1 windows的调试工具"></a>5.1 windows的调试工具</h3><p>四个调试器：</p><ul><li>Cdb 和 Ntsd 是用户模式调试器，可以附加到进程上，是命令行界面，没有什么大的区别</li><li>Kd 是内核调试器，提供命令行界面，可以附加到本地内核或其他机器</li><li>WinDbg 是有图形化界面的调试器，可以调试用户和内核模式</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>WinDbg Preview是WinDbg的“最新版”，解决了一些WinDbg上的bug</p></blockquote><p>这些调试器都是基于<code>DbgEng.Dll</code></p><h3 id="5-2-WinDbg简介"><a href="#5-2-WinDbg简介" class="headerlink" title="5.2 WinDbg简介"></a>5.2 WinDbg简介</h3><p>虽然有GUI，实际上还是命令行，所有UI操作都会转成命令，显示在命令行窗口上</p><p>WinDbg支持三种类型的命令：</p><ul><li>标准命令(Intrinsic)：内置在调试器中，在被调试的目标上运行</li><li>元命令(Meta)：以<code>.</code>开头，作用于调试器(debugging process)本身，而不是直接作用于被调试目标</li><li>拓展命令：以<code>!</code>开头，提供调试器大部分功能，都在拓展DLL中实现</li></ul><h4 id="教程：用户模式调试基础"><a href="#教程：用户模式调试基础" class="headerlink" title="教程：用户模式调试基础"></a>教程：用户模式调试基础</h4><p><strong>符号信息：</strong></p><p>设置符号的方法1：<code>.symfix</code></p><p>设置符号的方法2：设置环境变量<br><code>_NT_SYMBOL_PATH</code>=<code>SRV*c:\Symbols*http://msdl.microsoft.com/download/symbols</code></p><p><code>lm</code>：显示进程加载的模块，以及各模块是否加载了符号</p><p><code>.reload /f modulename.dll</code>：强制加载模块的符号</p><p><code>!sym noisy</code>：记录符号加载尝试的详细信息</p><p><strong>线程：</strong></p><p><code>~</code>：显示调试进程中所有线程的信息<br>线程信息前的<code>.</code>表示当前线程，<code>#</code>表示触发中断的线程<br>输入提示冒号右边的数字是当前线程的索引</p><pre class="line-numbers language-none"><code class="language-none">0  Id: 874c.18068 Suspend: 1 Teb: 00000001&#96;2229d000 Unfrozen[下标] Id: [PID].[TID] Suspend: [挂起计数] Teb: [TEB地址] [是否冻结]</code></pre><p><code>~ns</code>：切换到索引为n的线程<br>可以组合命令<code>~nk</code>，这样可以在不切换线程的情况下，在别的线程执行操作（这里是显示别的线程的调用堆栈）</p><p><code>k</code>：当前线程的调用堆栈（stack trace）</p><p><code>!teb</code>：查看TEB的部分信息，默认当前线程的</p><p><strong>进制转换：</strong></p><p>16转10：</p><pre class="line-numbers language-none"><code class="language-none">0:000&gt; ? 874cEvaluate expression: 34636 &#x3D; 0000874c</code></pre><p>10转16：</p><pre class="line-numbers language-none"><code class="language-none">0:000&gt; ? 0n34636Evaluate expression: 34636 &#x3D; 0000874c</code></pre><p><strong>数据或结构的显示：</strong></p><p><code>dt [type]</code>：显示数据结构的定义（如显示_TEB：<code>dt ntdll!_teb</code>）</p><p><code>dt [type] [addr]</code>：显示数据结构的数据（如显示某个_TEB：<code> dt ntdll!_teb 000000`012229d000</code>）</p><p><code>r [reg]</code>：读取寄存器（如读取rcx：<code>r rcx</code>）</p><p><code>d&#123;a|b|c|d|D|f|p|q|u|w|W&#125;</code>：以指定类型显示指定地址的数据<br>a：ascii字符<br>b,w,d,q：字节<br>u：unicode<br>f：单精浮点<br>D：双精浮点</p><p><code>u</code>：显示反汇编，默认8句汇编指令</p><p><code>!error [error_code]</code>：显示错误信息</p><p><strong>断点和运行：</strong></p><p><code>bp [symbol]</code>：设置断点（如CreateFile：<code>bp kernel32!createfilew</code>）</p><p><code>bl</code>：显示当前设置的断点</p><p><code>bd</code>：禁用断点，禁用所有断点：<code>bd *</code></p><p><code>bc</code>：删除断点</p><p><code>g</code>(F5)：运行直到断点</p><p><code>p</code>(F10)：步过</p><p><code>t</code>(F11)：步进</p><h3 id="5-3-内核调试（本地）"><a href="#5-3-内核调试（本地）" class="headerlink" title="5.3 内核调试（本地）"></a>5.3 内核调试（本地）</h3><h4 id="本地内核调试"><a href="#本地内核调试" class="headerlink" title="本地内核调试"></a>本地内核调试</h4><p>修改启动项：<code>bcdedit /debug on</code></p><h4 id="本地内核调试教程"><a href="#本地内核调试教程" class="headerlink" title="本地内核调试教程"></a>本地内核调试教程</h4><p><code>!process 0 0</code>：显示所有进程的基本信息</p><pre class="line-numbers language-none"><code class="language-none">lkd&gt; !process 0 0**** NT ACTIVE PROCESS DUMP ****PROCESS ffff8d0e682a73c0    SessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000    DirBase: 001ad002 ObjectTable: ffffe20712204b80 HandleCount: 9542.    Image: System    (truncated)</code></pre><ul><li>PROCESS旁边的地址：EPROCESS的地址</li><li>SessionId：进程所处的对话</li><li>Cid：pid</li><li>Peb：PEB地址（在用户模式地址空间）</li><li>ParentCid：父进程pid</li><li>DirBase：进程主页目录的物理地址（x32是PDPT基址、x64是PML4基址）</li><li>ObjectTable：指向进程的私有句柄表的指针 </li><li>HandleCount：进程中的句柄数</li><li>Image：可执行文件名称，或与可执行文件无关的特殊进程名称 </li></ul><p><code>!process</code>指令后第一个数字是筛选特定进程，0表示所有进程；第二个数字是细节掩码，0表示最少细节；第三个参数是筛选可执行文件</p><p><code>.process /p [EPROCESS]</code>：切换到指定进程</p><p>peb在用户模式地址空间中，查看peb需要先设置正确的用户模式进程环境</p><p>不切换的做法：<code>.process /p ffff8d0e849df080; !peb e8a8c9c000</code></p><p>调用堆栈中，nt前缀表示内核</p><p><code>.reload /user</code>：加载用户模式符号</p><p>其余常用/有趣的内核模式调试指令：</p><ul><li><code>!pcr</code>：显示指定为附加索引的处理器的进程控制区域 (PCR)（如果未指定索引，则默认显示处理器 0）</li><li><code>!vm</code>：显示系统和进程的内存统计信息</li><li><code>!running</code>：显示有关在系统上所有处理器上运行的线程的信息</li></ul><h3 id="5-4-完全内核调试（双机）"><a href="#5-4-完全内核调试（双机）" class="headerlink" title="5.4 完全内核调试（双机）"></a>5.4 完全内核调试（双机）</h3><p>完全内核调试需要”双机“</p><p>最好的连接方式是通过网络，这需要主机和被调试目标系统版最少为Win8</p><p>另外一种方法是COM串口，大多数虚拟机支持虚拟串口而不需要真实（物理的）串口线</p><p>详细配置方式略过</p><h4 id="配置目标机器"><a href="#配置目标机器" class="headerlink" title="配置目标机器"></a>配置目标机器</h4><pre class="line-numbers language-none"><code class="language-none">bcdedit &#x2F;debug onbcdedit &#x2F;dbgsettings serial debugport:1 baudrate:115200</code></pre><h4 id="配置主机"><a href="#配置主机" class="headerlink" title="配置主机"></a>配置主机</h4><p>调试器需要设置调试端口映射和命名管道，与虚拟机上的相同</p><p>输入提示kd左边的数字是引起中断的处理器的索引</p><h3 id="5-5-内核驱动调试教程"><a href="#5-5-内核驱动调试教程" class="headerlink" title="5.5 内核驱动调试教程"></a>5.5 内核驱动调试教程</h3><p>可以设置未来断点（在运行程序前设置断点）</p><p>如设置驱动prioritybooster的入口点：<code>bu prioritybooster!driverentry</code></p><p>可以设置只在指定进程上中断：<code>bp /p [EPROCESS] [symbol]</code><br>如：<code> bp /p ffffdd06042e4080 prioritybooster!priorityboosterdevicecontrol</code></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/kernel/">kernel</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wkp/">wkp</category>
      
      
      <comments>https://windgodm.github.io/blog/post/wkp1-5.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《逆向工程实战》1.7练习 反编译windows内核例程</title>
      <link>https://windgodm.github.io/blog/post/practicalre1-7.html</link>
      <guid>https://windgodm.github.io/blog/post/practicalre1-7.html</guid>
      <pubDate>Mon, 08 Nov 2021 14:07:00 GMT</pubDate>
      
      <description>《逆向工程实战》1.7练习，反编译windows内核例程</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="《逆向工程实战》1-7-练习-反编译windows内核例程"><a href="#《逆向工程实战》1-7-练习-反编译windows内核例程" class="headerlink" title="《逆向工程实战》1.7 练习 反编译windows内核例程"></a>《逆向工程实战》1.7 练习 反编译windows内核例程</h1><p>例程选取自win10 x64 21h1</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>每个例程反编译的知识点如下：</p><ul><li><p>KeInitializeDpc：结构体赋值，纯拷贝</p></li><li><p>KeInitializeApc：结构体赋值，有条件拷贝</p></li><li><p>ObFastDereferenceObject：while循环，比较后交换的分析</p></li><li><p>KeInitializeQueue：结构体赋值，有条件拷贝</p></li><li><p>KxWaitForLockChainValid：do-while循环，if(a &amp;&amp; b &amp;&amp; c){}else{}结构</p></li><li><p>KeReadyThread：嵌套的if(){}结构</p></li><li><p>KiInitializeTSS（未找到）</p></li><li><p>RtlValidateUnicodeString：if(a &amp;&amp; b || c){}else{}结构</p></li></ul><h2 id="条件复杂的if-else"><a href="#条件复杂的if-else" class="headerlink" title="条件复杂的if(){}else{}"></a>条件复杂的if(){}else{}</h2><p>KxWaitForLockChainValid和RtlValidateUnicodeString都有类似if(a &amp;&amp; b || c)的结构</p><p>其多个的jmp结果一定会去到两个分支之一，然后回到主分支</p><p>可以理解成析取或合取表达式的提取</p><p>我对windows采用的编译器的理解是，对于或（<code>||</code>）通过多个jmp实现：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; c++if(a&#x3D;&#x3D;0 || b&#x3D;&#x3D;0 || c&#x3D;&#x3D;0)    BranchA();else    BranchB();</code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># asmtest a, ajz loc_Atest b, bjz loc_Atest c, cjz loc_Acall BranchBjmp loc_edloc_A:call BrancAloc_ed:</code></pre><p>对于（<code>&amp;&amp;</code>）会将后面的合取转成析取，然后生成一个chunk：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; c++ 1if(a&#x3D;&#x3D;0 &amp;&amp; b&#x3D;&#x3D;0 &amp;&amp; c&#x3D;&#x3D;0) &#x2F;&#x2F; &#x3D;&gt; if(a&#x3D;&#x3D;0 &amp;&amp; !(b!&#x3D;0 || c!&#x3D;0))    BranchA();else    BranchB();&#x2F;&#x2F; c++ 2if(a&#x3D;&#x3D;0) &#123;    if(b!&#x3D;0 || c!&#x3D;0)         BranchB();    else        BranchA();&#125;else &#123;    BranchB();&#125;</code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># asmtest a, ajz chunk_1loc_B:call BranchBloc_ed:# ...chunk_1:test b, bjnz loc_Btest c, cjnz loc_Bcall BranchAjmp loc_ed</code></pre><h2 id="KeInitializeDpc"><a href="#KeInitializeDpc" class="headerlink" title="KeInitializeDpc"></a>KeInitializeDpc</h2><h3 id="前置信息"><a href="#前置信息" class="headerlink" title="前置信息"></a>前置信息</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; MSDNvoid KeInitializeDpc(  [out]          __drv_aliasesMem PRKDPC Dpc,  [in]           PKDEFERRED_ROUTINE      DeferredRoutine,  [in, optional] __drv_aliasesMem PVOID  DeferredContext);</code></pre><p>KDPC的结构（该结构在win10 x64各版本中未发生过改变）：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct _KDPC&#123;    union    &#123;        ULONG TargetInfoAsUlong;    &#x2F;&#x2F;0x0        struct        &#123;            UCHAR Type;             &#x2F;&#x2F;0x0            UCHAR Importance;       &#x2F;&#x2F;0x1            volatile USHORT Number; &#x2F;&#x2F;0x2        &#125;;    &#125;;    struct _SINGLE_LIST_ENTRY DpcListEntry; &#x2F;&#x2F;0x8    ULONGLONG ProcessorHistory;     &#x2F;&#x2F;0x10    VOID (*DeferredRoutine)(struct _KDPC* arg1, VOID* arg2, VOID* arg3, VOID* arg4); &#x2F;&#x2F;0x18    VOID* DeferredContext; &#x2F;&#x2F;0x20    VOID* SystemArgument1; &#x2F;&#x2F;0x28    VOID* SystemArgument2; &#x2F;&#x2F;0x30    VOID* DpcData;         &#x2F;&#x2F;0x38&#125;; </code></pre><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>使用工具得到的反汇编如下：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.text:00000001402E39E0 KeInitializeDpc proc near.text:00000001402E39E0                 xor     eax, eax.text:00000001402E39E2                 mov     dword ptr [rcx], 113h.text:00000001402E39E8                 mov     [rcx+38h], rax.text:00000001402E39EC                 mov     [rcx+10h], rax.text:00000001402E39F0                 mov     [rcx+18h], rdx.text:00000001402E39F4                 mov     [rcx+20h], r8.text:00000001402E39F8                 retn.text:00000001402E39F8 KeInitializeDpc endp</code></pre><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>该初始化函数只是简单的赋值</p><p>反编译结果如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void KeInitializeDpc(    PRKDPC Dpc,    PKDEFERRED_ROUTINE DeferredRoutine,    PVOID DeferredContext)&#123;    Dpc-&gt;TargetInfoAsUlong &#x3D; 0x113; &#x2F;&#x2F; Type&#x3D;0x13, Importance&#x3D;0x1, Number&#x3D;0    Dpc-&gt;ProcessorHistory &#x3D; 0;    Dpc-&gt;DeferredRoutine &#x3D; DeferredRoutine;    Dpc-&gt;DeferredContext &#x3D; DeferredContext;    Dpc-&gt;DpcData &#x3D; 0;&#125;</code></pre><h2 id="KeInitializeApc"><a href="#KeInitializeApc" class="headerlink" title="KeInitializeApc"></a>KeInitializeApc</h2><h3 id="前置信息-1"><a href="#前置信息-1" class="headerlink" title="前置信息"></a>前置信息</h3><p>这是个未文档化的函数</p><p>显然会用到KAPC结构（win10 x64 21H1）：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;0x58 bytes (sizeof)struct _KAPC&#123;    UCHAR Type;                      &#x2F;&#x2F;0x0    UCHAR SpareByte0;                &#x2F;&#x2F;0x1    UCHAR Size;                      &#x2F;&#x2F;0x2    UCHAR SpareByte1;                &#x2F;&#x2F;0x3    ULONG SpareLong0;                &#x2F;&#x2F;0x4    struct _KTHREAD* Thread;         &#x2F;&#x2F;0x8    struct _LIST_ENTRY ApcListEntry; &#x2F;&#x2F;0x10    VOID* Reserved[3];               &#x2F;&#x2F;0x20    VOID* NormalContext;             &#x2F;&#x2F;0x38    VOID* SystemArgument1;           &#x2F;&#x2F;0x40    VOID* SystemArgument2;           &#x2F;&#x2F;0x48    CHAR ApcStateIndex;              &#x2F;&#x2F;0x50    CHAR ApcMode;                    &#x2F;&#x2F;0x51    UCHAR Inserted;                  &#x2F;&#x2F;0x52&#125;; </code></pre><p>在旧版本中（21H1之前），成员Reserved[3]被认为是union：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">union   &#123;       struct       &#123;           VOID (*KernelRoutine)(struct _KAPC* arg1, VOID (**arg2)(VOID* arg1, VOID* arg2, VOID* arg3), VOID** arg3, VOID** arg4, VOID** arg5); &#x2F;&#x2F;0x20           VOID (*RundownRoutine)(struct _KAPC* arg1);                     &#x2F;&#x2F;0x28           VOID (*NormalRoutine)(VOID* arg1, VOID* arg2, VOID* arg3);      &#x2F;&#x2F;0x30       &#125;;       VOID* Reserved[3];                                                  &#x2F;&#x2F;0x20   &#125;;</code></pre><h3 id="汇编-1"><a href="#汇编-1" class="headerlink" title="汇编"></a>汇编</h3><p>使用工具得到的反汇编如下：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.text:00000001402F93D0 KeInitializeApc proc near.text:00000001402F93D0 arg_20          &#x3D; qword ptr  28h ; RundownRoutine.text:00000001402F93D0 arg_28          &#x3D; qword ptr  30h ; NormalRoutine.text:00000001402F93D0 arg_30          &#x3D; byte ptr  38h  ; ApcMode.text:00000001402F93D0 arg_38          &#x3D; qword ptr  40h ; NormalContext.text:00000001402F93D0.text:00000001402F93D0                 mov     byte ptr [rcx], 12h   ; Apc-&gt;Type &#x3D; 0x12.text:00000001402F93D3                 mov     r10, rcx.text:00000001402F93D6                 mov     byte ptr [rcx+2], 58h ; Apc-&gt;Size &#x3D; 0x58.text:00000001402F93DA                 cmp     r8d, 2.text:00000001402F93DE                 jz      short loc_1402F9424.text:00000001402F93E0.text:00000001402F93E0 loc_1402F93E0:                          ; CODE XREF: KeInitializeApc+5B↓j.text:00000001402F93E0                 mov     rax, [rsp+arg_20].text:00000001402F93E5                 mov     [rcx+50h], r8b ; Apc-&gt;ApcStateIndex &#x3D; ApcStateIndex.text:00000001402F93E9                 mov     [rcx+28h], rax ; Apc-&gt;RundownRoutine &#x3D; RundownRoutine.text:00000001402F93ED                 mov     [rcx+8], rdx   ; Apc-&gt;Thread &#x3D; Thread.text:00000001402F93F1                 mov     rdx, [rsp+arg_28].text:00000001402F93F6                 mov     [rcx+30h], rdx ; Apc-&gt;NormalRoutine &#x3D; NormalRoutine.text:00000001402F93FA                 mov     rax, rdx.text:00000001402F93FD                 neg     rax.text:00000001402F9400                 mov     [rcx+20h], r9  ; Apc-&gt;KernelRoutine &#x3D; KernelRoutine.text:00000001402F9404                 sbb     rcx, rcx.text:00000001402F9407                 and     rcx, [rsp+arg_38].text:00000001402F940C                 neg     rdx.text:00000001402F940F                 sbb     al, al.text:00000001402F9411                 and     al, [rsp+arg_30].text:00000001402F9415                 mov     [r10+51h], al  ; Apc-&gt;ApcMode &#x3D; ApcMode.text:00000001402F9419                 mov     [r10+38h], rcx ; Apc-&gt;NormalContext &#x3D; NormalContext.text:00000001402F941D                 mov     byte ptr [r10+52h], 0 ; Apc-&gt;Inserted &#x3D; 0.text:00000001402F9422                 retn.text:00000001402F9422 ; ---------------------------------------------------------------------------.text:00000001402F9423                 align 4.text:00000001402F9424.text:00000001402F9424 loc_1402F9424:                          ; CODE XREF: KeInitializeApc+E↑j.text:00000001402F9424                 mov     r8b, [rdx+24Ah] ; ApcStateIndex &#x3D; Thread-&gt;ApcStateIndex.text:00000001402F942B                 jmp     short loc_1402F93E0.text:00000001402F942B KeInitializeApc endp</code></pre><h3 id="反编译-1"><a href="#反编译-1" class="headerlink" title="反编译"></a>反编译</h3><p><code>1402F93D6 mov byte ptr [rcx+2], 58h</code>对照KAPC的结构，可以发现刚好成员<code>size</code>的偏移是<code>+2</code>，而<code>sizeof(_KAPC) = 0x58</code><br>由此判断rcx是<code>KAPC*</code></p><p>根据后面对Apc的赋值，能够还原参数的符号</p><p>比较有意思的是下面这段汇编：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.text:00000001402F93F1                 mov     rdx, [rsp+arg_28] ; rdx &#x3D; NormalRoutine; ....text:00000001402F93FA                 mov     rax, rdx          ; rax &#x3D; NormalRoutine; ....text:00000001402F940C                 neg     rdx               ; rdx &#x3D; -NormalRoutine.text:00000001402F940F                 sbb     al, al            ; al &#x3D; NormalRoutine !&#x3D; 0 ? -1 : 0.text:00000001402F9411                 and     al, [rsp+arg_30]  ; al &#x3D; NormalRoutine !&#x3D; 0 ? ApcMode : 0;.text:00000001402F9415                 mov     [r10+51h], al</code></pre><p>通过组合<code>neg b; sbb a, a; and a, c</code>实现的<code>a = b != 0 ? c : 0 </code></p><p>当b不等于0时，neg会置cf为1，sbb便会借位，于是<code>a = a - a - 1 = -1</code>；而b等于0时，neg会置cf为0，<code>a = a - a = 0</code></p><p>反编译代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void KeInitializeApc(    _KAPC* Apc,    struct _KTHREAD* Thread,    CHAR ApcStateIndex,    void* KernelRoutine,  &#x2F;&#x2F; func    void* RundownRoutine, &#x2F;&#x2F; func    void* NormalRoutine,  &#x2F;&#x2F; func    CHAR ApcMode,    VOID* NormalContext)&#123;    Apc-&gt;Type &#x3D; 0x12;    Apc-&gt;Size &#x3D; 0x58;    if(ApcStateIndex &#x3D;&#x3D; 2)        ApcStateIndex &#x3D; Thread-&gt;ApcStateIndex;     Apc-&gt;Thread &#x3D; Thread;    Apc-&gt;ApcStateIndex &#x3D; ApcStateIndex;    Apc-&gt;KernelRoutine &#x3D; KernelRoutine;    Apc-&gt;RundownRoutine &#x3D; RundownRoutine;    Apc-&gt;NormalRoutine &#x3D; NormalRoutine;    Apc-&gt;ApcMode &#x3D; NormalRoutine !&#x3D; 0 ? ApcMode : 0;    Apc-&gt;NormalContext &#x3D; NormalContext;&#125;</code></pre><h2 id="ObFastDereferenceObject"><a href="#ObFastDereferenceObject" class="headerlink" title="ObFastDereferenceObject"></a>ObFastDereferenceObject</h2><h3 id="前置信息-2"><a href="#前置信息-2" class="headerlink" title="前置信息"></a>前置信息</h3><p>已知该函数在20h2和21h1中相同，且调用惯例应该是stdcall（被调用方清理栈），由于只有两个参数（通过寄存器传递），所以不需要清理</p><p>查阅资料在win7中该函数的调用惯例应该也是stdcall</p><p>MSDN原文:</p><p><strong>ObDereferenceObject</strong> returns a value that is reserved for system use. Drivers must treat this value as VOID.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; MSDNvoid ObDereferenceObject(  [in]  a);</code></pre><h3 id="汇编-2"><a href="#汇编-2" class="headerlink" title="汇编"></a>汇编</h3><p>有一些比较陌生的汇编指令：</p><p><code>prefectchw</code>：不影响程序的行为。用于将数据提前装入缓存，减少延迟。</p><p><code>lock cmpxchg r/m, r</code>：x86上CAS被翻译成该指令。CAS是比较交换，无锁原子过程</p><p><code>cmpxchg (r/m)a, (r)b</code>：将al/ax/eax/rax与首操作数比较；<br>若相等，等同于<code>mov a, b</code>且<code>zf=1</code>；否则等同于<code>mov al/ax/eax/rax, a</code>且<code>zf=0</code></p><p>使用工具得到的反汇编如下：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.text:0000000140298F70 ObFastDereferenceObject proc near.text:0000000140298F70                 sub     rsp, 28h.text:0000000140298F74                 mov     r9, rdx         ; r9 &#x3D; a2.text:0000000140298F77                 prefetchw byte ptr [rcx].text:0000000140298F7A                 mov     rax, [rcx]      ; rax &#x3D; *a1.text:0000000140298F7D                 mov     r8, rax.text:0000000140298F80                 xor     r8, rdx         ; r8 &#x3D; (*a1) ^ a2.text:0000000140298F83                 cmp     r8, 0Fh.text:0000000140298F87                 jnb     short b1_140298F9A ; jmp r8 &gt;&#x3D; 0xf.text:0000000140298F89.text:0000000140298F89 loopBody_140298F89:                     ; CODE XREF: ObFastDereferenceObject+3E↓j.text:0000000140298F89                 lea     r8, [rax+1]     ; r8 &#x3D; *a1 + 1.text:0000000140298F8D                 lock cmpxchg [rcx], r8.text:0000000140298F92                 jnz     short loopCheck_140298FA4.text:0000000140298F94.text:0000000140298F94 ret_140298F94:                          ; CODE XREF: ObFastDereferenceObject+32↓j.text:0000000140298F94                 add     rsp, 28h.text:0000000140298F98                 retn.text:0000000140298F98 ; ---------------------------------------------------------------------------.text:0000000140298F99                 align 2.text:0000000140298F9A.text:0000000140298F9A b1_140298F9A:                           ; CODE XREF: ObFastDereferenceObject+17↑j.text:0000000140298F9A                                         ; ObFastDereferenceObject+40↓j.text:0000000140298F9A                 mov     rcx, r9         ; DmaAdapter.text:0000000140298F9D                 call    HalPutDmaAdapter.text:0000000140298FA2                 jmp     short ret_140298F94.text:0000000140298FA4 ; ---------------------------------------------------------------------------.text:0000000140298FA4.text:0000000140298FA4 loopCheck_140298FA4:                    ; CODE XREF: ObFastDereferenceObject+22↑j.text:0000000140298FA4                 mov     rdx, rax.text:0000000140298FA7                 xor     rdx, r9         ; rdx &#x3D; rax ^ r9.text:0000000140298FAA                 cmp     rdx, 0Fh.text:0000000140298FAE                 jb      short loopBody_140298F89 ; r8 &#x3D; *a1 + 1.text:0000000140298FB0                 jmp     short b1_140298F9A ; break.text:0000000140298FB0 ObFastDereferenceObject endp</code></pre><h3 id="反编译-2"><a href="#反编译-2" class="headerlink" title="反编译"></a>反编译</h3><p>_InterlockedCompareExchange64(*Dst, Exc, Cmp)，Exc是新值，Cmp是比较值</p><p>反编译代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ObDereferenceObject(UInt64* obj, const UInt64 a2)&#123;    &#x2F;&#x2F; begin:    _m_prefectchw(obj);    UInt64 v0 &#x3D; *obj; &#x2F;&#x2F; rax    UInt64 v1 &#x3D; v0 ^ a2;        while(v1 &lt; 0xf) &#123;        &#x2F;&#x2F; loopBody:        UInt64 oldV0 &#x3D; v0;        v0 &#x3D; _InterlockedCompareExchange64(obj, v0 + 1, v0);        if(oldV0 &#x3D;&#x3D; v0) &#x2F;&#x2F; if v0 not change(obj &#x3D; v0 + 1)            return;        &#x2F;&#x2F; loopCheck:        v1 &#x3D; v0 ^ a2;    &#125;        &#x2F;&#x2F; b1:    v0 &#x3D; HalPutDmaAdapter(a2);        &#x2F;&#x2F; ret:    return;&#125;</code></pre><p>其中loopBody的四行代码相当于以下代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(*obj &#x3D;&#x3D; v0) &#123;    *obj &#x3D; v0 + 1;    return;&#125;else&#123;    v0 &#x3D; *obj;&#125;</code></pre><h2 id="KeInitializeQueue"><a href="#KeInitializeQueue" class="headerlink" title="KeInitializeQueue"></a>KeInitializeQueue</h2><h3 id="前置信息-3"><a href="#前置信息-3" class="headerlink" title="前置信息"></a>前置信息</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; MSDNvoid KeInitializeQueue(  [out] PRKQUEUE Queue,  [in]  ULONG    Count);typedef struct _KQUEUE &#123;    DISPATCHER_HEADER Header;  &#x2F;&#x2F; +0h    LIST_ENTRY EntryListHead;  &#x2F;&#x2F; +18h    ULONG CurrentCount;        &#x2F;&#x2F; +28h    ULONG MaximumCount;        &#x2F;&#x2F; +2Ch    LIST_ENTRY ThreadListHead; &#x2F;&#x2F; +30h&#125; KQUEUE, *PKQUEUE, *RESTRICTED_POINTER PRKQUEUE;</code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct _DISPATCHER_HEADER&#123;union    &#123;        struct        &#123;            UCHAR QueueType;                           &#x2F;&#x2F;0x0            union            &#123;                UCHAR QueueControlFlags;               &#x2F;&#x2F;0x1                struct                &#123;                    UCHAR Abandoned:1;                 &#x2F;&#x2F;0x1                    UCHAR DisableIncrement:1;          &#x2F;&#x2F;0x1                    UCHAR QueueReservedControlFlags:6; &#x2F;&#x2F;0x1                &#125;;            &#125;;            UCHAR QueueSize;                           &#x2F;&#x2F;0x2            UCHAR QueueReserved;                       &#x2F;&#x2F;0x3        &#125;;    &#125;</code></pre><h3 id="汇编-3"><a href="#汇编-3" class="headerlink" title="汇编"></a>汇编</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.text:00000001402DE420 KeInitializeQueue proc near.text:00000001402DE420                 push    rbx.text:00000001402DE422                 sub     rsp, 20h.text:00000001402DE426                 mov     rbx, rcx        ; rbx &#x3D; Queue.text:00000001402DE429                 mov     byte ptr [rcx], 4 ; Queue-&gt;Header.QueueType &#x3D; 4.text:00000001402DE42C                 xor     ecx, ecx.text:00000001402DE42E                 mov     word ptr [rbx+1], 1000h ; *(WORD*)&amp;Queue-&gt;Header.QueueControlFlags &#x3D; 0x1000.text:00000001402DE434                 lea     rax, [rbx+8]    ; rax &#x3D; &amp;Queue-&gt;Header.WaitListHead.text:00000001402DE438                 mov     [rax+8], rax    ; Queue-&gt;Header.WaitListHead.Blink &#x3D; &amp;Queue-&gt;Header.WaitListHead.text:00000001402DE43C                 mov     [rax], rax      ; Queue-&gt;Header.WaitListHead.Flink &#x3D; &amp;Queue-&gt;Header.WaitListHead.text:00000001402DE43F                 lea     rax, [rbx+18h]  ; rax &#x3D; &amp;Queue-&gt;EntryListHead.text:00000001402DE443                 mov     [rax+8], rax    ; Queue-&gt;EntryListHead.Blink &#x3D; &amp;Queue-&gt;EntryListHead.text:00000001402DE447                 mov     [rax], rax      ; Queue-&gt;EntryListHead.Flink &#x3D; &amp;Queue-&gt;EntryListHead.text:00000001402DE44A                 lea     rax, [rbx+30h]  ; rax &#x3D; &amp;Queue-&gt;ThreadListHead.text:00000001402DE44E                 mov     [rax+8], rax    ; Queue-&gt;ThreadListHead.Blink &#x3D; &amp;Queue-&gt;ThreadListHead.text:00000001402DE452                 mov     [rax], rax      ; Queue-&gt;ThreadListHead.Flink &#x3D; &amp;Queue-&gt;ThreadListHead.text:00000001402DE455                 mov     [rbx+4], ecx    ; Queue-&gt;Header.SignalState &#x3D; 0.text:00000001402DE458                 mov     [rbx+28h], ecx  ; Queue-&gt;CurrentCount &#x3D; 0.text:00000001402DE45B                 test    edx, edx.text:00000001402DE45D                 jnz     short loc_1402DE46B ; jmp if edx.text:00000001402DE45F                 mov     ecx, 0FFFFh     ; GroupNumber.text:00000001402DE464                 call    KeQueryActiveProcessorCountEx.text:00000001402DE469                 mov     edx, eax.text:00000001402DE46B.text:00000001402DE46B loc_1402DE46B:                          ; CODE XREF: KeInitializeQueue+3D↑j.text:00000001402DE46B                 mov     [rbx+2Ch], edx  ; Queue-&gt;MaximumCount &#x3D; Count.text:00000001402DE46E                 add     rsp, 20h.text:00000001402DE472                 pop     rbx.text:00000001402DE473                 retn.text:00000001402DE473 ; ---------------------------------------------------------------------------.text:00000001402DE474                 db 0CCh.text:00000001402DE474 KeInitializeQueue endp</code></pre><h3 id="反编译-3"><a href="#反编译-3" class="headerlink" title="反编译"></a>反编译</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void KeInitializeQueue(PRKQUEUE Queue, ULONG Count)&#123;    Queue-&gt;Header.QueueType &#x3D; 4;    *(WORD*)&amp;Queue-&gt;Header.QueueControlFlags &#x3D; 0x1000;    Queue-&gt;Header.WaitListHead.Blink &#x3D; &amp;Queue-&gt;Header.WaitListHead;    Queue-&gt;Header.WaitListHead.Flink &#x3D; &amp;Queue-&gt;Header.WaitListHead;    Queue-&gt;EntryListHead.Blink &#x3D; &amp;Queue-&gt;EntryListHead;    Queue-&gt;EntryListHead.Flink &#x3D; &amp;Queue-&gt;EntryListHead;    Queue-&gt;ThreadListHead.Blink &#x3D; &amp;Queue-&gt;ThreadListHead;    Queue-&gt;ThreadListHead.Flink &#x3D; &amp;Queue-&gt;ThreadListHead;    Queue-&gt;Header.SignalState &#x3D; 0;    Queue-&gt;CurrentCount &#x3D; 0;    if ( !Count )    Count &#x3D; KeQueryActiveProcessorCountEx(0xFFFFu);    Queue-&gt;MaximumCount &#x3D; Count;&#125;</code></pre><h2 id="KxWaitForLockChainValid"><a href="#KxWaitForLockChainValid" class="headerlink" title="KxWaitForLockChainValid"></a>KxWaitForLockChainValid</h2><h3 id="汇编-4"><a href="#汇编-4" class="headerlink" title="汇编"></a>汇编</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.text:0000000140279BD0 KxWaitForLockChainValid proc near.text:0000000140279BD0 arg_0           &#x3D; qword ptr  8.text:0000000140279BD0                 mov     [rsp+arg_0], rbx.text:0000000140279BD5                 push    rdi.text:0000000140279BD6                 sub     rsp, 20h.text:0000000140279BDA                 mov     rdi, rcx        ; rdi &#x3D; a1.text:0000000140279BDD                 xor     ebx, ebx        ; ebx &#x3D; 0.text:0000000140279BDF.text:0000000140279BDF loopStart_140279BDF:                    ; CODE XREF: KxWaitForLockChainValid+25↓j.text:0000000140279BDF                 inc     ebx             ; ebx++.text:0000000140279BE1                 test    cs:HvlLongSpinCountMask, ebx.text:0000000140279BE7                 jz      branch1_140437A78.text:0000000140279BED.text:0000000140279BED pause_140279BED:                        ; CODE XREF: KxWaitForLockChainValid+1BDEB0↓j.text:0000000140279BED                 pause.text:0000000140279BEF.text:0000000140279BEF loopCheck_140279BEF:                    ; CODE XREF: KxWaitForLockChainValid+1BDECB↓j.text:0000000140279BEF                 mov     rax, [rdi]      ; rax &#x3D; *a1.text:0000000140279BF2                 test    rax, rax.text:0000000140279BF5                 jz      short loopStart_140279BDF ; jmp if *a1 &#x3D;&#x3D; 0.text:0000000140279BF7                 mov     rbx, [rsp+28h+arg_0].text:0000000140279BFC                 add     rsp, 20h.text:0000000140279C00                 pop     rdi.text:0000000140279C01                 retn.text:0000000140279C01 ; ---------------------------------------------------------------------------.text:0000000140279C02                 db 0CCh.text:0000000140279C02 KxWaitForLockChainValid endp.text:0000000140437A78 ; START OF FUNCTION CHUNK FOR KxWaitForLockChainValid.text:0000000140437A78.text:0000000140437A78 branch1_140437A78:                      ; CODE XREF: KxWaitForLockChainValid+17↑j.text:0000000140437A78                 mov     eax, cs:HvlEnlightenments.text:0000000140437A7E                 test    al, 40h.text:0000000140437A80                 jz      pause_140279BED.text:0000000140437A86                 call    KiCheckVpBackingLongSpinWaitHypercall.text:0000000140437A8B                 test    al, al.text:0000000140437A8D                 jz      pause_140279BED.text:0000000140437A93                 mov     ecx, ebx.text:0000000140437A95                 call    HvlNotifyLongSpinWait.text:0000000140437A9A                 nop.text:0000000140437A9B                 jmp     loopCheck_140279BEF ; rax &#x3D; *a1.text:0000000140437A9B ; END OF FUNCTION CHUNK FOR KxWaitForLockChainValid</code></pre><h3 id="反编译-4"><a href="#反编译-4" class="headerlink" title="反编译"></a>反编译</h3><p>branch1实际上就是一个if(a &amp; b &amp; c){}else{}的结构，各个jcc是顺序排序，只要触发一个就去到false分支，分析关键是抓住能走完全部jcc的路径</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unsigned long long KxWaitForLockChainValid(unsigned long long* a1)&#123;int i &#x3D; 0;    do&#123;        &#x2F;&#x2F; loopStart:        i++;        if((i &amp; HvlLongSpinCountMask) &#x3D;&#x3D; 0          &amp;&amp; (HvlEnlightenments &amp; 0x40) !&#x3D; 0          &amp;&amp; KiCheckVpBackingLongSpinWaitHypercall() !&#x3D; 0) &#123;            HvlNotifyLongSpinWait(i);        &#125;else&#123;            _mm_pause();        &#125;    &#125;while(!*a1);    return *a1;&#125;</code></pre><h2 id="KeReadyThread"><a href="#KeReadyThread" class="headerlink" title="KeReadyThread"></a>KeReadyThread</h2><p>嵌套的if{}，结构如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#123;    c0();    if() &#123;        c1();        if() c2();        c3();        if() ret();    &#125;    c4();    ret();&#125;</code></pre><h2 id="KiInitializeTSS（未找到）"><a href="#KiInitializeTSS（未找到）" class="headerlink" title="KiInitializeTSS（未找到）"></a>KiInitializeTSS（未找到）</h2><p>21h1的ntoskrnl.exe中未找到</p><h2 id="RtlValidateUnicodeString"><a href="#RtlValidateUnicodeString" class="headerlink" title="RtlValidateUnicodeString"></a>RtlValidateUnicodeString</h2><p>if((a &amp;&amp; b) || c)结构</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(a || (!b &amp;&amp; (c || d || e || f)) || (g &amp;&amp; (h || !i))) &#123;    return 0xC000000D;&#125;else&#123;    return 0;&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/practicalre/">practicalre</category>
      
      <category domain="https://windgodm.github.io/blog/tags/antiDebug/">antiDebug</category>
      
      
      <comments>https://windgodm.github.io/blog/post/practicalre1-7.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从0开始：某fpsgo简单透视制作</title>
      <link>https://windgodm.github.io/blog/post/fpsgoPerspective.html</link>
      <guid>https://windgodm.github.io/blog/post/fpsgoPerspective.html</guid>
      <pubDate>Mon, 08 Nov 2021 12:54:00 GMT</pubDate>
      
      <description>从0开始：某fpsgo简单透视制作</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="从0开始：某fpsgo简易透视制作"><a href="#从0开始：某fpsgo简易透视制作" class="headerlink" title="从0开始：某fpsgo简易透视制作"></a>从0开始：某fpsgo简易透视制作</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>前置知识：</p><p>线性代数知识：矩阵的基本运算</p><p>图形学知识：齐次坐标，仿射变换，MVP模型</p><p>（可选）旋转、四元数与欧拉角（我也不懂）</p><p>其他：CE的基本使用、C++、dll编写与注入、IMGUI</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>一些资源：</p><p><a href="https://github.com/frk1/hazedumper">frk1/hazedumper: up to date csgo offsets and hazedumper config (github.com)</a></p><p><a href="https://github.com/danielkrupinski/Osiris">danielkrupinski/Osiris: Free open-source game cheat for Counter-Strike: Global Offensive, written in modern C++. GUI powered by Dear ImGui. (github.com)</a></p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>hazedumper</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&gt;&#x2F;&#x2F; to client.dll&gt;constexpr DWORD myObjNodeOff &#x3D; dwEntityList;&gt;constexpr DWORD viewMatOff &gt;&#x2F;&#x2F; to OBJECT&gt;constexpr DWORD healthOff &#x3D; m_iHealth;&gt;constexpr DWORD positionOff&#x3D; m_vecOrigin;</code></pre></blockquote><p>hazedumper中有所需要的偏移的地址，抱着学习的目的，就选择手动找了</p><p>流程如下：</p><ul><li><p>1 找基址</p><ul><li>1.1 找object结构体地址</li><li>1.2 找object链表基址</li><li>1.3 分析结构体找出position偏移</li><li>1.4 找vp变换矩阵基址</li></ul></li><li><p>2 世界到屏幕坐标转换</p><ul><li>读取vp矩阵、读取position</li><li>视图变换</li><li>标准立方体到屏幕</li></ul></li><li><p>3 绘制</p></li></ul><p>（以下地址和偏移均不是真实值）</p><h2 id="1-找基址"><a href="#1-找基址" class="headerlink" title="1 找基址"></a>1 找基址</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>神秘指令：</p><p>// 已删除该部分</p></blockquote><h3 id="1-1-找结构体地址"><a href="#1-1-找结构体地址" class="headerlink" title="1.1 找结构体地址"></a>1.1 找结构体地址</h3><p>猜测生命值是结构体的成员，先找生命值的地址</p><p>用<code>hurtme</code>修改生命值，搜索精确数值，大概有22个结果</p><p>根据访问情况排除：</p><ul><li>只有cmp指令</li><li>server.dll中的指令</li><li>访问次数过少或没有</li><li>没有偏移量的（如<code>mov eax, [esi]</code>）</li><li>类型不符合（如搜整形遇到浮点指令）</li></ul><p>剩下如下可能性较大结果：</p><pre class="line-numbers language-none"><code class="language-none">h1 &#x3D; [0x0C704E00+0x1c](client.dll)mov eax, [edi+0x1c]cmp eax, -1h2 &#x3D; [0x0C8345F0+0x18](panorama.dll)mov ecx, [ecx+0x18]cmp ecx, [eax+0x18]h3 &#x3D; [0x41AA4248+0xd8](client.dll)call eax...mov [edi+0xd8], eaxh4 &#x3D; [606F4D60+0x100](client.dll)mov eax, [ecx+0x100]ret(client.dll)cmp [ecx+0x100], 0</code></pre><p>综合来看h4的可能性比较大，即h4的基址可能是结构体地址，生命值的偏移为0x100</p><pre class="line-numbers language-none"><code class="language-none">OBJ+0x100: health int</code></pre><h3 id="1-2-找链表地址"><a href="#1-2-找链表地址" class="headerlink" title="1.2 找链表地址"></a>1.2 找链表地址</h3><p>搜到4个绿色的地址，保存着结构体地址</p><p>只有一个具有链表的结构</p><p>最终得到如下结构：</p><pre class="line-numbers language-none"><code class="language-none">client.dll+666F75C OBJ_NODE+0: 6666BD60 OBJ*+4: 666      int+8:          OBJ_NODE*+C:          OBJ_NODE*</code></pre><p>也就是可以通过如下方式获取health：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">DWORD clientBase;DWORD pMyObjNode &#x3D; clientBase+0x6666888; &#x2F;&#x2F; OBJ_NODE*DWORD pMyObj &#x3D; *(DWORD*)(pobj_node);     &#x2F;&#x2F; OBJ*DWORD health &#x3D; *(DWORD*)(pobj+0x66);</code></pre><p>遍历链表可以发现，所以物品都在里面，生命值&gt;0的就是玩家或机器人，刚刚好有10个</p><p>下面是遍历的代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct _OBJ_NODE &#123;    void* pObj;    int id;    void* prev, * next;&#125;OBJ_NODE, * POBJ_NODE;constexpr DWORD myObjNodeOff &#x3D; 0x6666888;constexpr DWORD healthOff &#x3D; 0x66;HANDLE hProc;                &#x2F;&#x2F; get it by yourselfDWORD clientBase;            &#x2F;&#x2F; get it by yourselfvoid* pMyObjNode, *pObjNode;OBJ_NODE myObjNode, objNode;int healthAddr, health;&#x2F;&#x2F; My Nodeint numHeal &#x3D; 1;pMyObjNode &#x3D; (void*)(clientBase + myObjNodeOff);ReadProcessMemory(hProc, (LPVOID)pMyObjNode, &amp;myObjNode, sizeof(OBJ_NODE), NULL);healthAddr &#x3D; (DWORD)myObjNode.pObj + healthOff;ReadProcessMemory(hProc, (LPVOID)healthAddr, &amp;health, 4, NULL);&#x2F;&#x2F; Prevfor (pObjNode &#x3D; myObjNode.prev; pObjNode; pObjNode &#x3D; objNode.prev) &#123;    ReadProcessMemory(hProc, (LPVOID)pObjNode, &amp;objNode, sizeof(OBJ_NODE), NULL);    healthAddr &#x3D; (DWORD)objNode.pObj + healthOff;    ReadProcessMemory(hProc, (LPVOID)healthAddr, &amp;health, 4, NULL);    if (health &gt; 0) numHeal++;&#125;&#x2F;&#x2F; Nextfor (pObjNode &#x3D; myObjNode.next; pObjNode; pObjNode &#x3D; objNode.next) &#123;    ReadProcessMemory(hProc, (LPVOID)pObjNode, &amp;objNode, sizeof(OBJ_NODE), NULL);    healthAddr &#x3D; (DWORD)objNode.pObj + healthOff;    ReadProcessMemory(hProc, (LPVOID)healthAddr, &amp;health, 4, NULL);    if (health &gt; 0) numHeal++;&#125;printf_s(&quot;\nnumHeal:%d\n&quot;, numHeal);&#x2F;&#x2F; &gt;numHeal:10</code></pre><h3 id="1-3-找出position偏移"><a href="#1-3-找出position偏移" class="headerlink" title="1.3 找出position偏移"></a>1.3 找出position偏移</h3><p>查看结构体内存，显示类型选择单浮点，当跳的时候只有z轴是变的，根据此找坐标的位置</p><p>观察内存数值的变化得到下面的信息</p><pre class="line-numbers language-none"><code class="language-none">OBJ+64  加速度 float[3]+60  坐标   float[3]+6C  坐标   float[3]+88 坐标   float[3]</code></pre><h3 id="1-4-找vp变换矩阵基址"><a href="#1-4-找vp变换矩阵基址" class="headerlink" title="1.4 找vp变换矩阵基址"></a>1.4 找vp变换矩阵基址</h3><p>搜索单精度浮点</p><p>先移动视角，然后搜索变换的值，再移动位置，搜索未改变的值，重复以上步骤</p><h2 id="2-世界到屏幕坐标转换"><a href="#2-世界到屏幕坐标转换" class="headerlink" title="2 世界到屏幕坐标转换"></a>2 世界到屏幕坐标转换</h2><p>世界坐标系到屏幕坐标系的转换有2步，这里简述一下（具体实现根据引擎会有细微差别）（大量括号警告：CG有些名词中文翻译不一致，标上英语）：</p><ul><li><p>第一步是mvp转换：<br>m（model trans.）指模型坐标转世界坐标<br>v（view trans.）指世界坐标转摄像机（摄像机为原点）坐标<br>p（projection trans.）指投影转换，分为正交投影（Orthographic proj.)和透视投影（Perspective proj.），且会将结果归一化（正交投影就是归一化、而透视投影是透视变换+归一化）<br>前面我们得到的是世界坐标和vp矩阵，所以不存在模型坐标向世界坐标转换的步骤（opengl给的就是vp矩阵）</p></li><li><p>第1.5步是归一化（规范化？）：</p><p>（这一步opengl叫透视除法，perspective divide）<br>上面说到投影转换最后会归一化，但在opengl的透视投影转换的透视转换这一过程中，没有维持w为1<br>这一步就是除以那个w，因为用的是齐次坐标，点坐标的w应该为1</p></li><li><p>第二步是视口变换（viewport mapping）：<br>这一步的目标是将坐标转换成屏幕上的坐标<br>需要注意处理原点误差的问题</p></li></ul><p>opengl中把第一步结果的坐标系称为裁剪坐标系（Clip space）<br>第1.5步结果的坐标系称为规范化设备坐标系（NDC，Normalized Device Coord. space）<br>第二步结果的坐标系称为屏幕坐标（Screen space）</p><p>opengl中我认为易错的两点其一是第1.5步的维持点坐标w为1</p><p>其二是第二步视口转换中要处理原点误差</p><p>为了方便这里就不写矩阵了，对于x，原公式是<code>screen.x = ndc.x * (w/2) + (w/2) + x </code>，那个x是屏幕原点坐标，应该为0。<br>网上有些代码会写成<code>screen.x = ndc.x * (w/2) + (w/2) + ndc.x</code><br>因为归一化，ndc.x小于1，所以对结果没有太大影响，问题就被忽略了</p><h2 id="3-绘制"><a href="#3-绘制" class="headerlink" title="3 绘制"></a>3 绘制</h2><p>这里我用的是外部绘制，用的imgui，最好是静态编译（需要先安装dx sdk，才有静态的dx.lib）</p><p>内部绘制的话hook dx的api即可</p><p>透明窗口的创建如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#123;int width &#x3D; 1920;    int height &#x3D; 1080;WNDCLASSEX wc &#x3D; &#123; sizeof(WNDCLASSEX), CS_CLASSDC, WndProc, 0L, 0L, GetModuleHandle(NULL), NULL, NULL, NULL, NULL, _T(&quot;Diana&quot;), NULL &#125;;    RegisterClassEx(&amp;wc);    HWND hwnd &#x3D; ::CreateWindow(wc.lpszClassName, _T(&quot;DianaLookAtYou&quot;), WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_CHILD | WS_POPUP | WS_POPUP | WS_EX_TOPMOST, 0, 0, width, height, NULL, NULL, wc.hInstance, NULL);    LONG nRet &#x3D; ::GetWindowLong(hwnd, GWL_EXSTYLE); nRet &#x3D; nRet | WS_EX_LAYERED; ::SetWindowLong(hwnd, GWL_EXSTYLE, nRet);    SetLayeredWindowAttributes(hwnd, RGB(255, 0, 255), (BYTE)200, LWA_ALPHA | LWA_COLORKEY);    SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE) | WS_EX_TRANSPARENT);    SetLayeredWindowAttributes(hwnd, RGB(0, 0, 0), 0, LWA_COLORKEY);    SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Hack/">Hack</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/hack/">hack</category>
      
      <category domain="https://windgodm.github.io/blog/tags/fps/">fps</category>
      
      
      <comments>https://windgodm.github.io/blog/post/fpsgoPerspective.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《逆向工程实战》实例J</title>
      <link>https://windgodm.github.io/blog/post/practicalreJ.html</link>
      <guid>https://windgodm.github.io/blog/post/practicalreJ.html</guid>
      <pubDate>Fri, 22 Oct 2021 04:00:00 GMT</pubDate>
      
      <description>《逆向工程实战》实例J DllMain分析</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="《逆向工程实战》实例J"><a href="#《逆向工程实战》实例J" class="headerlink" title="《逆向工程实战》实例J"></a>《逆向工程实战》实例J</h1><h2 id="DllMain-反编译"><a href="#DllMain-反编译" class="headerlink" title="DllMain 反编译"></a>DllMain 反编译</h2><p>尽量按汇编反编译结果（没有太多优化）：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">BOOL DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    char[8] idtr;    unsigned int IDTBase;    PROCESSENTRY32 pe;        &#x2F;&#x2F; Chunk 0:        &#x2F;&#x2F; 10001C6A ~ 10001C6E    __sidt(&amp;idtr);    IDTBase &#x3D; *(unsigned int*)(idtr+2);        &#x2F;&#x2F; 10001C71 ~ 10001C85    if((IDTBase &gt; 0x8003F400) &amp;&amp; (IDTBase &lt; 0x80047400)) &#123;        return 0;    &#125;        &#x2F;&#x2F; Chunk 1:        &#x2F;&#x2F; 10001C88 ~ 10001CA9    HANDLE hSnapshot &#x3D; CraeteToolhelp32Snapshot(2, 0); &#x2F;&#x2F; get thread message    memset(&amp;pe, 0, 0x128); &#x2F;&#x2F; 4+0x49*4        &#x2F;&#x2F; 10001CAB ~ 10001CB6    if(hSnapshot &#x3D;&#x3D; -1) &#123;        &#x2F;&#x2F; invalid handle        return 0;    &#125;        &#x2F;&#x2F; Chunk 2:        &#x2F;&#x2F; 10001CB9 ~ 10001D22    pe.dwSize &#x3D; 0x128; &#x2F;&#x2F; &#x3D; sizeof(PROCESSENTRY32)    int flag &#x3D; Process32First(hSnapshot, &amp;pe);    while(flag) &#123;        if(stricmp(pe.szExeFile,&quot;explorer.exe&quot;) &#x3D;&#x3D; 0) &#123;        &#x2F;&#x2F; IsExplorer:            t1 &#x3D; pe.th32ParentProcessID;            t2 &#x3D; pe.th32ProcessID;            break;        &#125;        flag &#x3D; Process32Next(hSnapshot, &amp;pe);    &#125;    &#x2F;&#x2F; 10001D24 ~ 10001D27 (BreakWhileProc:)    int t1, t2;    if(flag &#x3D;&#x3D; 0) &#123;        t1 &#x3D; fdwReason;        t2 &#x3D; fdwReason;    &#125;        &#x2F;&#x2F; 10001D2A ~ 10001D35 (CheckLoopResult:)    if(t1 &#x3D;&#x3D; t2)        return 0;        &#x2F;&#x2F; Chunk3:        &#x2F;&#x2F; 10001D38 ~ 10001D5C    if(fdwReason &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; DLL_PROCESS_ATTACH        CreateThread(0, 0, 0x100032D0, 0, 0, 0);    &#125;    return 1;&#125;</code></pre><p>__sidt对应汇编指令<code>sidt</code>，作用是读取idtr寄存器到指定地址<br>idtr寄存器大小是6字节，高4字节是IDT基址</p><p>开头检查IDT基址，每个处理器（核）的IDT都不同<br>win xp中只有0核的IDT基址是<code>0x8003F400</code>，后续版本IDT每次重启都会变<br>所以作用是检查是否运行在xp的0核中</p><p>Chunk1到Chunk2：检查explorer.exe是否在运行，不在运行就退出</p><p>Chunk3：创建一个线程</p><h2 id="DllMain栈帧"><a href="#DllMain栈帧" class="headerlink" title="DllMain栈帧"></a>DllMain栈帧</h2><p>以下偏移是相对DllMain栈帧的ebp</p><p>a开头是参数、v开头是局部变量</p><table><thead><tr><th>offset(base16)</th><th>name</th><th>size(base16)</th></tr></thead><tbody><tr><td>-130</td><td>v_pe</td><td>128</td></tr><tr><td>-8</td><td>v_idtr</td><td>6/8</td></tr><tr><td>+0</td><td>last_ebp</td><td>4</td></tr><tr><td>+4</td><td>ret_addr</td><td>4</td></tr><tr><td>+8</td><td>a0_hinstDLL</td><td>4</td></tr><tr><td>+C</td><td>a1_fdwReason</td><td>4</td></tr><tr><td>+10</td><td>a2_lpvReserved</td><td>4</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/practicalre/">practicalre</category>
      
      
      <comments>https://windgodm.github.io/blog/post/practicalreJ.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>逆向工程核心原理 R3静态反调试 笔记</title>
      <link>https://windgodm.github.io/blog/post/recoreR3StaAntiDebug.html</link>
      <guid>https://windgodm.github.io/blog/post/recoreR3StaAntiDebug.html</guid>
      <pubDate>Sat, 16 Oct 2021 04:00:00 GMT</pubDate>
      
      <description>逆向工程核心原理 51章静态反调试 笔记</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="逆向工程核心原理-R3静态反调试-笔记"><a href="#逆向工程核心原理-R3静态反调试-笔记" class="headerlink" title="逆向工程核心原理 R3静态反调试 笔记"></a>逆向工程核心原理 R3静态反调试 笔记</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>主要是R3层面的静态反调试手段</p><p>参考逆向工程核心原理51章静态反调试</p><p>涉及的API：</p><ul><li><p>IsDebuggerPresent()</p></li><li><p>NtQueryInformationProcess()</p></li><li><p>NtQuerySystemInformation()</p></li><li><p>NtQueryObject()</p></li><li><p>ZwSetInformationThread()</p></li><li><p>DebugActiveProcessStop()</p></li></ul><h2 id="51-2-涉及peb的检查方式"><a href="#51-2-涉及peb的检查方式" class="headerlink" title="51.2 涉及peb的检查方式"></a>51.2 涉及peb的检查方式</h2><table><thead><tr><th>偏移</th><th>名称</th><th>类型</th></tr></thead><tbody><tr><td>0x2</td><td>BeingDebugged</td><td>UChar</td></tr><tr><td>0xc</td><td>Ldr</td><td>Ptr32 _PEB_LDR_DATA</td></tr><tr><td>0x18</td><td>ProcessHesap</td><td>Ptr32 Void</td></tr><tr><td>0x68</td><td>NtGlobalFlag</td><td>Uint48</td></tr></tbody></table><p><strong>BeingDebugged 标志位</strong> </p><p>处于调试状态，BeingDebugged被设置为1。<br>IsDebuggerPresent()检查 BeingDebugged。</p><p><strong>Ldr 堆内存检查</strong></p><p>调试进程未使用堆内存填充<code>0xFEEEFEEE</code>(x32)。<br>该方法只在xp中有效，且附加不存在该特征：<br>PEB_LDR_DATA结构体在堆内存中创建，扫描该区域是否存在上述特征。</p><p><strong>ProcessHeap 标志</strong></p><p>processheap结构//todo<br>该方法只在xp中有效，且附加不存在该特征：<br>正常情况Heap.Flags=2，Heap.ForceFlags=0</p><p><strong>NtGlobalFlag Bitmap</strong></p><p>该方法通过附加无效<br>调试状态PEB.NtGlobalFlag |= 0x70<br>由以下位组成<br>FLG_HEAP_ENABLE_TAIL_CHECK (0x10)<br>FLG_HEAP_ENABLE_FREE_CHECK (0x20)<br>FLG_HEAP_VALIDATE_PARAMETERS (0x40)</p><h2 id="51-3-NtQueryInformationProcess"><a href="#51-3-NtQueryInformationProcess" class="headerlink" title="51.3 NtQueryInformationProcess()"></a>51.3 NtQueryInformationProcess()</h2><p>该函数用于查询进程信息。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum PROCESSINFOCLASS &#123;ProcessDebugPort &#x3D; 0x7,ProcessDebugObjectHandle &#x3D; 0x1e,ProcessDebugFlags &#x3D; 0x1f&#125;;&#x2F;&#x2F; MSDN__kernel_entry NTSTATUS NtQueryInformationProcess(  HANDLE           ProcessHandle,  PROCESSINFOCLASS ProcessInformationClass,  PVOID            ProcessInformation,  ULONG            ProcessInformationLength,  PULONG           ReturnLength);</code></pre><p>第二个参数指定查询的信息。</p><p>非调试情况第三个参数指向地址被填充的值：<br>ProcessDebugPort 填充为0<br>ProcessDebugObjectHandle 填充为0<br>ProcessDebugFlags 填充为1</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool CheckNtQfP_API()&#123;&#x2F;&#x2F; get apiHMODULE hNtdll &#x3D; GetModuleHandleW(L&quot;NtDll.dll&quot;);auto pNtQueryInformationProcess &#x3D; (PNtQueryInformationProcess)GetProcAddress(hNtdll, &quot;NtQueryInformationProcess&quot;);&#x2F;&#x2F; temp valuesHANDLE hCurProc &#x3D; GetCurrentProcess();bool beingDebug &#x3D; false;&#x2F;&#x2F; Process Debug Port (0x7)DWORD dwDebugPort;pNtQueryInformationProcess(hCurProc, ProcessDebugPort, &amp;dwDebugPort, sizeof(dwDebugPort), NULL);    if (dwDebugPort) beingDebug &#x3D; true;&#x2F;&#x2F; Process Debug Object Handle (0x1E)HANDLE hDebugObject &#x3D; NULL;pNtQueryInformationProcess(hCurProc, ProcessDebugObjectHandle, &amp;hDebugObject, sizeof(hDebugObject), NULL);if (hDebugObject) beingDebug &#x3D; true;&#x2F;&#x2F; Process Debug Flags (0x1F)BOOL bDebugFlag &#x3D; true;pNtQueryInformationProcess(hCurProc, ProcessDebugFlags, &amp;bDebugFlag, sizeof(bDebugFlag), NULL);if (bDebugFlag &#x3D;&#x3D; 0) beingDebug &#x3D; true;    &#x2F;&#x2F; return    return beingDebug;&#125;</code></pre><h2 id="51-4-NtQuerySystemInformation"><a href="#51-4-NtQuerySystemInformation" class="headerlink" title="51.4 NtQuerySystemInformation()"></a>51.4 NtQuerySystemInformation()</h2><p>该函数用于查询系统信息，可以检测系统是否在调试模式下运行。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum SYSTEM_INFORMATION_CLASS &#123;SystemKernelDebuggerInformation &#x3D; 0x23&#125;;typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION &#123;BOOLEAN DebuggerEnabled;BOOLEAN DebuggerNotPresent;&#125;SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;&#x2F;&#x2F; MSDN__kernel_entry NTSTATUS NtQuerySystemInformation(  SYSTEM_INFORMATION_CLASS SystemInformationClass,  PVOID                    SystemInformation,  ULONG                    SystemInformationLength,  PULONG                   ReturnLength);</code></pre><p>非调试情况，debuggerInfo.DebuggerEnabled = 0</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool CheckNtQSI_API()&#123;&#x2F;&#x2F; get apiHMODULE hNtdll &#x3D; GetModuleHandleW(L&quot;NtDll.dll&quot;);auto pNtQuerySystemInformation &#x3D; (PNtQuerySystemInformation)GetProcAddress(hNtdll, &quot;NtQuerySystemInformation&quot;);&#x2F;&#x2F; SystemKernelDebuggerInformation(0x23)SYSTEM_KERNEL_DEBUGGER_INFORMATION debuggerInfo &#x3D; &#123; 0, &#125;;pNtQuerySystemInformation(SystemKernelDebuggerInformation, &amp;debuggerInfo, sizeof(debuggerInfo), 0);return debuggerInfo.DebuggerEnabled;&#125;</code></pre><p><strong>应对</strong></p><p>xp中修改boot.ini，删除<code>/debugport=coml /baudrate=115200 /Debug</code></p><p>win7 cmd中执行<code>bcdedit /debug off</code></p><h2 id="51-5-NtQueryObject"><a href="#51-5-NtQueryObject" class="headerlink" title="51.5 NtQueryObject()"></a>51.5 NtQueryObject()</h2><p>该函数用于查询内核对象，可以用于检测是否存在调试对象类型的内核对象。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum _OBJECT_INFORMATION_CLASS &#123;ObjectAllTypesInformation &#x3D; 3&#125; OBJECT_INFORMATION_CLASS;typedef struct _UNICODE_STRING &#123; &#x2F;&#x2F; sizeof &#x3D; 8USHORT Length;USHORT MaximumLength;PWSTR Buffer;&#125; UNICODE_STRING, * PUNICODE_STRING;typedef struct _OBJECT_TYPE_INFORMATION &#123; &#x2F;&#x2F; sizeof &#x3D; 16UNICODE_STRING TypeName;ULONG TotalNumberOfHandles;ULONG TotalNumberOfObjects;&#125; OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;typedef struct _OBJECT_ALL_INFORMATION &#123;ULONG NumberOfObjectsTypes;OBJECT_TYPE_INFORMATION ObjectTypeInformation[1];&#125; OBJECT_ALL_INFORMATION, *POBJECT_ALL_INFORMATION;&#x2F;&#x2F; MSDN__kernel_entry NTSYSCALLAPI NTSTATUS NtQueryObject(  HANDLE                   Handle,  OBJECT_INFORMATION_CLASS ObjectInformationClass,  PVOID                    ObjectInformation,  ULONG                    ObjectInformationLength,  PULONG                   ReturnLength);</code></pre><h3 id="分析返回的OBJECT-ALL-INFORMATION"><a href="#分析返回的OBJECT-ALL-INFORMATION" class="headerlink" title="分析返回的OBJECT_ALL_INFORMATION"></a>分析返回的OBJECT_ALL_INFORMATION</h3><p>ObjectInformation中会填充OBJECT_ALL_INFORMATION，需要遍历这个结构，我在一次调试中记录下了一些地址用于分析该结构<br>下面是返回的ObjectInformation指向的buf的数据内容：</p><pre class="line-numbers language-none"><code class="language-none">0x750000: OBJECT_ALL_INFORMATION  +0h : NumberOfObjectsTypes(ULONG)&#x3D; 67  +4h : ObjectTypeInformation(STRUCT)0x750004: (OBJECT_TYPE_INFORMATION)  +0h : ObjectTypeInformation[0].TypeName.Length(USHORT)&#x3D; 8  +2h : ObjectTypeInformation[0].TypeName.LengthMaximumLength(USHORT)&#x3D; 10  +4h : ObjectTypeInformation[0].TypeName.Buffer(wchar_t*)&#x3D; 0x750064  +8h : ObjectTypeInformation[0].TotalNumberOfHandles(ULONG)&#x3D; 67  +ch: ObjectTypeInformation[0].TotalNumberOfObjects(ULONG)&#x3D; 00x750014: (BYTE[80]) &#x2F;&#x2F; unknown0x750064: (wchar[5]) &#x3D; L&quot;Type&quot;0x75006E: (BYTE[2]) &#x3D; \x00\x000x750070: (OBJECT_TYPE_INFORMATION)  +0h : ObjectTypeInformation[1].TypeName.Length(USHORT)&#x3D; 18  +2h : ObjectTypeInformation[1].TypeName.LengthMaximumLength(USHORT)&#x3D; 20  +4h : ObjectTypeInformation[1].TypeName.Buffer(wchar_t*)&#x3D; 0x7500D0  ...0x750080: (BYTE[80]) &#x2F;&#x2F; unknown0x7500D0: (wchar[10]) &#x3D; L&quot;Directory&quot;0x7500E4: (OBJECT_TYPE_INFORMATION)  +0h : ObjectTypeInformation[2].TypeName.Length(USHORT)&#x3D; 24  +2h : ObjectTypeInformation[2].TypeName.LengthMaximumLength(USHORT)&#x3D; 26  +4h : ObjectTypeInformation[2].TypeName.Buffer(wchar_t*)&#x3D; 0x750144  ...0x7500F4: (BYTE[80]) &#x2F;&#x2F; unknown0x750144: (wchar[13]) &#x3D; L&quot;SymbolicLink&quot;...</code></pre><p>可以看到内存布局可简化为：</p><pre class="line-numbers language-none"><code class="language-none">NumberOfObjectsTypesObjectTypeInformation[0]80bytes undocument datewchar[]ObjectTypeInformation[1]80bytes undocument datewchar[]ObjectTypeInformation[2]80bytes undocument datewchar[]</code></pre><p>我的理解是<code>OBJECT_ALL_INFORMATION</code>中的<code>OBJECT_TYPE_INFORMATION[]</code>是个元素长度可变的”数组”</p><p><code>OBJECT_TYPE_INFORMATION[]</code>“数组”每个元素由已知的<code>OBJECT_TYPE_INFORMATION（16bytes）+ 未文档化数据（80bytes）+ wchar[]（长度不定）</code>组成</p><p>同时根据书中代码的<code>&amp;0xfffffffc</code>可知是4字节对齐，也就是元素起始地址为4的倍数</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>这里着重分析next那部分代码。</p><p>书中的做法是：<br>首先是找到<code>最后一个字符地址</code>（wchar字符串以\x00\x00结尾）<br>然后清楚低两位（实现4字节对齐）<br>然后加上4</p><p>不考虑对齐，<code>最后一个字符地址+2</code>=<code>下一个元素地址</code>（wchar字符串以\x00\x00结尾）</p><p>如果最后一个字符地址已经对齐，那么下一个元素地址就不对齐，偏移原本为+2，为了对齐变成+4</p><p>如果最后一个字符地址不对其，那么下一个元素地址就对齐，偏移原本为+2，但字符地址清楚了低两位，所以变成+4</p><p>所以最后不管是否对齐都是+4</p><p>也可以先猜测下一个元素地址，然后再判断是否对齐，不对齐就+2，但这样更费劲</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool CheckNtQO_API()&#123;bool beingDebug &#x3D; false;&#x2F;&#x2F; get apiHMODULE hNtdll &#x3D; GetModuleHandleW(L&quot;NtDll.dll&quot;);auto pNtQueryObject &#x3D; (PNtQueryObject)GetProcAddress(hNtdll, &quot;NtQueryObject&quot;);&#x2F;&#x2F; ObjectAllTypesInformation(0x3)&#x2F;&#x2F; get sizeULONG lSize &#x3D; 0;pNtQueryObject(0, ObjectAllTypesInformation, &amp;lSize, sizeof(lSize), &amp;lSize);&#x2F;&#x2F; alloc memorychar* buf &#x3D; 0;buf &#x3D; (char*)VirtualAlloc(NULL, lSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);&#x2F;&#x2F; get infoNTSTATUS sta;sta &#x3D; pNtQueryObject((HANDLE)0xFFFFFFFF, ObjectAllTypesInformation, buf, lSize, NULL);auto pObjAllInfo &#x3D; (POBJECT_ALL_INFORMATION)buf;&#x2F;&#x2F; checkULONG objNum &#x3D; pObjAllInfo-&gt;NumberOfObjectsTypes;auto pObjTypeInfo &#x3D; pObjAllInfo-&gt;ObjectTypeInformation;for (ULONG i &#x3D; 0; i &lt; objNum; i++) &#123;if (wcscmp(L&quot;DebugObject&quot;, pObjTypeInfo-&gt;TypeName.Buffer) &#x3D;&#x3D; 0) &#123;beingDebug &#x3D; true;break;&#125;&#x2F;&#x2F; next        &#x2F;&#x2F; go to last wcharpObjTypeInfo &#x3D; (POBJECT_TYPE_INFORMATION)((ULONG)pObjTypeInfo-&gt;TypeName.Buffer + pObjTypeInfo-&gt;TypeName.Length);        &#x2F;&#x2F; alignmentpObjTypeInfo &#x3D; (POBJECT_TYPE_INFORMATION)(((ULONG)pObjTypeInfo) &amp; 0xFFFFFFFC);        &#x2F;&#x2F; alignment offsetpObjTypeInfo &#x3D; (POBJECT_TYPE_INFORMATION)((ULONG)pObjTypeInfo + sizeof(DWORD));&#125;if (buf)VirtualFree(buf, 0, MEM_RELEASE);return beingDebug;&#125;</code></pre><h2 id="51-6-ZwSetInformationThread"><a href="#51-6-ZwSetInformationThread" class="headerlink" title="51.6 ZwSetInformationThread()"></a>51.6 ZwSetInformationThread()</h2><p>该函数用于设置线程信息，可将线程隐藏起来，使调试器收不到消息</p><p>DebugActiveProcessStop()则可以分离调试器和被调试线程</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef enum _THREADINFOCLASS &#123;ThreadHideFromDebugger &#x3D; 0x11&#125; THREADINFOCLASS;&#x2F;&#x2F; MSDNNTSYSAPI NTSTATUS ZwSetInformationThread(  HANDLE          ThreadHandle,  THREADINFOCLASS ThreadInformationClass,  PVOID           ThreadInformation,  ULONG           ThreadInformationLength);</code></pre><p>用法示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Detach()&#123;&#x2F;&#x2F; get apiHMODULE hNtdll &#x3D; GetModuleHandleW(L&quot;NtDll.dll&quot;);auto pZwSetInformationThread &#x3D; (PZwSetInformationThread)GetProcAddress(hNtdll, &quot;ZwSetInformationThread&quot;);&#x2F;&#x2F; detachpZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0);·&#125;void Stop()&#123;    &#x2F;&#x2F; #include &lt;windows.h&gt;    DebugActiveProcessStop(GetCurrentProcessId());&#125;</code></pre><h2 id="51-7-TLS"><a href="#51-7-TLS" class="headerlink" title="51.7 TLS"></a>51.7 TLS</h2><p>tls回调函数会在ep之前执行（实际上是在创建终止进程时都会执行）</p><p>示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma comment(linker, &quot;&#x2F;INCLUDE:__tls_used&quot;)void NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved);#pragma data_seg(&quot;.CRT$XLX&quot;)PIMAGE_TLS_CALLBACK pTLS_callbacks[] &#x3D; &#123; TLS_CALLBACK1, TLS_CALLBACK2 &#125;;#pragma data_seg()int main()&#123;    return 0;&#125;void NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123;switch (Reason) &#123;case DLL_PROCESS_ATTACH:cout &lt;&lt; &quot;tls:process attach\n\n&quot;;        &#x2F;&#x2F; YourAntiDebug();break;case DLL_THREAD_ATTACH:cout &lt;&lt; &quot;tls:thread attach\n\n&quot;;break;case DLL_THREAD_DETACH:cout &lt;&lt; &quot;tls:thread detach\n\n&quot;;break;case DLL_PROCESS_DETACH:cout &lt;&lt; &quot;tls:process detach\n\n&quot;;break;&#125;&#125;</code></pre><h2 id="51-8-ETC"><a href="#51-8-ETC" class="headerlink" title="51.8 ETC"></a>51.8 ETC</h2><p>检测窗口 FindWindow()</p><p>检测进程 CreateToolhelp32Snapshot()</p><p>检测计算机名</p><p>检测运行路径</p><p>检测虚拟机</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/reversecore/">reversecore</category>
      
      <category domain="https://windgodm.github.io/blog/tags/antiDebug/">antiDebug</category>
      
      
      <comments>https://windgodm.github.io/blog/post/recoreR3StaAntiDebug.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>pbctf21 btree wp</title>
      <link>https://windgodm.github.io/blog/post/pbctf21-btree-Wp.html</link>
      <guid>https://windgodm.github.io/blog/post/pbctf21-btree-Wp.html</guid>
      <pubDate>Sat, 09 Oct 2021 04:00:00 GMT</pubDate>
      
      <description>pbctf 21 btree wp, beaengine+dij</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="PBCTF21-RE-BinaryTree-Beaengine-dijkstra解法"><a href="#PBCTF21-RE-BinaryTree-Beaengine-dijkstra解法" class="headerlink" title="PBCTF21 RE BinaryTree Beaengine+dijkstra解法"></a>PBCTF21 RE BinaryTree Beaengine+dijkstra解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>代码是动态解密的，简单的xor，解密一块执行一块。每一块结尾会设置rbx，rbx决定下一块被解密的代码。</p><p>实际上每一块代码相当于一个节点，里面有一个根据输入的jz，决定下一个rbx以及一个cost，所以相当于一颗二叉树。</p><p>每次经过一个节点都会累加cost。</p><p>根节点对应的代码块会判断cost是否小于等于某个值，然后输出成功信息。</p><p>如果只有唯一解那么显然是找最短路。</p><p>解题思路是beaengine解析代码生成图，用dijkstra算法求最短路并输出路径。<br>事实上只有一条最短路，刚刚等于那个值。</p><h2 id="beaengine提取图"><a href="#beaengine提取图" class="headerlink" title="beaengine提取图"></a>beaengine提取图</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;windows.h&gt;#include &lt;queue&gt;#include &lt;set&gt;#define BEA_ENGINE_STATIC#include &quot;BeaEngine.h&quot;#pragma comment(lib,&quot;legacy_stdio_definitions.lib&quot;)#pragma comment(lib, &quot;BeaEngine.lib&quot;)using namespace std;typedef struct Block &#123;int index;char buf[32];&#125;;int path[25503][4] &#x3D; &#123; 0, &#125;; &#x2F;&#x2F; 0(path&#x2F;rbx,cost) 1(path&#x2F;rbx,cost)queue&lt;pair&lt;int, Block*&gt;&gt; rbxs; &#x2F;&#x2F; rbx(xor offset), lastBlockint sa &#x3D; 0x176;BYTE* firstBlock;int blockNum &#x3D; 0;set&lt;int&gt; dised;Block xorBlock &#x3D; &#123;0,0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x48,0xc7, 0xc7, 0x01, 0x00, 0x00, 0x00, 0x48, 0xc7,0xc2, 0x05, 0x00, 0x00, 0x00, 0x49, 0x81, 0xf9,0xda, 0x49, 0x00, 0x00, 0x7f, 0x07, 0x4c, 0x89&#125;;Block* Xor(char* firstBlock, UInt64 offset, Block &amp;oldBlock)&#123;Block* pB &#x3D; new Block();pB-&gt;index &#x3D; offset &gt;&gt; 5;blockNum++;char* xorBuf &#x3D; firstBlock + offset;for (int i &#x3D; 0; i &lt; 32; i++) &#123;pB-&gt;buf[i] &#x3D; xorBuf[i] ^ oldBlock.buf[i];&#125;return pB;&#125;void Jmp(DISASM&amp; infos)&#123;UINT64 nextVA &#x3D; infos.Instruction.AddrValue;UINT64 curVA &#x3D; infos.VirtualAddr;&#x2F;&#x2F; jmpinfos.EIP +&#x3D; nextVA - curVA;infos.VirtualAddr &#x3D; nextVA;&#125;void DisasmCode(char* stBuf, UINT64 stVA, Block* curBlock, int rbx, int branch)&#123;DISASM infos;size_t len;&#x2F;&#x2F; initmemset(&amp;infos, 0, sizeof(DISASM));infos.EIP &#x3D; (UINT64)stBuf;infos.VirtualAddr &#x3D; (UINT64)stVA;while (infos.Error &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; limitUInt64 offset &#x3D; infos.EIP - (UINT64)curBlock-&gt;buf;if (offset &lt; 0 || offset &gt;&#x3D; 32) &#123;break;&#125;if (infos.VirtualAddr &#x3D;&#x3D; 0x400080) &#123;&#x2F;&#x2F; xorrbxs.push(make_pair(rbx, curBlock));break;&#125;&#x2F;&#x2F;disasmlen &#x3D; Disasm(&amp;infos);cout &lt;&lt; hex &lt;&lt; infos.VirtualAddr &lt;&lt; &quot; &quot; &lt;&lt; infos.CompleteInstr &lt;&lt; endl;&#x2F;&#x2F; jmpif (infos.Instruction.BranchType &#x3D;&#x3D; JmpType) &#123;if (infos.Instruction.AddrValue &#x3D;&#x3D; 0x400080) &#123; &#x2F;&#x2F; xorrbxs.push(make_pair(rbx, curBlock));break;&#125;Jmp(infos);&#125;&#x2F;&#x2F; jmpif (infos.Instruction.BranchType) &#123;&#x2F;&#x2F; false branchDisasmCode((char*)(infos.EIP + len), infos.VirtualAddr + len, curBlock, rbx, 0);&#x2F;&#x2F; true branchbranch &#x3D; 1;Jmp(infos);continue;&#125;&#x2F;&#x2F; if modified rbx (0x8)if (((infos.Operand1.AccessMode &#x3D;&#x3D; WRITE) &amp;&amp; (infos.Operand1.Registers.gpr &amp; REG3))) &#123;rbx +&#x3D; infos.Operand2.Memory.Displacement;&#125;&#x2F;&#x2F; if add r9 (0x200)if ((infos.Operand1.AccessMode &#x3D;&#x3D; 3) &amp;&amp; (infos.Operand1.Registers.gpr &amp; 0x200)) &#123;if (branch &gt;&#x3D; 0) &#123;path[curBlock-&gt;index][branch * 2] &#x3D; rbx &gt;&gt; 5;path[curBlock-&gt;index][branch * 2 + 1] &#x3D; infos.Instruction.Immediat;&#125;&#125;&#x2F;&#x2F; go oninfos.EIP +&#x3D; len;infos.VirtualAddr +&#x3D; len;&#125;&#125;int main()&#123;ifstream fin;ofstream fout;BYTE* fileBuf;Block* lastBlock;Block* pB;&#x2F;&#x2F; read filefin.open(&quot;E:\\works\\ctf\\21pbctf\\re_BinaryTree\\main.elf&quot;, ios::in | ios::binary);fin.seekg(0, ios::end);size_t fileSize &#x3D; fin.tellg();fin.seekg(0, ios::beg);fileBuf &#x3D; (BYTE*)malloc(fileSize);fin.read((char*)fileBuf, fileSize);cout &lt;&lt; &quot;fileSize:&quot; &lt;&lt; dec &lt;&lt; fileSize &lt;&lt; endl;fin.close();&#x2F;&#x2F; disasmfirstBlock &#x3D; fileBuf + sa;cout &lt;&lt; &quot;rbx:0&quot; &lt;&lt; endl;pB &#x3D; Xor((char*)firstBlock, 0, xorBlock);dised.insert(0);DisasmCode(pB-&gt;buf, 0x4000AD, pB, 0, 0);while (!rbxs.empty()) &#123;pair&lt;int, Block*&gt; t &#x3D; rbxs.front();rbxs.pop();lastBlock &#x3D; t.second;cout &lt;&lt; &quot;num:&quot; &lt;&lt; dec &lt;&lt; blockNum &lt;&lt; endl; &#x2F;&#x2F; 0x639f * 2if (dised.insert(t.first).second) &#123;&#x2F;&#x2F; not disasmpB &#x3D; Xor((char*)firstBlock, t.first, *lastBlock);&#x2F;&#x2F; disasmDisasmCode(pB-&gt;buf, 0x4000AD, pB, 0, -1);&#125;&#125;&#x2F;&#x2F; write filefout.open(&quot;E:\\works\\ctf\\21pbctf\\re_BinaryTree\\main_.elf&quot;, ios::out | ios::binary);fout.write((char*)fileBuf, fileSize);fout.close();&#x2F;&#x2F; write filefout.open(&quot;E:\\works\\ctf\\21pbctf\\re_BinaryTree\\path.txt&quot;, ios::out);for (int i &#x3D; 0; i &lt; blockNum; i++) &#123;fout &lt;&lt; path[i][0] &lt;&lt; &quot; &quot; &lt;&lt; path[i][1] &lt;&lt; &quot; &quot; &lt;&lt; path[i][2] &lt;&lt; &quot; &quot; &lt;&lt; path[i][3] &lt;&lt; endl;&#125;fout.close();fout.open(&quot;E:\\works\\ctf\\21pbctf\\re_BinaryTree\\pathDij.txt&quot;, ios::out);int E &#x3D; 0;for (int i &#x3D; 0; i &lt; blockNum; i++) &#123;if (path[i][1]) &#123;fout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; path[i][0] &lt;&lt; &quot; &quot; &lt;&lt; path[i][1] &lt;&lt; endl;fout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; path[i][2] &lt;&lt; &quot; &quot; &lt;&lt; path[i][3] &lt;&lt; endl;E +&#x3D; 2;&#125;else &#123;cout &lt;&lt; i &lt;&lt; &quot;,&quot;;&#125;&#125;cout &lt;&lt; endl;fout.close();cout &lt;&lt; &quot;N E\n&quot;;cout &lt;&lt; dec &lt;&lt; blockNum &lt;&lt; &quot; &quot; &lt;&lt; E &lt;&lt; endl;&#x2F;&#x2F; 25503 50942 0return 0;&#125;</code></pre><h2 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h2><p>自己打oi时留下的板子，忘记有没有加优化了，不过这个版本比较方便记录path</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;** 有向+无向，不能用于负权图*&#x2F;#pragma warning(disable:4996)#include &lt;stdio.h&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;utility&gt;#include &lt;iostream&gt;using namespace std;typedef pair&lt;int, int&gt; TR;struct Edge &#123;int v;int w;&#125;;int roots[] &#x3D; &#123; 1225,1226,1891,1892,3929,3930,4929,4930,6295,6296,9313,9314,9813,9814,15465,15466,15713,15714,17301,17302,18767,18768,18841,18842,19145,19146,19279,19280,19927,19928,22501,22502 &#125;;int path[50943];int path1[50943];inline bool min(int a, int b)&#123;if (a !&#x3D; -1 &amp;&amp; (a &lt; b || b &#x3D;&#x3D; -1))return true;elsereturn false;&#125;int main()&#123;FILE* r &#x3D; freopen(&quot;E:\\works\\ctf\\21pbctf\\re_BinaryTree\\pathDij.txt&quot;, &quot;r&quot;, stdin);int i, j, u, v, w;Edge edge;list&lt;Edge&gt;::iterator it;TR tr;int N, E, start, iMin, nMin;int* flag;set&lt;TR&gt; ds;int* d;list&lt;Edge&gt;* es;scanf(&quot;%d %d&quot;, &amp;N, &amp;E);scanf(&quot;%d&quot;, &amp;start);&#x2F;&#x2F; 初始化flag &#x3D; new int[N];d &#x3D; new int[N];for (i &#x3D; 0; i &lt; N; i++) &#123;flag[i] &#x3D; 0;d[i] &#x3D; -1;path[i] &#x3D; -1;&#125;ds.insert(make_pair(0, start));d[start] &#x3D; 0;&#x2F;&#x2F; 读图es &#x3D; new list&lt;Edge&gt;[N];int boo &#x3D; 1;for (i &#x3D; 0; i &lt; E; i++) &#123;scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w);edge.v &#x3D; v;edge.w &#x3D; w;es[u].push_back(edge);if (boo) &#123;boo &#x3D; 0;path1[u] &#x3D; v;&#125;else &#123;boo &#x3D; 1;&#125;&#125;&#x2F;&#x2F; dijwhile (!ds.empty()) &#123;&#x2F;&#x2F; 找最小未完成节点（确保d[iMin] !&#x3D; -1）iMin &#x3D; ds.begin()-&gt;second;nMin &#x3D; ds.begin()-&gt;first;ds.erase(ds.begin());&#x2F;&#x2F; 标记完成u &#x3D; iMin;flag[u] &#x3D; 1;&#x2F;&#x2F; 依次松弛for (it &#x3D; es[u].begin(); it !&#x3D; es[u].end(); it++) &#123;v &#x3D; it-&gt;v;w &#x3D; d[iMin] + it-&gt;w;if (w &#x3D;&#x3D; d[v])path[v] &#x3D; u;if (min(w, d[v])) &#123;d[v] &#x3D; w;&#x2F;&#x2F; 加入settr &#x3D; make_pair(w, v);if (ds.find(tr) !&#x3D; ds.end()) ds.erase(tr);ds.insert(tr);path[v] &#x3D; u;&#125;&#125;&#125;&#x2F;&#x2F; 输出结果&#x2F;&#x2F; for (i &#x3D; 0; i &lt; N; i++)&#x2F;&#x2F;printf(&quot;%d:%d\n&quot;, i, d[i]);&#x2F;&#x2F; putchar(10);cout &lt;&lt; &quot;\nans:\n&quot;;for (i &#x3D; 0; i &lt; 32; i++) &#123;cout &lt;&lt; d[roots[i]] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; &quot;\nshortest:\n&quot;;for (i &#x3D; 0; i &lt; 32; i++) &#123;if (d[roots[i]] &lt;&#x3D; 0x49DA) &#123;cout &lt;&lt; roots[i] &lt;&lt; &quot;:&quot; &lt;&lt; d[roots[i]] &lt;&lt; &quot; &quot; &lt;&lt; endl;&#125;&#125;cout &lt;&lt; &quot;\npath\n&quot;;i &#x3D; 19279;do &#123;i &#x3D; path[i];cout &lt;&lt; i &lt;&lt; &quot; &quot;;&#125; while (i);cout &lt;&lt; &quot;\npath\n&quot;;i &#x3D; 19279;do &#123;&#x2F;&#x2F; path[i] -&gt; iif (path1[path[i]] &#x3D;&#x3D; i)cout &lt;&lt; 1;elsecout &lt;&lt; 0;i &#x3D; path[i];&#125; while (i);i &#x3D; 0;j &#x3D; 0;while (!es[i].empty()) &#123;i &#x3D; es[i].begin()-&gt;v;j++;&#125;cout &lt;&lt; &quot;\nl:&quot; &lt;&lt; j &lt;&lt; endl;&#x2F;&#x2F; 释放内存delete[] flag;delete[] es;return 0;&#125;</code></pre><h2 id="long2bytes"><a href="#long2bytes" class="headerlink" title="long2bytes"></a>long2bytes</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">from Crypto.Util.number import long_to_bytesans &#x3D; &#39;01111101001101110110010101100101011001100110001001100001001110000011000000110110001100100110001000110001011001100011011100110001001100000011100101100011001100110011000100110101011000110110000100111000001101110011010001100001001100100011001001100010011000100011000000110011011001010011000000110011011000110011010000110111011001010101111100100001001000010110010101100100011011110110001101011111011001110110111001101001011110010110011001101001011001000110111101101101001011010110011001101100011001010111001101011111011011100110100101011111011010000111010001100001011100000101111101110100011100110110010101110100011100100110111101101000011100110101111101100101011010000111010001011111011001110110111001101001011001000110111001101001011001100010000100100001011110110110011001110100011000110110001001110000&#39;ans &#x3D; int(ans, 2)print(long_to_bytes(ans)[::-1])</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[<a href="https://bbs.pediy.com/thread-269815.htm">原创]PBCTF21 RE BinaryTree Beaengine+dijkstra解法-bbs.pediy.com</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      
      <comments>https://windgodm.github.io/blog/post/pbctf21-btree-Wp.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>vmp2 (3) handler类型总结</title>
      <link>https://windgodm.github.io/blog/post/vmp2-p3.html</link>
      <guid>https://windgodm.github.io/blog/post/vmp2-p3.html</guid>
      <pubDate>Tue, 28 Sep 2021 04:00:00 GMT</pubDate>
      
      <description>分析handler后的总结</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="VMP2（3）handler类型总结"><a href="#VMP2（3）handler类型总结" class="headerlink" title="VMP2（3）handler类型总结"></a>VMP2（3）handler类型总结</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>详细分析push、pop、计算类handler以及粗略分析其余handler后对handler进行分类并做一些总结。</p><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>vm字节码结构有三种：</p><ul><li>opcode(1B)</li><li>opcode(1B) + Imm(1~8B)</li><li>opcode(1B) + VmRegOffset(1B)</li></ul><p>所有字节码都是经过加密的，解析时需要根据rbx动态解密。</p><p>vm字节码各部分是倒序排列的，也就是说后一条指令在前面，Imm、VmRegOffset在opcode前面。</p><h2 id="vm虚拟栈与虚拟寄存器"><a href="#vm虚拟栈与虚拟寄存器" class="headerlink" title="vm虚拟栈与虚拟寄存器"></a>vm虚拟栈与虚拟寄存器</h2><p>通过分析涉及vm栈的handler（如push、pop、add等），得出vm栈是2字节对齐的。vm寄存器实质可以理解为一个全局数组，也是2字节对齐的。</p><h2 id="push类"><a href="#push类" class="headerlink" title="push类"></a>push类</h2><p>push类指令push数据到栈上。分为三种：</p><ul><li>push 立即数</li><li>push vm寄存器</li><li>push 真实寄存器</li></ul><p>立即数即指令的Imm部分，push到vm寄存器时则根据VmRegOffset部分。</p><p>push压栈元素的大小不小于被压栈数据的长度。比如push 4字节的立即数有两条指令：一条是压入4字节(VmRsp-=4)；一条是压入8字节(VmRsp-=8)，其中被压入的立即数在栈顶的低4字节([VmRsp] = ImmD)。</p><h2 id="pop类"><a href="#pop类" class="headerlink" title="pop类"></a>pop类</h2><p>pop类指令从vm栈上pop数据。分为两种：</p><ul><li>pop到vm寄存器中</li><li>pop到真实寄存器中（包括popfq）。</li></ul><p>显然pop到vm寄存器的指令长度为2字节，第二个字节指示了vm寄存器的偏移。</p><h2 id="计算类"><a href="#计算类" class="headerlink" title="计算类"></a>计算类</h2><p>计算类指令有七种：</p><ul><li>nor</li><li>add</li><li>div</li><li>shl</li><li>shld</li><li>shr</li><li>shrd</li></ul><p>逻辑运算由nor组合实现，减法可以通过逻辑运算和加法实现，乘法可以由位移和加法组合实现。</p><p>各种指令的操作数也是分长度的。</p><p>计算类指令基于栈实现，可以等价成以下4步：</p><ul><li>所有操作数出栈</li><li>计算结果</li><li>入栈结果</li><li>入栈RFLAGS</li></ul><p>也就是计算以后操作数将清除，栈顶为RFLAGS(8Byte)、栈顶第二项为结果(长度由指令决定)</p><h2 id="Indirection类"><a href="#Indirection类" class="headerlink" title="Indirection类"></a>Indirection类</h2><p>该类指令用于解除应用。伪代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">top &#x3D; *top</code></pre><p>等价于以下3步：</p><ul><li>出栈（8字节指针）</li><li>解除引用</li><li>入栈结果</li></ul><h2 id="subscript类"><a href="#subscript类" class="headerlink" title="subscript类"></a>subscript类</h2><p>该类指令用于给内存地址赋值。伪代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">*top &#x3D; top2</code></pre><p>等价于以下3步：</p><ul><li>出栈左值（8字节指针）</li><li>出栈右值</li><li>往指针指向地址赋值</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有初始化虚拟机、call、ret、修改rbx、修改bp、基于vm栈的cpuid等指令。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Re/">Re</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/vmp2/">vmp2</category>
      
      
      <comments>https://windgodm.github.io/blog/post/vmp2-p3.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>BeaEngine</title>
      <link>https://windgodm.github.io/blog/post/BeaEngine.html</link>
      <guid>https://windgodm.github.io/blog/post/BeaEngine.html</guid>
      <pubDate>Mon, 20 Sep 2021 04:00:00 GMT</pubDate>
      
      <description>一个反汇编引擎,vs19中用c++以静态连接调用BeaEngine的配置，以及一些笔记。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="BeaEngine"><a href="#BeaEngine" class="headerlink" title="BeaEngine"></a>BeaEngine</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>一个反汇编引擎，支持c++、python等。</p><p>具体使用参照官方github的example，非常详细。</p><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char buf;UINT64 va;DISASM infos;int len;&#x2F;&#x2F; initmemset(&amp;infos, 0, sizeof(DISASM));infos.EIP &#x3D; buf;infos.VirtualAddr &#x3D; va;&#x2F;&#x2F; disasmlen &#x3D; Disasm(&amp;infos);&#x2F;&#x2F; Branch typeif (infos.Instruction.BranchType &#x3D;&#x3D; JmpType); &#x2F;&#x2F; RetType, CallType&#x2F;&#x2F; Operaterinfos.Instruction.Mnemonic; &#x2F;&#x2F; &quot;add&quot;&#x2F;&#x2F; Reginfos.Operand1.OpMnemonic; &#x2F;&#x2F; &quot;rax&quot;infos.Operand1.Registers.gpr;&#x2F;&#x2F; Continueinfos.EIP +&#x3D; len;infos.VirtualAddr +&#x3D; len;&#x2F;&#x2F; JmpUINT64 nextVA &#x3D; infos.Instruction.AddrValue;UINT64 curVA &#x3D; infos.VirtualAddr;infos.EIP +&#x3D; nextVA - curVA;infos.VirtualAddr &#x3D; nextVA;</code></pre><h2 id="vs2019-amp-static-lib"><a href="#vs2019-amp-static-lib" class="headerlink" title="vs2019 &amp; static lib"></a>vs2019 &amp; static lib</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>项目属性页 -&gt; C/C++ -&gt; 常规 -&gt; 附加包含目录 添加beaengine的headers目录</p><p>项目属性页 -&gt; C/C++ -&gt; 代码生成 -&gt; 运行库 /MD /MDd改成/MT /MTd</p><p>项目属性页 -&gt; 链接器 -&gt; 输入 -&gt; 忽略特定默认库 添加crt64.lib</p><p>然后在代码开头添加以下语句。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define BEA_ENGINE_STATIC#include &quot;BeaEngine.h&quot;#pragma comment(lib,&quot;legacy_stdio_definitions.lib&quot;)#pragma comment(lib, &quot;D:\\beaengine-5.3.0\\lib_static_x64\\BeaEngine.lib&quot;)</code></pre><p>重点是：第一行在include”BeaEngine.h”前指明是静态，修改运行库、忽略crt64.lib以及第三行链接兼容库。</p><h3 id="可能的错误"><a href="#可能的错误" class="headerlink" title="可能的错误"></a>可能的错误</h3><h4 id="无法解析的外部符号"><a href="#无法解析的外部符号" class="headerlink" title="无法解析的外部符号"></a>无法解析的外部符号</h4><p>如果缺少第一行，报错如下：</p><p><code>error LNK2019: 无法解析的外部符号 __imp_Disasm</code></p><p>使用静lib库时必须在include前通过define指明使用静态库</p><h4 id="无法打开crt64-lib-或-sprintf无效引用"><a href="#无法打开crt64-lib-或-sprintf无效引用" class="headerlink" title="无法打开crt64.lib 或 sprintf无效引用"></a>无法打开crt64.lib 或 sprintf无效引用</h4><p>如果没有忽略crt64.lib或者没有修改运行库，报错如下：</p><p><code>LINK : fatal error LNK1104: 无法打开文件“crt64.lib”</code></p><p>这时尝试在配置链接器中忽略掉crt64.lib这个库，就会报<code>_sprintf无效引用</code></p><p>这时需要链接兼容库<code>legacy_stdio_definitions.lib</code></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Programing/">Programing</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/Programing/">Programing</category>
      
      <category domain="https://windgodm.github.io/blog/tags/BeaEngine/">BeaEngine</category>
      
      
      <comments>https://windgodm.github.io/blog/post/BeaEngine.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>neo4j与CQL</title>
      <link>https://windgodm.github.io/blog/post/neo4j-CQL.html</link>
      <guid>https://windgodm.github.io/blog/post/neo4j-CQL.html</guid>
      <pubDate>Mon, 20 Sep 2021 04:00:00 GMT</pubDate>
      
      <description>neo4j是个非关系型数据库，用docker装了个neo4j玩玩。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="ne04j与CQL"><a href="#ne04j与CQL" class="headerlink" title="ne04j与CQL"></a>ne04j与CQL</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>neo4j是个nosql数据库，通过docker安装可以启动一个本地服务器，在浏览器中访问。能画出数据的关系图。通过CQL语言进行操作。</p><p>主要用途是构建社会关系、知识图谱这种类型的数据库。自带图形化展示数据的功能。</p><h2 id="通过docker安装"><a href="#通过docker安装" class="headerlink" title="通过docker安装"></a>通过docker安装</h2><p>首先安装docker，win10需要先装wsl2，可以通过下载离线安装包的方z式，安装某个wsl2子系统到指定位置，具体不在絮述。</p><p>官网查询最新版本，比如是4.3.3，在wsl2的shell中执行以下命令拉取neo4j的docker。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull neo4j:4.3.3-community</code></pre><p>执行以下命令运行。其中NEO4J_AUTH后跟着的是初始 账号/密码。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -d --name container_name -p 7474:7474 -p 7687:7687 -v &#x2F;home&#x2F;neo4j&#x2F;data:&#x2F;data -v &#x2F;home&#x2F;neo4j&#x2F;logs:&#x2F;logs -v &#x2F;home&#x2F;neo4j&#x2F;conf:&#x2F;var&#x2F;lib&#x2F;neo4j&#x2F;conf -v &#x2F;home&#x2F;neo4j&#x2F;import:&#x2F;var&#x2F;lib&#x2F;neo4j&#x2F;import --env NEO4J_AUTH&#x3D;neo4j&#x2F;password neo4j:4.3.3-community</code></pre><h2 id="CQL"><a href="#CQL" class="headerlink" title="CQL"></a>CQL</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>1、Neo4j数据库服务器使用此&lt;node-name&gt;将此节点详细信息存储在Database.As中作为Neo4j DBA或Developer，我们不能使用它来访问节点详细信息。———为何不能呢？</p><p>2、Neo4j数据库服务器创建一个&lt;label-name&gt;作为内部节点名称的别名。作为Neo4j DBA或Developer，我们应该使用此标签名称来访问节点详细信息。</p></blockquote><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p><code>CREATE (&lt;node-name&gt;:&lt;label-name&gt;)</code></p><p>node-name可以理解成编程语言里的变量名，是一条数据的别名、句柄，用于操作这一条数据。可以当成是一个临时变量。（可以参照下面第三、四个示例理解）<br>可以省略。</p><p>label-name是数据的标签，或者说类型，有人把它类比成sql中的表名。</p><p>示例如下：</p><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">&#x2F;&#x2F; 创建一个标签为person，没有其他属性、关系的节点。&#x2F;&#x2F; 写法1CREATE (a:person)&#x2F;&#x2F; 写法2，省略节点名CREATE (:person)</code></pre><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">&#x2F;&#x2F; 创建一个带有name、phone两个属性的节点。CREATE (a:person&#123;name:&#39;abc&#39;, phone:114514&#125;)</code></pre><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">&#x2F;&#x2F; 创建两个节点，并添加关系&#x2F;&#x2F; 写法1，创建时添加关系CREATE (p1:person) CREATE (p2:person)-[r:&#39;friend&#39;]-&gt;(p2)&#x2F;&#x2F; 写法2，创建后添加关系CREATE (p1:person) CREATE (p2:person) CREATE (p1)-[r:&#39;friend&#39;]-&gt;(p2)</code></pre><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">&#x2F;&#x2F; 创建一个节点，并在图中显示该节点CREATE (a:person) RETURN a</code></pre><h3 id="搜索节点"><a href="#搜索节点" class="headerlink" title="搜索节点"></a>搜索节点</h3><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">&#x2F;&#x2F; 显示所有的节点及其关系MATCH (n) RETURN n</code></pre><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">&#x2F;&#x2F; 显示所有标签为person的节点及其关系MATCH (n:person) RETURN n</code></pre><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">&#x2F;&#x2F; 显示所有标签为person，属性id&#x3D;1的节点及其关系MATCH (n:person&#123;id:1&#125;) RETURN n</code></pre><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">&#x2F;&#x2F; 显示所有关系为friend的节点MATCH p&#x3D;()-[r:&#39;friend&#39;]-&gt;() RETURN p</code></pre><h3 id="添加属性、关系"><a href="#添加属性、关系" class="headerlink" title="添加属性、关系"></a>添加属性、关系</h3><p>需要配合MATCH使用。</p><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">&#x2F;&#x2F; 添加修改属性MATCH (n:person&#123;id:1&#125;) SET n.name&#x3D;&#39;abc&#39;</code></pre><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">&#x2F;&#x2F; 添加关系MATCH (p:person&#123;id:1&#125;) MATCH (n:person&#123;id:1&#125;) CREATE (p)-[r:&#39;friend&#39;]-&gt;(n)</code></pre><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>需要配合MATCH使用。</p><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">MATCH (p:person&#123;id:1&#125;) DELETE p</code></pre><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">MATCH (p:person&#123;id:1&#125;)-[r]-(n:person&#123;id:2&#125;) DELETE p,r,n</code></pre><h3 id="删除属性、关系"><a href="#删除属性、关系" class="headerlink" title="删除属性、关系"></a>删除属性、关系</h3><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">MATCH (p:person&#123;id:1&#125;) REMOVE n.name</code></pre><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>csv文件内容：</p><pre class="line-numbers language-none"><code class="language-none">id, name1, aaa2, bbb</code></pre><p>读取并创建节点：</p><pre class="line-numbers language-CQL" data-language="CQL"><code class="language-CQL">LOAD CSV FROM &#39;pathname&#39; AS line FILEDTERMINATOR &#39;,&#39; CREATE (:p&#123;id:toInterger(line[0]), name:line[1]&#125;)</code></pre>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Database/">Database</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/Database/">Database</category>
      
      <category domain="https://windgodm.github.io/blog/tags/neo4j/">neo4j</category>
      
      <category domain="https://windgodm.github.io/blog/tags/CQL/">CQL</category>
      
      
      <comments>https://windgodm.github.io/blog/post/neo4j-CQL.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>vmp2 (2) 初步分析handler(BeaEngine)</title>
      <link>https://windgodm.github.io/blog/post/vmp2-p2.html</link>
      <guid>https://windgodm.github.io/blog/post/vmp2-p2.html</guid>
      <pubDate>Wed, 15 Sep 2021 04:00:00 GMT</pubDate>
      
      <description>初步分析handler,用BeaEngine辅助分析。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="VMP2（2）初步分析handler-BeaEngine"><a href="#VMP2（2）初步分析handler-BeaEngine" class="headerlink" title="VMP2（2）初步分析handler(BeaEngine)"></a>VMP2（2）初步分析handler(BeaEngine)</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>基于手动初步分析的基础，了解了vmp2的结构以及handler表及解密方式。<br>现在写些工具用于辅助分析。</p><p>流程为：</p><ul><li>获取handler RVA</li><li>分析跳转并dump handler</li></ul><p>由subs1(*top = top2)这类涉及栈的一字节操作handler可知vmp栈是两字节对齐。</p><p>dump handler的目的是为了方便分析，具体原因见“条件与无条件jmp”。</p><p>有一个handler存在循环，在自动分析中导致了栈溢出，无法dump出来（需要检查是否重复解析同一地址才能正确dump）。</p><h2 id="获取handler的RVA"><a href="#获取handler的RVA" class="headerlink" title="获取handler的RVA"></a>获取handler的RVA</h2><h3 id="获取handler表"><a href="#获取handler表" class="headerlink" title="获取handler表"></a>获取handler表</h3><p>根据手动调试的结果，可以得到handler表的va，计算出rva，再转换成fa即可通过读取文件获取handler表。</p><p>rva转fa解析pe头的section header即可，这里不做絮述。</p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">UINT64 handlers[256];UINT64 imageBase &#x3D; 0x140000000;for (int i &#x3D; 0; i &lt; 256; i++) &#123;    &#x2F;&#x2F; ror 5    handlers[i] &#x3D; (handlers[i] &gt;&gt; 5) | ((handlers[i] &amp; 31) &lt;&lt; 59);    &#x2F;&#x2F; get rva    handlers[i] -&#x3D; imageBase;&#125;</code></pre><p>vmp2默认 Image Base 是0x140000000。</p><h2 id="BeaEngine"><a href="#BeaEngine" class="headerlink" title="BeaEngine"></a>BeaEngine</h2><p>BeaEngine是一个反汇编引擎，可以辅助分析。</p><p>这里给出一个大概的框架，用于辅助分析handler中的跳转，以及折叠jmp和部分意义不大的jmp。<br>具体可以查看官网文档。</p><p>通过下述代码可以遍历handler，然后可以输出为文本（<code>infos.VirtualAddr</code>,<code>infos.CompleteInstr</code>），借助vsc、md等文本工具分析汇编代码。<br>其中vsc有一个提供asm高亮的插件<code>x86 and x86_64 Assembly</code>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void DisasmCode(char* stBuf, UINT64 stVA, UINT64 edVA)&#123;    DISASM infos;PDISASM prevInfos &#x3D; new DISASM();PDISASM prev2Infos &#x3D; new DISASM();PDISASM tpInfos;int len;UINT64 curVA, nextVA;int isJmp; &#x2F;&#x2F; -1: undefine, 0: false, 1: true        BYTE cmp_rbp_rax[3] &#x3D; &#123; 0x48, 0x39, 0xC5 &#125;;        while (infos.Error &#x3D;&#x3D; 0) &#123;curVA &#x3D; infos.VirtualAddr;if (curVA &#x3D;&#x3D; edVA) break;&#x2F;&#x2F; disasmlen &#x3D; Disasm(&amp;infos);cout &lt;&lt; curVA &lt;&lt; &quot; &quot; &lt;&lt; infos.CompleteInstr &lt;&lt; endl;&#x2F;&#x2F; jmpif (infos.Instruction.BranchType &#x3D;&#x3D; JmpType) &#123;Jmp(infos);continue;&#125;&#x2F;&#x2F; retif (infos.Instruction.BranchType &#x3D;&#x3D; RetType) &#123;break;&#125;&#x2F;&#x2F; callif (infos.Instruction.BranchType &#x3D;&#x3D; CallType) &#123;&#x2F;&#x2F; nextinfos.EIP +&#x3D; len;infos.VirtualAddr +&#x3D; len;continue;&#125;&#x2F;&#x2F; Not branch instructionif (infos.Instruction.BranchType &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; savetpInfos &#x3D; prevInfos;prevInfos &#x3D; prev2Infos;prev2Infos &#x3D; tpInfos;memcpy(prevInfos, &amp;infos, sizeof(DISASM));&#x2F;&#x2F; nextinfos.EIP +&#x3D; len;infos.VirtualAddr +&#x3D; len;continue;&#125;isJmp &#x3D; -1;if(infos.Instruction.BranchType &#x3D;&#x3D; JA)&#123;            &#x2F;&#x2F; 此处下断点即可检查所有JA语句if (memcmp((void*)prevInfos-&gt;EIP, cmp_rbp_rax, 3) &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; cmp rbp, rax : 48 39 c5&#x2F;&#x2F; 48: REX.W&#x2F;&#x2F; 39: cmp Ev, Gv&#x2F;&#x2F; c5: Ev &#x3D; bp, Gv &#x3D; axisJmp &#x3D; 1;&#125;&#125;else&#123;            &#x2F;&#x2F; 此处下断点即可检查漏掉的跳转语句        &#125;if (isJmp &#x3D;&#x3D; 1) &#123;Jmp(infos);&#125;else if(isJmp &#x3D;&#x3D; 0)&#123;&#x2F;&#x2F; nextinfos.EIP +&#x3D; len;infos.VirtualAddr +&#x3D; len;&#125;else &#123;&#x2F;&#x2F; false branchDisasmCode((char*)(infos.EIP+len), infos.VirtualAddr+len, edVA);&#x2F;&#x2F; true branchJmp(infos);&#125;&#125;&#125;int main()&#123;    unsigned char* fileBuf; &#x2F;&#x2F; 指向被加壳文件的拷贝    &#x2F;&#x2F; 读取被加壳文件，此处略过        &#x2F;&#x2F; 去重    for (int i &#x3D; 0; i &lt; 256; i++) &#123;        rva &#x3D; handlers[i];        fa &#x3D; RVA2FA(rva); &#x2F;&#x2F; rva-&gt;fa函数略过handler_Rva_Fa[rva] &#x3D; fa;&#125;        unsigned long long getHandlerRVA &#x3D; 0x190438; &#x2F;&#x2F; 这个是获取字节码的那段shellcode    unsigned long long enVA +&#x3D; 0x140000000;        map&lt;unsigned int, unsigned int&gt;::iterator iter;for (iter &#x3D; handler_Rva_Fa.begin(); iter !&#x3D; handler_Rva_Fa.end(); iter++) &#123;char* buf &#x3D; (char*)((UINT64)fileBuf + (UINT64)iter-&gt;second);unsigned long long va &#x3D; imageBase + (UINT64)iter-&gt;first;cout &lt;&lt; &quot;Dis(rva):0x&quot; &lt;&lt; hex &lt;&lt; iter-&gt;first &lt;&lt; endl;if (iter-&gt;first &#x3D;&#x3D; 0x18e53b) &#123; &#x2F;&#x2F; 这个handler有点奇怪的问题，会造成栈溢出，解析不了continue;&#125;DisasmCode(buf, va, edVA);&#125;&#125;</code></pre><h2 id="条件与无条件jmp"><a href="#条件与无条件jmp" class="headerlink" title="条件与无条件jmp"></a>条件与无条件jmp</h2><p>handler中大量的jmp和有条件跳转，严重影响分析handler的效率。所以需要折叠jmp和一些意义不大的条件jmp，再dump出来方便分析。</p><h2 id="ja的所有情况"><a href="#ja的所有情况" class="headerlink" title="ja的所有情况"></a>ja的所有情况</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>跳转标志位：<strong>CF==0 &amp;&amp; ZF==0</strong></p><p>跳转意义：</p><ul><li>无符号&gt;</li><li>加法无进位（CF=0）</li></ul><p>stc设置cf = 1</p><p>xor设置cf = 0</p><p>运算结果为0 zf = 0</p><h3 id="vm栈溢出-检查"><a href="#vm栈溢出-检查" class="headerlink" title="vm栈溢出 检查"></a>vm栈溢出 检查</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">lea rax, [rdi+0xE0]cmp rbp, raxjmp ImageBase+0x18F29Aja ImageBase+0x190438 # Jmp if no vmp&#39;s StackOverflow</code></pre><p>在push中会有上述代码，没有栈溢出时满足ja，直接跟踪true分支即可。</p><p>分析时检查到前一条非jmp指令为<code>cmp rbp, rax</code>即可直接ja。</p><h3 id="vm栈指针-无条件加法-检查"><a href="#vm栈指针-无条件加法-检查" class="headerlink" title="vm栈指针 无条件加法 检查"></a>vm栈指针 无条件加法 检查</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">add rbp, 0x10ja ImageBase+0x18cc56 # Jmp if no add overflow</code></pre><p>参照概述，直接跟踪true分支即可。</p><p>分析时检查到前一条非jmp指令为<code>add rbp</code> 即可直接ja。</p><h3 id="shl"><a href="#shl" class="headerlink" title="shl"></a>shl</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">shl ax, clja ImageBase+0x18ebef</code></pre><p>两条分支一样，可以不做处理。</p><h3 id="xor-eax-eax"><a href="#xor-eax-eax" class="headerlink" title="xor eax, eax"></a>xor eax, eax</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">je # truestc # cf &#x3D; 1xor eax, eax # cf &#x3D; 0ja ImageBase+0x18f460</code></pre><p><code>xor eax, eax</code>的结果为0，所以zf=1，所以这个ja为false，直接忽略。</p><h3 id="其他（未知）"><a href="#其他（未知）" class="headerlink" title="其他（未知）"></a>其他（未知）</h3><pre class="line-numbers language-none"><code class="language-none">lea rdx, [8682618a + rax*2]ja</code></pre><p>前面有个xor是的cf=0，没有找到影响zf的语句，直接忽略。</p><h2 id="jl的所有情况"><a href="#jl的所有情况" class="headerlink" title="jl的所有情况"></a>jl的所有情况</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>跳转标志位：<strong>SF != OF</strong></p><p>跳转意义：</p><ul><li>有符号&lt;</li></ul><h3 id="signed-bh-lt-0xf9（可疑）"><a href="#signed-bh-lt-0xf9（可疑）" class="headerlink" title="signed: bh &lt; 0xf9（可疑）"></a>signed: bh &lt; 0xf9（可疑）</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">cmp bh, 0xf9stc # cf &#x3D; 1jl</code></pre><p>这个jl就是 if(bh &lt; -7) 或者说 0x7f &lt; bh &lt; 0xf9，不知道想干嘛，在调试中发现bh一般为f4，这里当成true。</p><h3 id="NOR"><a href="#NOR" class="headerlink" title="NOR"></a>NOR</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">and rax, rdxjl</code></pre><p>经观察这是个NOR handle，jl以后的代码和没有jl的是一样的，所以当成什么都无所谓。</p><h3 id="Add-rbp"><a href="#Add-rbp" class="headerlink" title="Add rbp"></a>Add rbp</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">add rbp, 0xajl</code></pre><p>这个add最高位是0+0=0，相同，of=0；sf=结果最高位=0。</p><p>所以jl是false。</p><h3 id="Sub-rbp"><a href="#Sub-rbp" class="headerlink" title="Sub rbp"></a>Sub rbp</h3><pre class="line-numbers language-none"><code class="language-none">sub rbp, 4jl</code></pre><p>同add rbp，这个jl也是false。</p><h2 id="部分其余的条件跳转"><a href="#部分其余的条件跳转" class="headerlink" title="部分其余的条件跳转"></a>部分其余的条件跳转</h2><h3 id="JC"><a href="#JC" class="headerlink" title="JC"></a>JC</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">add dword ptr [rpb+8], eaxjc</code></pre><p>两条分支一样，可以不做处理。</p><h3 id="JE"><a href="#JE" class="headerlink" title="JE"></a>JE</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">pushfqje</code></pre><p>两条分支一样，可以不做处理。</p><h3 id="JG"><a href="#JG" class="headerlink" title="JG"></a>JG</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">cmp bp, sijg</code></pre><p>两条分支一样，可以不做处理。</p><h3 id="JNO"><a href="#JNO" class="headerlink" title="JNO"></a>JNO</h3><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">inc clmov cl, byte ptr [rbp+8]jno</code></pre><p>可能循环相关，跟踪两条分支。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Re/">Re</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/vmp2/">vmp2</category>
      
      <category domain="https://windgodm.github.io/blog/tags/BeaEngine/">BeaEngine</category>
      
      
      <comments>https://windgodm.github.io/blog/post/vmp2-p2.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>vmp2 (1) 初步分析</title>
      <link>https://windgodm.github.io/blog/post/vmp2-p1.html</link>
      <guid>https://windgodm.github.io/blog/post/vmp2-p1.html</guid>
      <pubDate>Mon, 13 Sep 2021 04:00:00 GMT</pubDate>
      
      <description>初步分析VMProtect Ultimate v 2.13.5加密后的程序,vmp基本概况。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="VMP2（1）初步分析"><a href="#VMP2（1）初步分析" class="headerlink" title="VMP2（1）初步分析"></a>VMP2（1）初步分析</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>初步分析VMProtect Ultimate v 2.13.5加密后的程序，得出vmp基本结构的总结。</p><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>版本：VMProtect Ultimate v 2.13.5</p></blockquote><p>vmp代码在tls中。</p><p>下面是分析出的一些寄存器在vmp中的作用：</p><table><thead><tr><th>寄存器</th><th>描述</th></tr></thead><tbody><tr><td>RSI</td><td>字节码数组（逆序）</td></tr><tr><td>R12</td><td>Handler表</td></tr><tr><td>R13</td><td>Handler基址</td></tr><tr><td>RBP</td><td>VMP栈顶指针（栈从高到低）</td></tr><tr><td>RDI</td><td>VMP寄存器指针</td></tr><tr><td>RBX</td><td>解码密钥（动态）</td></tr></tbody></table><p>rsi指向当前字节码，rsi-1指向下一条字节码。</p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>14019065C~140190E54（256个x8byte）</p><h3 id="Handler分析"><a href="#Handler分析" class="headerlink" title="Handler分析"></a>Handler分析</h3><p><strong>POP_Q</strong></p><p>从vmp栈pop8字节数据到指定vmp寄存器。</p><p>2字节命令，后1字节解密后为VMP寄存器偏移（rdi）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 获取pop8目标vmp寄存器的偏移unsigned char GetPOP8Offset()&#123;    unsigned char al, bl;        al &#x3D; stack[--_rsi];    bl &#x3D; _rbx &amp; 0xff;        al -&#x3D; bl;    al ^&#x3D; 0x2f;    al++;    al ^&#x3D; 0xf1;    _rbx &#x3D; _rbx - bl + (bl - al); &#x2F;&#x2F; bl -&#x3D; al    return al;&#125;</code></pre><p><strong>PUSH_Q_ID</strong></p><p>从字节码push4字节数据到vmp栈。</p><p>5字节命令，后4字节解密后为数据。</p><p><code>sub rbp, 8</code>：push的数据为4字节，而VMP栈指针减8。</p><p>在最后有如下一段代码</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">lea rax, qword ptr ds:[rdi+0xE0] # 108cmp rbp, rax                   # 10Dja &lt;VmGetHandle&gt;               # 10F</code></pre><p>当rbp&gt;rax时跳转到正常代码，rbp是vmp栈顶，可知rbp&gt;rdi+0xE0。</p><p>由此得知虚拟寄存器在低地址、虚拟栈在高地址。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 获取push4的数据unsigned int GetPUSH4Data()&#123;    unsigned int eax, ebx;    unsigned char _bl;        _rsi -&#x3D; 4;    eax &#x3D; *(unsigned int*)(stack+_rsi);    ebx &#x3D; _rbx &amp; 0xffffffff;        bswap(eax);    eax ^&#x3D; ebx;    eax -&#x3D; 0xcc3ff88a;    eax ^&#x3D; 0x9b616bfd;    eax &#x3D; !eax;    bl &#x3D; _rbx &amp; 0xff;    _rbx &#x3D; _rbx - bl + 0xfa; &#x2F;&#x2F; bl &#x3D; 0xfb; bx--;    cdqe;    return eax;&#125;</code></pre><p><strong>ADD_Q_Q</strong></p><p>基于栈的二元加法。实现的功能为<code>top2 = top2+top1</code>，<code>top1 = RFLAGS</code>。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Re/">Re</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/vmp2/">vmp2</category>
      
      
      <comments>https://windgodm.github.io/blog/post/vmp2-p1.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MEMZ彩虹猫分析</title>
      <link>https://windgodm.github.io/blog/post/memz.html</link>
      <guid>https://windgodm.github.io/blog/post/memz.html</guid>
      <pubDate>Fri, 13 Aug 2021 04:00:00 GMT</pubDate>
      
      <description>MEMZ彩虹猫详细分析（不包括mbr部分）。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="MEMZ彩虹猫分析"><a href="#MEMZ彩虹猫分析" class="headerlink" title="MEMZ彩虹猫分析"></a>MEMZ彩虹猫分析</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="https://z3.ax1x.com/2021/09/05/hWm3QA.png" alt="MEMZ流程"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void start()&#123;&#x2F;&#x2F; 紫色部分if(arbc &gt; 1)&#123;if(!lstrcmpW(argv[1], L&quot;&#x2F;watchdog&quot;))        &#123;            &#x2F;&#x2F; 红色部分        &#125;        &#x2F;&#x2F; 绿色部分&#125;    &#x2F;&#x2F; 蓝色部分&#125;</code></pre><p>根据命令行参数不同，实际上会有三种效果。</p><p>第一种（蓝色部分）是不带参数，会弹两次警告窗口，然后带参数的打开自身。</p><p>第二种（绿色部分）是带参数且argv[1] != “/watchdog”。会往硬盘写入恶意代码，修改mbr；然后打开一个notepad；接着是捣乱十阶段：依次创建十个线程分别搞破坏。</p><p>第三种（红色部分）是argv[1] != “/watchdog”，会创建一个线程用于检测除彩虹猫以外的进程数量，如果有减少，会触发蓝屏与重启。主线程会创建一个消息循环，接收到关闭消息也会触发蓝屏与重启。</p><h2 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct&#123;    LPVOID pFunc;    unsigned int sleepTime;&#125;struc_1;</code></pre><h3 id="无参数部分代码"><a href="#无参数部分代码" class="headerlink" title="无参数部分代码"></a>无参数部分代码</h3><p><img src="https://z3.ax1x.com/2021/09/05/hWmHw6.png" alt="MEMZ_none"></p><p>这部分代码比较普通，api都有符号，直接查MSDN即可。</p><h3 id="非-watchdog部分代码"><a href="#非-watchdog部分代码" class="headerlink" title="非/watchdog部分代码"></a>非/watchdog部分代码</h3><p>运行这部分的进程优先级会被设为高。</p><p>这部分代码的结尾有个死循环sleep，所以不会运行无参数部分的代码。</p><p><strong>修改MBR，写入恶意代码</strong></p><p><img src="https://z3.ax1x.com/2021/09/05/hWmIyR.png" alt="MEMZ_main1"></p><p>比较有意思的是文件名为<code>\\.PhysicalDrive0</code>可以打开磁盘0，并覆写MBR</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">hFile &#x3D; CreateFileA(&quot;\\\\.\\PhysicalDrive0&quot;, 0xC0000000, 3u, 0, 3u, 0, 0);&#x2F;&#x2F; 打开物理驱动器0</code></pre><p>写入的shellcode没有分析。</p><p><strong>打开记事本嘲讽</strong></p><p><img src="https://z3.ax1x.com/2021/09/05/hWmoO1.png" alt="MEMZ_main2"></p><p>然后写入记事本并打开。</p><p><strong>捣乱十连</strong></p><p><img src="https://z3.ax1x.com/2021/09/05/hWm5l9.png" alt="MEMZ_main3"></p><p>随后有个捣乱十阶段，间隔一定时间，创建十个线程，分别执行十个函数，下面是我稍微整理了下的代码。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">for(i &#x3D; 0; i &lt; 10; i++)&#123;    Sleep(messFuncs[i].sleepTime);    CreateThread(0, 0, LoopCallMess, &amp;messFuncs[i], 0, 0);&#125;</code></pre><p>其中messFuncs是一个结构体数组，猜测定义如下。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef struct _struc_1&#123;    LPVOID pFunc;    unsigned int sleepTime;&#125;struc_1;struc_1 messFuncs[10];</code></pre><p>执行的那十个函数的分析见下面的捣乱十阶段。</p><h3 id="watchdog部分代码"><a href="#watchdog部分代码" class="headerlink" title="/watchdog部分代码"></a>/watchdog部分代码</h3><p>创建一个线程，然后创建一个消息循环。</p><p><strong>创建的线程</strong></p><p>创建的线程会不断的创建快照，然后统计除MEMZ以外的进程数，如果有减少就执行一个导致蓝屏与重启的函数。</p><p>判断是否是MEMZ的方法是检测进程路径。</p><p><strong>消息循环</strong></p><p>消息循环函数在接收到关闭信息也会执行导致蓝屏与重启的函数。</p><h3 id="蓝屏与重启"><a href="#蓝屏与重启" class="headerlink" title="蓝屏与重启"></a>蓝屏与重启</h3><p><img src="https://z3.ax1x.com/2021/09/05/hWm7ex.png" alt="MEMZ_reboot"></p><p>先循环创建20个线程执行一个函数。</p><p>然后直接获取ntdll的api，然后调用触发蓝屏的函数。随后重启。</p><p>那20个线程执行的函数，会SetWindowsHook，hook函数会在窗口创建时随机随机修改窗口位置，随后调用MessageBoxA创建一个窗口，随机弹出嘲讽信息，由于设置了钩子，这个窗口位置是随机的。最后撤销钩子。</p><h3 id="捣乱十阶段"><a href="#捣乱十阶段" class="headerlink" title="捣乱十阶段"></a>捣乱十阶段</h3><h4 id="阶段一：乱开网页和窗口"><a href="#阶段一：乱开网页和窗口" class="headerlink" title="阶段一：乱开网页和窗口"></a>阶段一：乱开网页和窗口</h4><p>从46条字符串里随机挑一条作为ShellExecuteA的参数，相当于在运行一个shell，字符串是shell的输入。如果字符串是网页链接，就会打开网页。还可以是<code>calc</code>，<code>notepad</code>等，将打开对应的程序。</p><h4 id="阶段二：乱动鼠标"><a href="#阶段二：乱动鼠标" class="headerlink" title="阶段二：乱动鼠标"></a>阶段二：乱动鼠标</h4><p>获取鼠标坐标，然后加上随机数，最后再修改鼠标坐标，达到让鼠标乱抖的效果。</p><h4 id="阶段三：乱按键盘"><a href="#阶段三：乱按键盘" class="headerlink" title="阶段三：乱按键盘"></a>阶段三：乱按键盘</h4><p>调用SendInput api。</p><h4 id="阶段四：乱放系统声音"><a href="#阶段四：乱放系统声音" class="headerlink" title="阶段四：乱放系统声音"></a>阶段四：乱放系统声音</h4><p>调用PlaySoundA api。</p><h4 id="阶段五：反转桌面窗口颜色"><a href="#阶段五：反转桌面窗口颜色" class="headerlink" title="阶段五：反转桌面窗口颜色"></a>阶段五：反转桌面窗口颜色</h4><p>获取窗口句柄，然后用BitBlt()反转颜色。</p><h4 id="阶段六：嘲讽弹窗"><a href="#阶段六：嘲讽弹窗" class="headerlink" title="阶段六：嘲讽弹窗"></a>阶段六：嘲讽弹窗</h4><p>创建一个线程，该线程做的东西和前面StartAddresss那个函数差不多，也是通过SetWindowsHook实现随机位置弹出MessageBox，显示嘲讽信息。</p><h4 id="阶段七：错误图标"><a href="#阶段七：错误图标" class="headerlink" title="阶段七：错误图标"></a>阶段七：错误图标</h4><p>获取鼠标坐标，然后在鼠标旁边画图标。</p><h4 id="阶段八：反转文字"><a href="#阶段八：反转文字" class="headerlink" title="阶段八：反转文字"></a>阶段八：反转文字</h4><p>通过EnumChildWindows给全部窗口设一个回调函数，这个回调函数通过SendMessageTimeoutW发送信号给窗口，获取窗口的文字，然后把文字顺序反转，再发送信号给窗口更改文字。</p><h4 id="阶段九：无限桌面"><a href="#阶段九：无限桌面" class="headerlink" title="阶段九：无限桌面"></a>阶段九：无限桌面</h4><p>有点类似阶段五，不过这次不是反转颜色，可以理解为把桌面截图，然后向右和向下各平移50像素后覆盖到原来桌面。</p><h4 id="阶段十：混乱桌面"><a href="#阶段十：混乱桌面" class="headerlink" title="阶段十：混乱桌面"></a>阶段十：混乱桌面</h4><p>类似阶段九，不过这次是随机覆盖。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Virus/">Virus</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/virus/">virus</category>
      
      
      <comments>https://windgodm.github.io/blog/post/memz.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>简易压缩壳笔记</title>
      <link>https://windgodm.github.io/blog/post/SimplePack.html</link>
      <guid>https://windgodm.github.io/blog/post/SimplePack.html</guid>
      <pubDate>Wed, 04 Aug 2021 04:00:00 GMT</pubDate>
      
      <description>写一个简易的压缩壳的笔记。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="简易压缩壳笔记"><a href="#简易压缩壳笔记" class="headerlink" title="简易压缩壳笔记"></a>简易压缩壳笔记</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><pre class="line-numbers language-none"><code class="language-none">加壳器：读取被加壳文件加载壳代码复制壳代码的section header修改ep并保存oep加密压缩清空import、iat directory，保存import directory清空tls directoru，保存directory的AddressOfCallBacks重定位壳代码复制壳代码重定位表，并修改reloc directory修复壳代码重定位表写入文件壳代码：遍历ldr获取ntdll中的函数获取用于解壳的函数的地址解压解密修复并加密iat重定位tls反调试跳转到oep</code></pre><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>替换reloc等section时，只需要修改data directory即可。</p><p>增加section可以只增加header，写入文件时再追加写入。</p><p>通过dll形式写壳代码可以比较方便生成重定位表、iat等。</p><h3 id="关于导入表"><a href="#关于导入表" class="headerlink" title="关于导入表"></a>关于导入表</h3><p>关于加密iat，常见的做法对每一个api申请一块可执行内存作为跳转函数，然后把iat中api地址换成跳转函数地址。<br>此做法需要判断导入表中导入的是函数还是变量。如果是变量显然会出错。我采取的做法是判断地址是否位于dll的text段。</p><p>关于import_descriptor。该结构有OriginalFirstThunk和FirstThunk两个结构体数组的指针。理论上文件中时两个结构体应该都指向同一个地址，加载为image后FT指向IAT的RVA。<br>有时可能会出现OFT为0，只有FT的情况。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/pack/">pack</category>
      
      
      <comments>https://windgodm.github.io/blog/post/SimplePack.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WX数据库自动解密（已失效）</title>
      <link>https://windgodm.github.io/blog/post/WeChatDBDecrypt.html</link>
      <guid>https://windgodm.github.io/blog/post/WeChatDBDecrypt.html</guid>
      <pubDate>Thu, 22 Jul 2021 04:00:00 GMT</pubDate>
      
      <description>wx数据库解密，用hook dump密钥。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="微信-PC端-数据库-自动解密"><a href="#微信-PC端-数据库-自动解密" class="headerlink" title="微信 PC端 数据库 自动解密"></a>微信 PC端 数据库 自动解密</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>环境:</p><p>win10家庭中文版 10.0.19043 x64（本机）</p><p>微信 3.3.0.115</p><p>openssl-1.0.2r</p></blockquote><p>PC密码为32字节。</p><h2 id="手动流程"><a href="#手动流程" class="headerlink" title="手动流程"></a>手动流程</h2><h3 id="获取密码"><a href="#获取密码" class="headerlink" title="获取密码"></a>获取密码</h3><p>打开微信（不点登录）。</p><p>打开Odb附加WeChat.exe。</p><p>查找-&gt;可执行模块-&gt;WeChatWin。</p><p>用插件找ASCII字符串（我打了中文搜索补丁，直接用中文搜索的搜索ASCII字符串）。</p><p>然后搜索字符串<code>DBFactory::encryptDB</code>，跳转到第一次出现该字符串的位置。这里旧版本可能是第二个字符串的位置。3.3版本我找到了两个，都跳转过去看看，其中一个push语句下面有一个TEST，另一个只有一个call就return了。要找的是有TEST那个。</p><p>该TEST语句就是比较密码的地方，双击设置断点。然后运行并登录。</p><p>停在断点时，选择edx在数据窗口中跟随。</p><p>然后把从edx开始的32字节的数据dump出来，该32字节的数据就是密码。</p><h3 id="从源码安装openssl"><a href="#从源码安装openssl" class="headerlink" title="从源码安装openssl"></a>从源码安装openssl</h3><p>需要用到openssl，据说sqlcipher用的是最低版本的openssl。这里使用1.0.2u。</p><p>首先安装perl。（<a href="http://www.activestate.com/activeperl/downloads/%EF%BC%89">http://www.activestate.com/activeperl/downloads/）</a></p><p>然后运行 x86 Native Tools Command Prompt for VS 2019 这个shell。</p><p>激活perl环境</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">state activatecd &#x2F;d D:\openssl-1.0.2u\</code></pre><p>编译</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">perl Configure VC-WIN64A no-asm -prefix&#x3D;D:\Program Files\openssl102ums\do_ms.batnmake -f ms\ntdll.mak</code></pre><p>检查</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nmake -f ms\ntdll.mak test</code></pre><p>安装</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nmake -f ms\ntdll.mak install</code></pre><p>奇怪的是最后还是安装到了E:\usr\local\ssl\这个目录下</p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>这里分享vs2019解密的过程。</p><p>在项目的属性页 -&gt; C/C++ -&gt; 常规 -&gt; 附加包含目录 中添加openssl的include目录。</p><p>在项目的属性页 -&gt; 链接器 -&gt; 常规 -&gt; 附加库目录 中添加openssl的include目录。</p><p>在项目的属性页 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项 中添加libeay32.lib和ssleay32.lib。</p><p>然后编译运行看雪文章中的代码。（链接见参考）</p><p>然后把E:\usr\local\ssl\bin\中的两个dll复制exe的根目录，exe才能正常运行。</p><p>接着把exe和两个dll复制到微信缓存文件的目录/对应用户目录/Msg/里，微信缓存目录名为WeChat Files，可以在微信设置中查到。</p><p>复制过去后运行exe即可。</p><h2 id="自动获取（代码修改api-hook）"><a href="#自动获取（代码修改api-hook）" class="headerlink" title="自动获取（代码修改api hook）"></a>自动获取（代码修改api hook）</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>代码参考附件。</p><p>总流程如下：</p><pre class="line-numbers language-none"><code class="language-none">复制dll到wx根目录打开微信注入dll微信登录dll把密钥dump出来复制聊天记录文件解密</code></pre><p>其中dll所做的是修改目标函数的起始字节为jmp，跳转到hook函数中，然后读取原函数的参数，把密钥写到文件里，再unhook并跳回原来的位置继续运行。</p><p>因为比较懒，自动化代码没有写卸载dll的东西。另外有时会出现dump出密码后，微信直接闪退的情况。</p><h3 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h3><p>通过注入dll实现修改代码的hook来dump出密钥。</p><p>通过GetModuleHandle获取WeChatWin.dll的基址，然后加上目标api的偏移得到api的地址。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">hApi &#x3D; GetModuleHandleW(L&quot;WeChatWin&quot;) + apiOffset;hook_by_5b_code(hApi, (PROC)HookFunc);</code></pre><p>然后查看api的代码可以推算出密钥首地址为*(*(esp - 4 + 0x10))，减4是因为有个push ebp。然后剩下的照抄test edx, edx前的代码得到。</p><p>当然也可以直接在test edx, edx的地方跳转，这样直接读edx就行。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__declspec(naked) void HookFunc()&#123;    &#123;        DWORD _esp &#x3D; 0;         __asm &#123;            mov _esp, esp;            pusha;        &#125;         DWORD addr &#x3D; *(DWORD*)(*(DWORD*)(_esp + 0xc));        HANDLE hFile &#x3D; CreateFileW(L&quot;.&#x2F;pw.bin&quot;, GENERIC_WRITE, 0, 0, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);        WriteFile(hFile, (LPCVOID)addr, 32, NULL, NULL);        CloseHandle(hFile);        unhook_by_5b_code(hApi);         __asm &#123;            popa;            mov ecx, 0x53677E70;            jmp ecx;        &#125;    &#125;&#125;</code></pre><h3 id="食用指南"><a href="#食用指南" class="headerlink" title="食用指南"></a>食用指南</h3><p>GetPwHookCodeDll.cpp是dll的代码。AllInOne.cpp是自动解密的代码。需要提供wx根目录位置和微信用户文件的位置。</p><p>wx用户文件的位置：在wx的缓存文件（该目录在wx设置中有）中，有一个叫wxid_xxxxxxx的文件夹，xxxxx是你的初始wx id，这个就是对应wx账户的本地文件。</p><p>假设wx根目录是<code>D:\WeChat</code>，用户目录是<code>D:\WeChat Files\wxid_bravetroops</code>。<br>方法一：在自动程序根目录中打开shell，输入<code>AllInOne.exe D:\WeChat D:\WeChat Files\wxid_bravetroops</code>即可。<br>方法二：在程序根目录中有个aio_cf.txt，第一行输入wx根目录，第二行输入用户目录即可。</p><p>最后会在根目录生成一个dec_ChatMsg.db的文件，就是解密后的聊天记录。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[<a href="https://bbs.pediy.com/thread-251303.htm">原创]PC版微信数据库解密详细教程|bbs.pediy.com</a></p><p><a href="https://blog.csdn.net/qq_35014708/article/details/89354694">window10 安装 OpenSSL_sun-CSDN博客</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/WX/">WX</category>
      
      <category domain="https://windgodm.github.io/blog/tags/Database/">Database</category>
      
      
      <comments>https://windgodm.github.io/blog/post/WeChatDBDecrypt.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HammingCode</title>
      <link>https://windgodm.github.io/blog/post/HammingCode.html</link>
      <guid>https://windgodm.github.io/blog/post/HammingCode.html</guid>
      <pubDate>Wed, 14 Jul 2021 04:00:00 GMT</pubDate>
      
      <description>HammingCode笔记。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Hamming-Code"><a href="#Hamming-Code" class="headerlink" title="Hamming Code"></a>Hamming Code</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>多次奇偶校验，下标为2<sup>n</sup>的位作为奇偶校验位，校验对象为所有位中小标第n位为1的位，显然包括了一半的数据。</p><p>第0位一般弃置，或者作为奇偶校验位的奇偶校验位，这样就可以判断是否存在多个错误。</p><p>每一个奇偶校验位都校验了一半的数据，通过检测哪些校验位是错的即可找到哪一位数据出错。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>三种理解思路：一是多组奇偶校验；二是异或；三是线性代数。</p><p>只能纠错一个位，以及判断是否有多个错误，校验结果即为错误位。</p><p>若奇偶校验位的个数为n：</p><p>汉明码的位数：2<sup>n</sup> = 1 &lt;&lt; n</p><p>数据位的位数：2<sup>n</sup>-n-1 = (1&lt;&lt;n)-n-1</p><p>校验位按下标排序，错误的置一，其余置零，若结果不为0，得到的就是错误位的下标。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>该算法目前已经不常用。实际使用通常配合其他通信技巧使用。下面是我分别用python和c++实现的代码。实现方式为把原始数据分块再编码成汉明码。</p><p><a href="https://github.com/windgodm/Algorithm/tree/master/HammingCode">Algorithm/HammingCode at master · windgodm/Algorithm (github.com)</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1WK411N7kz">https://www.bilibili.com/video/BV1WK411N7kz</a></p><p><a href="https://www.bilibili.com/video/BV1pV411y7E8">https://www.bilibili.com/video/BV1pV411y7E8</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/Error-Correction/">Error_Correction</category>
      
      
      <comments>https://windgodm.github.io/blog/post/HammingCode.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>APIHook DLL注入实现代码钩取 笔记</title>
      <link>https://windgodm.github.io/blog/post/APIHookDllCodeHideProc.html</link>
      <guid>https://windgodm.github.io/blog/post/APIHookDllCodeHideProc.html</guid>
      <pubDate>Thu, 24 Jun 2021 06:44:00 GMT</pubDate>
      
      <description>逆向工程核心原理中利用dll注入修改代码来实现钩取的笔记,&lt;br&gt;钩取了ZwQuerySystemInformation()以隐藏进程。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="APIHook-DLL注入实现代码钩取-笔记"><a href="#APIHook-DLL注入实现代码钩取-笔记" class="headerlink" title="APIHook - DLL注入实现代码钩取 笔记"></a>APIHook - DLL注入实现代码钩取 笔记</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>技术摘要：</p><p><strong>动态</strong>修改<strong>进程内存</strong>中的<strong>代码</strong>。利用<strong>DLL注入</strong>修改代码开头跳转到补丁代码。</p></blockquote><p>起源是逆向工程核心原理里面以任务管理器ZwQuerySystemInformation()API钩取为例讲解利用dll注入修改api的起始代码为jmp实现api钩取。<br>该例子目标是隐藏某个进程。</p><p>大概流程如下</p><pre class="line-numbers language-none"><code class="language-none">调用者:1: call apiapi:2: jmp patchpatch:3: unhook4: call api（正常执行api功能）5: hook6: patch7: retn 到调用者</code></pre><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>有一些未公开的函数或者枚举类型一定要找尽可能正确的。可能因为资料的不正确导致钩取失败或没有效果。如果出现问题，要对比正常流程看钩取后传递的参数是否符合预期，一些标志位的设置是否正确。</p><p>不可避免的一个问题是会出现<strong>漏网之鱼</strong>，也就unhook期间原api被调用会暴露隐藏进程。我在测试时遇到过隐藏进程突然在任务管理器中闪出来几下的情况。</p><p>隐藏进程实际上是修改了ZwQuerySystemInformation返回的一个包含进程信息的链表，如果要隐藏的进程在链表中排第一个的话会出错，原因详见 实例 中。而实际中似乎链表的第一个一定是System(进程号为4)，随后是Registry和svchost。所以只有不隐藏System这个进程就不会有问题。</p><h2 id="实例：隐藏进程ZwQuerySystemInformation-（x64）"><a href="#实例：隐藏进程ZwQuerySystemInformation-（x64）" class="headerlink" title="实例：隐藏进程ZwQuerySystemInformation()（x64）"></a>实例：隐藏进程ZwQuerySystemInformation()（x64）</h2><p>该例子对象是任何直接或间接使用了ZwQuerySystemInformation查询进程信息的64位程序，比如任务管理器。</p><p>下面的步骤按运行时的执行顺序来写。</p><h3 id="1-dll注入"><a href="#1-dll注入" class="headerlink" title="1 dll注入"></a>1 dll注入</h3><p>第一步是把后面编写好的dll注入到目标程序中，关于dll注入的内容在此略过。</p><h3 id="2-dll"><a href="#2-dll" class="headerlink" title="2 dll"></a>2 dll</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#pragma comment(linker, &quot;&#x2F;SECTION:.SHARE,RWS&quot;)#pragma data_seg(&quot;.SHARE&quot;)wchar_t g_wszProcName[MAX_PATH] &#x3D; &#123; 0, &#125;;#pragma data_seg()void SetProcName(LPCTSTR wszProcName)&#123;    wcscpy_s(g_wszProcName, wszProcName);&#125;BOOL APIENTRY DllMain(HMODULE hModule,    DWORD  ul_reason_for_call,    LPVOID lpReserved)&#123;    char pszCurProc[MAX_PATH] &#x3D; &#123; 0, &#125;;    char* p &#x3D; NULL;    &#x2F;&#x2F; check    GetModuleFileNameA(NULL, pszCurProc, MAX_PATH);    p &#x3D; strrchr(pszCurProc, &#39;\\&#39;);    if ((p !&#x3D; NULL) &amp;&amp; !_stricmp(p + 1, &quot;remote_inject_x64.exe&quot;))        return TRUE;    switch (ul_reason_for_call) &#123;    case DLL_PROCESS_ATTACH:        &#x2F;&#x2F; set        SetProcName(L&quot;notepad.exe&quot;);        &#x2F;&#x2F; get api        hApi &#x3D; GetProcAddress(GetModuleHandleW(pwszDllName), &quot;ZwQuerySystemInformation&quot;);        &#x2F;&#x2F; hook        hook_by_5b_code(pszDllName, hApi, (PROC)MyZwQuerySystemInformation);        break;    case DLL_PROCESS_DETACH:        &#x2F;&#x2F;unhook        unhook_by_5b_code(pszDllName, hApi);        break;    &#125;    return TRUE;&#125;</code></pre><p>这里就是普通的dll，加载时钩取、卸载时脱钩。在加载时还会获取目标api的地址，以及设置要隐藏的dll名称。设置隐藏dll名称这一步可以换到别的地方设置。因为保存隐藏dll名称的变量是个共享变量，所以完全可以再写一个程序复制管理这个共享变量。只需要在管理程序中主动加载该dll，然后调用导出的SetProcName()即可，可以实现动态改变隐藏目标。当然也可以拓展代码实现隐藏多个不同名进程或按pid隐藏等。（这里SetProcName定义在dll的头文件中）</p><h3 id="3-hook-by-5bytes-code"><a href="#3-hook-by-5bytes-code" class="headerlink" title="3 hook by 5bytes code"></a>3 hook by 5bytes code</h3><p>hook_by_5b_code函数修改api开头的5字节内容，改成jmp指令。32和64的jmp都是e9+4字节的相对偏移，这个相对偏移是以jmp下一条指令的地址作为起始地址来计算的，具体见下面的代码。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool hook_by_5b_code(char* pszDllName, HANDLE api, PROC newApi)&#123;    DWORD dwOldProtect;    byte pNewBytes[5] &#x3D; &#123; 0xE9, 0, &#125;;    DWORD jmpOffset;    VirtualProtect(api, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    if (((PBYTE)api)[0] &#x3D;&#x3D; 0xE9)        return false;    &#x2F;&#x2F; bak origin byte    memcpy(pOriginBytes, api, 5);    &#x2F;&#x2F; count jmp offset    jmpOffset &#x3D; (DWORD)((size_t)newApi - (size_t)api - 5);    &#x2F;&#x2F; e9 offset(4bytes)    memcpy(&amp;pNewBytes[1], &amp;jmpOffset, 4);    &#x2F;&#x2F; hook    memcpy(api, pNewBytes, 5);    VirtualProtect(api, 9, dwOldProtect, &amp;dwOldProtect);    return true;&#125;</code></pre><p>unhook就是恢复api原始字节即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool unhook_by_5b_code(char* pszDllName, HANDLE api)&#123;    DWORD dwOldProtect;    VirtualProtect(api, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    if (((PBYTE)api)[0] !&#x3D; 0xE9)        return false;    &#x2F;&#x2F; unhook    memcpy(api, pOriginBytes, 5);    VirtualProtect(api, 5, dwOldProtect, &amp;dwOldProtect);    return true;&#125;</code></pre><h3 id="新api（补丁代码-ZwQuerySystemInformation）"><a href="#新api（补丁代码-ZwQuerySystemInformation）" class="headerlink" title="新api（补丁代码 ZwQuerySystemInformation）"></a>新api（补丁代码 ZwQuerySystemInformation）</h3><p>1~4对应摘要中的3~6，具体看代码及注释。在执行patch之前会检测返回值判断调用原api是否成功，以及判断此次调用是否为查询进程信息。</p><p>PSYSTEM_PROCESS_INFORMATION结构是一个链表，具体遍历方式参考代码即可。</p><p>SYSTEM_INFORMATION_CLASS是一个枚举类型，说明函数SystemInformation这个参数的类似是什么。如果 SystemInformationClass == SystemProcessorInformation(5) 即代表SystemInformation类型为PSYSTEM_PROCESS_INFORMATION。</p><p>可以看到代码中没有对链表第一个元素做特殊处理，这里算是一个不会产生太大影响的bug。如果要隐藏的进程在链表的第一个位置，此时prev和cur指向的都是第一个元素，执行操作以后会错误修改第一个元素的next偏移，导致无法正确找到第二个元素，同时也没有隐藏第一个。实际中第一个元素好像一般为System进程，只要不隐藏这个一般不会触发问题。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef struct _SYSTEM_PROCESS_INFORMATION &#123;ULONG NextEntryOffset;ULONG NumberOfThreads;BYTE Reserved1[48];PVOID Reserved2[3];HANDLE UniqueProcessId;PVOID Reserved3;ULONG HandleCount;BYTE Reserved4[4];PVOID Reserved5[11];SIZE_T PeakPagefileUsage;SIZE_T PrivatePageCount;LARGE_INTEGER Reserved6[6];&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;NTSTATUS WINAPI MyZwQuerySystemInformation(    _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,    _Inout_   PVOID                    SystemInformation,    _In_      ULONG                    SystemInformationLength,    _Out_opt_ PULONG                   ReturnLength)&#123;    NTSTATUS nts;    &#x2F;&#x2F; 1: unhook    unhook_by_5b_code(pszDllName, hApi);    &#x2F;&#x2F; 2: call origin api    nts &#x3D; ((ZwQuerySystemInformation)hApi)(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);    &#x2F;&#x2F; 3: hook    hook_by_5b_code(pszDllName, hApi, (PROC)MyZwQuerySystemInformation);    &#x2F;&#x2F; SystemProcessorInformation(5)    if ((nts !&#x3D; CMC_STATUS_SUCCESS) || SystemInformationClass !&#x3D; 5) &#123;        return nts;    &#125;    &#x2F;&#x2F; 4: patch: hide    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;    pCur &#x3D; (PSYSTEM_PROCESS_INFORMATION)SystemInformation;    pPrev &#x3D; pCur; &#x2F;&#x2F; warning    while (1) &#123;        &#x2F;&#x2F; hide        if (pCur-&gt;Reserved2[1] !&#x3D; NULL) &#123;            if (_wcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_wszProcName) &#x3D;&#x3D; 0) &#123;                if (pCur-&gt;NextEntryOffset &#x3D;&#x3D; 0)                    pPrev-&gt;NextEntryOffset &#x3D; 0;                else                    pPrev-&gt;NextEntryOffset +&#x3D; pCur-&gt;NextEntryOffset;            &#125;            else &#123;                pPrev &#x3D; pCur;            &#125;        &#125;        &#x2F;&#x2F; break        if (pCur-&gt;NextEntryOffset &#x3D;&#x3D; 0)            break;        &#x2F;&#x2F; next        pCur &#x3D; (PSYSTEM_PROCESS_INFORMATION)((size_t)pCur + (size_t)pCur-&gt;NextEntryOffset);    &#125;        return nts;&#125;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>逆向工程核心原理：part4-API钩取：第33章-隐藏进程</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/api-hook/">api_hook</category>
      
      <category domain="https://windgodm.github.io/blog/tags/reversecore/">reversecore</category>
      
      
      <comments>https://windgodm.github.io/blog/post/APIHookDllCodeHideProc.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>APIHook DLL注入实现IAT钩取 笔记</title>
      <link>https://windgodm.github.io/blog/post/APIHookDllIATCalc.html</link>
      <guid>https://windgodm.github.io/blog/post/APIHookDllIATCalc.html</guid>
      <pubDate>Sat, 19 Jun 2021 06:22:00 GMT</pubDate>
      
      <description>逆向工程核心原理中利用dll注入修改iat来实现钩取的笔记,&lt;br&gt;钩取了计算器的SetWindowText()以显示中文数字。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="APIHook-DLL注入实现IAT钩取-笔记"><a href="#APIHook-DLL注入实现IAT钩取-笔记" class="headerlink" title="APIHook - DLL注入实现IAT钩取 笔记"></a>APIHook - DLL注入实现IAT钩取 笔记</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>技术摘要：</p><p><strong>动态</strong>修改<strong>进程内存</strong>中的<strong>IAT</strong>。利用<strong>DLL注入</strong>修改API的IAT。</p></blockquote><p>起源是逆向工程核心原理里面以计算器SetWindowText()API钩取为例讲解利用dll注入修改api的iat来实现钩取。<br>该例子目标是把显示的阿拉伯数字改成中文数字。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>补丁函数（新api）要申明为WINAPI，即stdcall。c++默认的是cdecl，由调用者处理栈。而api使用的stdcall是由被调用者处理的。如果不声明为stdcall，调用钩取api结束时本应该清理栈，而实际上不会清理。同样钩取api中调用原api时，原api结束时清理了一次栈，而我们的钩取api又会再处理一次栈。这时esp指向的不是旧ebp，pop ebp时就会触发错误。<br>实际上由于win32 api为stdcall，使得我们的新函数对栈不需要做特殊操作。</p><h2 id="实例：计算器SetWindowTextW-（x32）"><a href="#实例：计算器SetWindowTextW-（x32）" class="headerlink" title="实例：计算器SetWindowTextW()（x32）"></a>实例：计算器SetWindowTextW()（x32）</h2><p>该例子对象是xp的x32的calc.exe，运行环境是在win10中。（我把xp虚拟机里的计算机复制出来了）在win10的计算机中尝试失败了，还没找到原因。</p><p>下面的步骤按运行时的执行顺序来写。</p><h3 id="1-dll注入"><a href="#1-dll注入" class="headerlink" title="1 dll注入"></a>1 dll注入</h3><p>第一步是把后面编写好的dll注入到目标程序中，关于dll注入的内容在此略过。</p><h3 id="2-dll"><a href="#2-dll" class="headerlink" title="2 dll"></a>2 dll</h3><p>当 dll第一次加载进进程(DLL_PROCESS_ATTACH) 时先记录原本api的地址，如何再hook。</p><p>当 卸载dll(DLL_PROCESS_DETACH) 时unhook。</p><p>因为hook实际上就是把iat中被钩取api的地址换成补丁函数的地址，而unhook的过程则反过来把iat中补丁函数地址换回原本地址，所以可以统一写成一个函数hook_iat()。该函数会将oldFunc替换成newFunc。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool hook_iat(char* pszDllName, HANDLE oldFunc, HANDLE newFunc);BOOL WINAPI MySetWindowTextW(    HWND    hWnd,    LPCWSTR lpString);BOOL APIENTRY DllMain(HMODULE hModule,    DWORD  ul_reason_for_call,    LPVOID lpReserved)&#123;    switch (ul_reason_for_call) &#123;    case DLL_PROCESS_ATTACH:        &#x2F;&#x2F; save origin api        pOriginFunc &#x3D; GetProcAddress(GetModuleHandleW(L&quot;user32.dll&quot;), &quot;SetWindowTextW&quot;);        &#x2F;&#x2F; hook        hook_iat(&quot;user32.dll&quot;, pOriginFunc, MySetWindowTextW);        break;    case DLL_PROCESS_DETACH:        &#x2F;&#x2F;unhook        hook_iat(&quot;user32.dll&quot;, MySetWindowTextW, pOriginFunc);        break;    &#125;    return TRUE;&#125;</code></pre><h3 id="3-改写iat（hook-iat-）"><a href="#3-改写iat（hook-iat-）" class="headerlink" title="3 改写iat（hook_iat()）"></a>3 改写iat（hook_iat()）</h3><p>这个函数用于把iat中名为 pszDllName 的 library 中的 oldFunc 换成 newFunc。本质上整段代码就是在解析pe文件以及遍历iat。这里不做详细解析，详见反射注入文章[2]中 处理导入表 部分内容。</p><p>其中用到了size_t，这是个与机器有关的unsigned类型。说人话就是按32位编译时是32位；按64位编译时是64位。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool hook_iat(char* pszDllName, HANDLE oldFunc, HANDLE newFunc)&#123;    &#x2F;&#x2F; pe    PIMAGE_DOS_HEADER pDosHeader &#x3D; (PIMAGE_DOS_HEADER)GetModuleHandleW(NULL);    PIMAGE_NT_HEADERS32 pNtHeader &#x3D; (PIMAGE_NT_HEADERS32)padd(pDosHeader, pDosHeader-&gt;e_lfanew);    PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)padd(pDosHeader, pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);    &#x2F;&#x2F; find dll    LPCSTR pszLibName;    for (; pImportDescriptor-&gt;Name; pImportDescriptor++) &#123;        pszLibName &#x3D; (LPCSTR)padd(pDosHeader, pImportDescriptor-&gt;Name);        if (_stricmp(pszLibName, pszDllName) &#x3D;&#x3D; 0) &#123;            &#x2F;&#x2F; find old func            PIMAGE_THUNK_DATA32 pThunk &#x3D; (PIMAGE_THUNK_DATA32)padd(pDosHeader, pImportDescriptor-&gt;FirstThunk);            for (; pThunk-&gt;u1.Function; pThunk++) &#123;                if (pThunk-&gt;u1.Function &#x3D;&#x3D; (size_t)oldFunc) &#123;                    &#x2F;&#x2F; replace                    DWORD dwOldProt;                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, 4, PAGE_EXECUTE_READWRITE, &amp;dwOldProt);                    pThunk-&gt;u1.Function &#x3D; (size_t)newFunc;                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, 4, dwOldProt, &amp;dwOldProt);                    return true;                &#125;            &#125;        &#125;    &#125;    return false;&#125;</code></pre><h3 id="4-新api（补丁代码-MySetWindowTextW-）"><a href="#4-新api（补丁代码-MySetWindowTextW-）" class="headerlink" title="4 新api（补丁代码 MySetWindowTextW()）"></a>4 新api（补丁代码 MySetWindowTextW()）</h3><p>这部分代码参考逆向工程核心原理[1]，这个函数用于将unicode的数字转换成中文数字。temp数组的目的是构造一个0结尾的字符串，用于_wtoi。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef BOOL(WINAPI *SETWINDOWTEXTW)(HWND, LPCWSTR);BOOL WINAPI MySetWindowTextW(    HWND    hWnd,    LPCWSTR lpString)&#123;    wchar_t pNumTab[] &#x3D; L&quot;零一二三四五六七八九&quot;;    wchar_t temp[2] &#x3D; &#123; 0, &#125;; &#x2F;&#x2F; for wtoi    size_t i, nLen, nIndex;    nLen &#x3D; wcslen(lpString);    for (i &#x3D; 0; i &lt; nLen; i++) &#123;        &#x2F;&#x2F; translate        if (L&#39;0&#39; &lt;&#x3D; lpString[i] &amp;&amp; lpString[i] &lt;&#x3D; L&#39;9&#39;) &#123;            temp[0] &#x3D; lpString[i];            nIndex &#x3D; _wtoi(temp);            ((wchar_t*)lpString)[i] &#x3D; pNumTab[nIndex];        &#125;    &#125;    return ((SETWINDOWTEXTW)pOriginFunc)(hWnd, lpString);&#125;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 逆向工程核心原理：part4-API钩取：第32章-计算器显示中文数字</p><p>[2] 反射注入 <a href="https://bbs.pediy.com/thread-266929.htm">看雪文章链接</a> <a href="https://windgodm.github.io/blog/2021/04/11/reflectiveDllInjection/">博客文章链接</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/api-hook/">api_hook</category>
      
      <category domain="https://windgodm.github.io/blog/tags/reversecore/">reversecore</category>
      
      
      <comments>https://windgodm.github.io/blog/post/APIHookDllIATCalc.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>APIHook 调试技术 笔记</title>
      <link>https://windgodm.github.io/blog/post/APIHookDebugNotebook.html</link>
      <guid>https://windgodm.github.io/blog/post/APIHookDebugNotebook.html</guid>
      <pubDate>Thu, 17 Jun 2021 14:10:00 GMT</pubDate>
      
      <description>逆向工程核心原理中利用调试技术附加到目标进程实现钩取API的笔记,&lt;br&gt;钩取了记事本的WriteFile()实现大小写转换。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="APIHook-调试技术-笔记"><a href="#APIHook-调试技术-笔记" class="headerlink" title="APIHook-调试技术 笔记"></a>APIHook-调试技术 笔记</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>技术摘要：</p><p><strong>动态</strong>修改<strong>进程内存</strong>中的<strong>代码</strong>。利用<strong>调试</strong>技术附加到目标进程钩取API。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>术语：</p><p>debuger：调试器<br>debugee：被调试者</p></blockquote><p>起源是逆向工程核心原理里面以记事本WriteFile()API钩取为例讲解利用调试来实现API钩取。<br>该例子目标是在文件保存时把小写转成大写。</p><p>概括来说就是实现一个调试器，给对应api下断点。</p><p>以记事本WriteFile()API为例，大概流程是作为调试器附加到notepad上，然后给WriteFile()的起始地址下个int 3断点，这样控制流就能回到调试器，就可以读取栈获得api参数了。</p><p>大概流程如下</p><pre class="line-numbers language-none"><code class="language-none">1: 作为调试器附加2: 进入调试循环判断是否为int3断点，且断点位置为目标api起始地址OnException:  1: unhook  2: get thread context  3: your patch  4: change ctx(eip&#x2F;rip)  5: continue debugee  Sleep(0)  6: hook对于其他异常，交回给debugee的seh处理</code></pre><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>首先是要注意32和64位的问题，然后可能需要获取Debug权限。</p><h2 id="实例：记事本WriteFile-API（x32）"><a href="#实例：记事本WriteFile-API（x32）" class="headerlink" title="实例：记事本WriteFile()API（x32）"></a>实例：记事本WriteFile()API（x32）</h2><p>该例子对象是win10的x32的notepad.exe。</p><h3 id="1-作为调试器附加"><a href="#1-作为调试器附加" class="headerlink" title="1 作为调试器附加"></a>1 作为调试器附加</h3><p>代码如下只有一行：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">DebugActiveProcess(dwPID);</code></pre><p>附加失败会返回0，通过GetLastError()可以获取错误代码，x32的debuger附加x64的debugee会失败并得到0x32这个错误代码。</p><p>成功后会发送一个CREATE_PROCESS_DEBUG_EVENT事件，可以被WaitForDebugEvent()获取。</p><p>还有另外一种方法是用CreateProcess()来创建并附加一个进程。</p><h3 id="2-调试循环"><a href="#2-调试循环" class="headerlink" title="2 调试循环"></a>2 调试循环</h3><p>附加成功后就要进入调试循环：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">DEBUG_EVENT de;DWORD dwDECode;DWORD dwContinueStatus;&#x2F;&#x2F; wait for debug eventwhile (WaitForDebugEvent(&amp;de, INFINITE)) &#123;    dwContinueStatus &#x3D; DBG_EXCEPTION_NOT_HANDLED;    dwDECode &#x3D; de.dwDebugEventCode;    &#x2F;&#x2F; exception    if (dwDECode &#x3D;&#x3D; EXCEPTION_DEBUG_EVENT) &#123;        if (OnException(&amp;de))            continue;    &#125;    &#x2F;&#x2F; on create or attach debug event    else if (dwDECode &#x3D;&#x3D; CREATE_PROCESS_DEBUG_EVENT) &#123;        OnCreate(&amp;de);        dwContinueStatus &#x3D; DBG_CONTINUE;    &#125;    &#x2F;&#x2F; debuggee exit    else if (dwDECode &#x3D;&#x3D; EXIT_PROCESS_DEBUG_EVENT) &#123;        break;    &#125;    &#x2F;&#x2F; continue to run debuggee    ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus);&#125;</code></pre><p>WaitForDebugEvent()用于等待调试事件。第一个参数用于接收调试信息；第二个为等待时间(ms)，如果等待时间为INFINITE(0xFFFFFFFF)则会一直等待直到有调试时间再返回，这时debugee会被挂起。</p><h3 id="3-处理调试事件"><a href="#3-处理调试事件" class="headerlink" title="3 处理调试事件"></a>3 处理调试事件</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; minwinbase.htypedef struct _DEBUG_EVENT &#123;    DWORD dwDebugEventCode;    DWORD dwProcessId;    DWORD dwThreadId;    union &#123;        EXCEPTION_DEBUG_INFO Exception;        CREATE_THREAD_DEBUG_INFO CreateThread;        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;        EXIT_THREAD_DEBUG_INFO ExitThread;        EXIT_PROCESS_DEBUG_INFO ExitProcess;        LOAD_DLL_DEBUG_INFO LoadDll;        UNLOAD_DLL_DEBUG_INFO UnloadDll;        OUTPUT_DEBUG_STRING_INFO DebugString;        RIP_INFO RipInfo;    &#125; u;&#125; DEBUG_EVENT, *LPDEBUG_EVENT;</code></pre><p><strong>EXCEPTION_DEBUG_EVENT</strong><br>(u.Exception = EXCEPTION_DEBUG_INFO)<br>为异常调试事件，<strong>int 3</strong>中断时会触发该事件，这时我们需要执行自己的代码，具体见“6 异常调试事件”。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; minwinbase.htypedef struct _EXCEPTION_DEBUG_INFO &#123;    EXCEPTION_RECORD ExceptionRecord;    DWORD dwFirstChance;&#125; EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;&#x2F;&#x2F; winnt.htypedef struct _EXCEPTION_RECORD &#123;    DWORD    ExceptionCode;    DWORD ExceptionFlags;    struct _EXCEPTION_RECORD *ExceptionRecord;    PVOID ExceptionAddress;    DWORD NumberParameters;    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];&#125; EXCEPTION_RECORD;</code></pre><p><strong>CREATE_PROCESS_DEBUG_EVENT</strong><br>(u.CreateProcessInfo = CREATE_PROCESS_DEBUG_INFO)<br>在<strong>刚附加</strong>到debugee时会触发，这时需要完成hook，具体见“5 首次hook”。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; minwinbase.htypedef struct _CREATE_PROCESS_DEBUG_INFO &#123;    HANDLE hFile;    HANDLE hProcess;    HANDLE hThread;    LPVOID lpBaseOfImage;    DWORD dwDebugInfoFileOffset;    DWORD nDebugInfoSize;    LPVOID lpThreadLocalBase;    LPTHREAD_START_ROUTINE lpStartAddress;    LPVOID lpImageName;    WORD fUnicode;&#125; CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;</code></pre><p><strong>EXIT_PROCESS_DEBUG_EVENT</strong><br>(u.ExitProcess = EXIT_PROCESS_DEBUG_INFO)<br>在debugee退出时触发。</p><h3 id="4-继续运行debugee"><a href="#4-继续运行debugee" class="headerlink" title="4 继续运行debugee"></a>4 继续运行debugee</h3><p>处理完调试事件后，调用ContinueDebugEvent()以继续运行debugee。</p><p>ContinueDebugEvent第三个参数比较特殊，如果处理成功设置为DBG_CONTINUE即可，如果不能处理设置成DBG_EXCEPTION_NOT_HANDLED让seh来处理。</p><h3 id="5-首次hook"><a href="#5-首次hook" class="headerlink" title="5 首次hook"></a>5 首次hook</h3><p>该事件在刚附加时触发一次，这时我们需要完成对API的hook：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool OnCreate(DEBUG_EVENT* pde)&#123;    &#x2F;&#x2F; get api address    hKernel32 &#x3D; GetModuleHandleW(L&quot;kernel32.dll&quot;);    if (hKernel32 &#x3D;&#x3D; 0) &#123; cout &lt;&lt; &quot;Get kernel32.dll failed.\n&quot;; return false; &#125;    pWriteFile &#x3D; GetProcAddress(hKernel32, &quot;WriteFile&quot;);    if (pWriteFile &#x3D;&#x3D; 0) &#123; cout &lt;&lt; &quot;Get WriteFile() failed.\n&quot;; return false; &#125;    &#x2F;&#x2F; hook    memcpy(&amp;cpdi, &amp;pde-&gt;u.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_INFO));    ReadProcessMemory(cpdi.hProcess, pWriteFile, &amp;chOrigin, 1, NULL);    WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chINT3, 1, NULL);    return true;&#125;</code></pre><p>kernel32在不同进程中加载到同样位置，直接在本进程GetModuleHandleW就行。</p><p>需要注意的是把CreateProcessInfo保存下来，其中有一些信息比如debugee的进程、线程id我们在接下来的再次hook时也需要使用。</p><h3 id="6-异常调试事件（补丁代码）"><a href="#6-异常调试事件（补丁代码）" class="headerlink" title="6 异常调试事件（补丁代码）"></a>6 异常调试事件（补丁代码）</h3><p>发生异常调试事件时触发，如果为int3且断点为目标api地址就执行我们的补丁，这里我们的补丁是把文本的小写字母转换成大写：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool OnException(DEBUG_EVENT* pde)&#123;    CONTEXT ctx;    PEXCEPTION_RECORD per &#x3D; &amp;pde-&gt;u.Exception.ExceptionRecord;    DWORD dwBuffer, dwNum; &#x2F;&#x2F; WriteFile() param 2, 3    PBYTE lpBuffer &#x3D; NULL;    int i;    &#x2F;&#x2F; int 3    if (per-&gt;ExceptionCode &#x3D;&#x3D; EXCEPTION_BREAKPOINT) &#123;        &#x2F;&#x2F; breakpoint address        if (per-&gt;ExceptionAddress &#x3D;&#x3D; pWriteFile) &#123;            &#x2F;&#x2F; 1: unhook            WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chOrigin, 1, NULL);            &#x2F;&#x2F; 2: get thread context            ctx.ContextFlags &#x3D; CONTEXT_CONTROL;            GetThreadContext(cpdi.hThread, &amp;ctx);            &#x2F;&#x2F; 3.1: get WriteFile() param 2, 3            ReadProcessMemory(cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;dwBuffer, 4, NULL);            ReadProcessMemory(cpdi.hProcess, (LPVOID)(ctx.Esp + 0xC), &amp;dwNum, 4, NULL);            &#x2F;&#x2F; 3.2: malloc buffer            lpBuffer &#x3D; (PBYTE)malloc(dwNum + 1);            memset(lpBuffer, 0, dwNum + 1);            &#x2F;&#x2F; 3.3: copy to buffer            ReadProcessMemory(cpdi.hProcess, (LPVOID)dwBuffer, lpBuffer, dwNum, NULL);            cout &lt;&lt; &quot;\nOrigin:\n&quot; &lt;&lt; lpBuffer &lt;&lt; endl;            &#x2F;&#x2F; 3.4: Convert            for (i &#x3D; 0; i &lt; dwNum; i++) &#123;                if (&#39;a&#39; &lt;&#x3D; lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;&#x3D; &#39;z&#39;)                    lpBuffer[i] -&#x3D; 0x20;            &#125;            cout &lt;&lt; &quot;\nConverted:\n&quot; &lt;&lt; lpBuffer &lt;&lt; endl;            &#x2F;&#x2F; 3.5: copy back            WriteProcessMemory(cpdi.hProcess, (LPVOID)dwBuffer, lpBuffer, dwNum, NULL);            free(lpBuffer);            &#x2F;&#x2F; 4: change ctx(eip)            ctx.Eip &#x3D; (DWORD)pWriteFile;            SetThreadContext(cpdi.hThread, &amp;ctx);            &#x2F;&#x2F; 5: run            ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE);            Sleep(0);            &#x2F;&#x2F; 6: hook            WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chINT3, 1, NULL);            return true;        &#125;    &#125;    return false;&#125;</code></pre><p>流程是unhook -&gt; 获取上下文 -&gt; 补丁 -&gt; 恢复eip/rip -&gt; 继续运行debugee -&gt; 恢复hook</p><p>在继续运行debugee之后需要Sleep(0)再恢复hook，是因为hook会修改内存中的代码，此时debugee也在运行同一段内存的代码，可能会发生内存访问异常。Sleep(0)可以释放当前线程的剩余时间，让cpu先去执行其他线程，然后再回来恢复hook。</p><p>其中需要用到api的参数，这里简单分析下此时的栈。此时刚刚进入函数，还未push ebp，所以esp指向旧的栈顶，也就是函数放回地址。32位以寄存器传参，第n的参数此时在esp+4*n的位置。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>逆向工程核心原理：part4-API钩取：第30章-记事本WriteFile()API钩取</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/api-hook/">api_hook</category>
      
      <category domain="https://windgodm.github.io/blog/tags/reversecore/">reversecore</category>
      
      
      <comments>https://windgodm.github.io/blog/post/APIHookDebugNotebook.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>21KctfSpring</title>
      <link>https://windgodm.github.io/blog/post/21KctfSpring.html</link>
      <guid>https://windgodm.github.io/blog/post/21KctfSpring.html</guid>
      <pubDate>Wed, 02 Jun 2021 12:43:07 GMT</pubDate>
      
      <description>21kctf春季赛 re部分题解</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="21-kctf-春"><a href="#21-kctf-春" class="headerlink" title="21 kctf 春"></a>21 kctf 春</h1><h2 id="2-南冥神功"><a href="#2-南冥神功" class="headerlink" title="2 南冥神功"></a>2 南冥神功</h2><p>分析main函数</p><h3 id="1-char-2-int"><a href="#1-char-2-int" class="headerlink" title="1 char 2 int"></a>1 char 2 int</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">chars_table &#x3D; &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;while(v24 !&#x3D; ++v23)&#123;if(chars_table[v23] &#x3D;&#x3D; input_i)        goto LABEL_11;&#125;</code></pre><p>上面代码中input_i是输入的第i个字符，goto执行时，v23 = int(input_i)。</p><h3 id="2-找出二维数组"><a href="#2-找出二维数组" class="headerlink" title="2 找出二维数组"></a>2 找出二维数组</h3><p>有一句 <code>&amp;aS_1[10*row+col]</code>可以判断出是二维数组。<br>该句上面是一个switch，对row和col操作，然后判断越界，然后才到v13 = &amp;aS_1。紧接着又有一个if(*v13) break猜测是走二维数组地图的题。且1为墙，0为空。</p><h3 id="3-主要循环"><a href="#3-主要循环" class="headerlink" title="3 主要循环"></a>3 主要循环</h3><p>switch外面套了个for，然后还有一些向前的goto，构成了主要循环。下面是该循环的部分代码。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">x2 &#x3D; (i + int_inputs[i] &#x2F; 6) % 6;x &#x3D; 5 - (i + int_inputs[i]) % 6;for (j &#x3D; 0 ;; j &#x3D; 1) &#123; &#x2F;&#x2F; 一共循环两次        switch(x) &#123;&#125; &#x2F;&#x2F; 移动        &#x2F;&#x2F; 越界撞墙判断    if (col &gt; 9) break;    if (row &gt; 8) break;    v13 &#x3D; &amp;aS_1[10 * row + col];    if ( *v13 ) break;    *v13 &#x3D; 1; &#x2F;&#x2F; 走过的位置填充        if (j &#x3D;&#x3D; 1) &#123;        if (input[++i])        goto LABEL_4; &#x2F;&#x2F; 去把inputs[i]转换成数字        else            goto LABEL_19; &#x2F;&#x2F; 到了输入结尾，去判断有没有全部被填充    &#125;        x &#x3D; x2; &#x2F;&#x2F; x &#x3D; x2 再循环一次&#125;</code></pre><p>可以看到实际上这个for循环执行了两次，也就是每个inputs[i]对应两次移动。</p><p>其中LABEL_19对应的代码会检测aS_1是否全为1，全为1就输出”Good job!”</p><h3 id="4-switch"><a href="#4-switch" class="headerlink" title="4 switch"></a>4 switch</h3><p>接着分析switch，即移动的方式。这里直接给结论。实际上可以不分析，直接复制这个switch去写暴力解码脚本。</p><p>case 1：col += 1</p><p>case 2：!(row&amp;1) 时col += 1，然后 row += 1</p><p>case 3：row&amp;1 时col -= 1，然后 row += 1</p><p>case 4：col -= 1</p><p>case 5：row&amp;1 时col -= 1，然后 row -= 1</p><p>case 0：!(row&amp;1) 时col += 1，然后 row -= 1</p><h3 id="5-接下来就可以爆破了"><a href="#5-接下来就可以爆破了" class="headerlink" title="5 接下来就可以爆破了"></a>5 接下来就可以爆破了</h3><p>刚刚打完acm不想写爆破了。要不是每一个字符对应两次位移，可以建一个图来跑。</p><h2 id="4-英雄救美"><a href="#4-英雄救美" class="headerlink" title="4 英雄救美"></a>4 英雄救美</h2><p>分析main函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">scanf_s(&quot;%s&quot;, pszIn, 81);nLen &#x3D; strlen(pszIn);if (nLen &lt;&#x3D; 64 &amp;&amp; fun2(nLen, pszIn, v10) &#x3D;&#x3D; 1 &amp;&amp; fun1(v10, nLen - 9) &#x3D;&#x3D; 1)&#123;    &#x2F;&#x2F; pass&#125;</code></pre><p>可以看到有三个判定。fun2有三个参数，但我的ida在main中只识别出两个。通过看汇编把缺的参数补全了。</p><h3 id="1-fun2"><a href="#1-fun2" class="headerlink" title="1 fun2"></a>1 fun2</h3><p>下面给出数据和重构的代码。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">char v60[16] &#x3D; &#123;0x46, 0x53, 0x4c, 0x52, 0x41, 0x3b, 0x2e, 0x6c, 0x3d, 0x43, 0x45, 0x6b, 0x76, 0x4b, 0x2d, 0x28&#125;;char v70[16] &#x3D; &#123;0x6a, 0x69, 0x63, 0x30, 0x21, 0x68, 0x64, 0x79, 0x7b, 0x6f, 0x5a, 0x7a, 0x2d, 0x40, 0x6e, 0x2b&#125;;char v80[16] &#x3D; &#123;0x24, 0x42, 0x50, 0x56, 0x3a, 0x75, 0x62, 0x66, 0x59, 0x70, 0x7d, 0x5d, 0x44, 0x74, 0x4e, 0x3e&#125;;char v90[16] &#x3D; &#123;0x3f, 0x26, 0x25, 0x73, 0x5f, 0x2f, 0x67, 0x3c, 0x65, 0x5b, 0x57, 0x29, 0x58, 0x55, 0x78, 0x52&#125;;char vA0[16] &#x3D; &#123;0x61, 0x54, 0x5e, 0x4d, 0x47, 0x6d, 0x4a, 0x51, 0x23, 0x2a, 0x48, 0x72, 0x60, 0x4f, 0x27, 0x77&#125;&#x2F;&#x2F; psTable &#x3D; v80+vA0+v70+v90+v60+0x71char psTable[82] &#x3D; &quot;$BPV:ubfYp&#125;]DtN&gt;aT^MGmJQ#*Hr&#96;O&#39;wjic0!hdy&#123;oZz-@n+?&amp;%s_&#x2F;g&lt;e[W)XUxRFSLRA;.l&#x3D;CEkvK-(q&quot;;</code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">i &#x3D; 0;j &#x3D; 0;v5 &#x3D; 0;&#x2F;&#x2F; psTable[81]while (1) &#123;    if(pszIn[i] &gt; &#39;0&#39; &amp;&amp; pszIn[i] &lt;&#x3D; &#39;9&#39;)&#123;        if(j + pszIn[i] &#x3D;&#x3D; &#39;9&#39;)&#123;            j &#x3D; 0;            v5 +&#x3D; 9;        &#125;        else&#123;            return -1;        &#125;    &#125;    else&#123;        v7 &#x3D; v5;        if(v5 &gt;&#x3D; 81)            return 0;                &#x2F;&#x2F; v7 &#x3D; pszIn[i]对应psTable[]中相同字符的下标        while(pszIn[i] !&#x3D; *(psTable+v7)) &#123;            if(++v7 &gt;&#x3D; 81)                return 0;        &#125;                v9 &#x3D; v7 % 9 + 1;        if( v9 &#x3D;&#x3D; -1)            return 0;        *pcV10 &#x3D; v9; &#x2F;&#x2F; 重构输入        j++;        pcV10++;    &#125;        if(++i &gt;&#x3D; nLen)        return 1;&#125;</code></pre><p>搞了一大堆，其中一个退出条件是，如果输入全都是9，就能return 1，但显然答案不是这个。</p><p>相反，只要输入中没有1-9，v5就一直为0，这样就会根据输入字符在psTable中的相同字符的下标重构一个pcV10。</p><p>比如 <code>pszIn = &quot;$$V:$V&quot;</code>，<code>pcV10 = &#123;1, 1, 4, 5, 1, 4&#125;</code></p><h3 id="2-算flag"><a href="#2-算flag" class="headerlink" title="2 算flag"></a>2 算flag</h3><p>fun1实际上就是检测是否符合数独情况。</p><p>解出数独答案来，然后推出输出。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">table &#x3D; [0x24, 0x42, 0x50, 0x56, 0x3A, 0x75, 0x62, 0x66, 0x59, 0x70, 0x7D, 0x5D, 0x44, 0x74, 0x4E, 0x3E, 0x61, 0x54, 0x5E, 0x4D, 0x47, 0x6D, 0x4A, 0x51, 0x23, 0x2A, 0x48, 0x72, 0x60, 0x4F, 0x27, 0x77, 0x6A, 0x69, 0x63, 0x30, 0x21, 0x68, 0x64, 0x79, 0x7B, 0x6F, 0x5A, 0x7A, 0x2D, 0x40, 0x6E, 0x2B, 0x3F, 0x26, 0x25, 0x73, 0x5F, 0x2F, 0x67, 0x3C, 0x65, 0x5B, 0x57, 0x29, 0x58, 0x55, 0x78, 0x52, 0x46, 0x53, 0x4C, 0x52, 0x41, 0x3B, 0x2E, 0x6C, 0x3D, 0x43, 0x45, 0x6B, 0x76, 0x4B, 0x2D, 0x28, 0x71]o &#x3D; [[0, 4, 0, 7, 0, 0, 0, 0, 0], [9, 2, 0, 0, 0, 0, 6, 0, 7], [8, 3, 0, 0, 0, 5, 4, 0, 0], [0, 1, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 2, 0, 1, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 4, 0], [0, 0, 4, 9, 0, 0, 0, 7, 1], [3, 0, 5, 0, 0, 0, 0, 9, 4], [0, 0, 0, 0, 0, 8, 0, 6, 0]]r &#x3D; [[5, 4, 6, 7, 1, 9, 2, 3, 8], [9, 2, 1, 8, 3, 4, 6, 5, 7], [8, 3, 7, 6, 2, 5, 4, 1, 9], [7, 1, 8, 4, 6, 3, 9, 2, 5], [4, 5, 3, 2, 9, 1, 7, 8, 6], [6, 9, 2, 5, 8, 7, 1, 4, 3], [2, 8, 4, 9, 5, 6, 3, 7, 1], [3, 6, 5, 1, 7, 2, 8, 9, 4], [1, 7, 9, 3, 4, 8, 5, 6, 2]]# 1print(&#39;#1&#39;)flag &#x3D; &#39;&#39;for y in range(9):    j &#x3D; 0    for x in range(9):        if o[y][x] &#x3D;&#x3D; 0:            j +&#x3D; 1            flag +&#x3D; chr(table[r[y][x] - 1 + y * 9])    flag +&#x3D; chr(ord(&#39;9&#39;) - j)print(flag)# 2print(&#39;#2&#39;)flag &#x3D; &#39;&#39;j &#x3D; 0n9 &#x3D; 0for y in range(9):    for x in range(9):        if o[y][x] &#x3D;&#x3D; 0:            j +&#x3D; 1            flag +&#x3D; chr(table[r[y][x] - 1 + n9 * 9])        if j &gt;&#x3D; 8:            flag +&#x3D; &#39;1&#39;            j &#x3D; 0            n9 +&#x3D; 1while n9 &lt; 9:    flag +&#x3D; chr(ord(&#39;9&#39;) - j)    j &#x3D; 0    n9 +&#x3D; 1print(flag)</code></pre><p>第一个flag是正确的，第二个只能过输入转换fun2和数独检测fun1，而不能弹出窗口。</p><pre class="line-numbers language-none"><code class="language-none">:u$YBPf2pa]Dt4#QM^H4ic&#39;j0&#96;w2y&#123;d-Zzo2%&#x2F;n_s@+2&lt;UW)e4AR;F.4&#x3D;-qEkvC2:u$YBPf$1a]Dt&gt;N&#125;p1H#*mQHMJ1&#39;wO0icjj1-hzZ!dhz1&amp;%+%@sn_1gXxe[W&lt;299</code></pre><p>在VA之前有几个函数，这个函数会检测转换前的原始输入。如果原始输入不符合要求，将不能正确弹窗，（弹窗的代码依赖于正确的输入来生成，但前面的if检查并不严格，错误的原始输入产生了错误的代码）会报错0xc0000096然后崩溃。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      
      <comments>https://windgodm.github.io/blog/post/21KctfSpring.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>games101笔记</title>
      <link>https://windgodm.github.io/blog/post/games101Note.html</link>
      <guid>https://windgodm.github.io/blog/post/games101Note.html</guid>
      <pubDate>Mon, 24 May 2021 14:12:26 GMT</pubDate>
      
      <description>cg入门课程games101的笔记，内容比较随缘，有重点内容会单独写,&lt;br&gt;只是个人爱好，大概率会咕咕咕,&lt;br&gt;更新到第五课(21-08-10)</description>
      
      
      
      <content:encoded><![CDATA[<p>games101-5</p><p><a href="/blog/note/games101Note.html">games 101 note</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/ComputerGraphics/">ComputerGraphics</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/ComputerGraphics/">ComputerGraphics</category>
      
      <category domain="https://windgodm.github.io/blog/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/">持续更新</category>
      
      
      <comments>https://windgodm.github.io/blog/post/games101Note.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CPP编写类库给其他语言使用的总结</title>
      <link>https://windgodm.github.io/blog/post/CppDllForOthers.html</link>
      <guid>https://windgodm.github.io/blog/post/CppDllForOthers.html</guid>
      <pubDate>Thu, 22 Apr 2021 17:05:59 GMT</pubDate>
      
      <description>主要是使用vs2019作为ide，cpp为语言编写类库，然后编译成dll，供其他cpp、c#、python等语言的工程调用类库,&lt;br&gt;目的是一次编写与编译某个类库，然后给多语言使用。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="CPP编写类库给其他语言使用"><a href="#CPP编写类库给其他语言使用" class="headerlink" title="CPP编写类库给其他语言使用"></a>CPP编写类库给其他语言使用</h1><p>主要是使用vs2019作为ide，cpp为语言编写类库，然后编译成dll，供其他cpp、c#、python等语言的工程调用类库。目的是一次编写与编译某个类库，然后给多语言使用。</p><p>这里是个傻瓜式操作总结贴（我总是忘记细节emm），总结网上及书里提供的一些方法，尽量用简单的方式实现目的。</p><h2 id="用cpp写类库（VS2019）"><a href="#用cpp写类库（VS2019）" class="headerlink" title="用cpp写类库（VS2019）"></a>用cpp写类库（VS2019）</h2><h3 id="类库项目"><a href="#类库项目" class="headerlink" title="类库项目"></a>类库项目</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>直接新建空白项目，然后在项目属性页中进行如下配置：</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>常规-常规属性-配置类型：动态库(.dll)</p></blockquote><h4 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h4><p>下面给出项目的框架。直接编译就可以得到MyDll.dll</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;** 项目（MyDll）：头文件：MyDll.h*&#x2F;#pragma once#ifndef MYDLL_H#define MYDLL_H&#x2F;&#x2F; 这里是输出的函数_declspec(dllexport) int Add(int a, int b);&#x2F;&#x2F; 这里是输出的类class _declspec(dllexport) MyClass&#123;private:    int a[2];public:    MyClass();    ~MyClass();    int Set(int index, int x);&#125;#endif &#x2F;&#x2F; !MYDLL_H</code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;** 项目（MyDll）：源文件：MyDll.cpp*&#x2F;#include &quot;MyDll.h&quot;&#x2F;&#x2F; 实现头文件中的函数int Add(int a, int b)&#123;    return a + b;&#125;&#x2F;&#x2F; 实现头文件中类的函数MyClass::MyClass()&#123;    a[0] &#x3D; 1;    a[1] &#x3D; 0;&#125;MyClass::~MyClass()&#123;&#125;int MyClass::Set(int index, int x)&#123;    a[index] &#x3D; x;    return a[0] + a[1];&#125;</code></pre><h3 id="添加类库对应的共享项目"><a href="#添加类库对应的共享项目" class="headerlink" title="添加类库对应的共享项目"></a>添加类库对应的共享项目</h3><p>这一步的目的主要是为了解决<strong>调用类库项目</strong>和<strong>类库项目</strong> <strong>不在同一个解决方案</strong>的情况。</p><p>在同一个解决方案中，新建一个<strong>共享项目</strong>项目，然后在<strong>解决方案资源管理器</strong>-<strong>共享项目</strong>上右键<strong>添加</strong>-<strong>添加现有项</strong>，找到MyDll.h、MyDll.cpp添加进去。</p><h2 id="cpp项目-调用-cpp写的类库（VS2019）"><a href="#cpp项目-调用-cpp写的类库（VS2019）" class="headerlink" title="cpp项目 调用 cpp写的类库（VS2019）"></a>cpp项目 调用 cpp写的类库（VS2019）</h2><h3 id="方案一：隐式链接"><a href="#方案一：隐式链接" class="headerlink" title="方案一：隐式链接"></a>方案一：隐式链接</h3><ul><li><p><strong>添加引用：</strong><br>在<strong>解决方案资源管理器</strong>中<strong>你的cpp项目</strong>的<strong>引用</strong>处右键选择<strong>添加引用</strong></p><ul><li>cpp项目和dll项目在<strong>同一个解决方案</strong>：<br>然后在弹出窗口的左侧菜单选择<strong>项目</strong>-<strong>解决方案</strong>，然后找到刚刚写好的<strong>dll项目</strong>，点击勾选框。</li><li>两者不在同一个解决方案：<br>先参考<strong>cpp写类库</strong>-<strong>配置共享项目</strong>配置好，然后在弹出窗口的左侧菜单选择<strong>共享的项目</strong>-<strong>解决方方案</strong>，找到<strong>dll项目对应的共享项目</strong>，点击勾选框。</li></ul></li><li><p><strong>包含头文件</strong>：通过相对或绝对<strong>路径引用</strong>dll项目的头文件。</p></li></ul><h3 id="方案二：显示链接"><a href="#方案二：显示链接" class="headerlink" title="方案二：显示链接"></a>方案二：显示链接</h3><p>没有需求，所以还没有测试这种方案这么处理比较方便。// todo</p><h2 id="C-（WPF）项目-调用-cpp写的类库（vs2019）"><a href="#C-（WPF）项目-调用-cpp写的类库（vs2019）" class="headerlink" title="C#（WPF）项目 调用 cpp写的类库（vs2019）"></a>C#（WPF）项目 调用 cpp写的类库（vs2019）</h2><p>我的情况是涉及一个大量使用指针的类。通过一个托管类把类的函数都暴露出来，实际上就是在托管类中做一个跳转，有时候还需要在这个跳转的函数中做c#和c++间的类型转换。</p><p>流程大概是先写个托管类，然后再在wpf项目中导入。</p><p>需要<strong>注意</strong>的是，Debug调试时，应该把 MyDll.dll 放到WPF的 /bin/Debug 目录中，原因是 MyDllCSWrapper.dll 需要导入 MyDll.dll。所以需要把 <strong>MyDll.dll</strong> 放到项目的<strong>可执行文件的根目录</strong>（当然系统目录啥的好像也行）。<br>至于MyDllCSWrapper.dll放哪里都行，c#中ImportDll的路径填对就行。</p><h3 id="托管类"><a href="#托管类" class="headerlink" title="托管类"></a>托管类</h3><p>首先参考“用cpp写类库”新建一个项目写托管。</p><p>这里直接给出托管类代码框架，原型类参考前面“用cpp写类库”。</p><p>这里MyDll.h中的Add不是类中的函数，我没有这个需求没有去研究，不确定该如何暴露，欢迎补充。// todo</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;** 项目（MyDllCSWrapper）：头文件：MyDllCSWrapper.h*&#x2F;#pragma once&#x2F;&#x2F; 这里通过相对或绝对路径引用MyDll的头文件#include &quot;..&#x2F;MyDll&#x2F;MyDll.h&quot;namespace MyDllCSWrapper&#123;extern &quot;C&quot; __declspec(dllexport) int Set(int index, int x);&#125;</code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;** 项目（MyDllCSWrapper）：源文件：MyDllCSWrapper.cpp*&#x2F;#include &quot;MyDllCSWrapper.h&quot;namespace MyDllCSWrapper&#123;MyClass* pmc &#x3D; new MyClass();int Set(int index, int x)&#123;return ppe-&gt;Set(index, x);&#125;&#125;</code></pre><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>c++中的类型与c#不是完全对应的。int、double、float啥的好像是一一对应的，但指针就不一定了，要小心处理。</p><p>我遇到的一个特殊情况就是我需要传递一个数组过去，c#中使用类型 char[]、ref char[] 只能传递第一个元素过去。需要使用 byte[] 才行。</p><p>下面是我遇到一些的情况。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>c++类型 —- c# 类型</p><p>unsigned int、unsigned long、DWORD —- uint</p><p>char*（数组）—- byte[]</p></blockquote><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>暂时没有需求，没有了解，可能下个星期就会需要。// todo</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Programing/">Programing</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/dll/">dll</category>
      
      <category domain="https://windgodm.github.io/blog/tags/Programing/">Programing</category>
      
      <category domain="https://windgodm.github.io/blog/tags/cpp/">cpp</category>
      
      
      <comments>https://windgodm.github.io/blog/post/CppDllForOthers.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>21虎符CTF-RE-wp</title>
      <link>https://windgodm.github.io/blog/post/HufuCtfReWp.html</link>
      <guid>https://windgodm.github.io/blog/post/HufuCtfReWp.html</guid>
      <pubDate>Thu, 15 Apr 2021 14:04:21 GMT</pubDate>
      
      <description>21虎符ctf re部分题解</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="虎符-2021-RE"><a href="#虎符-2021-RE" class="headerlink" title="虎符 2021 RE"></a>虎符 2021 RE</h1><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>mips架构什么的，完全不了解，溜了</p><h2 id="gocrypt"><a href="#gocrypt" class="headerlink" title="gocrypt"></a>gocrypt</h2><p>是个go语言程序</p><p>里面有个encodeing_hex_Decode，作用是string转hex（”b0a0” =&gt; [0xa0, 0xb0]）<br>第7个参数是dest<br>第10个参数是source<br>第11个参数是source的长度</p><p>有个runtime_check会检查格式，推出格式是flag{hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh}</p><p>main_myCipher_Encrypt中有(a+(a&gt;&gt;5)&amp;(16*a))猜出加密方式是xtea</p><p>解密脚本就不贴了，实际上异或的另一边是密钥，利用异或的可逆很快就能推出解密脚本</p><p>在打极客时就有个想法，这种简单的re题核心都是推导加密函数的逆函数，不知道能不能写个逻辑分析程序一把梭。</p><h2 id="CrackMe"><a href="#CrackMe" class="headerlink" title="CrackMe"></a>CrackMe</h2><p>运行什么提示都没，但还是搜字符串试试，rva=2A90，2AB0的两个函数似乎有点重要。</p><p>main里面有两次输入，判定两次。sub_1360这个函数ida似乎识别出了问题，不知道是不是bug。</p><p>第一次输入后有两个循环，会把17个输入分成前7个和后10个</p><p>第二次输入后有几个循环</p><p>第一个循环是在求dx = 0.001，[0,100]，sub_1360(x, (v94/12379) + 1)*dx的积分 a</p><p>然后int(2a+3) == 0x13AFA + 9 == 0x13B03 (sub_13A0中v7044+=9)</p><p>第二个循环同样求和第一个差不多的积分 b，不过第二个参数变成了(v94%12379 + 1)</p><p>然后int(2b+3) == 0x59D + 5 == 0x5A2 (sub_13A0中v7048+=5)</p><p>爆破脚本</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;math.h&gt;#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;inline double f(double a, double b)&#123;double tmp &#x3D; pow(a, b - 1.0);double ret &#x3D; tmp &#x2F; exp(a);return ret;&#125;int main() &#123;double s &#x3D; 0.0;double x &#x3D; 0.0;int i;for (i &#x3D; 0; i &lt; 12379; ++i) &#123;x &#x3D; 0.0;s &#x3D; 0.0;do &#123;s +&#x3D; f(x, (double)i) * 0.001;x +&#x3D; + 0.001;&#125; while (x &lt;&#x3D; 100.0);int ans &#x3D; (int)(s + s + 3.0);if (ans &#x3D;&#x3D; 0x5a2) &#123; &#x2F;&#x2F; 0x59D + 5printf(&quot;i &#x3D; %d, v95 &#x3D; %d\n&quot;, i, i-1); &#x2F;&#x2F; i &#x3D; 7, v95 &#x3D; 6break;&#125;&#125;for (i &#x3D; i - 1; ; i +&#x3D; 12379) &#123;x &#x3D; 0.0;s &#x3D; 0.0;double b &#x3D; (double)((int)i &#x2F; 12379) + 1.0;do &#123;s +&#x3D; f(x, (double)b) * 0.001;x +&#x3D; +0.001;&#125; while (x &lt;&#x3D; 100.0);int ans &#x3D; (int)(s + s + 3);if (ans &#x3D;&#x3D; 0x13B03) &#123; &#x2F;&#x2F; 0x13AFA + 9printf(&quot;v95 &#x3D; %d\n&quot;, i); &#x2F;&#x2F; v95 &#x3D; 99038break;&#125;&#125;return 0;&#125;</code></pre><p>最后与第一次输入的内容处理后，得到flag</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;using namespace std;int main() &#123;int i;char a[8] &#x3D; &quot;9903819&quot;;short s1[7] &#x3D; &#123;0x8, 0x4d, 0x59, 0x06, 0x73, 0x02, 0x40&#125;;char c[20] &#x3D; &#123; 0 &#125;;for (i &#x3D; 0; i &lt; 7; i++)c[i] &#x3D; a[i] ^ s1[i];char s2[10] &#x3D; &#123; 0xb2, 0xd6, 0x8e, 0x3f, 0xaa, 0x14, 0x53, 0x54, 0xc6, 0x06 &#125;;char key[10] &#x3D; &#123; 0xe0, 0x95, 0xba, 0x60, 0xc9, 0x66, 0x2a, 0x24, 0xb2, 0x36 &#125;;for (i &#x3D; 0; i &lt; 10; i++)c[i + 7] &#x3D; s2[i] ^ key[i];cout &lt;&lt; c &lt;&lt; endl;return 0;&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      
      <comments>https://windgodm.github.io/blog/post/HufuCtfReWp.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>反射式dll注入源码笔记</title>
      <link>https://windgodm.github.io/blog/post/reflectiveDllInjection.html</link>
      <guid>https://windgodm.github.io/blog/post/reflectiveDllInjection.html</guid>
      <pubDate>Sun, 11 Apr 2021 10:31:55 GMT</pubDate>
      
      <description>读msf的反射注入源码学习了下反射注入,&lt;br&gt;学习了下pe结构和windows加载模块的过程，如填写iat、重定位</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="从反射注入学习pe文件加载"><a href="#从反射注入学习pe文件加载" class="headerlink" title="从反射注入学习pe文件加载"></a>从反射注入学习pe文件加载</h1><h2 id="前言？后记与总结"><a href="#前言？后记与总结" class="headerlink" title="前言？后记与总结"></a>前言？后记与总结</h2><p>这是我写完代码后写的总结。重新梳理一下反射注入到底想干什么、以及怎么干。以及从中学到了什么。</p><h3 id="收获？目标？反射注入是什么"><a href="#收获？目标？反射注入是什么" class="headerlink" title="收获？目标？反射注入是什么"></a>收获？目标？反射注入是什么</h3><p>首先是学习反射注入的收获，当然也可以作为学习的目标，同时也是反射注入实际做的东西。</p><p>我的理解是反射注入实际上就是手工加载模块。通过LoadLibrary加载dll会在peb中留下记录，通过手工实现加载过程，我们的dll能像正常dll那样工作，且不再peb中留下痕迹。</p><p>也就是说，通过学习反射注入，可以了解到windows系统加载一个pe文件的流程。其中涉及到了部分的peb以及大量的pe结构。</p><p>我们主要需要peb中的ldr结构，这个结构中保存了该进程已经加载了的dll。</p><p>既然我们的主要工作是手工加载pe文件，自然要对pe文件格式有一定了解。但笔记中不会多提pe文件结构，实际上只要大概了解pe文件格是是个什么，然后在写代码时多去看pe结构的定义，就可以对pe文件结构有一个更深的理解。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>在学习过程中参考了许多资料，最主要的就是msf的反射注入payload的源码。其他如有不懂通过百度也可以找到详细的解释。相关文章比较多，dddd，就不一一列举了。</p><h3 id="关于这篇东西"><a href="#关于这篇东西" class="headerlink" title="关于这篇东西"></a>关于这篇东西</h3><p>这篇东西由我阅读源码，查资料时做的笔记发展而来。国内虽然少但也有一些优秀的反射注入的文章，看雪中也有类似文章，但阅读门槛稍微有点高。因为是由笔记发展而来，这更像是一个零基础初学者的学习笔记（实际上在开始学反射注入之前，只知道pe文件格是是什么东西，几乎完全不了解。对windows的机制也完全不了解），希望能帮助到初学者，这项技术对我学习windows有很大帮助，虽然我只是一个初学者，但这项实践使我之后对书本、资料上的内容有了更深的了解。可能会有错误，希望发现错误的dalao可以帮帮我这个初学者纠正。</p><h3 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h3><p>va、fa、rva这几个概念搞清楚好像就行。实际上就是对pe文件如何从文件映射到内存有一个大体的认识。我们的工作就是具体完成这个过程。可以参考下图。</p><p><img src="https://z3.ax1x.com/2021/04/11/c0exl4.png" alt="pe文件到内存的映射"></p><p>pe文件的格式网上有比较多的图片，这里就不贴了。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">(前置条件序号) 序号 流程内容&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;注入器：&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;(0)   1 打开dll文件(CreateFile)，获取dll长度(GetFileSize)(1)   2 分配内存(HealAlloc)，读取文件(ReadFile)(0)   3 打开目标进程(OpenProcess)(2,3) 4 调用反射注入函数(LoadLibraryR.c&gt;LoadRemoteLibraryR)(2)   5 获取反射加载函数的文件偏移(LoadLibraryR.c&gt;GetReflectiveLoaderOffset)(2,3) 6 在目标进程中分配空间(VirtualAllocEx)，写入dll(WriteProcessMemory)(6)   7 修改目标进程中的空间为可执行(VirtualProtectEx)(5,7) 8 创建远程线程，执行反射加载函数(CreateRemoteThread)&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;反射加载函数（运行在被注入进程的新建线程中）：&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1 获取基地址2 获取需要的kernel32.dll及ntdll.dll的函数的va3 分配空间作为映像空间，并复制pe头到新的位置4 复制所有段到映像的对应位置5 处理导入表，填写iat6 重定位7 跳转到ep（_DllMainCRTStartup）8 返回entry point地址</code></pre><h2 id="注入器"><a href="#注入器" class="headerlink" title="注入器"></a>注入器</h2><h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><p>首先打开dll文件，获取长度，并在堆中分配空间读取文件。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">hFile &#x3D; CreateFileW(dllPathname, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);dwDllLen &#x3D; GetFileSize(hFile, 0);lpDll &#x3D; HeapAlloc(GetProcessHeap(), 0, dwDllLen);</code></pre><p>然后找到dll中ReflectiveLoader的入口点。</p><p>最后以RW申请空间，写入dll后改成RX，然后以ReflectiveLoader作为线程函数创建远程线程。</p><h3 id="计算fa"><a href="#计算fa" class="headerlink" title="计算fa"></a>计算fa</h3><p>LoadLibraryR中有个函数Rva2Offset用于获取rva对应的fa。</p><p>原理是遍历区块获取区块的section_rva和section_fa，然后比较rva和section_rva找到rva所在的section，最后计算出fa。再用fa+baseAddr得到内存中的位置。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">DWORD Rva2Fa(DWORD rva, PIMAGE_SECTION_HEADER sections, int sectionNum)&#123;    for (int i &#x3D; 0; i &lt; sectionNum; i++) &#123;        int sectionVa &#x3D; sections[i].VirtualAddress;        if ((rva &gt;&#x3D; sectionVa) &amp;&amp; ((sectionVa + sections[i].SizeOfRawData) &gt; rva))            return rva - (sectionVa - sections[i].PointerToRawData);    &#125;    return 0;&#125;</code></pre><h3 id="获取ReflectivelLoader位置（输出表）"><a href="#获取ReflectivelLoader位置（输出表）" class="headerlink" title="获取ReflectivelLoader位置（输出表）"></a>获取ReflectivelLoader位置（输出表）</h3><p>通过nt头，计算出sections的fa，以及通过nt头的optionalheader获取输出表的rva。</p><p>然后遍历section找到输出表的fa，接着遍历输出表的函数名字rva表，计算出rva对应fa得到导出函数名字，与需要的导出函数做对比，确定要找的函数在函数名表中的下标。用此下标在序号表中找到序号，最后再用序号去地址表找到地址。</p><h2 id="反射加载函数"><a href="#反射加载函数" class="headerlink" title="反射加载函数"></a>反射加载函数</h2><h3 id="1-获取基址"><a href="#1-获取基址" class="headerlink" title="1. 获取基址"></a>1. 获取基址</h3><p>首先获取代码的位置，然后再往前找dos头。</p><p>_ReturnAddress()返回当前调用函数的返回地址。所以在loader中调用一个函数，该函数再调用_ReturnAddress()，返回调用函数的返回地址，即loader中调用函数的下一条语句的地址。<br>其中 __declspec(noinline) 用于防止编译器优化该函数成内联函数，否则返回的就是loader的返回地址。</p><p>使用_ReturnAddress需要intrin.h，并使用#pragma intrinsic防止内联优化。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;intrin.h&gt;#pragma intrinsic(_ReturnAddress)__declspec(noinline) PVOID NextAddr()&#123;return (PVOID)_ReturnAddress();&#125;</code></pre><p>根据pe格式可知，dos头(IMAGE_DOS_HEADER)中有有一个e_magic标志，值是0x5A4D(MZ)。<br>所以向前遍历内存，直到找到MZ标志，再检查pe头的PE标志，这样就找到dos头了。<br>需要注意的是，检查PE标志时要检查pe头偏移是否正确，防止错误的内存访问。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">while (TRUE) &#123;    if (dosHeadAddr-&gt;e_magic &#x3D;&#x3D; 0x5A4D) &#123;        LONG e_lfanew &#x3D; dosHeadAddr-&gt;e_lfanew;        if (e_lfanew &gt;&#x3D; sizeof(IMAGE_DOS_HEADER) &amp;&amp; e_lfanew &lt; 1024) &#123;            ntHeadAddr &#x3D; (PIMAGE_NT_HEADERS)((PVOID)dosHeadAddr + (PVOID)e_lfanew);            if (ntHeadAddr-&gt;Signature &#x3D;&#x3D; 0x4550)                break;        &#125;    &#125;    dosHeadAddr--;&#125;</code></pre><p>这里也可以取巧，远程线程是可以传递一个参数的，对于我们这个简单的dll，imagebase实际上就是分配空间的首地址，可以作为参数传入。</p><h3 id="2-获取需要的内核导出函数的va"><a href="#2-获取需要的内核导出函数的va" class="headerlink" title="2. 获取需要的内核导出函数的va"></a>2. 获取需要的内核导出函数的va</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>接下来的步骤中需要用到一些ntdll.dll，kernel32.dll中的导出函数，所以需要先找到这些函数的va。这些系统模块都是已经加载了的，可以在peb中找到其加载的位置。</p><p>这里利用hash避免直接比较字符串。</p><p>我们需要LoadLibraryA、GetProcAddress加载导入表中的dll的对应的函数。</p><p>需要VirtualAlloc分配内存给我们把pe文件加载到其中。</p><p>需要NtFlushInstructionCache刷新指令缓存。</p><h4 id="LDR-DATA-TABLE-ENTRY"><a href="#LDR-DATA-TABLE-ENTRY" class="headerlink" title="LDR_DATA_TABLE_ENTRY"></a>LDR_DATA_TABLE_ENTRY</h4><p>InMemoryOrderModuleList对应的链表是一个环形双向链表，且有一个头节点（或者说哨兵节点）。InMemoryOrderModuleList的Flink指向链表的第一个节点，Blink指向链表最后一个节点。头节点的Flink是第一个节点，可以以此为跳出条件遍历该链表。</p><p><img src="https://z3.ax1x.com/2021/04/11/c0mZ1e.jpg" alt="ldr链"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先从peb中找到ldr，然后遍历InMemoryOrderModuleList，通过hash(BaseName)找到kernel32.dll和ntdll.dll对应的LDR_DATA_TABLE_ENTRY结构。</p><p>找到dll对应的LDR_DATA_TABLE_ENTRY后，获取其imagebase，然后解析pe头，计算出导出表位置。同样利用hash比较字符串找到所需的导出函数，并计算出va。</p><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 找pLdrDataTableEnrtyDWORD pPeb &#x3D; __readfsdword(0x30);DWORD pLdr &#x3D; *(DWORD*)(pPeb + 0xc);DWORD pInMemoryOrderModuleList &#x3D; pLdr + 0x14; &#x2F;&#x2F; 第一个节点的二级指针DWORD pLdrDataTableEnrty &#x3D; *(DWORD*)(pInMemoryOrderModuleList + 0);&#x2F;&#x2F; 遍历LdrDataTableEnrtydo&#123;WCHAR* name &#x3D; (WCHAR*)*(DWORD*)(pLdrDataTableEnrty + 0x24 + 0x4);hash &#x3D; YourHashFun(name); &#x2F;&#x2F; 使用你自己的函数计算hash值if(hash &#x3D;&#x3D; DLLHASH) &#123; &#x2F;&#x2F; DLLHASH由你自己的函数计算得出DWORD baseAddr &#x3D; *(DWORD*)(pLdrDataTableEnrty + 0x10);&#x2F;&#x2F; 解析pe头过程省略for(int i &#x3D; 0; i &lt; funcNum; i++) &#123; &#x2F;&#x2F; funcNum是导出函数的个数char* name &#x3D; (char*)(baseAddr + ((DWORD*)nameRvas)[i]);DWORD hash &#x3D; YourHashFun(name);if (hash &#x3D;&#x3D; FUNCHASH) &#123;pFunc &#x3D; (FUNC)(baseAddr + ((DWORD*)funcRvas)[((WORD*)ordRvas)[i]]);&#125;&#125;&#125;&#125;while(*(DWORD*)(pLdrDataTableEnrty) !&#x3D; *(DWORD*)(pInMemoryOrderModuleList))</code></pre><h3 id="3-给映像分配空间，并加载pe头"><a href="#3-给映像分配空间，并加载pe头" class="headerlink" title="3. 给映像分配空间，并加载pe头"></a>3. 给映像分配空间，并加载pe头</h3><p>新分配大小等于sizeOfImga的内存作为映像加载的空间，然后把pe头复制到新内存里，这里我只更新了新nt头的imagebase地址。太简单就不贴代码了。</p><h3 id="4-加载段"><a href="#4-加载段" class="headerlink" title="4. 加载段"></a>4. 加载段</h3><p>遍历section_header获取fa和rva，计算出section在旧内存中的va和新内存中的va。然后复制section到新内存中的对应位置。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">oldVA &#x3D; oldImageBase + sections[i].PointerToRawData;newVA &#x3D; newImageBase + sections[i].VirtualAddress; </code></pre><h3 id="5-处理导入表"><a href="#5-处理导入表" class="headerlink" title="5. 处理导入表"></a>5. 处理导入表</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><p>找到导入表，然后遍历导入表，依次加载对应的dll，及需要的dll的导出函数，并填写对应iat。</p><h4 id="导入表结构"><a href="#导入表结构" class="headerlink" title="导入表结构"></a>导入表结构</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; winnt.htypedef struct _IMAGE_THUNK_DATA32 &#123;    union &#123;        DWORD ForwarderString;      &#x2F;&#x2F; PBYTE         DWORD Function;             &#x2F;&#x2F; PDWORD        DWORD Ordinal;        DWORD AddressOfData;        &#x2F;&#x2F; PIMAGE_IMPORT_BY_NAME (补充一下，这是个rva)    &#125; u1;&#125; IMAGE_THUNK_DATA32;typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;typedef struct _IMAGE_IMPORT_BY_NAME &#123;    WORD    Hint;    CHAR   Name[1];&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</code></pre><p>和导出表不同，导入表是一个结构体数组。它不提供结构体数量，最后一个结构体仅作为结束标志，不包含导入信息，其成员Characteristics为0，这可以作为遍历的退出条件。</p><p>对于每个导入表，在文件中时OriginalFirstThunk和FirstThunk都是RVA，指向同一个IMAGE_THUNK_DATA结构体数组。<br>当加载到内存时，FirstThunk改为函数的VA，即iat。</p><p>文件中时，OriginalFirstThunk和FirstThunk指向的结构体数组中，每一个IMAGE_THUNK_DATA的成员u1都被解释为Ordinal，若该函数应该通过序号导入，则Ordinal的最高位会被置为1。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>见实现代码注释。</p><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pNewDosHeader + pNewNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);for (; pImportDescriptor-&gt;Characteristics; pImportDes++) &#123;    &#x2F;&#x2F; 加载dll    HMODULE libraryAddress &#x3D; pLoadLibraryA((LPCSTR)((DWORD)pNewDosHeader + pImportDes-&gt;Name));    if (!libraryAddress)            continue;        &#x2F;&#x2F; parsing pe structure    PIMAGE_THUNK_DATA32 pOriginalThunk &#x3D; (PIMAGE_THUNK_DATA32)((DWORD)pNewDosHeader + pImportDes-&gt;OriginalFirstThunk);    PIMAGE_THUNK_DATA32 pThunk &#x3D; (PIMAGE_THUNK_DATA32)((DWORD)pNewDosHeader + pImportDes-&gt;FirstThunk);    PIMAGE_NT_HEADERS32 pLibNtHeader &#x3D; (PIMAGE_NT_HEADERS32)((DWORD)libraryAddress + ((PIMAGE_DOS_HEADER)libraryAddress)-&gt;e_lfanew);    PIMAGE_EXPORT_DIRECTORY pExportDir &#x3D; (PIMAGE_EXPORT_DIRECTORY)((DWORD)libraryAddress + pLibNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);    PDWORD funcRvas &#x3D; (PDWORD)((DWORD)libraryAddress + pExportDir-&gt;AddressOfFunctions);    while (*(DWORD*)pThunk) &#123;        if (pOriginalThunk &amp;&amp; pOriginalThunk-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG) &#123;            &#x2F;&#x2F; import by ord            WORD ord &#x3D; pOriginalThunk-&gt;u1.Ordinal - pExportDir-&gt;Base;            *(DWORD*)pThunk &#x3D; ((DWORD)libraryAddress + funcRvas[ord]);        &#125;        else &#123;            &#x2F;&#x2F; import by name (this is a rva)            *(DWORD*)pThunk &#x3D; (DWORD)pGetProcAddress(libraryAddress, ((PIMAGE_IMPORT_BY_NAME)((DWORD)pNewDosHeader + pThunk-&gt;u1.AddressOfData))-&gt;Name);        &#125;        pThunk++;        if (pOriginalThunk)            pOriginalThunk++;    &#125;&#125;</code></pre><h3 id="6-重定位"><a href="#6-重定位" class="headerlink" title="6. 重定位"></a>6. 重定位</h3><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><p>完成重定位过程。</p><h4 id="重定位表结构"><a href="#重定位表结构" class="headerlink" title="重定位表结构"></a>重定位表结构</h4><p>重定位表是一个结构体数组，DataDirectory中的重定位表项保存着第一个重定位表的rva，遍历每一个重定位表，并遍历重定位表中的表项，根据其重定位类型，执行重定位操作。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef struct &#123;    WORD offset : 12;    WORD type : 4;&#125; RELOC;typedef struct &#123;DWORD VA;DWORD size;&#x2F;&#x2F; RELOC reloc[];&#125; IMAGE_BASE_RELOCATION;</code></pre><p>其中每一个重定位表保存着一个rva，重定位实际上就是遍历IMAGE_BASE_RELOCATION的成员reloc，然后执行<code>*(rva+baseAddr+reloc[i].offset) += baseAddr - ImageBase</code>。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>两层循环，遍历重定位表，再遍历每个表的 RELOC reloc[]。然后根据重定位类型进行重定位。</p><h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 解析pe，并计算offsetPIMAGE_DATA_DIRECTORY pDDBaseReloc &#x3D; &amp;pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];PIMAGE_BASE_RELOCATION pBaseRelocation;ULONG_PTR offset &#x3D; (ULONG_PTR)pNewDosHeader - (ULONG_PTR)pNtHeaders-&gt;OptionalHeader.ImageBase;if (pDDBaseReloc-&gt;Size) &#123;    DWORD size &#x3D; pDDBaseReloc-&gt;Size;    pBaseRelocation &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pNewDosHeader + pDDBaseReloc-&gt;VirtualAddress);    &#x2F;&#x2F; 遍历重定位表结构体    while (size &amp;&amp; pBaseRelocation-&gt;SizeOfBlock) &#123;        DWORD va &#x3D; (DWORD)pNewDosHeader + pBaseRelocation-&gt;VirtualAddress;        DWORD num &#x3D; (pBaseRelocation-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) &#x2F; sizeof(IMAGE_RELOC); &#x2F;&#x2F; 计算reloc[]大小        PIMAGE_RELOC reloc &#x3D; (PIMAGE_RELOC)((DWORD)pBaseRelocation + sizeof(IMAGE_BASE_RELOCATION));        &#x2F;&#x2F; 遍历reloc[]，根据重定位类型重定位        while (num--) &#123;            DWORD type &#x3D; reloc-&gt;type;            if (type &#x3D;&#x3D; IMAGE_REL_BASED_HIGH) &#123;                *(WORD*)(va + reloc-&gt;offset) +&#x3D; HIWORD(offset);            &#125;            else if (type &#x3D;&#x3D; IMAGE_REL_BASED_LOW) &#123;                *(WORD*)(va + reloc-&gt;offset) +&#x3D; LOWORD(offset);            &#125;            else if (type &#x3D;&#x3D; IMAGE_REL_BASED_HIGHLOW) &#123;                *(DWORD*)(va + reloc-&gt;offset) +&#x3D; (DWORD)offset;            &#125;            reloc++;        &#125;        size -&#x3D; pBaseRelocation-&gt;SizeOfBlock;        pBaseRelocation &#x3D; (PIMAGE_BASE_RELOCATION)((DWORD)pBaseRelocation + pBaseRelocation-&gt;SizeOfBlock);    &#125;&#125;</code></pre><h3 id="7-跳转到ep"><a href="#7-跳转到ep" class="headerlink" title="7. 跳转到ep"></a>7. 跳转到ep</h3><p>跳转到dll的ep。实际上就是执行dll原本的_DllMainCRTStartup函数。该函数会完成一些初始化工作并转到dllMain，让我们的dllMain像正常dllmain那样运行，但又不在peb中留下dll加载的痕迹。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef BOOL(WINAPI* DLLMAIN)(HINSTANCE, DWORD, LPVOID);PVOID entryPoint &#x3D; (PVOID)((DWORD)pNewDosHeader + pNewNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);pNtFlushInstructionCache((HANDLE)-1, NULL, 0);((DLLMAIN)entryPoint)((HMODULE)pNewDosHeader, DLL_PROCESS_ATTACH, lpParameter);</code></pre><h3 id="8-返回"><a href="#8-返回" class="headerlink" title="8. 返回"></a>8. 返回</h3><p>最后返回entrypoint。</p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p>本文看雪链接：<a href="https://bbs.pediy.com/thread-266929.htm">https://bbs.pediy.com/thread-266929.htm</a></p><p>msf反射注入源码：<a href="https://github.com/rapid7/ReflectiveDLLInjection">https://github.com/rapid7/ReflectiveDLLInjection</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/dll/">dll</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      
      <comments>https://windgodm.github.io/blog/post/reflectiveDllInjection.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>hgame21</title>
      <link>https://windgodm.github.io/blog/post/hgame21.html</link>
      <guid>https://windgodm.github.io/blog/post/hgame21.html</guid>
      <pubDate>Wed, 17 Mar 2021 12:51:25 GMT</pubDate>
      
      <description>2021hgame wp</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="web-week1"><a href="#web-week1" class="headerlink" title="web week1"></a>web week1</h1><h2 id="智商检测鸡（150）"><a href="#智商检测鸡（150）" class="headerlink" title="智商检测鸡（150）"></a>智商检测鸡（150）</h2><p>我用的python requests+beautifulsoup。</p><p>这题是通过cookie当作账号，做出一题就会给出下一个cookie。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsfrom bs4 import BeautifulSoupimport requestsgetQ &#x3D; &#39;http:&#x2F;&#x2F;r4u.top:5000&#x2F;api&#x2F;getQuestion&#39;getS &#x3D; &#39;http:&#x2F;&#x2F;r4u.top:5000&#x2F;api&#x2F;getStatus&#39;submit &#x3D; &#39;http:&#x2F;&#x2F;r4u.top:5000&#x2F;api&#x2F;verify&#39;getF &#x3D; &#39;http:&#x2F;&#x2F;r4u.top:5000&#x2F;api&#x2F;getFlag&#39;res &#x3D; requests.get(url&#x3D;getQ)header &#x3D; &#123;&#39;Cookie&#39;: res.headers[&#39;Set-Cookie&#39;]&#125;def f(x):    return c&#x2F;2*x*x + d*xfor i in range(100):    # 获取    res &#x3D; requests.get(url&#x3D;getQ, headers&#x3D;header)    bs &#x3D; BeautifulSoup(res.text, &#39;html.parser&#39;)    a &#x3D; int(bs.msubsup.contents[1].mn.text)    if(bs.msubsup.contents[1].mo !&#x3D; None):        if(bs.msubsup.contents[1].mo.text &#x3D;&#x3D; &#39;-&#39;):            a &#x3D; -a    b &#x3D; int(bs.msubsup.contents[2].mn.text)    if(bs.msubsup.contents[2].mo !&#x3D; None):        if(bs.msubsup.contents[2].mo.text &#x3D;&#x3D; &#39;-&#39;):            b &#x3D; -b    c &#x3D; int(bs.mrow.contents[2].text)    d &#x3D; int(bs.mrow.contents[5].text)    # 计算    ans &#x3D; round(f(b)-f(a), 2)    # 返回    res2 &#x3D; requests.post(url&#x3D;submit, headers&#x3D;header, json&#x3D;&#123;&#39;answer&#39;:ans&#125;)    print(res2.headers[&#39;Set-Cookie&#39;])    header &#x3D; &#123;&#39;Cookie&#39;: res2.headers[&#39;Set-Cookie&#39;]&#125;    # 检查    res &#x3D; requests.get(url&#x3D;getS, headers&#x3D;header)    print(res.text)res &#x3D; requests.get(url&#x3D;getF, headers&#x3D;header)print(res.text)</code></pre><h1 id="misc-week1"><a href="#misc-week1" class="headerlink" title="misc week1"></a>misc week1</h1><h2 id="Base全家福（50）"><a href="#Base全家福（50）" class="headerlink" title="Base全家福（50）"></a>Base全家福（50）</h2><p>base64+base32+base16</p><h1 id="pwn-week1"><a href="#pwn-week1" class="headerlink" title="pwn week1"></a>pwn week1</h1><h2 id="whitegive（50）"><a href="#whitegive（50）" class="headerlink" title="whitegive（50）"></a>whitegive（50）</h2><p>if(num == “paSsw0rd”)</p><p>ida中找到if语句中的字符串地址即可。</p><h1 id="re-week1"><a href="#re-week1" class="headerlink" title="re week1"></a>re week1</h1><h2 id="apacha（150）"><a href="#apacha（150）" class="headerlink" title="apacha（150）"></a>apacha（150）</h2><p>一个比较复杂的推理。需要注意的是，变量要用unsigned int。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unsigned int new_a1[35] &#x3D; &#123;&#125;; &#x2F;&#x2F; dumpfor (i &#x3D; 6; i &gt;&#x3D; 0; i--) &#123;    unsigned int l, r;    v6 &#x3D; v6s[i];    v7 &#x3D; v6 &gt;&gt; 2;    &#x2F;&#x2F; 最后一个    v5 &#x3D; new_a1[a2 - 2];    result &#x3D; (v5 * 16) ^ (new_a1[0] &gt;&gt; 3);    l &#x3D; (a3[((a2 - 1) ^ (unsigned __int8)v7) &amp; 3] ^ v5) + (new_a1[0] ^ v6);    r &#x3D; ((4 * new_a1[0]) ^ (v5 &gt;&gt; 5)) + result;    old_a1[a2 - 1] &#x3D; new_a1[a2 - 1] - (l ^ r);    for (j &#x3D; a2 - 2; j &gt;&#x3D; 0; j--) &#123; &#x2F;&#x2F; j &#x3D; v8        if (j &gt; 0) &#123;            v5 &#x3D; new_a1[j - 1];        &#125;        else &#123;            v5 &#x3D; old_a1[a2 - 1];        &#125;        l &#x3D; ((v5 &gt;&gt; 5) ^ (4 * old_a1[j + 1])) + ((16 * v5) ^ (old_a1[j + 1] &gt;&gt; 3));        r &#x3D; (a3[(((unsigned __int8)j ^ (unsigned __int8)v7) &amp; 3)] ^ v5) + ((old_a1[j + 1]) ^ (v6));        f &#x3D; l ^ r;        old_a1[j] &#x3D; new_a1[j] - f;    &#125;    for (j &#x3D; 0; j &lt; 35; j++)        new_a1[j] &#x3D; old_a1[j];</code></pre><h2 id="hellowRe（150）"><a href="#hellowRe（150）" class="headerlink" title="hellowRe（150）"></a>hellowRe（150）</h2><p>一个异或。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; [0x97, 0x99, 0x9C, 0x91, 0x9E, 0x81, 0x91, 0x9D, 0x9B, 0x9A, 0x9A,0xAB, 0x81, 0x97, 0x0AE, 0x80, 0x83, 0x8F, 0x94, 0x89, 0x99,0x97, 0x0, 0x0]b &#x3D; 0xffc &#x3D; []for i in range(24):    c.append(a[i] ^ b)    b -&#x3D; 1</code></pre><h2 id="pypy（150）"><a href="#pypy（150）" class="headerlink" title="pypy（150）"></a>pypy（150）</h2><p>python字节码转python代码。一个交换和异或。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from Crypto.Util.number import long_to_bytesflag &#x3D; 0x30466633346f59213b4139794520572b45514d61583151576638643acipher &#x3D; long_to_bytes(flag)length &#x3D; len(cipher)def f(x):    cipher &#x3D; list(x)    for i in range(length&#x2F;&#x2F;2):        cipher[i*2], cipher[2*i+1] &#x3D; cipher[i*2+1], cipher[2*i]    res &#x3D; []    for i in range(length):        res.append(cipher[i] ^ i)    return bytes(res)def re(cipher):    res &#x3D; list(cipher)    for i in range(length):        res[i] ^&#x3D; i    for i in range(length&#x2F;&#x2F;2):        res[i*2], res[2*i+1] &#x3D; res[i*2+1], res[2*i]        return bytes(res)print(re(flag))</code></pre><h1 id="re-week2"><a href="#re-week2" class="headerlink" title="re week2"></a>re week2</h1><h2 id="ezApk"><a href="#ezApk" class="headerlink" title="ezApk"></a>ezApk</h2><p>找到位置后，看不太懂，是aes cbc加密。</p><h2 id="helloRe2"><a href="#helloRe2" class="headerlink" title="helloRe2"></a>helloRe2</h2><h3 id="sse2指令"><a href="#sse2指令" class="headerlink" title="sse2指令"></a>sse2指令</h3><p>sse2指令集是个扩展指令集。cpp中需要include &lt;emmintrin.h&gt;。</p><p>_mm_load_si128：加载128bits值，vs中试了以下相当于把字符串直接转数字。</p><p>_mm_cmpeq_epi8：判断是否相等</p><p>_mm_movemask_epi8：没查</p><h3 id="flag1"><a href="#flag1" class="headerlink" title="flag1"></a>flag1</h3><p>cmp(load(flag1), flag)</p><p>ida中flag = 0x981b02a3a6e5c0b2</p><p>所以flag1(input)是”2b0c5e6a3a20b189”</p><h3 id="flag2"><a href="#flag2" class="headerlink" title="flag2"></a>flag2</h3><p>flag1正确后会异或一次然后重启程序，接着进入输入flag2的分支。</p><p>BCrypt解密没看懂。后面补了AES的CBC和ECB才看懂。</p><h3 id="复现主函数及BCrypt-h的使用"><a href="#复现主函数及BCrypt-h的使用" class="headerlink" title="复现主函数及BCrypt.h的使用"></a>复现主函数及BCrypt.h的使用</h3><p>要先include windows.h再include BCrypt.h</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/seccng/cng-algorithm-identifiers">https://docs.microsoft.com/en-us/windows/win32/seccng/cng-algorithm-identifiers</a></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">NTSTATUS BCryptGenerateSymmetricKey(  BCRYPT_ALG_HANDLE hAlgorithm,  &#x2F;&#x2F; handle of algorithm  BCRYPT_KEY_HANDLE *phKey,      &#x2F;&#x2F; recive handle of key  PUCHAR            pbKeyObject, &#x2F;&#x2F; recive key object  ULONG             cbKeyObject, &#x2F;&#x2F; sizeof(pbKeyObject)  PUCHAR            pbSecret,    &#x2F;&#x2F; pt a key witch to creat key  ULONG             cbSecret,    &#x2F;&#x2F; sizeof(pbSecret)  ULONG             dwFlags);</code></pre><p>找到关键的参数如下。c实际上有32位，这里只得到16位，上网找脚本破解。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s &#x3D; [0x32, 0x63, 0x32, 0x60, 0x31, 0x60, 0x30, 0x66, 0x3b, 0x68, 0x38, 0x3b, 0x6e, 0x3c, 0x36, 0x36]# 32633260316030663b68383b6e3c3636iv &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd ,0xe ,0xf]# 000102030405060708090a0b0c0d0e0fc &#x3D; [0xB7, 0xFE, 0xFE, 0xD9, 7, 0x76, 0x79, 0x65, 0x3F, 0x4E, 0x5F, 0x62, 0xD5, 2, 0xF6, 0x7E]# b7fefed9077679653f4e5f62d502f67em &#x3D; &#39;7a4ad6c5671fb313&#39;flag &#x3D; &#39;hgame&#123;2b0c5e6a3a20b189_7a4ad6c5671fb313&#125;&#39;</code></pre><p>复现了一下他的代码。这里解密失败了，不知道是什么原因。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BCRYPT_HANDLE name;DWORD objLen &#x3D; 0, blockLength &#x3D; 0;unsigned long btw &#x3D; 0, nts &#x3D; 0;wchar_t mode[16] &#x3D; L&quot;ChainingModeCBC&quot;;BCRYPT_KEY_HANDLE hKey;UCHAR pKey[618] &#x3D; &#123; 0 &#125;, pbSecret[16] &#x3D; &#123; 0x32, 0x63, 0x32, 0x60, 0x31, 0x60, 0x30, 0x66, 0x3b, 0x68, 0x38, 0x3b, 0x6e, 0x3c, 0x36, 0x36 &#125;, pKeyBLOB[560] &#x3D; &#123; 0 &#125;;UCHAR pIV[16] &#x3D; &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf &#125;;name &#x3D; 0;__try &#123;    &#x2F;&#x2F; 初始化    nts &#x3D; BCryptOpenAlgorithmProvider(&amp;name, L&quot;AES&quot;, 0, 0);    if ((nts &lt; 0) || name &#x3D;&#x3D; 0) &#123;        cout &lt;&lt; nts &lt;&lt; endl;        __leave;    &#125;    &#x2F;&#x2F; 获取属性值    nts &#x3D; BCryptGetProperty(name, L&quot;ObjectLength&quot;, (PUCHAR)&amp;objLen, 4, &amp;btw, 0);    cout &lt;&lt; &quot;ObjectLength(&quot; &lt;&lt; btw &lt;&lt; &quot;): &quot; &lt;&lt; objLen &lt;&lt; endl; &#x2F;&#x2F; 618    nts &#x3D; BCryptGetProperty(name, L&quot;BlockLength&quot;, (PUCHAR)&amp;blockLength, 4, &amp;btw, 0);    cout &lt;&lt; &quot;BlockLength(&quot; &lt;&lt; btw &lt;&lt; &quot;): &quot; &lt;&lt; blockLength &lt;&lt; endl; &#x2F;&#x2F; 16    if (blockLength &lt;&#x3D; 16) &#123;        &#x2F;&#x2F; 设置模式为CBC        nts &#x3D; BCryptSetProperty(name, L&quot;ChainingMode&quot;, (PUCHAR)mode, 0x20, 0);        &#x2F;&#x2F; 生成密钥对象        nts &#x3D; BCryptGenerateSymmetricKey(name, &amp;hKey, pKey, objLen, pbSecret, 16, 0);        &#x2F;&#x2F; 获取key BLOB长度        &#x2F;nts &#x3D; BCryptExportKey(hKey, 0, L&quot;OpaqueKeyBlob&quot;, 0, 0, &amp;btw, 0);        cout &lt;&lt; &quot;keyBLOBLen: &quot; &lt;&lt; btw &lt;&lt; endl; &#x2F;&#x2F; 560        &#x2F;&#x2F; 接收key BLOB        nts &#x3D; BCryptExportKey(hKey, 0, L&quot;OpaqueKeyBlob&quot;, pKeyBLOB, 560, &amp;btw, 0);        &#x2F;&#x2F; 获取密文长度        nts &#x3D; BCryptEncrypt(hKey, inputs, 16, 0, pIV, 16, 0, 0, &amp;btw, BCRYPT_BLOCK_PADDING);        cout &lt;&lt; &quot;ciphertextLen: &quot; &lt;&lt; btw &lt;&lt; endl; &#x2F;&#x2F; 32        &#x2F;&#x2F; 加密        nts &#x3D; BCryptEncrypt(hKey, inputs, 16, 0, pIV, 16, c, 32, &amp;btw, BCRYPT_BLOCK_PADDING);        &#x2F;&#x2F; 解密        nts &#x3D; BCryptDecrypt(hKey, c, 32, 0, pIV, 16, m, 16, &amp;btw, BCRYPT_BLOCK_PADDING);        cout &lt;&lt; btw &lt;&lt; endl;        cout &lt;&lt; m &lt;&lt; endl;    &#125;&#125;__finally &#123;&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/pwn/">pwn</category>
      
      <category domain="https://windgodm.github.io/blog/tags/misc/">misc</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      <category domain="https://windgodm.github.io/blog/tags/web/">web</category>
      
      
      <comments>https://windgodm.github.io/blog/post/hgame21.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>vnctf21ReWp</title>
      <link>https://windgodm.github.io/blog/post/vnctf21ReWp.html</link>
      <guid>https://windgodm.github.io/blog/post/vnctf21ReWp.html</guid>
      <pubDate>Wed, 17 Mar 2021 11:03:13 GMT</pubDate>
      
      <description>vnctf2021 re部分题解（没有安卓那两题）</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="notsudoku"><a href="#notsudoku" class="headerlink" title="notsudoku"></a>notsudoku</h1><p>这题是python打包的exe</p><p>首先用pyinstxtractor解包</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.\pyinstxtractor.py:86: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module&#39;s documentation for alternative uses  import imp[*] Processing .\notsudoku.exe[*] Pyinstaller version: 2.1+[*] Python version: 37[*] Length of package: 5560832 bytes[*] Found 60 files in CArchive[*] Beginning extraction...please standby[+] Possible entry point: pyiboot01_bootstrap[+] Possible entry point: 2[*] Found 133 files in PYZ archive[*] Successfully extracted pyinstaller archive: .\notsudoku.exeYou can now use a python decompiler on the pyc files within the extracted directory</code></pre><p>得到主要代码在文件 2 ，把这个文件改名为2.pyc，并复制struct文件的E3前面的内容，然后粘贴到2.pyc的E3前面。接着用uncompyle6反编译成py文件。</p><p>最后改一下变量名，得到的是要解一个五阶幻方。本来有多组解，因为有个校验所以只有唯一解。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import time, sys, hashlibnum &#x3D; 65# 124 126print(&#39;welcome baby~ input your flag~:&#39;, end&#x3D;&#39;&#39;)# 128str1 &#x3D; input()# 130 132print(&#39;your input is:&#39;, end&#x3D;&#39;&#39;)print(str1)# 134print(&quot;let&#39;s check......&quot;, end&#x3D;&#39;&#39;)# 136time.sleep(0.5)# 138 ~ 146list2 &#x3D; []list2 +&#x3D; [[0 for i in range(5)]]list2 +&#x3D; [[0 for i in range(5)]]list2 +&#x3D; [[0 for i in range(5)]]list2 +&#x3D; [[0 for i in range(5)]]list2 +&#x3D; [[0 for i in range(5)]]# 148if len(str1) % 2 !&#x3D; 0:    sys.exit()for i in str1:    if ord(i) &gt; 52 or ord(i) &lt; 48: # [0, 4]        sys.exit()x &#x3D; str(hashlib.new(&#39;md5&#39;, bytes((str1), encoding&#x3D;&#39;utf8&#39;)).hexdigest())if x[:6] !&#x3D; &#39;e3a912&#39;:    sys.exit()flag &#x3D; x# 150j &#x3D; 0a &#x3D; 0b &#x3D; 0for i in range(0, len(str1), 2):    j +&#x3D; 1    a &#x3D; int(str1[i])    b &#x3D; int(str1[(i + 1)])    list2[a][b] &#x3D; j# 152if list2[0][1] !&#x3D; 24 or list2[4][3] !&#x3D; 2:    sys.exit()if list2[0][2] !&#x3D; 1 or list2[2][3] !&#x3D; 20:    sys.exit()if list2[1][0] !&#x3D; 23 or list2[3][4] !&#x3D; 3:    sys.exit()# 154 ~ 162for a in range(0, 5):    tnum &#x3D; 0    a &#x3D; 0    for i in range(5):        tnum +&#x3D; cla.list2[a][i]    if tnum !&#x3D; num:        sys.exit()# 164 ~ 172for b in range(0, 5):    tnum &#x3D; 0    for i in range(5):        tnum +&#x3D; list2[i][b]    if tnum !&#x3D; num:        sys.exit()# 174 ~ 180print(&#39;Goodjob!&#39;, end&#x3D;&#39;&#39;)print(&#39;The flag is vnctf&#123;&#39;, end&#x3D;&#39;&#39;)print(flag, end&#x3D;&#39;&#39;)print(&#39;&#125;&#39;, end&#x3D;&#39;&#39;)#182sys.exit()</code></pre><h1 id="FlipGame"><a href="#FlipGame" class="headerlink" title="FlipGame"></a>FlipGame</h1><p>ida中看到主函数中，有一个16x16的位数组，先是把16进制转10进制，然后翻转上下左右中间。</p><p>解法是暴力搜索第一行的情况，接着对于第i+1行，如果第i行对应位置为0，就在第i+1行的那一位执行翻转操作。这样就能得到解。</p><p>代码的话搜索poj 3279即可，是个noip题目。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      
      <comments>https://windgodm.github.io/blog/post/vnctf21ReWp.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>远程线程注入逆向</title>
      <link>https://windgodm.github.io/blog/post/dllRemoteInject.html</link>
      <guid>https://windgodm.github.io/blog/post/dllRemoteInject.html</guid>
      <pubDate>Tue, 16 Mar 2021 09:08:49 GMT</pubDate>
      
      <description>对远程线程注入（CreateRemoteThread）所用到的函数做了一下逆向研究,&lt;br&gt;用native api实现了远程注入</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="远程线程注入逆向"><a href="#远程线程注入逆向" class="headerlink" title="远程线程注入逆向"></a>远程线程注入逆向</h1><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><h3 id="MSDN中的函数定义"><a href="#MSDN中的函数定义" class="headerlink" title="MSDN中的函数定义"></a>MSDN中的函数定义</h3><h4 id="OpenProcess-processthreadsapi-h"><a href="#OpenProcess-processthreadsapi-h" class="headerlink" title="OpenProcess (processthreadsapi.h)"></a>OpenProcess (processthreadsapi.h)</h4><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><h4 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h4><p>HANDLE OpenProcess (<br>    DWORD dwDesiredAccess,<br>    BOOL bInheritHandle,<br>    DWORD dwProcessId);</p><h4 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h4><p>DLL：Kernel32.dll</p></blockquote><h4 id="NtOpenProcess-ntddk-h"><a href="#NtOpenProcess-ntddk-h" class="headerlink" title="NtOpenProcess (ntddk.h)"></a>NtOpenProcess (ntddk.h)</h4><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><h4 id="Syntax-1"><a href="#Syntax-1" class="headerlink" title="Syntax"></a>Syntax</h4><p>__kernel_entry NTSYSCALLAPI NTSTATUS NtOpenProcess (<br>   PHANDLE ProcessHandle,<br>   ACCESS_MASK DesiredAccess,<br>   POBJECT_ATTRIBUTES ObjectAttributes,<br>   PCLIENT_ID ClientId);</p><h4 id="Requirements-1"><a href="#Requirements-1" class="headerlink" title="Requirements"></a>Requirements</h4><p>Header：ntddk.h (include Ntddk.h, Ntifs.h)</p></blockquote><h4 id="NtAllocateVirtualMemory-ntifs-h"><a href="#NtAllocateVirtualMemory-ntifs-h" class="headerlink" title="NtAllocateVirtualMemory (ntifs.h)"></a>NtAllocateVirtualMemory (ntifs.h)</h4><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><h4 id="Syntax-2"><a href="#Syntax-2" class="headerlink" title="Syntax"></a>Syntax</h4><p>__kernel_entry NTSYSCALLAPI NTSTATUS NtAllocateVirtualMemory(<br>   HANDLE ProcessHandle,<br>   PVOID *BaseAddress,<br>   ULONG_PTR ZeroBits,<br>   PSIZE_T RegionSize,<br>   ULONG AllocationType,<br>   ULONG Protect);</p></blockquote><h3 id="第三方网站中的函数定义"><a href="#第三方网站中的函数定义" class="headerlink" title="第三方网站中的函数定义"></a>第三方网站中的函数定义</h3><h4 id="NtWriteVirtualMemory"><a href="#NtWriteVirtualMemory" class="headerlink" title="NtWriteVirtualMemory"></a>NtWriteVirtualMemory</h4><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>__kernel_entry NTSYSCALLAPI NTSTATUS NtQueryVirtualMemory(<br>   HANDLE ProcessHandle,<br>   PVOID BaseAddress,<br>   MEMORY_INFORMATION_CLASS MemoryInformationClass,<br>   PVOID MemoryInformation,<br>   SIZE_T MemoryInformationLength,<br>   PSIZE_T ReturnLength );</p></blockquote><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><h4 id="UNICODE-STRING-ntdef-h"><a href="#UNICODE-STRING-ntdef-h" class="headerlink" title="UNICODE_STRING (ntdef.h)"></a>UNICODE_STRING (ntdef.h)</h4><p>似乎是一种安全的unicode字符串类型，下面是ntdef源码。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;&#x2F;&#x2F; Unicode strings are counted 16-bit character strings. If they are&#x2F;&#x2F; NULL terminated, Length does not include trailing NULL.&#x2F;&#x2F;typedef struct _UNICODE_STRING &#123;    USHORT Length;    USHORT MaximumLength;#ifdef MIDL_PASS    [size_is(MaximumLength &#x2F; 2), length_is((Length) &#x2F; 2) ] USHORT * Buffer;#else &#x2F;&#x2F; MIDL_PASS    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH   Buffer;#endif &#x2F;&#x2F; MIDL_PASS&#125; UNICODE_STRING;typedef UNICODE_STRING *PUNICODE_STRING;typedef const UNICODE_STRING *PCUNICODE_STRING;&#x2F;&#x2F; end_sdfwdm&#x2F;&#x2F; end_wudfwdm</code></pre><h4 id="OBJECT-ATTRIBUTES-ntdef-h"><a href="#OBJECT-ATTRIBUTES-ntdef-h" class="headerlink" title="OBJECT_ATTRIBUTES (ntdef.h)"></a>OBJECT_ATTRIBUTES (ntdef.h)</h4><p>下面是ntdef源码。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef struct _OBJECT_ATTRIBUTES &#123;    ULONG Length;    HANDLE RootDirectory;    PUNICODE_STRING ObjectName;    ULONG Attributes;    PVOID SecurityDescriptor;        &#x2F;&#x2F; Points to type SECURITY_DESCRIPTOR    PVOID SecurityQualityOfService;  &#x2F;&#x2F; Points to type SECURITY_QUALITY_OF_SERVICE&#125; OBJECT_ATTRIBUTES;typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;typedef CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;</code></pre><h4 id="CLIENT-ID-MSDN"><a href="#CLIENT-ID-MSDN" class="headerlink" title="CLIENT_ID (MSDN)"></a>CLIENT_ID (MSDN)</h4><p>MSDN的解释是包括进程和线程的id，下面是MSDN中的定义。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef struct _CLIENT_ID &#123;HANDLE UniqueProcess;HANDLE UniqueThread;&#125; CLIENT_ID;</code></pre><h3 id="文件地址"><a href="#文件地址" class="headerlink" title="文件地址"></a>文件地址</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>C:\Windows\System32\kernel32.dll<br>C:\Windows\System32\KernelBase.dll<br>C:\Windows\SysWOW64\kernel32.dll<br>C:\Windows\SysWOW64\KernelBase.dll<br>C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\um\windows.h<br>C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\ntdef.h</p></blockquote><h2 id="逆向重写OpenProcess（NtOpenProcess）"><a href="#逆向重写OpenProcess（NtOpenProcess）" class="headerlink" title="逆向重写OpenProcess（NtOpenProcess）"></a>逆向重写OpenProcess（NtOpenProcess）</h2><h3 id="在dll中寻找OpenProcess"><a href="#在dll中寻找OpenProcess" class="headerlink" title="在dll中寻找OpenProcess"></a>在dll中寻找OpenProcess</h3><p>在本机的System32\kernel32.dll里没有找到，只找到OpenProcessStub()，这个函数会直接调用OpenProcess。在System32\KernelBase.dll里找到了OpenProcess，然后用ida f5，改了以下符号名是下面这个样子。</p><p>其中ObjectAttributes.Length这个参数有问题，64位是48，32位是24，msdn里是<code>sizeof(OBJECT_ATTRIBUTES)</code>。</p><p>如果有dalao看到这里肯定发现，system32目录下的是64位的dll，但我原本是想找32位的，很尴尬。</p><h3 id="KernelBase"><a href="#KernelBase" class="headerlink" title="KernelBase"></a>KernelBase</h3><p>MSDN上找到一份关于win7的资料[5]，大概意思是把部分kernel32和advapi32的函数移到了kernelbase里，并称kernelbase为low-level binaries，应该是低权限的意思。目的是为了以后的网络工程开发和减少攻击面。</p><h3 id="OpenProcess调用过程（x32）"><a href="#OpenProcess调用过程（x32）" class="headerlink" title="OpenProcess调用过程（x32）"></a>OpenProcess调用过程（x32）</h3><p>在重写OpenProcess改用NtOpenProcess后（详细见下面重新OpenProcess），我重新跟踪了下调用OpenProcess的过程。</p><p><img src="https://s3.ax1x.com/2021/03/16/6y9jbj.png" alt="op32"></p><p>首先main函数call OpenProcess，跳转到kernel.dll；然后jmp到kernelbase.dll；在kernelbase.dll里才是OpenProcess的主要代码，其中会调用ntdll的NtOpenProcess；而NtOpenProcess会调用系统调用。</p><h3 id="OpenProcess调用过程（x64）"><a href="#OpenProcess调用过程（x64）" class="headerlink" title="OpenProcess调用过程（x64）"></a>OpenProcess调用过程（x64）</h3><p>64位和32差不多，先是main call OpenProcess跳转到kernel.dll；然后jmp到kernelbase.dll；kernelbase.dll里是主要代码，不同点是ObjectAttributes.Length的值，以及32位调用的NtOpenProcess，在64中改成了ntdll的ZwOpenProcess；而ZwOpenProcess同样调用了系统调用。</p><p><img src="https://s3.ax1x.com/2021/03/16/6yCuPx.png" alt="op64"></p><h3 id="重写OpenProcess（NtOpenProcess）"><a href="#重写OpenProcess（NtOpenProcess）" class="headerlink" title="重写OpenProcess（NtOpenProcess）"></a>重写OpenProcess（NtOpenProcess）</h3><p>直接引用ntdef.h会引发下面的错误：</p><p>error C2338: Windows headers require the default packing option. Changing this can lead to memory corruption. This diagnostic can be disabled by building with WINDOWS_IGNORE_PACKING_MISMATCH defined.</p><p>最终代替OpenProcess的代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef struct _UNICODE_STRING &#123;USHORT Length;USHORT MaximumLength;PWSTR  Buffer;&#125;UNICODE_STRING, *PUNICODE_STRING;typedef struct _OBJECT_ATTRIBUTES &#123;ULONG Length;HANDLE RootDirectory;PUNICODE_STRING ObjectName;ULONG Attributes;PVOID SecurityDescriptor;PVOID SecurityQualityOfService;&#125;OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;typedef struct _CLIENT_ID &#123;HANDLE UniqueProcess;HANDLE UniqueThread;&#125;CLIENT_ID, *PCLIENT_ID;typedef long (WINAPI* PNtOpenProcess) (PHANDLE ProcessHandle,ACCESS_MASK DesiredAccess,POBJECT_ATTRIBUTES ObjectAttributes,PCLIENT_ID ClientId);&#x2F;&#x2F; hTarget &#x3D; OpenProcess((PROCESS_CREATE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION), false, pid);HMODULE mdNT &#x3D; GetModuleHandleW(L&quot;ntdll.dll&quot;);PNtOpenProcess NtOpenProcess &#x3D; (PNtOpenProcess)GetProcAddress(mdNT, &quot;NtOpenProcess&quot;);OBJECT_ATTRIBUTES ObjectAttributes &#x3D; &#123; sizeof(OBJECT_ATTRIBUTES) &#125;; &#x2F;&#x2F; 0x18CLIENT_ID ClientId &#x3D; &#123; (HANDLE)pid, 0 &#125;;DWORD nts &#x3D; NtOpenProcess(&amp;hTarget, (PROCESS_CREATE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION), &amp;ObjectAttributes, &amp;ClientId);</code></pre><p>其中ObjectAttributes.Length我一开始照抄48（后面才发现，照抄的是64位版本的openprocess。），然后NtOpenProcess给我返回了0xC000000D，MSDN中的说明是传入非法参数，再仔细看Members条目，发现这个参数应该为<code>sizeof(OBJECT_ATTRIBUTES)</code>，vs中调试发现这个结构体的长度为24，修改后就能正常用了。原因是32和64的OBJECT_ATTRIBUTES结构长度不一样。</p><h2 id="R0和R3通信"><a href="#R0和R3通信" class="headerlink" title="R0和R3通信"></a>R0和R3通信</h2><p>后面查资料才知道，windwos程序运行在r3（用户态）层；驱动在r1，r2；系统代码在r0（内核态）层。r0权限最高。</p><p>ntdll提供api使得r3层面的程序能够执行r0层的代码。而ntdll的native api都是成对出现的，分别以Nt和Zw开头。</p><h2 id="逆向重写VirtualAllocEx（NtAllocateVirtualMemory）"><a href="#逆向重写VirtualAllocEx（NtAllocateVirtualMemory）" class="headerlink" title="逆向重写VirtualAllocEx（NtAllocateVirtualMemory）"></a>逆向重写VirtualAllocEx（NtAllocateVirtualMemory）</h2><h3 id="KernelBase-dll中的VirtualAllocEx"><a href="#KernelBase-dll中的VirtualAllocEx" class="headerlink" title="KernelBase.dll中的VirtualAllocEx"></a>KernelBase.dll中的VirtualAllocEx</h3><p>VirtualAllocEx会直接调用VirtualAllocExNuma；然后VirtualAllocExNuma调用NtAllocateVirtualMemory。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef long (WINAPI* PNtAllocateVirtualMemory) (HANDLE ProcessHandle,PVOID* BaseAddress,ULONG_PTR ZeroBits,PSIZE_T RegionSize,ULONG AllocationType,ULONG Protect);&#x2F;&#x2F; pszPathname &#x3D; (PWSTR)VirtualAllocEx(hTarget, NULL, pathnameLen, MEM_COMMIT, PAGE_READWRITE);PNtAllocateVirtualMemory NtAllocateVirtualMemory &#x3D; (PNtAllocateVirtualMemory)GetProcAddress(mdNT, &quot;NtAllocateVirtualMemory&quot;);nts &#x3D; NtAllocateVirtualMemory(hTarget, (PVOID*)&amp;pszPathname, 0, (SIZE_T*)&amp;pathnameLen, MEM_COMMIT &amp; 0xFFFFFFC0, PAGE_READWRITE);</code></pre><h2 id="逆向重写WriteProcessMemory（NtWriteVirtualMemory）"><a href="#逆向重写WriteProcessMemory（NtWriteVirtualMemory）" class="headerlink" title="逆向重写WriteProcessMemory（NtWriteVirtualMemory）"></a>逆向重写WriteProcessMemory（NtWriteVirtualMemory）</h2><h3 id="KernelBase-dll中的WriteProcessMemory"><a href="#KernelBase-dll中的WriteProcessMemory" class="headerlink" title="KernelBase.dll中的WriteProcessMemory"></a>KernelBase.dll中的WriteProcessMemory</h3><p>WriteProcessMemory中调用了NtQueryVirtualMemory，NtProtectVirtualMemory，NtWriteVirtualMemory，NtFlushInstructionCache。后三个在MSDN中似乎都没有资料。</p><p>其中 NtQueryVirtualMemory 用于获取虚拟内存的属性。</p><p>在第三方网站查询得到 NtProtectVirtualMemory[7] 用于改变虚拟内存区域的保护状态。</p><p>关于 NtFlushInstructionCache 的资料没有找到多少，说是用于刷新指令缓存，不知道具体有什么用。</p><p>同样在第三方网站查询得到 NtWriteVirtualMemory[8] 用于写入内存。所以只需要直接调用这个即可。</p><h3 id="重写-1"><a href="#重写-1" class="headerlink" title="重写"></a>重写</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef long(WINAPI* PNtWriteVirtualMemory) (HANDLE ProcessHandle,PVOID BaseAddress,PVOID Buffer,ULONG BufferSize,PULONG NumberOfBytesWritten);&#x2F;&#x2F; WriteProcessMemory(hTarget, (LPVOID)memoryAddr, buf, bufSize, &amp;byw);PNtWriteVirtualMemory NtWriteVirtualMemory &#x3D; (PNtWriteVirtualMemory)GetProcAddress(mdNT, &quot;NtWriteVirtualMemory&quot;);NtWriteVirtualMemory(hTarget, memoryAddr, buf, bufSize, &amp;byw);</code></pre><h2 id="逆向重写LoadLibraryExW（LdrLoadDll）"><a href="#逆向重写LoadLibraryExW（LdrLoadDll）" class="headerlink" title="逆向重写LoadLibraryExW（LdrLoadDll）"></a>逆向重写LoadLibraryExW（LdrLoadDll）</h2><p>32位下调用过程如下，不管调用哪个版本，最终都会去到LoadLibraryExW。</p><p>LoadLibraryA -&gt; LoadLibraryExA -&gt;LoadLibraryExW，LoadLibraryW -&gt; LoadLibraryExW</p><h3 id="KernelBase-dll中的LoadLibraryExW"><a href="#KernelBase-dll中的LoadLibraryExW" class="headerlink" title="KernelBase.dll中的LoadLibraryExW"></a>KernelBase.dll中的LoadLibraryExW</h3><p>首先通过传入的dwFlags参数确认传入的dll名称是不是unicode编码，不是就设置错误代码为0xC000000D（传入参数非法）。</p><p>然后转换成UNICODE_STRING（RtlInitUnicodeString）。</p><p>转换后会进行检查，去掉unicode字符串末尾的空格。如果全是空格同样会设置错误代码为0xC000000D。</p><p>接着有一段代码会调用 LdrGetDllPath，这段代码如果调用 LoadLibraryW 进入的 LoadLibraryExW 不会触发。</p><p>然后又有一系列从 LoadLibraryW 进入不会触发的if语句。</p><p>最后调用 LdrLoadDll。</p><p>需要注意的是，要选择Release模式，debug模式会出问题，不能正确获得ShellCode地址。</p><h3 id="重写-2"><a href="#重写-2" class="headerlink" title="重写"></a>重写</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void __declspec(naked) ShellCode(PVOID addr)&#123;    &#x2F;&#x2F; para 3 UNICODE_STRING pathname    &#x2F;&#x2F; [addr+0x0] 2:  USHORT  Length    &#x2F;&#x2F; [addr+0x2] 2:  USHORT  MaximumLength    &#x2F;&#x2F; [addr+0x4] 4:  PWSTR   Buffer        &#x3D; addr+8    &#x2F;&#x2F; [addr+0x8] 0x14: wchar_t dllPathname    &#x2F;&#x2F; para 2    &#x2F;&#x2F; [addr+0x98] 4: ULONG LoadFlags &#x3D; 0    &#x2F;&#x2F; para 4    &#x2F;&#x2F; [addr+0x9C] 4: PVOID BaseAddress &#x3D; 0    &#x2F;&#x2F; [addr+0x100] 4: PVOID LdrLoadDll    &#x2F;&#x2F; [addr+0x200] : shellcode__asm &#123;pushad;mov eax, addr;&#x2F;&#x2F; para 4mov ebx, eax;add ebx, 0x9c;push ebx;&#x2F;&#x2F; para 3mov ebx, eax;push ebx;&#x2F;&#x2F; para 2mov ebx, eax;add ebx, 0x98;push ebx;&#x2F;&#x2F; para 1mov ebx, 1;push ebx;&#x2F;&#x2F; call LdrLoadDlladd eax, 0x100;mov edx, [eax];call edx;popad;mov eax, addr;add eax, 0x9C;mov eax, [eax];ret;&#125;&#125;</code></pre><h4 id="写入参数及shellcode"><a href="#写入参数及shellcode" class="headerlink" title="写入参数及shellcode"></a>写入参数及shellcode</h4><p>这里需要用NtWriteVirtualMemory写入参数及shellcode。</p><p>第三个参数 UNICODE_STRING pathname 我直接选择自己构建，MaximumLength就是dll路径字符串的字节数（包括末尾的零），而Length必须是字符串不包括末尾\x0\x0的字节数，否则会LdrLoadDll会找不到dll并返回0xC0000135。</p><h2 id="逆向重写CreateRemoteThreadEx（NtCreateThreadEx）"><a href="#逆向重写CreateRemoteThreadEx（NtCreateThreadEx）" class="headerlink" title="逆向重写CreateRemoteThreadEx（NtCreateThreadEx）"></a>逆向重写CreateRemoteThreadEx（NtCreateThreadEx）</h2><h3 id="KernelBase-dll中的CreateRemoteThreadEx"><a href="#KernelBase-dll中的CreateRemoteThreadEx" class="headerlink" title="KernelBase.dll中的CreateRemoteThreadEx"></a>KernelBase.dll中的CreateRemoteThreadEx</h3><p>CreateRemoteThread会直接调用CreateRemoteThreadEx</p><p>然后CreateRemoteThreadEx会搞一堆奇奇怪怪的检测，并调用NtCreateThreadEx。</p><p>在网上找到定义[9]，照着定义和ida写了下。其中调用了个BaseFormatObjectAttributes，但传了两个零进去发现其实什么也没干。</p><h3 id="重写-3"><a href="#重写-3" class="headerlink" title="重写"></a>重写</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef long(WINAPI* PNtCreateThreadEx) (PHANDLE hThread,ACCESS_MASK DesiredAccess,LPVOID ObjectAttributes,HANDLE ProcessHandle,LPTHREAD_START_ROUTINE lpStartAddress,LPVOID lpParameter,BOOL CreateSuspended,ULONG StackZeroBits,ULONG SizeOfStackCommit,ULONG SizeOfStackReserve,LPVOID lpBytesBuffer);PNtCreateThreadEx NtCreateThreadEx &#x3D; (PNtCreateThreadEx)GetProcAddress(mdNT, &quot;NtCreateThreadEx&quot;);nts &#x3D; NtCreateThreadEx(    &amp;hDll,    0x1FFFFF,    0,    hTarget,    (LPTHREAD_START_ROUTINE)(pVirtualMemory + 0x200),    (PVOID)pVirtualMemory,    0,    0,    0,    0,    0);</code></pre><h2 id="用RtlCreateUserThread代替CreateRemoteThread"><a href="#用RtlCreateUserThread代替CreateRemoteThread" class="headerlink" title="用RtlCreateUserThread代替CreateRemoteThread"></a>用RtlCreateUserThread代替CreateRemoteThread</h2><p>据说RtlCreateUserThread是NtCreateThread的一个小型封装。抄了一下Metasploit的代码[11]。</p><p>Metasploit会先用CraeteRemoteThread，没有足够空间时再使用RtlCreateUserThread。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef long(WINAPI* PRtlCreateUserThread) (HANDLE ProcessHandle,PSECURITY_DESCRIPTOR SecurityDescriptor,BOOLEAN CreateSuspended,ULONG StackZeroBits,PULONG StackReserved,PULONG StackCommit,PVOID StartAddress,PVOID StartParameter,PHANDLE ThreadHandle,PCLIENT_ID ClientID);PRtlCreateUserThread RtlCreateUserThread &#x3D; (PRtlCreateUserThread)GetProcAddress(mdNT, &quot;RtlCreateUserThread&quot;);nts &#x3D; RtlCreateUserThread(    hTarget,    0,    0,    0,    0,    0,    (LPTHREAD_START_ROUTINE)(pVirtualMemory + 0x200),    (PVOID)pVirtualMemory,    &amp;hDll,    0);</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] UNICODE_STRING ：<a href="https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_unicode_string">https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_unicode_string</a></p><p>[2] OBJECT_ATTRIBUTES：<a href="https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_object_attributes">https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_object_attributes</a></p><p>[3] CLIENT_ID：<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tsts/a11e7129-685b-4535-8d37-21d4596ac057">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tsts/a11e7129-685b-4535-8d37-21d4596ac057</a></p><p>[4] NtOpenProcess：<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-ntopenprocess">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-ntopenprocess</a></p><p>[5] New Low-Level Binaries（win7）：<a href="https://docs.microsoft.com/en-us/windows/win32/win7appqual/new-low-level-binaries">https://docs.microsoft.com/en-us/windows/win32/win7appqual/new-low-level-binaries</a></p><p>[6] r0和r3之间的通信：<a href="https://blog.csdn.net/qq_33526144/article/details/103503011">https://blog.csdn.net/qq_33526144/article/details/103503011</a></p><p>[7] NtQueryVirtualMemory：<a href="http://www.codewarrior.cn/ntdoc/winnt/mm/NtProtectVirtualMemory.htm">http://www.codewarrior.cn/ntdoc/winnt/mm/NtProtectVirtualMemory.htm</a></p><p>[8] NtWriteProcessMemory：<a href="http://www.codewarrior.cn/ntdoc/winnt/mm/NtWriteVirtualMemory.htm">http://www.codewarrior.cn/ntdoc/winnt/mm/NtWriteVirtualMemory.htm</a></p><p>[9] NtCreateThread：<a href="https://securityxploded.com/ntcreatethreadex.php">https://securityxploded.com/ntcreatethreadex.php</a></p><p>[10] RtlCreateUserThread：<a href="https://undocumented.ntinternals.net/index.html?page=UserMode/Undocumented%20Functions/Executable%20Images/RtlCreateUserThread.html">https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FExecutable%20Images%2FRtlCreateUserThread.html</a></p><p>[11] RtlCreateUserThread Metasploit例子：<a href="https://github.com/rapid7/meterpreter/blob/6d43284689240f4261cae44a47f0fb557c1dde27/source/common/arch/win/remote_thread.c#L77">https://github.com/rapid7/meterpreter/blob/6d43284689240f4261cae44a47f0fb557c1dde27/source/common/arch/win/remote_thread.c#L77</a></p><p>[12] RtlCreateUserThread mimikatz例子：<a href="https://github.com/gentilkiwi/mimikatz/blob/d5676aa66cb3f01afc373b0a2f8fcc1a2822fd27/modules/kull_m_remotelib.c#L59">https://github.com/gentilkiwi/mimikatz/blob/d5676aa66cb3f01afc373b0a2f8fcc1a2822fd27/modules/kull_m_remotelib.c#L59</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/dll/">dll</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      
      <comments>https://windgodm.github.io/blog/post/dllRemoteInject.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>windows核心编程 dll笔记</title>
      <link>https://windgodm.github.io/blog/post/winViaC-dll.html</link>
      <guid>https://windgodm.github.io/blog/post/winViaC-dll.html</guid>
      <pubDate>Tue, 16 Mar 2021 08:52:35 GMT</pubDate>
      
      <description>看windows核心编程dll注入部分的时候做的一些笔记</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="windows核心编程-dll笔记"><a href="#windows核心编程-dll笔记" class="headerlink" title="windows核心编程 dll笔记"></a>windows核心编程 dll笔记</h1><h2 id="构建及使用dll"><a href="#构建及使用dll" class="headerlink" title="构建及使用dll"></a>构建及使用dll</h2><p>以下是核心编程的示例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* .\Mylib\MyLib.h *&#x2F;#ifndef MYLIB#define MYLIB extern &quot;C&quot; __declspec(dllimport)#endifMYLIB int num;MYLIB int DllFun();</code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* .\Mylib\MyLib1.cpp *&#x2F;#include &lt;windows.h&gt;#define MYLIB extern &quot;C&quot; __declspec(dllexport)#include &quot;MyLib.h&quot;int dll_num;int DllFun() &#123;    return dll_num;&#125;</code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* .\MyExe.cpp *&#x2F;#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &quot;MyLib\MyLib.h&quot;int main()&#123;    dll_num &#x3D; 10;    std::cout &lt;&lt; DllFun();    return 0;&#125;</code></pre><p>extern “C”修饰符用于指明使用C++。</p><h2 id="载入dll模块"><a href="#载入dll模块" class="headerlink" title="载入dll模块"></a>载入dll模块</h2><h3 id="显式载入"><a href="#显式载入" class="headerlink" title="显式载入"></a>显式载入</h3><p>将dll映射到进程的地址空间</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">HMODULE LoadLibrary(PCTSTR pszDLLPathName);HMODULE LoadLibraryEx(PCTSTR pszDLLPathName,                      HANDLE hFile,                      DWORD dwFlags);</code></pre><p>返回值是被映射到的虚拟内存地址。（此处HMODULE等价于HINSTANCE）</p><p>通过GetLastError确定是否成功载入。</p><h3 id="显式链接到导出符号"><a href="#显式链接到导出符号" class="headerlink" title="显式链接到导出符号"></a>显式链接到导出符号</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">FARPROC GetProcAddress(HMODULE hInstDll, PCSTR pszSymbolName);</code></pre><h3 id="显式卸载"><a href="#显式卸载" class="headerlink" title="显式卸载"></a>显式卸载</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">BOOL FreeLibrary(HMODULE hInstDll);VOID FreeLivraryAndExitThread(HMODULE hInstDll, DWORD dwExitCode);</code></pre><h3 id="dll搜索顺序"><a href="#dll搜索顺序" class="headerlink" title="dll搜索顺序"></a>dll搜索顺序</h3><ul><li>当前目录</li><li>windows系统目录</li><li>16位windows系统目录（windows目录下的system子目录）</li><li>windows目录</li><li>path环境变量中的目录</li></ul><h2 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain"></a>DllMain</h2><h3 id="fdwReason"><a href="#fdwReason" class="headerlink" title="fdwReason"></a>fdwReason</h3><p><strong>DLL_PROCESS_ATTACH：</strong><br>第一次将DLL<strong>映射到进程中</strong>时，会调用DllMain并传入该信号。<br>通常此时应该通过HeapCreate创建需要的堆。<br>返回值用于表示是否初始化成功。</p><p><strong>DLL_THREAD_ATTACH：</strong><br>进程创建一个线程时触发。</p><p><strong>DLL_THREAD_DETACH：</strong><br>ExitThread触发。</p><p><strong>DLL_PROCESS_DETACH：</strong><br>撤销映射时传入该信号。<br>通常执行HeapDestroy销毁初始化时创建的堆。</p><h2 id="模块的基地址重定位"><a href="#模块的基地址重定位" class="headerlink" title="模块的基地址重定位"></a>模块的基地址重定位</h2><p>重定位段(relocation section)包含一个字节偏移量的列表，记录机器指令的内存地址，用于需要重定位时遍历修改内存映像中的地址。</p><h2 id="RemoteInject（CreateRemoteThread）"><a href="#RemoteInject（CreateRemoteThread）" class="headerlink" title="RemoteInject（CreateRemoteThread）"></a>RemoteInject（CreateRemoteThread）</h2><h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><ul><li><p>获取目标进程pid，并打开目标进程。</p></li><li><p>在目标进程中申请空间，写入注入dll的路径。</p></li><li><p>获取LoadLibrary在Kernel32.dll的真实地址。</p></li><li><p>通过远程创建线程，在目标进程中创建一个线程，执行LoadLibrary(dllPathname)。</p></li><li><p>释放申请的空间，并关闭句柄。</p></li></ul><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>因为是在目标进程中执行LoadLibrary(dllPathname)的，所以需要先把dll路径写入目标进程中，并作为LoadLibrary的参数。</p><p>直接调用LoadLibrary时，链接器会生成一个调用，调用导入段中的一个转换函数。即先跳转到转换函数，再跳转到实际函数。<br>而转换函数在不同进程中是会变的，但Kernel32.dll在所有进程中映射的地址是一样的，所以需要获取LoadLibrary在Kernel32.dll中的地址。</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*RemoteInject.cpp*&#x2F;#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;TlHelp32.h&gt;using std::cout;using std::endl;DWORD GetPidByName(WCHAR* name);int main()&#123;wchar_t targetName[20] &#x3D; L&quot;Target.exe&quot;;wchar_t dllPathname[] &#x3D; L&quot;E:\\MyDll.dll&quot;;int pathnameLen &#x3D; (1 + lstrlenW(dllPathname)) * sizeof(wchar_t);DWORD pid &#x3D; 0, byw &#x3D; 0;HANDLE hTarget &#x3D; 0, hDll &#x3D; 0;PWSTR pszPathname &#x3D; 0;PTHREAD_START_ROUTINE realAddr &#x3D; 0;__try &#123;&#x2F;&#x2F; 1 get pidpid &#x3D; GetPidByName(targetName);if (pid &#x3D;&#x3D; 0) &#123;cout &lt;&lt; &quot;e:Get pid failed\n&quot;;__leave;&#125;cout &lt;&lt; &quot;pid:&quot; &lt;&lt; pid &lt;&lt; endl;&#x2F;&#x2F; 2 open processhTarget &#x3D; OpenProcess((PROCESS_CREATE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION), false, pid);if (hTarget &#x3D;&#x3D; NULL) &#123;cout &lt;&lt; &quot;e:Open process failed\n&quot;;__leave;&#125;&#x2F;&#x2F; 3 alloc memory for dll pathnamepszPathname &#x3D; (PWSTR)VirtualAllocEx(hTarget, NULL, pathnameLen, MEM_COMMIT, PAGE_READWRITE);if (pszPathname &#x3D;&#x3D; NULL) &#123;cout &lt;&lt; &quot;e:Alloc memory failed\n&quot;;__leave;&#125;else &#123;cout &lt;&lt; &quot;pathname addr: &quot; &lt;&lt; pszPathname &lt;&lt; endl;&#125;&#x2F;&#x2F; 4 write dll pathnameWriteProcessMemory(hTarget, (LPVOID)pszPathname, dllPathname, pathnameLen, &amp;byw);cout &lt;&lt; &quot;dll pathname(len, write len): &quot; &lt;&lt; pathnameLen &lt;&lt; &quot; &quot; &lt;&lt; byw &lt;&lt; std::endl;&#x2F;&#x2F; 5 get the real address of LoadLibraryW in Kernel32.dllHMODULE mh &#x3D; GetModuleHandleW(L&quot;Kernel32.dll&quot;);if (mh &#x3D;&#x3D; NULL) &#123;cout &lt;&lt; &quot;e:kernel\n&quot;;__leave;&#125;realAddr &#x3D; (PTHREAD_START_ROUTINE)GetProcAddress(mh, &quot;LoadLibraryW&quot;);&#x2F;&#x2F; 6 create a remote thread to call LoadLibraryW(dllPathname)hDll &#x3D; CreateRemoteThread(hTarget, NULL, 0, realAddr, pszPathname, 0, NULL);if (hDll &#x3D;&#x3D; NULL) &#123;cout &lt;&lt; &quot;e:create remote thread failed\n&quot;;__leave;&#125;else &#123;cout &lt;&lt; &quot;hDll: &quot; &lt;&lt; hDll &lt;&lt; endl;&#125;&#x2F;&#x2F; waitWaitForSingleObject(hDll, INFINITE);&#125;__finally &#123;&#x2F;&#x2F; cleanif (hDll !&#x3D; NULL) &#123;CloseHandle(hDll);&#125;if (hTarget !&#x3D; NULL) &#123;if (pszPathname !&#x3D; NULL)VirtualFreeEx(hTarget, pszPathname, 0, MEM_RELEASE);CloseHandle(hTarget);&#125;&#125;&#125;DWORD GetPidByName(WCHAR* name)&#123;HANDLE hsnapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);if (hsnapshot &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;printf_s(&quot;CreateToolhelp32Snapshot error!\n&quot;);return 0;&#125;PROCESSENTRY32 pe&#123;&#125;;pe.dwSize &#x3D; sizeof(PROCESSENTRY32);int flag &#x3D; Process32First(hsnapshot, &amp;pe);while (flag !&#x3D; 0) &#123;if (wcscmp(pe.szExeFile, name) &#x3D;&#x3D; 0) &#123;return pe.th32ProcessID;&#125;flag &#x3D; Process32Next(hsnapshot, &amp;pe);&#125;CloseHandle(hsnapshot);return 0;&#125;</code></pre><h2 id="ImageWalk"><a href="#ImageWalk" class="headerlink" title="ImageWalk"></a>ImageWalk</h2><p>遍历内存区块查询对应的信息</p><h3 id="MEMORY-BASIC-INFORMATION"><a href="#MEMORY-BASIC-INFORMATION" class="headerlink" title="MEMORY_BASIC_INFORMATION"></a>MEMORY_BASIC_INFORMATION</h3><p>AllocationBase：内存单元起始地址</p><p>BaseAddress：模块基地址</p><p>RegionSize：模块所以页面的大小</p><h3 id="C6262-堆栈溢出警告"><a href="#C6262-堆栈溢出警告" class="headerlink" title="C6262 堆栈溢出警告"></a>C6262 堆栈溢出警告</h3><p>C6262：函数使用了堆栈的“26300”个字节: 超过了 /analyze:stacksize ‘16384’。 请考虑将某些数据移到堆中。</p><p>其中有一个变量为 char szBuf[260 * 100]，260是路径长度最大值，100是个数，这里减少下个数避免这个警告。</p><p>其他解决方式如malloc或new就不再深究了。</p><h2 id="小笔记"><a href="#小笔记" class="headerlink" title="小笔记"></a>小笔记</h2><p>__try和try：据说Release模式下，如果没有throw模块，vc会优化掉try catch</p><p>线性地址：逻辑地址（偏移）+ 基地址</p><p>HMODULE：模块句柄，win32下通常是被载入模块的线性地址</p><p>MAX_PATH：宏常量，通常为260，代表编译器支持的最长路径长度</p><p>sz：string zero，表示以零结尾的字符串，即c字符串</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>C6262：<a href="https://blog.csdn.net/mxclxp/article/details/7991127">https://blog.csdn.net/mxclxp/article/details/7991127</a></p><p>随书代码下载页面：<a href="https://www.wintellect.com/windows-via-cc-by-jeffrey-richter-and-christopher-nasarre/">https://www.wintellect.com/windows-via-cc-by-jeffrey-richter-and-christopher-nasarre/</a></p><p>随书代码下载地址：<a href="https://www.wintellect.com/wp-content/uploads/2017/11/Windows-via-C-Code-January-29-2008.zip">https://www.wintellect.com/wp-content/uploads/2017/11/Windows-via-C-Code-January-29-2008.zip</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/dll/">dll</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/windows-via-c/">windows_via_c</category>
      
      
      <comments>https://windgodm.github.io/blog/post/winViaC-dll.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>geek20</title>
      <link>https://windgodm.github.io/blog/post/geek20.html</link>
      <guid>https://windgodm.github.io/blog/post/geek20.html</guid>
      <pubDate>Tue, 08 Dec 2020 09:48:04 GMT</pubDate>
      
      <description>2020年极客大挑战部分wp（除了web基本都有）</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="/blog/ctf_wp/geek20.html">geek challenge 20th</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/geek-challenge/">geek_challenge</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/pwn/">pwn</category>
      
      <category domain="https://windgodm.github.io/blog/tags/crypt/">crypt</category>
      
      <category domain="https://windgodm.github.io/blog/tags/misc/">misc</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      
      <comments>https://windgodm.github.io/blog/post/geek20.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
