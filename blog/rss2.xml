<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>BraveTroops</title>
    <link>https://windgodm.github.io/blog/</link>
    
    <atom:link href="https://windgodm.github.io/blog/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 18 Jan 2022 09:38:46 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>sctf21 BabyDriver 出题思路</title>
      <link>https://windgodm.github.io/blog/2021/12/26/sctf21-babydriver/</link>
      <guid>https://windgodm.github.io/blog/2021/12/26/sctf21-babydriver/</guid>
      <pubDate>Sun, 26 Dec 2021 04:00:00 GMT</pubDate>
      
      <description>sctf21 BabyDriver 出题思路</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="BabyDriver-出题思路"><a href="#BabyDriver-出题思路" class="headerlink" title="BabyDriver 出题思路"></a>BabyDriver 出题思路</h1><p>这题是和0x太上一起出的，他提供了题目的框架和内核通信部分的代码，我负责其余的实现</p><p><a href="https://github.com/0xTalShang">0xTalShang (0x太上) (github.com)</a></p><p><a href="https://github.com/SycloverTeam/SCTF2021">SycloverTeam/SCTF2021: SCTF 2021 (github.com)</a></p><p>有选手反馈R3部分出得不太好，确实没有很好的把驱动的考点和R3的加密结合在一起，下次加油吧</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>题目有一个R3的客户端<code>babydriver.exe</code>和一个驱动<code>sctf.sys</code></p><p>客户端会要求输入一个flag，并读取文件<code>key.bin</code>，然后对flag进行运算</p><p>运算的结果会传给驱动</p><p>驱动进行第二次运算，然后与目标值比较</p><p>客户端再向驱动查询比较结果是否正确</p><h3 id="babydriver-exe"><a href="#babydriver-exe" class="headerlink" title="babydriver.exe"></a>babydriver.exe</h3><p>客户端会要求输入一个flag，并读取文件<code>key.bin</code>。</p><p>flag的输入格式限制为只能用64个字符</p><p>然后对flag进行一个类似base64解密的过程，把输入的20个字节的flag转换成15字节的数据</p><p>这个过程按每两位的移动，拆分成了60个位移函数。一共有60*60共3600个函数用于移动。</p><p>程序根据<code>key.bin</code>决定使用哪些位移函数（实际上就是3600取60）。</p><p>每个位移函数会有一个<code>费用</code>，总<code>费用</code>必须为3100</p><h3 id="内核通信"><a href="#内核通信" class="headerlink" title="内核通信"></a>内核通信</h3><p>驱动程序会注册一个时间回调函数，客户端修改时间会触发该回调函数。</p><p>整个通讯流程是客户端把要传输的数据写入PE文件头，然后修改时间触发回调进入内核。回调函数再从PE头文件中读写数据，并做处理。</p><h3 id="sctf-sys"><a href="#sctf-sys" class="headerlink" title="sctf.sys"></a>sctf.sys</h3><p>驱动要手动启动，该驱动负责实现和注册回调函数，并对传输给内核的数据做校验。</p><p>驱动对传入数据的处理是将传入的15字节分成4组，每组进行一个模乘，比较结果是否为目标值</p><h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p>babydriver.exe中利用VEH添加了一些call 0和除0语句，以触发异常<br>其中除0异常用于跳转到位移函数</p><p>驱动中在接收数据后，会对后3字节做一些处理，将后3字节左移一个字节，然后填充一个10h，模乘校验完后再还原回去</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="key-bin"><a href="#key-bin" class="headerlink" title="key.bin"></a>key.bin</h3><p>位移函数格式如下（实际上是无参的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x = inBuf[iIdx] &gt;&gt; (iSh * <span class="number">2</span>);</span><br><span class="line">    x = x &amp; <span class="number">3</span>;</span><br><span class="line">    x = x &lt;&lt; (oSh * <span class="number">2</span>);</span><br><span class="line">    outBuf[oIdx] |= x;</span><br><span class="line">    totalC -= cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要提取3600个位移函数的参数</p><p>已知约束是cost的和必须为3100</p><p>根据题意得到隐含的约束条件是要选择其中的60个函数，每个函数会从输入中选2个位，复制到输出中，输入的偏移和输出的偏移不能相同</p><p>然后用动态规划算法找出解</p><p>和为3100且选择了60个的解有多个。但完全覆盖输入和输出所有位的解只有1个</p><p>这里给出python版本的参考代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ReadMM</span>(<span class="params">name, n, w</span>):</span></span><br><span class="line">    mm = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(w)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;&#123;&#125;_&#123;&#125;_&#123;&#125;.txt&#x27;</span>.<span class="built_in">format</span>(name, n, w), <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> line.split():</span><br><span class="line">                mm[i][j] = <span class="built_in">int</span>(w)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> mm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">msOrd2wsOrd</span>(<span class="params">ms_ord</span>):</span></span><br><span class="line"></span><br><span class="line">    a = ms[ms_ord][<span class="number">0</span>]*<span class="number">3</span>+ms[ms_ord][<span class="number">1</span>]</span><br><span class="line">    b = ms[ms_ord][<span class="number">2</span>]*<span class="number">4</span>+ms[ms_ord][<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> a * <span class="number">60</span> + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp3</span>(<span class="params">ii, ww</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ww &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mm3[ii][ww] != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> mm3[ii][ww]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># take ws[n]</span></span><br><span class="line">    <span class="keyword">if</span> ii == <span class="number">59</span>:</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(ii*<span class="number">60</span>, (ii+<span class="number">1</span>)*<span class="number">60</span>):</span><br><span class="line">            print(n)</span><br><span class="line">            new_w = ww - ws[n]</span><br><span class="line">            ans += dp3(ii-<span class="number">1</span>, new_w)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(ii*<span class="number">60</span>, (ii+<span class="number">1</span>)*<span class="number">60</span>):</span><br><span class="line">            new_w = ww - ws[n]</span><br><span class="line">            ans += dp3(ii-<span class="number">1</span>, new_w)</span><br><span class="line"></span><br><span class="line">    mm3[ii][ww] = ans</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">opos = [<span class="number">0</span>]*<span class="number">60</span></span><br><span class="line">cur_ans = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPath</span>(<span class="params">ii, ww</span>):</span></span><br><span class="line"></span><br><span class="line">    total_ans = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ii == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> oo <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>):</span><br><span class="line">            <span class="keyword">if</span> ws[oo] == ww:</span><br><span class="line">                total_ans = [cur_ans[:] + [oo]]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> total_ans</span><br><span class="line"></span><br><span class="line">    n = ii*<span class="number">60</span></span><br><span class="line">    <span class="keyword">for</span> oo <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>):</span><br><span class="line">        <span class="keyword">if</span> opos[oo]:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        new_w = ww - ws[n]</span><br><span class="line">        <span class="keyword">if</span> new_w &gt;= <span class="number">0</span> <span class="keyword">and</span> mm3[ii-<span class="number">1</span>][new_w] &gt; <span class="number">0</span>:</span><br><span class="line">            opos[oo] = <span class="number">1</span></span><br><span class="line">            cur_ans.append(n)</span><br><span class="line"></span><br><span class="line">            new_ans = findPath(ii-<span class="number">1</span>, new_w)</span><br><span class="line"></span><br><span class="line">            total_ans += new_ans</span><br><span class="line"></span><br><span class="line">            <span class="keyword">del</span> cur_ans[-<span class="number">1</span>]</span><br><span class="line">            opos[oo] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># continue</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total_ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = <span class="number">3100</span></span><br><span class="line">ms = ReadMM(<span class="string">&#x27;ms&#x27;</span>, <span class="number">3600</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">wsOrd2msOrd = [<span class="number">0</span>]*<span class="number">3600</span></span><br><span class="line">ws = [<span class="number">0</span>]*<span class="number">3600</span></span><br><span class="line"><span class="keyword">for</span> msOrd <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3600</span>):</span><br><span class="line">    wsOrd = msOrd2wsOrd(msOrd)</span><br><span class="line">    wsOrd2msOrd[wsOrd] = msOrd</span><br><span class="line">    ws[wsOrd] = ms[msOrd][<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1 dp</span></span><br><span class="line"></span><br><span class="line">mm3 = [[-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>)]</span><br><span class="line"><span class="keyword">for</span> ww <span class="keyword">in</span> <span class="built_in">range</span>(w+<span class="number">1</span>):</span><br><span class="line">    mm3[<span class="number">0</span>][ww] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> oo <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>):</span><br><span class="line">    mm3[<span class="number">0</span>][ws[oo]] = <span class="number">1</span></span><br><span class="line">dp3(<span class="number">59</span>, w)</span><br><span class="line">print(mm3[<span class="number">59</span>][w])</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2 dfs</span></span><br><span class="line"></span><br><span class="line">ansWsOrds = findPath(<span class="number">59</span>, w)[<span class="number">0</span>]</span><br><span class="line">ansMsOrds = [wsOrd2msOrd[<span class="built_in">ord</span>] <span class="keyword">for</span> <span class="built_in">ord</span> <span class="keyword">in</span> ansWsOrds]</span><br><span class="line">print(ansMsOrds)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3 key</span></span><br><span class="line"></span><br><span class="line">ans = [<span class="number">0</span>]*<span class="number">3600</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">ord</span> <span class="keyword">in</span> ansMsOrds:</span><br><span class="line">    ans[<span class="built_in">ord</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> ans:</span><br><span class="line">    s += <span class="built_in">str</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./key.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3600</span>, <span class="number">8</span>):</span><br><span class="line">        f.write(<span class="built_in">int</span>(s[i:i+<span class="number">8</span>][::-<span class="number">1</span>], <span class="number">2</span>).to_bytes(<span class="number">1</span>, <span class="string">&#x27;little&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="一元同余方程"><a href="#一元同余方程" class="headerlink" title="一元同余方程"></a>一元同余方程</h3><p>这个比较简单就不说了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>求出一元同余方程的解，得到变形base64的输出。然后求出key.bin得到base64的规则，逆推出输入。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/12/26/sctf21-babydriver/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《Windows Kernel Programming》 笔记 1~5 内核开发入门</title>
      <link>https://windgodm.github.io/blog/2021/12/24/wkp1-5/</link>
      <guid>https://windgodm.github.io/blog/2021/12/24/wkp1-5/</guid>
      <pubDate>Fri, 24 Dec 2021 04:00:00 GMT</pubDate>
      
      <description>《Windows Kernel Programming》 笔记 1~5 内核开发入门</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Windows-Kernel-Programming-笔记-1-5-内核开发入门"><a href="#Windows-Kernel-Programming-笔记-1-5-内核开发入门" class="headerlink" title="Windows Kernel Programming 笔记 1~5 内核开发入门"></a>Windows Kernel Programming 笔记 1~5 内核开发入门</h1><h2 id="1-windows内部概况"><a href="#1-windows内部概况" class="headerlink" title="1 windows内部概况"></a>1 windows内部概况</h2><p>描述一些Windows内部工作中最重要、最基本的概念，部分概念将在后面的章节做更详细的研究</p><h3 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h3><p>进程不运行（Processes dont’t run - processes manage），线程才执行代码</p><p>进程拥有以下内容：</p><ul><li>一个可执行程序（PE文件），包括代码和数据</li><li>私有的虚拟内存空间</li><li>主令牌（primary token），是一个对象，存储进程默认安全上下文</li><li>对象（事件、信号、文件）句柄表</li><li>一个或多个线程（没有线程的用户态进程一般情况下会被内核销毁）</li></ul><h3 id="1-2-虚拟内存"><a href="#1-2-虚拟内存" class="headerlink" title="1.2 虚拟内存"></a>1.2 虚拟内存</h3><p>每个进程拥有自己的<strong>虚拟、私有、线性地址</strong>空间<br>（该地址空间初始时几乎为空，然后pe、ntdll.dll开始被影射，接着是其他子系统dll）</p><p>32位进程默认地址空间<strong>2GB</strong>，设置pe中的<code>LARGEADDRESSAWARE</code>标志可以增加到<strong>3GB</strong>（32位系统）或<strong>4GB</strong>（64位系统）</p><p>64位进程默认地址空间<strong>128TB</strong>（win8之前是8TB）</p><p>虚拟内存被映射到物理内存（RAM）或临时驻留在文件中（如page file）<br>如果不在物理内存，则触发page fault异常，并或取数据到物理内存中</p><p><strong>页（page）</strong>是内存管理的单位，默认大小为<strong>4KB</strong></p><h4 id="页状态"><a href="#页状态" class="headerlink" title="页状态"></a>页状态</h4><p>虚拟内存中的页处于三种状态之一</p><ul><li>Free：未分配</li><li>Committed：已分配，通常映射到RAM或文件（例如page file）</li><li>Reserved：未分配，对cpu而言与Free相似，自动分配将不会使用该页<br>一个例子是线程栈（thread stack）</li></ul><h4 id="系统内存"><a href="#系统内存" class="headerlink" title="系统内存"></a>系统内存</h4><p>系统空间与进程无关</p><p>系统空间就是内核</p><h3 id="1-3-线程"><a href="#1-3-线程" class="headerlink" title="1.3 线程"></a>1.3 线程</h3><p>实际执行代码的是线程</p><p>线程拥有的最重要的内容：</p><ul><li>当前访问模式（用户或内核）</li><li>执行上下文</li><li>一个或两个栈（stack）</li><li>Thread Local Storage（TLS）</li><li>基本优先级和当前（动态）优先级</li><li>处理器关联信息</li></ul><p>线程最常处于的状态：</p><ul><li>Running：在逻辑处理器运行中</li><li>Ready：等待运行（所有处理器在忙或不可用）</li><li>Waiting：等待某个事件，事件触发就变成Ready</li></ul><p>括号中的数字是状态号：</p><p>Running(2) =&gt; Waiting(5) =&gt; Deferred Ready(7), Ready(1) =&gt; Running(2)</p><h4 id="1-3-1-线程栈"><a href="#1-3-1-线程栈" class="headerlink" title="1.3.1 线程栈"></a>1.3.1 线程栈</h4><p>线程至少有一个位于内核空间的栈（32位系统12KB，64位系统24KB）</p><p>用户态的线程还有一个位于所属进程空间的栈（默认上限1MB）</p><p>线程<code>Running</code>或<code>Ready</code>时，内核栈驻留在RAM</p><p>栈初始时会尽可能少提交页（最少一页），剩下的页设置为<code>Reserved</code>，而最后一个<code>Committed</code>的页的下一页设置为<code>PAGE_GUARD</code></p><h3 id="1-4-系统调用（又名系统服务）"><a href="#1-4-系统调用（又名系统服务）" class="headerlink" title="1.4 系统调用（又名系统服务）"></a>1.4 系统调用（又名系统服务）</h3><p>原标题：System Services (a.k.a. System Calls)</p><p>R3代码通过系统调用完成一些只能在R0下完成的功能，如分配内存、打开文件、创建线程等</p><p>大致流程是：<br>调用subsystem dll（如kernel32.dll）中的文档化api（如CreateFile）<br>进入NTDLL中的 Native Api（如NtCreateFile）<br>进入内核中的系统服务分发函数<br>进入Native Api对应的内核中的函数</p><p>Native Api将调用号存入eax然后进入r0的系统服务分发函数，eax实际是SSDT（System Service Dispatch Table）的下标</p><h3 id="1-5-通用系统架构"><a href="#1-5-通用系统架构" class="headerlink" title="1.5 通用系统架构"></a>1.5 通用系统架构</h3><p><img src="https://s4.ax1x.com/2022/01/18/70IBlR.png"></p><h3 id="1-6-句柄和对象"><a href="#1-6-句柄和对象" class="headerlink" title="1.6 句柄和对象"></a>1.6 句柄和对象</h3><p>对象被引用计数，当计数为0时才会被释放</p><p>句柄是进程的对象表的索引</p><blockquote><p>注意：返回值为句柄的函数，大多数失败时返回<code>0</code>。有些返回<code>INVALID_HANDLE_VALUE (-1)</code>，比如<code>CreateFile</code></p></blockquote><p>句柄值是4的倍数，0不是有效句柄值</p><h4 id="1-6-1-对象名"><a href="#1-6-1-对象名" class="headerlink" title="1.6.1 对象名"></a>1.6.1 对象名</h4><p>某些类型的对象可以有名称，可用于通过合适的 Open 函数按名称打开对象。 </p><p>用户模式调用 Create 函数按名称创建对象，如果存在，则仅打开现有对象。</p><p>winObj中显示的名称有时不是对象的真实名称：</p><ul><li>进程和线程显示ID</li><li>文件对象显示文件名（或设备名），因为共享的原因，无法通过文件名获得文件对象句柄</li><li>（注册表）键对象与注册表的路径一起显示，原因同文件对象</li><li>目录对象显示路径，目录不是文件系统对象，而是对象管理器目录，可通过Sysinternals WinObj查看</li><li>令牌对象名称与存储在令牌中的用户名一起显示</li></ul><h4 id="1-6-2-访问现有对象"><a href="#1-6-2-访问现有对象" class="headerlink" title="1.6.2 访问现有对象"></a>1.6.2 访问现有对象</h4><p>Process Explorer 的句柄视图中的访问列显示用于打开或创建句柄的访问掩码</p><p>Process Explorer中显示的引用数（References）不是实际引用数（outstanding references）</p><p>[windbg]中用<code>!trueref</code>获取实际引用数（actual reference）</p><h2 id="2-内核开发入门"><a href="#2-内核开发入门" class="headerlink" title="2 内核开发入门"></a>2 内核开发入门</h2><p>本章主要是关于准备内核开发所需的环境，包括开发和调试的工具以及环境配置</p><p>以及启动和运行内核驱动的知识</p><p>然后写一个可以加载和卸载的驱动</p><h3 id="驱动开发准备工作"><a href="#驱动开发准备工作" class="headerlink" title="驱动开发准备工作"></a>驱动开发准备工作</h3><p>首先按 2.1安装工具 完成安装，然后为驱动开发配置虚拟机（未包括内核调试的配置）</p><p><strong>安装无签名驱动</strong></p><p>如果驱动没有签名，安装驱动需要以该模式启动系统</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> testsigning on</span><br></pre></td></tr></table></figure><p><strong>显示内核调试信息</strong></p><p>在<code>HKLM\SYSTEM\CurrentControlSet\Control\Session Manager</code>添加一个名为<code>Debug Print Filter</code>的键<br>在键中添加一个<code>DWORD</code>，名为<code>DEFAULT</code>，值为<code>8</code></p><p><strong>虚拟机文件共享</strong></p><p>实际操作时，安装在虚拟机中（避免本机崩溃），需要共享项目的文件给虚拟机</p><p>共享本机的 vs解决方案文件夹 给虚拟机，名称为<code>MyDriver</code></p><p>虚拟机中的debug输出路径为：<code>\\vmware-host\Shared Folders\MyDriver\x64\Debug</code></p><p><strong>驱动调试工具</strong></p><p>安装完WDK后，把<code>C:\Program Files (x86)\Windows Kits\10\Tools\x64</code>这个目录复制到虚拟机中，这个是x64下的驱动开发调试工具，比如用于查看内存池的poolmon</p><h3 id="2-1-安装工具"><a href="#2-1-安装工具" class="headerlink" title="2.1 安装工具"></a>2.1 安装工具</h3><p>需要vs2019、windows 10 sdk（vs2019中安装）、windows 10 driver kit（WDK）</p><p>以及 Sysinternals，该工具包含debug view、process monitor等一系列有用的工具</p><blockquote><p>在实际编译中发现，新版本的vs驱动项目默认开启缓解Spectre 漏洞</p><p>可以在c/c++、代码生成中关闭该项，或在vs installer中安装对应工具</p></blockquote><h3 id="2-2-创建一个驱动工程"><a href="#2-2-创建一个驱动工程" class="headerlink" title="2.2 创建一个驱动工程"></a>2.2 创建一个驱动工程</h3><p>vs2019中选择创建一个<code>Empty WDM Driver</code>，创建完成后有个<code>inf</code>后缀的文件，暂时不需要，删除掉</p><h3 id="2-3-DriverEntry-和-Unload-Routines"><a href="#2-3-DriverEntry-和-Unload-Routines" class="headerlink" title="2.3 DriverEntry 和 Unload Routines"></a>2.3 DriverEntry 和 Unload Routines</h3><p>DriverEntry 是驱动的默认入口点</p><p>系统线程以<code>IRQL_PASSIVE_LEVEL</code>(0)调用 DriverEntry</p><p>DriverEntry函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">NTSTATUS</span><br><span class="line">DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath);</span><br></pre></td></tr></table></figure><p>一个简单的驱动（sample.cpp）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SampleUnload</span><span class="params">(_In_ PDRIVER_OBJECT DriverObject)</span> </span>&#123;</span><br><span class="line">UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">NTSTATUS</span><br><span class="line">DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) &#123;</span><br><span class="line">UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    </span><br><span class="line">DriverObject-&gt;DriverUnload = SampleUnload;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-安装驱动"><a href="#2-4-安装驱动" class="headerlink" title="2.4 安装驱动"></a>2.4 安装驱动</h3><p>安装驱动和安装用户态服务相似，需要调用Create Service API或使用工具</p><p>sc.exe（系统自带）是著名工具之一</p><p>安装驱动需要管理员权限</p><p>创建服务项：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> create sample <span class="built_in">type</span>= kernel binPath= <span class="string">&quot;\\vmware-host\Shared Folders\MyDriver\x64\Debug\sample.sys&quot;</span></span><br></pre></td></tr></table></figure><p>随后就能在注册表（regedit.exe）的<code>HKLM\System\CurrentControlSet\Services\Sample</code>中看到该项</p><blockquote><p>注册表项位置：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Sample</p><p>假设<code>binPath= c:\</code>，注册表项<code>ImagePath= \??\c:\</code></p><p>假设<code>binPaht= &quot;\\vmware-hots\&quot;</code>，注册表项<code>ImagePath= \??\UNC\vmware-hots\</code></p></blockquote><p>加载驱动（启动服务）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> <span class="built_in">start</span> sample</span><br></pre></td></tr></table></figure><p>在process explorer中，选择System进程，查看dll窗口，拉到最下面就能看到sample.sys</p><p>卸载驱动（停止服务）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> stop sample</span><br></pre></td></tr></table></figure><h3 id="2-5-简单跟踪（S1）"><a href="#2-5-简单跟踪（S1）" class="headerlink" title="2.5 简单跟踪（S1）"></a>2.5 简单跟踪（S1）</h3><p><code>KdPrint 宏</code>是<code>DbgPrint API</code>的包装</p><p>通过在每个函数开头加入<code>KdPrint((&quot;Debug messgae&quot;));</code>可以观察函数调用的发生</p><p>使用DebugView，选择capture Kernel可以看到内核调试信息</p><h3 id="2-6-练习：显示系统信息（E1）"><a href="#2-6-练习：显示系统信息（E1）" class="headerlink" title="2.6 练习：显示系统信息（E1）"></a>2.6 练习：显示系统信息（E1）</h3><p>创建一个驱动用于显示系统版本信息，使用<code>RtlGetVersion</code></p><p>code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get Version</span></span><br><span class="line">RTL_OSVERSIONINFOW versionInfo = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">versionInfo.dwOSVersionInfoSize = <span class="keyword">sizeof</span>(RTL_OSVERSIONINFOW);</span><br><span class="line">RtlGetVersion(&amp;versionInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print</span></span><br><span class="line">DbgPrint(<span class="string">&quot;[E1] Major:%d\n[E1] Minor:%d\n[E1] Build:%d&quot;</span>,</span><br><span class="line">versionInfo.dwMajorVersion,</span><br><span class="line">versionInfo.dwMinorVersion,</span><br><span class="line">versionInfo.dwBuildNumber);</span><br></pre></td></tr></table></figure><p>shell:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> create E1_OSVersion <span class="built_in">type</span>= kernel binPath= <span class="string">&quot;\\vmware-host\Shared Folders\MyDriver\x64\Debug\E1_OSVersion.sys&quot;</span></span><br><span class="line"><span class="built_in">sc</span> <span class="built_in">start</span> E1_OSVersion</span><br><span class="line"><span class="built_in">sc</span> stop E1_OSVersion</span><br></pre></td></tr></table></figure><h2 id="3-内核编程基础"><a href="#3-内核编程基础" class="headerlink" title="3 内核编程基础"></a>3 内核编程基础</h2><p>研究一些内核的API、结构和定义，以及一些驱动程序中的机制</p><h3 id="3-1-通用内核编程指南"><a href="#3-1-通用内核编程指南" class="headerlink" title="3.1 通用内核编程指南"></a>3.1 通用内核编程指南</h3><p>用户模式和内核模式调试的重要区别</p><table><thead><tr><th></th><th>用户模式</th><th>内核模式</th></tr></thead><tbody><tr><td>未处理异常</td><td>进程崩溃</td><td>系统崩溃</td></tr><tr><td>终止</td><td>当进程终止，所有内存和资源都会被自动释放</td><td>当驱动卸载，如果没有手动释放，会造成泄露直到重启</td></tr><tr><td>返回值</td><td>API错误有时候会忽略</td><td>应该不忽略任何错误</td></tr><tr><td>IRQL</td><td>总是 PASSIVE_LEVEL (0)</td><td>可能为更高</td></tr><tr><td>错误代码</td><td>通常只会影响本进程</td><td>影响整个系统</td></tr><tr><td>测试和调试</td><td>通常在开发机器上调试</td><td>需要双机调试</td></tr><tr><td>库（Lib）</td><td>可以使用C/C++库（如STL、boost）</td><td>大多数标准库无法使用</td></tr><tr><td>异常处理</td><td>可以使用C++异常或SEH</td><td>只能使用SEH</td></tr><tr><td>C++支持</td><td>完全的C++支持</td><td>不支持C++ runtime</td></tr></tbody></table><h4 id="3-1-1-未处理异常"><a href="#3-1-1-未处理异常" class="headerlink" title="3.1.1 未处理异常"></a>3.1.1 未处理异常</h4><p>未处理异常会导致蓝屏，原因是防止继续执行代码、对系统造成不可逆转的伤害</p><p>内核代码不应该跳过任何细节或错误检查</p><h4 id="3-1-2-终止"><a href="#3-1-2-终止" class="headerlink" title="3.1.2 终止"></a>3.1.2 终止</h4><p>如果驱动程序卸载时仍保留分配的内存或打开的内核句柄，这些资源不会自动释放，只会在下次系统启动时释放</p><p>原因是驱动程序可以分配一些缓冲区，然后将其传递给另一个与之合作的驱动程序</p><h4 id="3-1-3-函数返回值"><a href="#3-1-3-函数返回值" class="headerlink" title="3.1.3 函数返回值"></a>3.1.3 函数返回值</h4><p>忽略内核API的返回值很危险，应该总是检查返回值</p><h4 id="3-1-4-IRQL"><a href="#3-1-4-IRQL" class="headerlink" title="3.1.4 IRQL"></a>3.1.4 IRQL</h4><p>中断请求级（Interrupt Request Level, IRQL）通常为0</p><p>用户模式下始终为0，内核模式下大部分时间为0</p><h4 id="3-1-5-C-使用"><a href="#3-1-5-C-使用" class="headerlink" title="3.1.5 C++使用"></a>3.1.5 C++使用</h4><p>没有C++ runtime</p><p>一些不支持的C++特性：</p><ul><li>不支持<code>new</code>和<code>delete</code>，这正常是在用户模式堆分配的</li><li>不会调用具有非默认构造函数的全局变量<ul><li>避免在构造函数中使用代码，创建一些要显式调用的Init函数</li><li>仅将指针分配为全局变量，动态创建实例</li></ul></li><li>不支持C++异常处理（<code>try</code>、<code>catch</code>、<code>throw</code>）</li><li>不可使用标准C++库，如<code>std::vector&lt;&gt;</code>、<code>std::wstring</code>等</li></ul><p>一些支持的C++特性：</p><ul><li><code>nullptr</code>关键字</li><li><code>auto</code>关键字</li><li>模板将在有意义时使用</li><li>重载new 和delete 运算符</li><li>构造函数和析构函数，尤其是用于构建 RAII 类型</li></ul><h4 id="3-1-6-测试和调试"><a href="#3-1-6-测试和调试" class="headerlink" title="3.1.6 测试和调试"></a>3.1.6 测试和调试</h4><p>内核调试需要双机调试，一台作为调试者、另一台作为被调试者运行驱动程序</p><h3 id="3-2-Debug-vs-Release-生成"><a href="#3-2-Debug-vs-Release-生成" class="headerlink" title="3.2 Debug vs. Release 生成"></a>3.2 Debug vs. Release 生成</h3><p>内核术语是 Checked（Debug）和 Free（Release）</p><p>Debug意味着可以使用DBG符号</p><h3 id="3-3-内核API"><a href="#3-3-内核API" class="headerlink" title="3.3 内核API"></a>3.3 内核API</h3><p>内核API常用前缀的意义：</p><ul><li>Ex：一般执行函数</li><li>Ke：一般内核函数</li><li>Mm：内存管理</li><li>Rtl：一般运行时库</li><li>FsRtl：文件系统运行时库</li><li>Flt：文件系统迷你过滤库</li><li>Ob：对象管理</li><li>Io：I/O管理</li><li>Se：安全</li><li>Ps：进程结构</li><li>Po：电源管理</li><li>Wmi：Windows管理工具</li><li>Zw：native API 包装</li><li>Hal：硬件抽象层</li><li>Cm：配置管理器（注册表）</li></ul><p>Nt前缀的内核函数对应NtDll.Dll的函数，会根据 KTHREAD 结构的标记（调用者是否来自内核）对参数进行检查</p><p>Zw前缀的内核函数先将调用者模式设为<code>KernelMode(0)</code>，然后调用Nt前缀的内核函数</p><h3 id="3-4-函数和错误代码"><a href="#3-4-函数和错误代码" class="headerlink" title="3.4 函数和错误代码"></a>3.4 函数和错误代码</h3><p>可以在<code>ntstatus.h</code>中找到<code>NTSTATUS</code>值的定义</p><p>大多数代码并不关心错误具体是什么，仅测试最高位即可，可以使用<code>NT_SUCCESS</code>宏</p><p>当返回到用户层时，会由<code>STATUS_xxx</code>转成<code>ERROR_yyy</code>，用户模式通过GetLastError可以得到这些错误</p><p>通常遇到错误时，会返回相同的 NTSTATUS 到调用函数</p><h3 id="3-5-字符串"><a href="#3-5-字符串" class="headerlink" title="3.5 字符串"></a>3.5 字符串</h3><p>内核使用<code>UNICODE_STRING</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">USHORT Length;</span><br><span class="line">USHORT MaximumLength;</span><br><span class="line">PWCH Buffer;</span><br><span class="line">&#125; UNICODE_STRING;</span><br><span class="line"><span class="keyword">typedef</span> UNICODE_STRING *PUNICODE_STRING;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> UNICODE_STRING *PCUNICODE_STRING;</span><br></pre></td></tr></table></figure><p><code>Length</code>是字符串的字节数（不包括\x00\x00结束符）</p><p><code>MaximumLength</code>是不需要重新分配内存的情况下、字符串字节数上限</p><p>需要注意的是，UNICODE_STRING并<strong>不总是有\x00\x00结尾</strong></p><p>一些常用的字符串操作函数：</p><ul><li>RtlInitUnicodeString</li><li>RtlCopyUnicodeString</li><li>RtlCompareUnicodeString </li><li>RtlEqualUnicodeString </li><li>RtlAppendUnicodeStringToString</li><li>RtlAppendUnicodeToString</li></ul><h3 id="3-6-动态内存分配（S2）"><a href="#3-6-动态内存分配（S2）" class="headerlink" title="3.6 动态内存分配（S2）"></a>3.6 动态内存分配（S2）</h3><p>内核提供两种通用内存池（general memory pools）给驱动使用：</p><ul><li>页池（Paged pool）：可能会被换出（paged out）的内存池</li><li>非页池（Non Paged Pool）：一直在RAM中的内存池</li></ul><p>枚举类型<code>POOL_TYPE</code>表示池类型，只有三种是可以用于驱动的：<br><code>PagedPool</code>、<code>NonPagedPool</code>、<code>NonPagedPoolNx</code><br>（non-page pool没有可执行权限）</p><p>常用内存池函数：</p><ul><li>ExAllocatePool（已过时，将被下面的函数取代）</li><li>ExAllocatePoolWithTag</li><li>ExAllocatePoolWithQuotaTag</li><li>ExFreePool</li></ul><p>tag是4字节的值</p><p>可以在PoolMon（WDK的Windows Kits中）中观察到有tag的内存池（tag以大端序字符串显示）</p><p>给ustring分配页池内存：</p><p>code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING strA;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="comment">// allocate</span></span><br><span class="line">strA.Buffer = (WCHAR*)ExAllocatePoolWithTag(PagedPool,</span><br><span class="line">length, &#x27;dcba&#x27;);</span><br><span class="line"><span class="keyword">if</span> (strA.Buffer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    KdPrint((<span class="string">&quot;Failed to allocate memory\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">&#125;</span><br><span class="line">strA.MaximumLength = length;</span><br></pre></td></tr></table></figure><p>shell:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> create S2_DynMemAlloc <span class="built_in">type</span>= kernel binPath= <span class="string">&quot;\\vmware-host\Shared Folders\MyDriver\x64\Debug\S2_DynMemAlloc.sys&quot;</span></span><br><span class="line"><span class="built_in">sc</span> <span class="built_in">start</span> S2_DynMemAlloc</span><br><span class="line"><span class="built_in">sc</span> stop S2_DynMemAlloc</span><br></pre></td></tr></table></figure><h3 id="3-7-链表"><a href="#3-7-链表" class="headerlink" title="3.7 链表"></a>3.7 链表</h3><p>内核使用循环双向链表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span></span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY;</span><br></pre></td></tr></table></figure><p><code>CONTAINING_RECORD</code>宏执行适当的偏移计算并转换为实际数据类型<br><code>CONTAINING_RECORD(pvoid, type, entry_member_name)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyDataItem</span> &#123;</span></span><br><span class="line">    <span class="comment">// some data members</span></span><br><span class="line">    LIST_ENTRY Link;</span><br><span class="line">    <span class="comment">// more data members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyDataItem* <span class="title">GetItem</span><span class="params">(LIST_ENTRY* pEntry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> CONTAINING_RECORD(pEntry, MyDataItem, Link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用链表函数（时间复杂度都是常数）：</p><ul><li>InitializeListHead</li><li>InsertHeadList</li><li>InsertTailList</li><li>IsListEmpty</li><li>RemoveHeadList</li><li>RemoveTailList</li><li>RemoveEntryList</li><li>ExInterlockedInsertHeadList</li><li>ExInterlockedInsertTailList</li><li>ExInterlockedRemoveHeadList</li></ul><p>后三个关于自旋锁，在第6章详细讨论</p><h3 id="3-8-驱动对象（The-Driver-Object）"><a href="#3-8-驱动对象（The-Driver-Object）" class="headerlink" title="3.8 驱动对象（The Driver Object）"></a>3.8 驱动对象（The Driver Object）</h3><p>常用major function代码：</p><ul><li>IRP_MJ_CREATE (0) </li><li>IRP_MJ_CLOSE (2)</li><li>IRP_MJ_READ (3) </li><li>IRP_MJ_WRITE (4) </li><li>IRP_MJ_DEVICE_CONTROL (14) </li><li>IRP_MJ_INTERNAL_DEVICE_CONTROL (15)</li><li>IRP_MJ_PNP (31) </li><li>IRP_MJ_POWER (22)</li></ul><p><code>MajorFunction</code>数组由内核初始化指向内核内部例程<code>IopInvalidDeviceRequest</code>，该例程直接返回失败，表示不支持该操作</p><h3 id="3-9-设备对象（Device-Objects）"><a href="#3-9-设备对象（Device-Objects）" class="headerlink" title="3.9 设备对象（Device Objects）"></a>3.9 设备对象（Device Objects）</h3><p>驱动通过设备与r3代码通信，驱动应该至少创建一个设备对象并为其命名</p><p>CreateFile可以打开设备，第一个参数为设备对象名称</p><p>打开文件或设备的句柄会创建内核结构 FILE_OBJECT 的实例，这是个半文档化的结构。 </p><p>更准确的说，CreteFile接受一个<code>symbolic link</code>（符号链接）</p><p>对象管理器中名为<code>??</code>的目录下的符号链接都可被用户模式代码通过CreateFile或Createfile2调用</p><p>可以通过WinObj查看（WinObj中目录名为<code>Global??</code>）</p><p>使用符号链接的CreateFile的文件名（第一个参数），必须加上前缀<code>\\.\</code>（c++中是<code>&quot;\\\\.\\&quot;</code>）</p><p>如果创建了多个设备对象，将形成一个单向链表，添加设备时是头插法，所以第一个创建的设备在链表的最后</p><h2 id="4-驱动从头到尾（Driver-from-Start-to-Finish）（S3）"><a href="#4-驱动从头到尾（Driver-from-Start-to-Finish）（S3）" class="headerlink" title="4 驱动从头到尾（Driver from Start to Finish）（S3）"></a>4 驱动从头到尾（Driver from Start to Finish）（S3）</h2><p>将完成一个完整的驱动及客户端程序，利用驱动完成只能在内核模式下完成的功能（设置任意级别的线程优先级）</p><h3 id="4-1-绪论"><a href="#4-1-绪论" class="headerlink" title="4.1 绪论"></a>4.1 绪论</h3><p>线程优先级 = 进程优先级 + 相对线程优先级</p><p>用户模式下，设置进程优先级可以用<code>SetPriorityClass</code>，共有6个级别<br>设置相对线程优先级可以用<code>SetThreadPriority</code>，共有7个级别</p><p>下面是线程优先级合法值的表（通过windows api设置），据别的书说是个未文档化的东西，windows不建议开发时考虑线程优先级，该表的值随windows版本变化可能发生改变</p><table><thead><tr><th>进程优先级</th><th>-Sat</th><th>-2</th><th>-1</th><th>0</th><th>+1</th><th>+2</th><th>+sat</th></tr></thead><tbody><tr><td>Idle(low)</td><td>1</td><td></td><td></td><td>4</td><td></td><td></td><td>15</td></tr><tr><td>Below Normal</td><td>1</td><td></td><td></td><td>6</td><td></td><td></td><td>15</td></tr><tr><td>Normal</td><td>1</td><td></td><td></td><td>8</td><td></td><td></td><td>15</td></tr><tr><td>Above Normal</td><td>1</td><td></td><td></td><td>10</td><td></td><td></td><td>15</td></tr><tr><td>High</td><td>1</td><td></td><td></td><td>13</td><td></td><td></td><td>15</td></tr><tr><td>Real-time</td><td>16</td><td></td><td></td><td>24</td><td></td><td></td><td>31</td></tr></tbody></table><p>进程优先级枚举：级别+<code>_PRIORITY_CLASS</code></p><p>线程优先级枚举：<code>THREAD_PRIORITY_</code>+级别</p><h3 id="4-2-驱动初始化"><a href="#4-2-驱动初始化" class="headerlink" title="4.2 驱动初始化"></a>4.2 驱动初始化</h3><p>大多数驱动需要在DriverEntry中做如下操作：</p><ul><li>设置Unload例程</li><li>设置驱动支持的调度例程</li><li>创建一个设备对象</li><li>创建一个指向设备对象的符号链接</li></ul><p>所有驱动必须支持<code>IRP_MJ_CREATE</code>和<code>IRP_MJ_CLOSE</code>，不然无法打开一个驱动的设备的句柄，通常这两个调度例程是相同的</p><p>调度例程的函数原型：<code>NTSTATUS Function(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)</code></p><h4 id="4-2-1-将信息传给驱动"><a href="#4-2-1-将信息传给驱动" class="headerlink" title="4.2.1 将信息传给驱动"></a>4.2.1 将信息传给驱动</h4><p>用户模式客户端可用的三个基础函数：<code>WriteFile</code>、<code>ReadFile</code>、<code>DeviceIoControl</code></p><h4 id="4-2-2-客户端-驱动程序通信协议"><a href="#4-2-2-客户端-驱动程序通信协议" class="headerlink" title="4.2.2 客户端/驱动程序通信协议"></a>4.2.2 客户端/驱动程序通信协议</h4><p>必须使用<code>CTL_CODE</code>宏来构建控制代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTL_CODE( DeviceType, Function, Method, Access ) (                 \</span></span><br><span class="line">    ((DeviceType) &lt;&lt; <span class="number">16</span>) | ((Access) &lt;&lt; <span class="number">14</span>) | ((Function) &lt;&lt; <span class="number">2</span>) | (Method) \</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>DeviceType：设备类型标识，<code>FILE_DEVICE_xxx</code>，第三方应以0x8000开头</li><li>Function：指示特定操作的升序数字，第三方应该以0x800开头</li><li>Method：指示客户端提供的输入和输出缓冲区如何传递给驱动程序（将在第6章详细讨论）</li><li>Access：指示对驱动来说这个操作是什么？</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_DEVICE 0x800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_MY_OP CTL_CODE(\</span></span><br><span class="line">MY_DEVICE, <span class="number">0x800</span>, METHOD_NEITHER, FILE_ANY_ACCESS)</span><br></pre></td></tr></table></figure><h4 id="4-2-3-创建一个设备对象"><a href="#4-2-3-创建一个设备对象" class="headerlink" title="4.2.3 创建一个设备对象"></a>4.2.3 创建一个设备对象</h4><p><strong>创建设备名：</strong></p><p>在创建一个设备对象前，需要先创建一个<code>UNICODE_STRING</code>存储内部设备名称</p><p>下面是两种初始化方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plan A</span></span><br><span class="line">UNICODE_STRING devName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\YourName&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// plan B</span></span><br><span class="line">UNICODE_STRING devName;</span><br><span class="line">RtlInitUnicodeString(&amp;devName, <span class="string">L&quot;\\Device\\YourName&quot;</span>);</span><br></pre></td></tr></table></figure><p>设备名称需要在设备对象管理器目录下</p><p>（RtlInitUnicodeString函数内部字符串的长度，RTL_CONSTANT_STRING宏在编译时计算长度）</p><p><strong>创建设备对象：</strong></p><p>创建设备对象需要调用<code>IoCreateDevice</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCreateDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ PDRIVER_OBJECT DriverObject,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ ULONG DeviceExtensionSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_opt_ PUNICODE_STRING DeviceName,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ DEVICE_TYPE DeviceType,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ ULONG DeviceCharacteristics,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ BOOLEAN Exclusive,</span></span></span><br><span class="line"><span class="function"><span class="params">    _Outptr_ PDEVICE_OBJECT *DeviceObject)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>创建设备完整示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING devName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\DEVICE\\devName&quot;</span>);</span><br><span class="line">PDEVICE_OBJECT devObj;</span><br><span class="line">status = IoCreateDevice(</span><br><span class="line">    DriverObject,        <span class="comment">// our driver object</span></span><br><span class="line">    <span class="number">0</span>,                   <span class="comment">// no need for extra bytes</span></span><br><span class="line">    &amp;devName,            <span class="comment">// the device name</span></span><br><span class="line">    FILE_DEVICE_UNKNOWN, <span class="comment">// device type</span></span><br><span class="line">    <span class="number">0</span>,                   <span class="comment">// characteristics flags</span></span><br><span class="line">    FALSE,               <span class="comment">// not exclusive</span></span><br><span class="line">    &amp;devObj              <span class="comment">// the resulting pointer</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    KdPrint((<span class="string">&quot;[] Failed to create device object (0x%08X)\n&quot;</span>, status));</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建符号链接：</strong></p><p>需要创建一个指向设备的符号链接，供r3调用</p><p>同样需要先创建一个字符串作为符号链接对象名称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING symLink = RTL_CONSTANT_STRING(<span class="string">L&quot;\\??\\symLinkName&quot;</span>);</span><br><span class="line">status = IoCreateSymbolicLink(&amp;symLink, &amp;devName);</span><br><span class="line"><span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">KdPrint((<span class="string">&quot;[] Failed to create symbolic link (0x%08X)\n&quot;</span>, status));</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：资源释放</strong></p><p>上面创建的字符串会自动释放（好像在函数的栈中）？但对象不会，需要（在unload例程中）手动删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unload</span><span class="params">(_In_ PDRIVER_OBJECT DriverObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// delete symbolic link</span></span><br><span class="line">    UNICODE_STRING symLink = RTL_CONSTANT_STRING(<span class="string">L&quot;\\??\\symLinkName&quot;</span>);</span><br><span class="line">    IoDeleteSymbolicLink(&amp;symLink);</span><br><span class="line">    <span class="comment">// delete device object</span></span><br><span class="line">    IoDeleteDevice(DriverObject-&gt;DeviceObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-客户端代码"><a href="#4-3-客户端代码" class="headerlink" title="4.3 客户端代码"></a>4.3 客户端代码</h3><p>将用<code>CTL_CODE</code>构造的控制代码放到一个头文件中，供驱动代码和用户模式客户端代码同时使用</p><p>通过符号链接获驱动的设备的句柄</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    HANDLE hDevice = CreateFile(<span class="string">L&quot;\\\\.\\symLinkName&quot;</span>, GENERIC_WRITE,</span><br><span class="line">        FILE_SHARE_WRITE, <span class="literal">nullptr</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE)</span><br><span class="line">        <span class="keyword">return</span> Error(<span class="string">&quot;Failed to open device&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Error</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s (error=%d)\n&quot;</span>, msg, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-Create和Close调度例程"><a href="#4-4-Create和Close调度例程" class="headerlink" title="4.4 Create和Close调度例程"></a>4.4 Create和Close调度例程</h3><p>该例程什么都不用做，直接返回成功即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PriorityBoosterCreateClose</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span> </span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DeviceObject);</span><br><span class="line">    </span><br><span class="line">    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">    Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    IoCompleteRequest(Irp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IRP是半文档化结构，通常来自运行中的管理器：I/O Manager, Plug &amp; Play Manager or Power Manager</p><p>对驱动程序的每个请求总是包装在 IRP 中</p><p>IRP中有一个或多个<code>IO_STACK_LOCATION</code>结构</p><p>为了完成IRP，需要调用<code>IoCompleteRequest</code>，这个函数做很多东西，基本上理解为将IRP传播回创建者（通常是I/O管理器），然后由管理器通知客户端操作完成</p><h3 id="4-5-DeviceIoControl调度例程"><a href="#4-5-DeviceIoControl调度例程" class="headerlink" title="4.5 DeviceIoControl调度例程"></a>4.5 DeviceIoControl调度例程</h3><p>调用<code>IoGetCurrentIrpStackLocation</code>获取当前设备对应的<code>IO_STACK_LOCATION</code></p><p><code>IO_STACK_LOCATION</code>中有控制代码、输入输出buffer指针等</p><blockquote><p>调度例程运行在调用该例程的用户模式进程的上下文中</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD threadId;</span><br><span class="line">PETHREAD Thread;</span><br><span class="line">status = PsLookupThreadByThreadId(ULongToHandle(threadId), &amp;Thread);</span><br></pre></td></tr></table></figure><p>使用<code>ULongToHandle</code>（这实际上只是个casting）将pid转换成<code>HANDLE</code></p><p>线程和进程存在一个全局私有内核句柄表，句柄的“值”实际上就是ID</p><p>（HANDLE在64位系统是64位，线程ID始终是32位）</p><h3 id="4-6-安装和测试"><a href="#4-6-安装和测试" class="headerlink" title="4.6 安装和测试"></a>4.6 安装和测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sc create S3_PriorityBooster type&#x3D; kernel binPath&#x3D; &quot;\\vmware-host\Shared Folders\MyDriver\x64\Debug\S3_PriorityBooster.sys&quot;</span><br><span class="line">sc start S3_PriorityBooster</span><br><span class="line">sc stop S3_PriorityBooster</span><br><span class="line">sc delete S3_PriorityBooster</span><br></pre></td></tr></table></figure><p>start后可以在WinObj中的<code>Driver</code>目录下看到驱动、<code>GLOBAL??</code>目录下看到符号链接</p><p>可以在Process Explorer中查看进程的pid以及其线程的动态优先级</p><h2 id="5-调试"><a href="#5-调试" class="headerlink" title="5 调试"></a>5 调试</h2><p>关于使用WinDbg进行调试</p><h3 id="5-1-windows的调试工具"><a href="#5-1-windows的调试工具" class="headerlink" title="5.1 windows的调试工具"></a>5.1 windows的调试工具</h3><p>四个调试器：</p><ul><li>Cdb 和 Ntsd 是用户模式调试器，可以附加到进程上，是命令行界面，没有什么大的区别</li><li>Kd 是内核调试器，提供命令行界面，可以附加到本地内核或其他机器</li><li>WinDbg 是有图形化界面的调试器，可以调试用户和内核模式</li></ul><blockquote><p>WinDbg Preview是WinDbg的“最新版”，解决了一些WinDbg上的bug</p></blockquote><p>这些调试器都是基于<code>DbgEng.Dll</code></p><h3 id="5-2-WinDbg简介"><a href="#5-2-WinDbg简介" class="headerlink" title="5.2 WinDbg简介"></a>5.2 WinDbg简介</h3><p>虽然有GUI，实际上还是命令行，所有UI操作都会转成命令，显示在命令行窗口上</p><p>WinDbg支持三种类型的命令：</p><ul><li>标准命令(Intrinsic)：内置在调试器中，在被调试的目标上运行</li><li>元命令(Meta)：以<code>.</code>开头，作用于调试器(debugging process)本身，而不是直接作用于被调试目标</li><li>拓展命令：以<code>!</code>开头，提供调试器大部分功能，都在拓展DLL中实现</li></ul><h4 id="教程：用户模式调试基础"><a href="#教程：用户模式调试基础" class="headerlink" title="教程：用户模式调试基础"></a>教程：用户模式调试基础</h4><p><strong>符号信息：</strong></p><p>设置符号的方法1：<code>.symfix</code></p><p>设置符号的方法2：设置环境变量<br><code>_NT_SYMBOL_PATH</code>=<code>SRV*c:\Symbols*http://msdl.microsoft.com/download/symbols</code></p><p><code>lm</code>：显示进程加载的模块，以及各模块是否加载了符号</p><p><code>.reload /f modulename.dll</code>：强制加载模块的符号</p><p><code>!sym noisy</code>：记录符号加载尝试的详细信息</p><p><strong>线程：</strong></p><p><code>~</code>：显示调试进程中所有线程的信息<br>线程信息前的<code>.</code>表示当前线程，<code>#</code>表示触发中断的线程<br>输入提示冒号右边的数字是当前线程的索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0  Id: 874c.18068 Suspend: 1 Teb: 00000001&#96;2229d000 Unfrozen</span><br><span class="line">[下标] Id: [PID].[TID] Suspend: [挂起计数] Teb: [TEB地址] [是否冻结]</span><br></pre></td></tr></table></figure><p><code>~ns</code>：切换到索引为n的线程<br>可以组合命令<code>~nk</code>，这样可以在不切换线程的情况下，在别的线程执行操作（这里是显示别的线程的调用堆栈）</p><p><code>k</code>：当前线程的调用堆栈（stack trace）</p><p><code>!teb</code>：查看TEB的部分信息，默认当前线程的</p><p><strong>进制转换：</strong></p><p>16转10：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; ? 874c</span><br><span class="line">Evaluate expression: 34636 &#x3D; 0000874c</span><br></pre></td></tr></table></figure><p>10转16：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; ? 0n34636</span><br><span class="line">Evaluate expression: 34636 &#x3D; 0000874c</span><br></pre></td></tr></table></figure><p><strong>数据或结构的显示：</strong></p><p><code>dt [type]</code>：显示数据结构的定义（如显示_TEB：<code>dt ntdll!_teb</code>）</p><p><code>dt [type] [addr]</code>：显示数据结构的数据（如显示某个_TEB：<code> dt ntdll!_teb 000000`012229d000</code>）</p><p><code>r [reg]</code>：读取寄存器（如读取rcx：<code>r rcx</code>）</p><p><code>d&#123;a|b|c|d|D|f|p|q|u|w|W&#125;</code>：以指定类型显示指定地址的数据<br>a：ascii字符<br>b,w,d,q：字节<br>u：unicode<br>f：单精浮点<br>D：双精浮点</p><p><code>u</code>：显示反汇编，默认8句汇编指令</p><p><code>!error [error_code]</code>：显示错误信息</p><p><strong>断点和运行：</strong></p><p><code>bp [symbol]</code>：设置断点（如CreateFile：<code>bp kernel32!createfilew</code>）</p><p><code>bl</code>：显示当前设置的断点</p><p><code>bd</code>：禁用断点，禁用所有断点：<code>bd *</code></p><p><code>bc</code>：删除断点</p><p><code>g</code>(F5)：运行直到断点</p><p><code>p</code>(F10)：步过</p><p><code>t</code>(F11)：步进</p><h3 id="5-3-内核调试（本地）"><a href="#5-3-内核调试（本地）" class="headerlink" title="5.3 内核调试（本地）"></a>5.3 内核调试（本地）</h3><h4 id="本地内核调试"><a href="#本地内核调试" class="headerlink" title="本地内核调试"></a>本地内核调试</h4><p>修改启动项：<code>bcdedit /debug on</code></p><h4 id="本地内核调试教程"><a href="#本地内核调试教程" class="headerlink" title="本地内核调试教程"></a>本地内核调试教程</h4><p><code>!process 0 0</code>：显示所有进程的基本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; !process 0 0</span><br><span class="line">**** NT ACTIVE PROCESS DUMP ****</span><br><span class="line">PROCESS ffff8d0e682a73c0</span><br><span class="line">    SessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000</span><br><span class="line">    DirBase: 001ad002 ObjectTable: ffffe20712204b80 HandleCount: 9542.</span><br><span class="line">    Image: System</span><br><span class="line">    </span><br><span class="line">(truncated)</span><br></pre></td></tr></table></figure><ul><li>PROCESS旁边的地址：EPROCESS的地址</li><li>SessionId：进程所处的对话</li><li>Cid：pid</li><li>Peb：PEB地址（在用户模式地址空间）</li><li>ParentCid：父进程pid</li><li>DirBase：进程主页目录的物理地址（x32是PDPT基址、x64是PML4基址）</li><li>ObjectTable：指向进程的私有句柄表的指针 </li><li>HandleCount：进程中的句柄数</li><li>Image：可执行文件名称，或与可执行文件无关的特殊进程名称 </li></ul><p><code>!process</code>指令后第一个数字是筛选特定进程，0表示所有进程；第二个数字是细节掩码，0表示最少细节；第三个参数是筛选可执行文件</p><p><code>.process /p [EPROCESS]</code>：切换到指定进程</p><p>peb在用户模式地址空间中，查看peb需要先设置正确的用户模式进程环境</p><p>不切换的做法：<code>.process /p ffff8d0e849df080; !peb e8a8c9c000</code></p><p>调用堆栈中，nt前缀表示内核</p><p><code>.reload /user</code>：加载用户模式符号</p><p>其余常用/有趣的内核模式调试指令：</p><ul><li><code>!pcr</code>：显示指定为附加索引的处理器的进程控制区域 (PCR)（如果未指定索引，则默认显示处理器 0）</li><li><code>!vm</code>：显示系统和进程的内存统计信息</li><li><code>!running</code>：显示有关在系统上所有处理器上运行的线程的信息</li></ul><h3 id="5-4-完全内核调试（双机）"><a href="#5-4-完全内核调试（双机）" class="headerlink" title="5.4 完全内核调试（双机）"></a>5.4 完全内核调试（双机）</h3><p>完全内核调试需要”双机“</p><p>最好的连接方式是通过网络，这需要主机和被调试目标系统版最少为Win8</p><p>另外一种方法是COM串口，大多数虚拟机支持虚拟串口而不需要真实（物理的）串口线</p><p>详细配置方式略过</p><h4 id="配置目标机器"><a href="#配置目标机器" class="headerlink" title="配置目标机器"></a>配置目标机器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdedit &#x2F;debug on</span><br><span class="line">bcdedit &#x2F;dbgsettings serial debugport:1 baudrate:115200</span><br></pre></td></tr></table></figure><h4 id="配置主机"><a href="#配置主机" class="headerlink" title="配置主机"></a>配置主机</h4><p>调试器需要设置调试端口映射和命名管道，与虚拟机上的相同</p><p>输入提示kd左边的数字是引起中断的处理器的索引</p><h3 id="5-5-内核驱动调试教程"><a href="#5-5-内核驱动调试教程" class="headerlink" title="5.5 内核驱动调试教程"></a>5.5 内核驱动调试教程</h3><p>可以设置未来断点（在运行程序前设置断点）</p><p>如设置驱动prioritybooster的入口点：<code>bu prioritybooster!driverentry</code></p><p>可以设置只在指定进程上中断：<code>bp /p [EPROCESS] [symbol]</code><br>如：<code> bp /p ffffdd06042e4080 prioritybooster!priorityboosterdevicecontrol</code></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/kernel/">kernel</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wkp/">wkp</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/12/24/wkp1-5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《逆向工程实战》1.7练习 反编译windows内核例程</title>
      <link>https://windgodm.github.io/blog/2021/11/08/practicalre1-7/</link>
      <guid>https://windgodm.github.io/blog/2021/11/08/practicalre1-7/</guid>
      <pubDate>Mon, 08 Nov 2021 14:07:00 GMT</pubDate>
      
      <description>《逆向工程实战》1.7练习，反编译windows内核例程</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="《逆向工程实战》1-7-练习-反编译windows内核例程"><a href="#《逆向工程实战》1-7-练习-反编译windows内核例程" class="headerlink" title="《逆向工程实战》1.7 练习 反编译windows内核例程"></a>《逆向工程实战》1.7 练习 反编译windows内核例程</h1><p>例程选取自win10 x64 21h1</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>每个例程反编译的知识点如下：</p><ul><li><p>KeInitializeDpc：结构体赋值，纯拷贝</p></li><li><p>KeInitializeApc：结构体赋值，有条件拷贝</p></li><li><p>ObFastDereferenceObject：while循环，比较后交换的分析</p></li><li><p>KeInitializeQueue：结构体赋值，有条件拷贝</p></li><li><p>KxWaitForLockChainValid：do-while循环，if(a &amp;&amp; b &amp;&amp; c){}else{}结构</p></li><li><p>KeReadyThread：嵌套的if(){}结构</p></li><li><p>KiInitializeTSS（未找到）</p></li><li><p>RtlValidateUnicodeString：if(a &amp;&amp; b || c){}else{}结构</p></li></ul><h2 id="条件复杂的if-else"><a href="#条件复杂的if-else" class="headerlink" title="条件复杂的if(){}else{}"></a>条件复杂的if(){}else{}</h2><p>KxWaitForLockChainValid和RtlValidateUnicodeString都有类似if(a &amp;&amp; b || c)的结构</p><p>其多个的jmp结果一定会去到两个分支之一，然后回到主分支</p><p>可以理解成析取或合取表达式的提取</p><p>我对windows采用的编译器的理解是，对于或（<code>||</code>）通过多个jmp实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span> || b==<span class="number">0</span> || c==<span class="number">0</span>)</span><br><span class="line">    BranchA();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    BranchB();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># asm</span><br><span class="line">test a, a</span><br><span class="line">jz loc_A</span><br><span class="line">test b, b</span><br><span class="line">jz loc_A</span><br><span class="line">test c, c</span><br><span class="line">jz loc_A</span><br><span class="line">call BranchB</span><br><span class="line">jmp loc_ed</span><br><span class="line">loc_A:</span><br><span class="line">call BrancA</span><br><span class="line">loc_ed:</span><br></pre></td></tr></table></figure><p>对于（<code>&amp;&amp;</code>）会将后面的合取转成析取，然后生成一个chunk：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++ 1</span></span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span> &amp;&amp; b==<span class="number">0</span> &amp;&amp; c==<span class="number">0</span>) <span class="comment">// =&gt; if(a==0 &amp;&amp; !(b!=0 || c!=0))</span></span><br><span class="line">    BranchA();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    BranchB();</span><br><span class="line"></span><br><span class="line"><span class="comment">// c++ 2</span></span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(b!=<span class="number">0</span> || c!=<span class="number">0</span>)</span><br><span class="line">         BranchB();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        BranchA();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    BranchB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># asm</span><br><span class="line">test a, a</span><br><span class="line">jz chunk_1</span><br><span class="line">loc_B:</span><br><span class="line">call BranchB</span><br><span class="line">loc_ed:</span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line">chunk_1:</span><br><span class="line">test b, b</span><br><span class="line">jnz loc_B</span><br><span class="line">test c, c</span><br><span class="line">jnz loc_B</span><br><span class="line">call BranchA</span><br><span class="line">jmp loc_ed</span><br></pre></td></tr></table></figure><h2 id="KeInitializeDpc"><a href="#KeInitializeDpc" class="headerlink" title="KeInitializeDpc"></a>KeInitializeDpc</h2><h3 id="前置信息"><a href="#前置信息" class="headerlink" title="前置信息"></a>前置信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MSDN</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KeInitializeDpc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [out]          __drv_aliasesMem PRKDPC Dpc,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           PKDEFERRED_ROUTINE      DeferredRoutine,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] __drv_aliasesMem PVOID  DeferredContext</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>KDPC的结构（该结构在win10 x64各版本中未发生过改变）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KDPC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG TargetInfoAsUlong;    <span class="comment">//0x0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR Type;             <span class="comment">//0x0</span></span><br><span class="line">            UCHAR Importance;       <span class="comment">//0x1</span></span><br><span class="line">            <span class="keyword">volatile</span> USHORT Number; <span class="comment">//0x2</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">DpcListEntry</span>;</span> <span class="comment">//0x8</span></span><br><span class="line">    ULONGLONG ProcessorHistory;     <span class="comment">//0x10</span></span><br><span class="line">    VOID (*DeferredRoutine)(struct _KDPC* arg1, VOID* arg2, VOID* arg3, VOID* arg4); <span class="comment">//0x18</span></span><br><span class="line">    VOID* DeferredContext; <span class="comment">//0x20</span></span><br><span class="line">    VOID* SystemArgument1; <span class="comment">//0x28</span></span><br><span class="line">    VOID* SystemArgument2; <span class="comment">//0x30</span></span><br><span class="line">    VOID* DpcData;         <span class="comment">//0x38</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>使用工具得到的反汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00000001402E39E0 KeInitializeDpc proc near</span><br><span class="line">.text:00000001402E39E0                 xor     eax, eax</span><br><span class="line">.text:00000001402E39E2                 mov     dword ptr [rcx], 113h</span><br><span class="line">.text:00000001402E39E8                 mov     [rcx+38h], rax</span><br><span class="line">.text:00000001402E39EC                 mov     [rcx+10h], rax</span><br><span class="line">.text:00000001402E39F0                 mov     [rcx+18h], rdx</span><br><span class="line">.text:00000001402E39F4                 mov     [rcx+20h], r8</span><br><span class="line">.text:00000001402E39F8                 retn</span><br><span class="line">.text:00000001402E39F8 KeInitializeDpc endp</span><br></pre></td></tr></table></figure><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>该初始化函数只是简单的赋值</p><p>反编译结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KeInitializeDpc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PRKDPC Dpc,</span></span></span><br><span class="line"><span class="function"><span class="params">    PKDEFERRED_ROUTINE DeferredRoutine,</span></span></span><br><span class="line"><span class="function"><span class="params">    PVOID DeferredContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dpc-&gt;TargetInfoAsUlong = <span class="number">0x113</span>; <span class="comment">// Type=0x13, Importance=0x1, Number=0</span></span><br><span class="line">    Dpc-&gt;ProcessorHistory = <span class="number">0</span>;</span><br><span class="line">    Dpc-&gt;DeferredRoutine = DeferredRoutine;</span><br><span class="line">    Dpc-&gt;DeferredContext = DeferredContext;</span><br><span class="line">    Dpc-&gt;DpcData = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KeInitializeApc"><a href="#KeInitializeApc" class="headerlink" title="KeInitializeApc"></a>KeInitializeApc</h2><h3 id="前置信息-1"><a href="#前置信息-1" class="headerlink" title="前置信息"></a>前置信息</h3><p>这是个未文档化的函数</p><p>显然会用到KAPC结构（win10 x64 21H1）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x58 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KAPC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UCHAR Type;                      <span class="comment">//0x0</span></span><br><span class="line">    UCHAR SpareByte0;                <span class="comment">//0x1</span></span><br><span class="line">    UCHAR Size;                      <span class="comment">//0x2</span></span><br><span class="line">    UCHAR SpareByte1;                <span class="comment">//0x3</span></span><br><span class="line">    ULONG SpareLong0;                <span class="comment">//0x4</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span>* <span class="title">Thread</span>;</span>         <span class="comment">//0x8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ApcListEntry</span>;</span> <span class="comment">//0x10</span></span><br><span class="line">    VOID* Reserved[<span class="number">3</span>];               <span class="comment">//0x20</span></span><br><span class="line">    VOID* NormalContext;             <span class="comment">//0x38</span></span><br><span class="line">    VOID* SystemArgument1;           <span class="comment">//0x40</span></span><br><span class="line">    VOID* SystemArgument2;           <span class="comment">//0x48</span></span><br><span class="line">    CHAR ApcStateIndex;              <span class="comment">//0x50</span></span><br><span class="line">    CHAR ApcMode;                    <span class="comment">//0x51</span></span><br><span class="line">    UCHAR Inserted;                  <span class="comment">//0x52</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>在旧版本中（21H1之前），成员Reserved[3]被认为是union：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">       &#123;</span></span><br><span class="line">           VOID (*KernelRoutine)(struct _KAPC* arg1, VOID (**arg2)(VOID* arg1, VOID* arg2, VOID* arg3), VOID** arg3, VOID** arg4, VOID** arg5); <span class="comment">//0x20</span></span><br><span class="line">           VOID (*RundownRoutine)(struct _KAPC* arg1);                     <span class="comment">//0x28</span></span><br><span class="line">           VOID (*NormalRoutine)(VOID* arg1, VOID* arg2, VOID* arg3);      <span class="comment">//0x30</span></span><br><span class="line">       &#125;;</span><br><span class="line">       VOID* Reserved[<span class="number">3</span>];                                                  <span class="comment">//0x20</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><h3 id="汇编-1"><a href="#汇编-1" class="headerlink" title="汇编"></a>汇编</h3><p>使用工具得到的反汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.text:00000001402F93D0 KeInitializeApc proc near</span><br><span class="line">.text:00000001402F93D0 arg_20          &#x3D; qword ptr  28h ; RundownRoutine</span><br><span class="line">.text:00000001402F93D0 arg_28          &#x3D; qword ptr  30h ; NormalRoutine</span><br><span class="line">.text:00000001402F93D0 arg_30          &#x3D; byte ptr  38h  ; ApcMode</span><br><span class="line">.text:00000001402F93D0 arg_38          &#x3D; qword ptr  40h ; NormalContext</span><br><span class="line">.text:00000001402F93D0</span><br><span class="line">.text:00000001402F93D0                 mov     byte ptr [rcx], 12h   ; Apc-&gt;Type &#x3D; 0x12</span><br><span class="line">.text:00000001402F93D3                 mov     r10, rcx</span><br><span class="line">.text:00000001402F93D6                 mov     byte ptr [rcx+2], 58h ; Apc-&gt;Size &#x3D; 0x58</span><br><span class="line">.text:00000001402F93DA                 cmp     r8d, 2</span><br><span class="line">.text:00000001402F93DE                 jz      short loc_1402F9424</span><br><span class="line">.text:00000001402F93E0</span><br><span class="line">.text:00000001402F93E0 loc_1402F93E0:                          ; CODE XREF: KeInitializeApc+5B↓j</span><br><span class="line">.text:00000001402F93E0                 mov     rax, [rsp+arg_20]</span><br><span class="line">.text:00000001402F93E5                 mov     [rcx+50h], r8b ; Apc-&gt;ApcStateIndex &#x3D; ApcStateIndex</span><br><span class="line">.text:00000001402F93E9                 mov     [rcx+28h], rax ; Apc-&gt;RundownRoutine &#x3D; RundownRoutine</span><br><span class="line">.text:00000001402F93ED                 mov     [rcx+8], rdx   ; Apc-&gt;Thread &#x3D; Thread</span><br><span class="line">.text:00000001402F93F1                 mov     rdx, [rsp+arg_28]</span><br><span class="line">.text:00000001402F93F6                 mov     [rcx+30h], rdx ; Apc-&gt;NormalRoutine &#x3D; NormalRoutine</span><br><span class="line">.text:00000001402F93FA                 mov     rax, rdx</span><br><span class="line">.text:00000001402F93FD                 neg     rax</span><br><span class="line">.text:00000001402F9400                 mov     [rcx+20h], r9  ; Apc-&gt;KernelRoutine &#x3D; KernelRoutine</span><br><span class="line">.text:00000001402F9404                 sbb     rcx, rcx</span><br><span class="line">.text:00000001402F9407                 and     rcx, [rsp+arg_38]</span><br><span class="line">.text:00000001402F940C                 neg     rdx</span><br><span class="line">.text:00000001402F940F                 sbb     al, al</span><br><span class="line">.text:00000001402F9411                 and     al, [rsp+arg_30]</span><br><span class="line">.text:00000001402F9415                 mov     [r10+51h], al  ; Apc-&gt;ApcMode &#x3D; ApcMode</span><br><span class="line">.text:00000001402F9419                 mov     [r10+38h], rcx ; Apc-&gt;NormalContext &#x3D; NormalContext</span><br><span class="line">.text:00000001402F941D                 mov     byte ptr [r10+52h], 0 ; Apc-&gt;Inserted &#x3D; 0</span><br><span class="line">.text:00000001402F9422                 retn</span><br><span class="line">.text:00000001402F9422 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000001402F9423                 align 4</span><br><span class="line">.text:00000001402F9424</span><br><span class="line">.text:00000001402F9424 loc_1402F9424:                          ; CODE XREF: KeInitializeApc+E↑j</span><br><span class="line">.text:00000001402F9424                 mov     r8b, [rdx+24Ah] ; ApcStateIndex &#x3D; Thread-&gt;ApcStateIndex</span><br><span class="line">.text:00000001402F942B                 jmp     short loc_1402F93E0</span><br><span class="line">.text:00000001402F942B KeInitializeApc endp</span><br></pre></td></tr></table></figure><h3 id="反编译-1"><a href="#反编译-1" class="headerlink" title="反编译"></a>反编译</h3><p><code>1402F93D6 mov byte ptr [rcx+2], 58h</code>对照KAPC的结构，可以发现刚好成员<code>size</code>的偏移是<code>+2</code>，而<code>sizeof(_KAPC) = 0x58</code><br>由此判断rcx是<code>KAPC*</code></p><p>根据后面对Apc的赋值，能够还原参数的符号</p><p>比较有意思的是下面这段汇编：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:00000001402F93F1                 mov     rdx, [rsp+arg_28] ; rdx &#x3D; NormalRoutine</span><br><span class="line">; ...</span><br><span class="line">.text:00000001402F93FA                 mov     rax, rdx          ; rax &#x3D; NormalRoutine</span><br><span class="line">; ...</span><br><span class="line">.text:00000001402F940C                 neg     rdx               ; rdx &#x3D; -NormalRoutine</span><br><span class="line">.text:00000001402F940F                 sbb     al, al            ; al &#x3D; NormalRoutine !&#x3D; 0 ? -1 : 0</span><br><span class="line">.text:00000001402F9411                 and     al, [rsp+arg_30]  ; al &#x3D; NormalRoutine !&#x3D; 0 ? ApcMode : 0;</span><br><span class="line">.text:00000001402F9415                 mov     [r10+51h], al</span><br></pre></td></tr></table></figure><p>通过组合<code>neg b; sbb a, a; and a, c</code>实现的<code>a = b != 0 ? c : 0 </code></p><p>当b不等于0时，neg会置cf为1，sbb便会借位，于是<code>a = a - a - 1 = -1</code>；而b等于0时，neg会置cf为0，<code>a = a - a = 0</code></p><p>反编译代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KeInitializeApc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _KAPC* Apc,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct _KTHREAD* Thread,</span></span></span><br><span class="line"><span class="function"><span class="params">    CHAR ApcStateIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* KernelRoutine,  <span class="comment">// func</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* RundownRoutine, <span class="comment">// func</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* NormalRoutine,  <span class="comment">// func</span></span></span></span><br><span class="line"><span class="function"><span class="params">    CHAR ApcMode,</span></span></span><br><span class="line"><span class="function"><span class="params">    VOID* NormalContext</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Apc-&gt;Type = <span class="number">0x12</span>;</span><br><span class="line">    Apc-&gt;Size = <span class="number">0x58</span>;</span><br><span class="line">    <span class="keyword">if</span>(ApcStateIndex == <span class="number">2</span>)</span><br><span class="line">        ApcStateIndex = Thread-&gt;ApcStateIndex;</span><br><span class="line">     Apc-&gt;Thread = Thread;</span><br><span class="line">    Apc-&gt;ApcStateIndex = ApcStateIndex;</span><br><span class="line">    Apc-&gt;KernelRoutine = KernelRoutine;</span><br><span class="line">    Apc-&gt;RundownRoutine = RundownRoutine;</span><br><span class="line">    Apc-&gt;NormalRoutine = NormalRoutine;</span><br><span class="line">    Apc-&gt;ApcMode = NormalRoutine != <span class="number">0</span> ? ApcMode : <span class="number">0</span>;</span><br><span class="line">    Apc-&gt;NormalContext = NormalContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ObFastDereferenceObject"><a href="#ObFastDereferenceObject" class="headerlink" title="ObFastDereferenceObject"></a>ObFastDereferenceObject</h2><h3 id="前置信息-2"><a href="#前置信息-2" class="headerlink" title="前置信息"></a>前置信息</h3><p>已知该函数在20h2和21h1中相同，且调用惯例应该是stdcall（被调用方清理栈），由于只有两个参数（通过寄存器传递），所以不需要清理</p><p>查阅资料在win7中该函数的调用惯例应该也是stdcall</p><p>MSDN原文:</p><p><strong>ObDereferenceObject</strong> returns a value that is reserved for system use. Drivers must treat this value as VOID.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MSDN</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObDereferenceObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]  a</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="汇编-2"><a href="#汇编-2" class="headerlink" title="汇编"></a>汇编</h3><p>有一些比较陌生的汇编指令：</p><p><code>prefectchw</code>：不影响程序的行为。用于将数据提前装入缓存，减少延迟。</p><p><code>lock cmpxchg r/m, r</code>：x86上CAS被翻译成该指令。CAS是比较交换，无锁原子过程</p><p><code>cmpxchg (r/m)a, (r)b</code>：将al/ax/eax/rax与首操作数比较；<br>若相等，等同于<code>mov a, b</code>且<code>zf=1</code>；否则等同于<code>mov al/ax/eax/rax, a</code>且<code>zf=0</code></p><p>使用工具得到的反汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000140298F70 ObFastDereferenceObject proc near</span><br><span class="line">.text:0000000140298F70                 sub     rsp, 28h</span><br><span class="line">.text:0000000140298F74                 mov     r9, rdx         ; r9 &#x3D; a2</span><br><span class="line">.text:0000000140298F77                 prefetchw byte ptr [rcx]</span><br><span class="line">.text:0000000140298F7A                 mov     rax, [rcx]      ; rax &#x3D; *a1</span><br><span class="line">.text:0000000140298F7D                 mov     r8, rax</span><br><span class="line">.text:0000000140298F80                 xor     r8, rdx         ; r8 &#x3D; (*a1) ^ a2</span><br><span class="line">.text:0000000140298F83                 cmp     r8, 0Fh</span><br><span class="line">.text:0000000140298F87                 jnb     short b1_140298F9A ; jmp r8 &gt;&#x3D; 0xf</span><br><span class="line">.text:0000000140298F89</span><br><span class="line">.text:0000000140298F89 loopBody_140298F89:                     ; CODE XREF: ObFastDereferenceObject+3E↓j</span><br><span class="line">.text:0000000140298F89                 lea     r8, [rax+1]     ; r8 &#x3D; *a1 + 1</span><br><span class="line">.text:0000000140298F8D                 lock cmpxchg [rcx], r8</span><br><span class="line">.text:0000000140298F92                 jnz     short loopCheck_140298FA4</span><br><span class="line">.text:0000000140298F94</span><br><span class="line">.text:0000000140298F94 ret_140298F94:                          ; CODE XREF: ObFastDereferenceObject+32↓j</span><br><span class="line">.text:0000000140298F94                 add     rsp, 28h</span><br><span class="line">.text:0000000140298F98                 retn</span><br><span class="line">.text:0000000140298F98 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000140298F99                 align 2</span><br><span class="line">.text:0000000140298F9A</span><br><span class="line">.text:0000000140298F9A b1_140298F9A:                           ; CODE XREF: ObFastDereferenceObject+17↑j</span><br><span class="line">.text:0000000140298F9A                                         ; ObFastDereferenceObject+40↓j</span><br><span class="line">.text:0000000140298F9A                 mov     rcx, r9         ; DmaAdapter</span><br><span class="line">.text:0000000140298F9D                 call    HalPutDmaAdapter</span><br><span class="line">.text:0000000140298FA2                 jmp     short ret_140298F94</span><br><span class="line">.text:0000000140298FA4 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000140298FA4</span><br><span class="line">.text:0000000140298FA4 loopCheck_140298FA4:                    ; CODE XREF: ObFastDereferenceObject+22↑j</span><br><span class="line">.text:0000000140298FA4                 mov     rdx, rax</span><br><span class="line">.text:0000000140298FA7                 xor     rdx, r9         ; rdx &#x3D; rax ^ r9</span><br><span class="line">.text:0000000140298FAA                 cmp     rdx, 0Fh</span><br><span class="line">.text:0000000140298FAE                 jb      short loopBody_140298F89 ; r8 &#x3D; *a1 + 1</span><br><span class="line">.text:0000000140298FB0                 jmp     short b1_140298F9A ; break</span><br><span class="line">.text:0000000140298FB0 ObFastDereferenceObject endp</span><br></pre></td></tr></table></figure><h3 id="反编译-2"><a href="#反编译-2" class="headerlink" title="反编译"></a>反编译</h3><p>_InterlockedCompareExchange64(*Dst, Exc, Cmp)，Exc是新值，Cmp是比较值</p><p>反编译代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObDereferenceObject</span><span class="params">(UInt64* obj, <span class="keyword">const</span> UInt64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// begin:</span></span><br><span class="line">    _m_prefectchw(obj);</span><br><span class="line">    UInt64 v0 = *obj; <span class="comment">// rax</span></span><br><span class="line">    UInt64 v1 = v0 ^ a2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(v1 &lt; <span class="number">0xf</span>) &#123;</span><br><span class="line">        <span class="comment">// loopBody:</span></span><br><span class="line">        UInt64 oldV0 = v0;</span><br><span class="line">        v0 = _InterlockedCompareExchange64(obj, v0 + <span class="number">1</span>, v0);</span><br><span class="line">        <span class="keyword">if</span>(oldV0 == v0) <span class="comment">// if v0 not change(obj = v0 + 1)</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// loopCheck:</span></span><br><span class="line">        v1 = v0 ^ a2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// b1:</span></span><br><span class="line">    v0 = HalPutDmaAdapter(a2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ret:</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中loopBody的四行代码相当于以下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(*obj == v0) &#123;</span><br><span class="line">    *obj = v0 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    v0 = *obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KeInitializeQueue"><a href="#KeInitializeQueue" class="headerlink" title="KeInitializeQueue"></a>KeInitializeQueue</h2><h3 id="前置信息-3"><a href="#前置信息-3" class="headerlink" title="前置信息"></a>前置信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MSDN</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KeInitializeQueue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [out] PRKQUEUE Queue,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]  ULONG    Count</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KQUEUE</span> &#123;</span></span><br><span class="line">    DISPATCHER_HEADER Header;  <span class="comment">// +0h</span></span><br><span class="line">    LIST_ENTRY EntryListHead;  <span class="comment">// +18h</span></span><br><span class="line">    ULONG CurrentCount;        <span class="comment">// +28h</span></span><br><span class="line">    ULONG MaximumCount;        <span class="comment">// +2Ch</span></span><br><span class="line">    LIST_ENTRY ThreadListHead; <span class="comment">// +30h</span></span><br><span class="line">&#125; KQUEUE, *PKQUEUE, *RESTRICTED_POINTER PRKQUEUE;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">DISPATCHER_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            UCHAR QueueType;                           <span class="comment">//0x0</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                UCHAR QueueControlFlags;               <span class="comment">//0x1</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                    UCHAR Abandoned:<span class="number">1</span>;                 <span class="comment">//0x1</span></span><br><span class="line">                    UCHAR DisableIncrement:<span class="number">1</span>;          <span class="comment">//0x1</span></span><br><span class="line">                    UCHAR QueueReservedControlFlags:<span class="number">6</span>; <span class="comment">//0x1</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            UCHAR QueueSize;                           <span class="comment">//0x2</span></span><br><span class="line">            UCHAR QueueReserved;                       <span class="comment">//0x3</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="汇编-3"><a href="#汇编-3" class="headerlink" title="汇编"></a>汇编</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.text:00000001402DE420 KeInitializeQueue proc near</span><br><span class="line">.text:00000001402DE420                 push    rbx</span><br><span class="line">.text:00000001402DE422                 sub     rsp, 20h</span><br><span class="line">.text:00000001402DE426                 mov     rbx, rcx        ; rbx &#x3D; Queue</span><br><span class="line">.text:00000001402DE429                 mov     byte ptr [rcx], 4 ; Queue-&gt;Header.QueueType &#x3D; 4</span><br><span class="line">.text:00000001402DE42C                 xor     ecx, ecx</span><br><span class="line">.text:00000001402DE42E                 mov     word ptr [rbx+1], 1000h ; *(WORD*)&amp;Queue-&gt;Header.QueueControlFlags &#x3D; 0x1000</span><br><span class="line">.text:00000001402DE434                 lea     rax, [rbx+8]    ; rax &#x3D; &amp;Queue-&gt;Header.WaitListHead</span><br><span class="line">.text:00000001402DE438                 mov     [rax+8], rax    ; Queue-&gt;Header.WaitListHead.Blink &#x3D; &amp;Queue-&gt;Header.WaitListHead</span><br><span class="line">.text:00000001402DE43C                 mov     [rax], rax      ; Queue-&gt;Header.WaitListHead.Flink &#x3D; &amp;Queue-&gt;Header.WaitListHead</span><br><span class="line">.text:00000001402DE43F                 lea     rax, [rbx+18h]  ; rax &#x3D; &amp;Queue-&gt;EntryListHead</span><br><span class="line">.text:00000001402DE443                 mov     [rax+8], rax    ; Queue-&gt;EntryListHead.Blink &#x3D; &amp;Queue-&gt;EntryListHead</span><br><span class="line">.text:00000001402DE447                 mov     [rax], rax      ; Queue-&gt;EntryListHead.Flink &#x3D; &amp;Queue-&gt;EntryListHead</span><br><span class="line">.text:00000001402DE44A                 lea     rax, [rbx+30h]  ; rax &#x3D; &amp;Queue-&gt;ThreadListHead</span><br><span class="line">.text:00000001402DE44E                 mov     [rax+8], rax    ; Queue-&gt;ThreadListHead.Blink &#x3D; &amp;Queue-&gt;ThreadListHead</span><br><span class="line">.text:00000001402DE452                 mov     [rax], rax      ; Queue-&gt;ThreadListHead.Flink &#x3D; &amp;Queue-&gt;ThreadListHead</span><br><span class="line">.text:00000001402DE455                 mov     [rbx+4], ecx    ; Queue-&gt;Header.SignalState &#x3D; 0</span><br><span class="line">.text:00000001402DE458                 mov     [rbx+28h], ecx  ; Queue-&gt;CurrentCount &#x3D; 0</span><br><span class="line">.text:00000001402DE45B                 test    edx, edx</span><br><span class="line">.text:00000001402DE45D                 jnz     short loc_1402DE46B ; jmp if edx</span><br><span class="line">.text:00000001402DE45F                 mov     ecx, 0FFFFh     ; GroupNumber</span><br><span class="line">.text:00000001402DE464                 call    KeQueryActiveProcessorCountEx</span><br><span class="line">.text:00000001402DE469                 mov     edx, eax</span><br><span class="line">.text:00000001402DE46B</span><br><span class="line">.text:00000001402DE46B loc_1402DE46B:                          ; CODE XREF: KeInitializeQueue+3D↑j</span><br><span class="line">.text:00000001402DE46B                 mov     [rbx+2Ch], edx  ; Queue-&gt;MaximumCount &#x3D; Count</span><br><span class="line">.text:00000001402DE46E                 add     rsp, 20h</span><br><span class="line">.text:00000001402DE472                 pop     rbx</span><br><span class="line">.text:00000001402DE473                 retn</span><br><span class="line">.text:00000001402DE473 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000001402DE474                 db 0CCh</span><br><span class="line">.text:00000001402DE474 KeInitializeQueue endp</span><br></pre></td></tr></table></figure><h3 id="反编译-3"><a href="#反编译-3" class="headerlink" title="反编译"></a>反编译</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KeInitializeQueue</span><span class="params">(PRKQUEUE Queue, ULONG Count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue-&gt;Header.QueueType = <span class="number">4</span>;</span><br><span class="line">    *(WORD*)&amp;Queue-&gt;Header.QueueControlFlags = <span class="number">0x1000</span>;</span><br><span class="line">    Queue-&gt;Header.WaitListHead.Blink = &amp;Queue-&gt;Header.WaitListHead;</span><br><span class="line">    Queue-&gt;Header.WaitListHead.Flink = &amp;Queue-&gt;Header.WaitListHead;</span><br><span class="line">    Queue-&gt;EntryListHead.Blink = &amp;Queue-&gt;EntryListHead;</span><br><span class="line">    Queue-&gt;EntryListHead.Flink = &amp;Queue-&gt;EntryListHead;</span><br><span class="line">    Queue-&gt;ThreadListHead.Blink = &amp;Queue-&gt;ThreadListHead;</span><br><span class="line">    Queue-&gt;ThreadListHead.Flink = &amp;Queue-&gt;ThreadListHead;</span><br><span class="line">    Queue-&gt;Header.SignalState = <span class="number">0</span>;</span><br><span class="line">    Queue-&gt;CurrentCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !Count )</span><br><span class="line">    Count = KeQueryActiveProcessorCountEx(<span class="number">0xFFFF</span>u);</span><br><span class="line">    Queue-&gt;MaximumCount = Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KxWaitForLockChainValid"><a href="#KxWaitForLockChainValid" class="headerlink" title="KxWaitForLockChainValid"></a>KxWaitForLockChainValid</h2><h3 id="汇编-4"><a href="#汇编-4" class="headerlink" title="汇编"></a>汇编</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000140279BD0 KxWaitForLockChainValid proc near</span><br><span class="line">.text:0000000140279BD0 arg_0           &#x3D; qword ptr  8</span><br><span class="line">.text:0000000140279BD0                 mov     [rsp+arg_0], rbx</span><br><span class="line">.text:0000000140279BD5                 push    rdi</span><br><span class="line">.text:0000000140279BD6                 sub     rsp, 20h</span><br><span class="line">.text:0000000140279BDA                 mov     rdi, rcx        ; rdi &#x3D; a1</span><br><span class="line">.text:0000000140279BDD                 xor     ebx, ebx        ; ebx &#x3D; 0</span><br><span class="line">.text:0000000140279BDF</span><br><span class="line">.text:0000000140279BDF loopStart_140279BDF:                    ; CODE XREF: KxWaitForLockChainValid+25↓j</span><br><span class="line">.text:0000000140279BDF                 inc     ebx             ; ebx++</span><br><span class="line">.text:0000000140279BE1                 test    cs:HvlLongSpinCountMask, ebx</span><br><span class="line">.text:0000000140279BE7                 jz      branch1_140437A78</span><br><span class="line">.text:0000000140279BED</span><br><span class="line">.text:0000000140279BED pause_140279BED:                        ; CODE XREF: KxWaitForLockChainValid+1BDEB0↓j</span><br><span class="line">.text:0000000140279BED                 pause</span><br><span class="line">.text:0000000140279BEF</span><br><span class="line">.text:0000000140279BEF loopCheck_140279BEF:                    ; CODE XREF: KxWaitForLockChainValid+1BDECB↓j</span><br><span class="line">.text:0000000140279BEF                 mov     rax, [rdi]      ; rax &#x3D; *a1</span><br><span class="line">.text:0000000140279BF2                 test    rax, rax</span><br><span class="line">.text:0000000140279BF5                 jz      short loopStart_140279BDF ; jmp if *a1 &#x3D;&#x3D; 0</span><br><span class="line">.text:0000000140279BF7                 mov     rbx, [rsp+28h+arg_0]</span><br><span class="line">.text:0000000140279BFC                 add     rsp, 20h</span><br><span class="line">.text:0000000140279C00                 pop     rdi</span><br><span class="line">.text:0000000140279C01                 retn</span><br><span class="line">.text:0000000140279C01 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000140279C02                 db 0CCh</span><br><span class="line">.text:0000000140279C02 KxWaitForLockChainValid endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0000000140437A78 ; START OF FUNCTION CHUNK FOR KxWaitForLockChainValid</span><br><span class="line">.text:0000000140437A78</span><br><span class="line">.text:0000000140437A78 branch1_140437A78:                      ; CODE XREF: KxWaitForLockChainValid+17↑j</span><br><span class="line">.text:0000000140437A78                 mov     eax, cs:HvlEnlightenments</span><br><span class="line">.text:0000000140437A7E                 test    al, 40h</span><br><span class="line">.text:0000000140437A80                 jz      pause_140279BED</span><br><span class="line">.text:0000000140437A86                 call    KiCheckVpBackingLongSpinWaitHypercall</span><br><span class="line">.text:0000000140437A8B                 test    al, al</span><br><span class="line">.text:0000000140437A8D                 jz      pause_140279BED</span><br><span class="line">.text:0000000140437A93                 mov     ecx, ebx</span><br><span class="line">.text:0000000140437A95                 call    HvlNotifyLongSpinWait</span><br><span class="line">.text:0000000140437A9A                 nop</span><br><span class="line">.text:0000000140437A9B                 jmp     loopCheck_140279BEF ; rax &#x3D; *a1</span><br><span class="line">.text:0000000140437A9B ; END OF FUNCTION CHUNK FOR KxWaitForLockChainValid</span><br></pre></td></tr></table></figure><h3 id="反编译-4"><a href="#反编译-4" class="headerlink" title="反编译"></a>反编译</h3><p>branch1实际上就是一个if(a &amp; b &amp; c){}else{}的结构，各个jcc是顺序排序，只要触发一个就去到false分支，分析关键是抓住能走完全部jcc的路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">KxWaitForLockChainValid</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>* a1)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">// loopStart:</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>((i &amp; HvlLongSpinCountMask) == <span class="number">0</span></span><br><span class="line">          &amp;&amp; (HvlEnlightenments &amp; <span class="number">0x40</span>) != <span class="number">0</span></span><br><span class="line">          &amp;&amp; KiCheckVpBackingLongSpinWaitHypercall() != <span class="number">0</span>) &#123;</span><br><span class="line">            HvlNotifyLongSpinWait(i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            _mm_pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(!*a1);</span><br><span class="line">    <span class="keyword">return</span> *a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KeReadyThread"><a href="#KeReadyThread" class="headerlink" title="KeReadyThread"></a>KeReadyThread</h2><p>嵌套的if{}，结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    c0();</span><br><span class="line">    <span class="keyword">if</span>() &#123;</span><br><span class="line">        c1();</span><br><span class="line">        <span class="keyword">if</span>() c2();</span><br><span class="line">        c3();</span><br><span class="line">        <span class="keyword">if</span>() ret();</span><br><span class="line">    &#125;</span><br><span class="line">    c4();</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KiInitializeTSS（未找到）"><a href="#KiInitializeTSS（未找到）" class="headerlink" title="KiInitializeTSS（未找到）"></a>KiInitializeTSS（未找到）</h2><p>21h1的ntoskrnl.exe中未找到</p><h2 id="RtlValidateUnicodeString"><a href="#RtlValidateUnicodeString" class="headerlink" title="RtlValidateUnicodeString"></a>RtlValidateUnicodeString</h2><p>if((a &amp;&amp; b) || c)结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a || (!b &amp;&amp; (c || d || e || f)) || (g &amp;&amp; (h || !i))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xC000000D</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/antiDebug/">antiDebug</category>
      
      <category domain="https://windgodm.github.io/blog/tags/practicalre/">practicalre</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/11/08/practicalre1-7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从0开始：某fpsgo简单透视制作</title>
      <link>https://windgodm.github.io/blog/2021/11/08/fpsgoPerspective/</link>
      <guid>https://windgodm.github.io/blog/2021/11/08/fpsgoPerspective/</guid>
      <pubDate>Mon, 08 Nov 2021 12:54:00 GMT</pubDate>
      
      <description>从0开始：某fpsgo简单透视制作</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="从0开始：某fpsgo简易透视制作"><a href="#从0开始：某fpsgo简易透视制作" class="headerlink" title="从0开始：某fpsgo简易透视制作"></a>从0开始：某fpsgo简易透视制作</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><p>前置知识：</p><p>线性代数知识：矩阵的基本运算</p><p>图形学知识：齐次坐标，仿射变换，MVP模型</p><p>（可选）旋转、四元数与欧拉角（我也不懂）</p><p>其他：CE的基本使用、C++、dll编写与注入、IMGUI</p></blockquote><blockquote><p>一些资源：</p><p><a href="https://github.com/frk1/hazedumper">frk1/hazedumper: up to date csgo offsets and hazedumper config (github.com)</a></p><p><a href="https://github.com/danielkrupinski/Osiris">danielkrupinski/Osiris: Free open-source game cheat for Counter-Strike: Global Offensive, written in modern C++. GUI powered by Dear ImGui. (github.com)</a></p></blockquote><blockquote><p>hazedumper</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// to client.dll</span></span><br><span class="line">&gt;<span class="keyword">constexpr</span> DWORD myObjNodeOff = dwEntityList;</span><br><span class="line">&gt;<span class="keyword">constexpr</span> DWORD viewMatOff </span><br><span class="line">&gt;<span class="comment">// to OBJECT</span></span><br><span class="line">&gt;<span class="keyword">constexpr</span> DWORD healthOff = m_iHealth;</span><br><span class="line">&gt;<span class="keyword">constexpr</span> DWORD positionOff= m_vecOrigin;</span><br></pre></td></tr></table></figure></blockquote><p>hazedumper中有所需要的偏移的地址，抱着学习的目的，就选择手动找了</p><p>流程如下：</p><ul><li><p>1 找基址</p><ul><li>1.1 找object结构体地址</li><li>1.2 找object链表基址</li><li>1.3 分析结构体找出position偏移</li><li>1.4 找vp变换矩阵基址</li></ul></li><li><p>2 世界到屏幕坐标转换</p><ul><li>读取vp矩阵、读取position</li><li>视图变换</li><li>标准立方体到屏幕</li></ul></li><li><p>3 绘制</p></li></ul><p>（以下地址和偏移均不是真实值）</p><h2 id="1-找基址"><a href="#1-找基址" class="headerlink" title="1 找基址"></a>1 找基址</h2><blockquote><p>神秘指令：</p><p>// 已删除该部分</p></blockquote><h3 id="1-1-找结构体地址"><a href="#1-1-找结构体地址" class="headerlink" title="1.1 找结构体地址"></a>1.1 找结构体地址</h3><p>猜测生命值是结构体的成员，先找生命值的地址</p><p>用<code>hurtme</code>修改生命值，搜索精确数值，大概有22个结果</p><p>根据访问情况排除：</p><ul><li>只有cmp指令</li><li>server.dll中的指令</li><li>访问次数过少或没有</li><li>没有偏移量的（如<code>mov eax, [esi]</code>）</li><li>类型不符合（如搜整形遇到浮点指令）</li></ul><p>剩下如下可能性较大结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">h1 &#x3D; [0x0C704E00+0x1c]</span><br><span class="line">(client.dll)</span><br><span class="line">mov eax, [edi+0x1c]</span><br><span class="line">cmp eax, -1</span><br><span class="line"></span><br><span class="line">h2 &#x3D; [0x0C8345F0+0x18]</span><br><span class="line">(panorama.dll)</span><br><span class="line">mov ecx, [ecx+0x18]</span><br><span class="line">cmp ecx, [eax+0x18]</span><br><span class="line"></span><br><span class="line">h3 &#x3D; [0x41AA4248+0xd8]</span><br><span class="line">(client.dll)</span><br><span class="line">call eax</span><br><span class="line">...</span><br><span class="line">mov [edi+0xd8], eax</span><br><span class="line"></span><br><span class="line">h4 &#x3D; [606F4D60+0x100]</span><br><span class="line">(client.dll)</span><br><span class="line">mov eax, [ecx+0x100]</span><br><span class="line">ret</span><br><span class="line">(client.dll)</span><br><span class="line">cmp [ecx+0x100], 0</span><br></pre></td></tr></table></figure><p>综合来看h4的可能性比较大，即h4的基址可能是结构体地址，生命值的偏移为0x100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OBJ</span><br><span class="line">+0x100: health int</span><br></pre></td></tr></table></figure><h3 id="1-2-找链表地址"><a href="#1-2-找链表地址" class="headerlink" title="1.2 找链表地址"></a>1.2 找链表地址</h3><p>搜到4个绿色的地址，保存着结构体地址</p><p>只有一个具有链表的结构</p><p>最终得到如下结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client.dll+666F75C OBJ_NODE</span><br><span class="line">+0: 6666BD60 OBJ*</span><br><span class="line">+4: 666      int</span><br><span class="line">+8:          OBJ_NODE*</span><br><span class="line">+C:          OBJ_NODE*</span><br></pre></td></tr></table></figure><p>也就是可以通过如下方式获取health：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD clientBase;</span><br><span class="line">DWORD pMyObjNode = clientBase+<span class="number">0x6666888</span>; <span class="comment">// OBJ_NODE*</span></span><br><span class="line">DWORD pMyObj = *(DWORD*)(pobj_node);     <span class="comment">// OBJ*</span></span><br><span class="line">DWORD health = *(DWORD*)(pobj+<span class="number">0x66</span>);</span><br></pre></td></tr></table></figure><p>遍历链表可以发现，所以物品都在里面，生命值&gt;0的就是玩家或机器人，刚刚好有10个</p><p>下面是遍历的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJ_NODE</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* pObj;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">void</span>* prev, * next;</span><br><span class="line">&#125;OBJ_NODE, * POBJ_NODE;</span><br><span class="line"><span class="keyword">constexpr</span> DWORD myObjNodeOff = <span class="number">0x6666888</span>;</span><br><span class="line"><span class="keyword">constexpr</span> DWORD healthOff = <span class="number">0x66</span>;</span><br><span class="line"></span><br><span class="line">HANDLE hProc;                <span class="comment">// get it by yourself</span></span><br><span class="line">DWORD clientBase;            <span class="comment">// get it by yourself</span></span><br><span class="line"><span class="keyword">void</span>* pMyObjNode, *pObjNode;</span><br><span class="line">OBJ_NODE myObjNode, objNode;</span><br><span class="line"><span class="keyword">int</span> healthAddr, health;</span><br><span class="line"></span><br><span class="line"><span class="comment">// My Node</span></span><br><span class="line"><span class="keyword">int</span> numHeal = <span class="number">1</span>;</span><br><span class="line">pMyObjNode = (<span class="keyword">void</span>*)(clientBase + myObjNodeOff);</span><br><span class="line">ReadProcessMemory(hProc, (LPVOID)pMyObjNode, &amp;myObjNode, <span class="keyword">sizeof</span>(OBJ_NODE), <span class="literal">NULL</span>);</span><br><span class="line">healthAddr = (DWORD)myObjNode.pObj + healthOff;</span><br><span class="line">ReadProcessMemory(hProc, (LPVOID)healthAddr, &amp;health, <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// Prev</span></span><br><span class="line"><span class="keyword">for</span> (pObjNode = myObjNode.prev; pObjNode; pObjNode = objNode.prev) &#123;</span><br><span class="line">    ReadProcessMemory(hProc, (LPVOID)pObjNode, &amp;objNode, <span class="keyword">sizeof</span>(OBJ_NODE), <span class="literal">NULL</span>);</span><br><span class="line">    healthAddr = (DWORD)objNode.pObj + healthOff;</span><br><span class="line">    ReadProcessMemory(hProc, (LPVOID)healthAddr, &amp;health, <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (health &gt; <span class="number">0</span>) numHeal++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Next</span></span><br><span class="line"><span class="keyword">for</span> (pObjNode = myObjNode.next; pObjNode; pObjNode = objNode.next) &#123;</span><br><span class="line">    ReadProcessMemory(hProc, (LPVOID)pObjNode, &amp;objNode, <span class="keyword">sizeof</span>(OBJ_NODE), <span class="literal">NULL</span>);</span><br><span class="line">    healthAddr = (DWORD)objNode.pObj + healthOff;</span><br><span class="line">    ReadProcessMemory(hProc, (LPVOID)healthAddr, &amp;health, <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (health &gt; <span class="number">0</span>) numHeal++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf_s(<span class="string">&quot;\nnumHeal:%d\n&quot;</span>, numHeal);</span><br><span class="line"><span class="comment">// &gt;numHeal:10</span></span><br></pre></td></tr></table></figure><h3 id="1-3-找出position偏移"><a href="#1-3-找出position偏移" class="headerlink" title="1.3 找出position偏移"></a>1.3 找出position偏移</h3><p>查看结构体内存，显示类型选择单浮点，当跳的时候只有z轴是变的，根据此找坐标的位置</p><p>观察内存数值的变化得到下面的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJ</span><br><span class="line">+64  加速度 float[3]</span><br><span class="line">+60  坐标   float[3]</span><br><span class="line">+6C  坐标   float[3]</span><br><span class="line">+88 坐标   float[3]</span><br></pre></td></tr></table></figure><h3 id="1-4-找vp变换矩阵基址"><a href="#1-4-找vp变换矩阵基址" class="headerlink" title="1.4 找vp变换矩阵基址"></a>1.4 找vp变换矩阵基址</h3><p>搜索单精度浮点</p><p>先移动视角，然后搜索变换的值，再移动位置，搜索未改变的值，重复以上步骤</p><h2 id="2-世界到屏幕坐标转换"><a href="#2-世界到屏幕坐标转换" class="headerlink" title="2 世界到屏幕坐标转换"></a>2 世界到屏幕坐标转换</h2><p>世界坐标系到屏幕坐标系的转换有2步，这里简述一下（具体实现根据引擎会有细微差别）（大量括号警告：CG有些名词中文翻译不一致，标上英语）：</p><ul><li><p>第一步是mvp转换：<br>m（model trans.）指模型坐标转世界坐标<br>v（view trans.）指世界坐标转摄像机（摄像机为原点）坐标<br>p（projection trans.）指投影转换，分为正交投影（Orthographic proj.)和透视投影（Perspective proj.），且会将结果归一化（正交投影就是归一化、而透视投影是透视变换+归一化）<br>前面我们得到的是世界坐标和vp矩阵，所以不存在模型坐标向世界坐标转换的步骤（opengl给的就是vp矩阵）</p></li><li><p>第1.5步是归一化（规范化？）：</p><p>（这一步opengl叫透视除法，perspective divide）<br>上面说到投影转换最后会归一化，但在opengl的透视投影转换的透视转换这一过程中，没有维持w为1<br>这一步就是除以那个w，因为用的是齐次坐标，点坐标的w应该为1</p></li><li><p>第二步是视口变换（viewport mapping）：<br>这一步的目标是将坐标转换成屏幕上的坐标<br>需要注意处理原点误差的问题</p></li></ul><p>opengl中把第一步结果的坐标系称为裁剪坐标系（Clip space）<br>第1.5步结果的坐标系称为规范化设备坐标系（NDC，Normalized Device Coord. space）<br>第二步结果的坐标系称为屏幕坐标（Screen space）</p><p>opengl中我认为易错的两点其一是第1.5步的维持点坐标w为1</p><p>其二是第二步视口转换中要处理原点误差</p><p>为了方便这里就不写矩阵了，对于x，原公式是<code>screen.x = ndc.x * (w/2) + (w/2) + x </code>，那个x是屏幕原点坐标，应该为0。<br>网上有些代码会写成<code>screen.x = ndc.x * (w/2) + (w/2) + ndc.x</code><br>因为归一化，ndc.x小于1，所以对结果没有太大影响，问题就被忽略了</p><h2 id="3-绘制"><a href="#3-绘制" class="headerlink" title="3 绘制"></a>3 绘制</h2><p>这里我用的是外部绘制，用的imgui，最好是静态编译（需要先安装dx sdk，才有静态的dx.lib）</p><p>内部绘制的话hook dx的api即可</p><p>透明窗口的创建如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> width = <span class="number">1920</span>;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">1080</span>;</span><br><span class="line"></span><br><span class="line">WNDCLASSEX wc = &#123; <span class="keyword">sizeof</span>(WNDCLASSEX), CS_CLASSDC, WndProc, <span class="number">0L</span>, <span class="number">0L</span>, GetModuleHandle(<span class="literal">NULL</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, _T(<span class="string">&quot;Diana&quot;</span>), <span class="literal">NULL</span> &#125;;</span><br><span class="line">    RegisterClassEx(&amp;wc);</span><br><span class="line">    HWND hwnd = ::CreateWindow(wc.lpszClassName, _T(<span class="string">&quot;DianaLookAtYou&quot;</span>), WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_CHILD | WS_POPUP | WS_POPUP | WS_EX_TOPMOST, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="literal">NULL</span>, <span class="literal">NULL</span>, wc.hInstance, <span class="literal">NULL</span>);</span><br><span class="line">    LONG nRet = ::GetWindowLong(hwnd, GWL_EXSTYLE); nRet = nRet | WS_EX_LAYERED; ::SetWindowLong(hwnd, GWL_EXSTYLE, nRet);</span><br><span class="line">    SetLayeredWindowAttributes(hwnd, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), (BYTE)<span class="number">200</span>, LWA_ALPHA | LWA_COLORKEY);</span><br><span class="line">    SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE) | WS_EX_TRANSPARENT);</span><br><span class="line">    SetLayeredWindowAttributes(hwnd, RGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>, LWA_COLORKEY);</span><br><span class="line">    SetWindowPos(hwnd, HWND_TOPMOST, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, SWP_NOMOVE | SWP_NOSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Hack/">Hack</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/hack/">hack</category>
      
      <category domain="https://windgodm.github.io/blog/tags/fps/">fps</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/11/08/fpsgoPerspective/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《逆向工程实战》实例J</title>
      <link>https://windgodm.github.io/blog/2021/10/22/practicalreJ/</link>
      <guid>https://windgodm.github.io/blog/2021/10/22/practicalreJ/</guid>
      <pubDate>Fri, 22 Oct 2021 04:00:00 GMT</pubDate>
      
      <description>《逆向工程实战》实例J DllMain分析</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="《逆向工程实战》实例J"><a href="#《逆向工程实战》实例J" class="headerlink" title="《逆向工程实战》实例J"></a>《逆向工程实战》实例J</h1><h2 id="DllMain-反编译"><a href="#DllMain-反编译" class="headerlink" title="DllMain 反编译"></a>DllMain 反编译</h2><p>尽量按汇编反编译结果（没有太多优化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[<span class="number">8</span>] idtr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> IDTBase;</span><br><span class="line">    PROCESSENTRY32 pe;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Chunk 0:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 10001C6A ~ 10001C6E</span></span><br><span class="line">    __sidt(&amp;idtr);</span><br><span class="line">    IDTBase = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(idtr+<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 10001C71 ~ 10001C85</span></span><br><span class="line">    <span class="keyword">if</span>((IDTBase &gt; <span class="number">0x8003F400</span>) &amp;&amp; (IDTBase &lt; <span class="number">0x80047400</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Chunk 1:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 10001C88 ~ 10001CA9</span></span><br><span class="line">    HANDLE hSnapshot = CraeteToolhelp32Snapshot(<span class="number">2</span>, <span class="number">0</span>); <span class="comment">// get thread message</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;pe, <span class="number">0</span>, <span class="number">0x128</span>); <span class="comment">// 4+0x49*4</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 10001CAB ~ 10001CB6</span></span><br><span class="line">    <span class="keyword">if</span>(hSnapshot == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// invalid handle</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Chunk 2:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 10001CB9 ~ 10001D22</span></span><br><span class="line">    pe.dwSize = <span class="number">0x128</span>; <span class="comment">// = sizeof(PROCESSENTRY32)</span></span><br><span class="line">    <span class="keyword">int</span> flag = Process32First(hSnapshot, &amp;pe);</span><br><span class="line">    <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">        <span class="keyword">if</span>(stricmp(pe.szExeFile,<span class="string">&quot;explorer.exe&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// IsExplorer:</span></span><br><span class="line">            t1 = pe.th32ParentProcessID;</span><br><span class="line">            t2 = pe.th32ProcessID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = Process32Next(hSnapshot, &amp;pe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 10001D24 ~ 10001D27 (BreakWhileProc:)</span></span><br><span class="line">    <span class="keyword">int</span> t1, t2;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>) &#123;</span><br><span class="line">        t1 = fdwReason;</span><br><span class="line">        t2 = fdwReason;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 10001D2A ~ 10001D35 (CheckLoopResult:)</span></span><br><span class="line">    <span class="keyword">if</span>(t1 == t2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Chunk3:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 10001D38 ~ 10001D5C</span></span><br><span class="line">    <span class="keyword">if</span>(fdwReason == <span class="number">1</span>) &#123; <span class="comment">// DLL_PROCESS_ATTACH</span></span><br><span class="line">        CreateThread(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0x100032D0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__sidt对应汇编指令<code>sidt</code>，作用是读取idtr寄存器到指定地址<br>idtr寄存器大小是6字节，高4字节是IDT基址</p><p>开头检查IDT基址，每个处理器（核）的IDT都不同<br>win xp中只有0核的IDT基址是<code>0x8003F400</code>，后续版本IDT每次重启都会变<br>所以作用是检查是否运行在xp的0核中</p><p>Chunk1到Chunk2：检查explorer.exe是否在运行，不在运行就退出</p><p>Chunk3：创建一个线程</p><h2 id="DllMain栈帧"><a href="#DllMain栈帧" class="headerlink" title="DllMain栈帧"></a>DllMain栈帧</h2><p>以下偏移是相对DllMain栈帧的ebp</p><p>a开头是参数、v开头是局部变量</p><table><thead><tr><th>offset(base16)</th><th>name</th><th>size(base16)</th></tr></thead><tbody><tr><td>-130</td><td>v_pe</td><td>128</td></tr><tr><td>-8</td><td>v_idtr</td><td>6/8</td></tr><tr><td>+0</td><td>last_ebp</td><td>4</td></tr><tr><td>+4</td><td>ret_addr</td><td>4</td></tr><tr><td>+8</td><td>a0_hinstDLL</td><td>4</td></tr><tr><td>+C</td><td>a1_fdwReason</td><td>4</td></tr><tr><td>+10</td><td>a2_lpvReserved</td><td>4</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/antiDebug/">antiDebug</category>
      
      <category domain="https://windgodm.github.io/blog/tags/practicalre/">practicalre</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/10/22/practicalreJ/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>逆向工程核心原理 R3静态反调试 笔记</title>
      <link>https://windgodm.github.io/blog/2021/10/16/recoreR3StaAntiDebug/</link>
      <guid>https://windgodm.github.io/blog/2021/10/16/recoreR3StaAntiDebug/</guid>
      <pubDate>Sat, 16 Oct 2021 04:00:00 GMT</pubDate>
      
      <description>逆向工程核心原理 51章静态反调试 笔记</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="逆向工程核心原理-R3静态反调试-笔记"><a href="#逆向工程核心原理-R3静态反调试-笔记" class="headerlink" title="逆向工程核心原理 R3静态反调试 笔记"></a>逆向工程核心原理 R3静态反调试 笔记</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>主要是R3层面的静态反调试手段</p><p>参考逆向工程核心原理51章静态反调试</p><p>涉及的API：</p><ul><li><p>IsDebuggerPresent()</p></li><li><p>NtQueryInformationProcess()</p></li><li><p>NtQuerySystemInformation()</p></li><li><p>NtQueryObject()</p></li><li><p>ZwSetInformationThread()</p></li><li><p>DebugActiveProcessStop()</p></li></ul><h2 id="51-2-涉及peb的检查方式"><a href="#51-2-涉及peb的检查方式" class="headerlink" title="51.2 涉及peb的检查方式"></a>51.2 涉及peb的检查方式</h2><table><thead><tr><th>偏移</th><th>名称</th><th>类型</th></tr></thead><tbody><tr><td>0x2</td><td>BeingDebugged</td><td>UChar</td></tr><tr><td>0xc</td><td>Ldr</td><td>Ptr32 _PEB_LDR_DATA</td></tr><tr><td>0x18</td><td>ProcessHesap</td><td>Ptr32 Void</td></tr><tr><td>0x68</td><td>NtGlobalFlag</td><td>Uint48</td></tr></tbody></table><p><strong>BeingDebugged 标志位</strong> </p><p>处于调试状态，BeingDebugged被设置为1。<br>IsDebuggerPresent()检查 BeingDebugged。</p><p><strong>Ldr 堆内存检查</strong></p><p>调试进程未使用堆内存填充<code>0xFEEEFEEE</code>(x32)。<br>该方法只在xp中有效，且附加不存在该特征：<br>PEB_LDR_DATA结构体在堆内存中创建，扫描该区域是否存在上述特征。</p><p><strong>ProcessHeap 标志</strong></p><p>processheap结构//todo<br>该方法只在xp中有效，且附加不存在该特征：<br>正常情况Heap.Flags=2，Heap.ForceFlags=0</p><p><strong>NtGlobalFlag Bitmap</strong></p><p>该方法通过附加无效<br>调试状态PEB.NtGlobalFlag |= 0x70<br>由以下位组成<br>FLG_HEAP_ENABLE_TAIL_CHECK (0x10)<br>FLG_HEAP_ENABLE_FREE_CHECK (0x20)<br>FLG_HEAP_VALIDATE_PARAMETERS (0x40)</p><h2 id="51-3-NtQueryInformationProcess"><a href="#51-3-NtQueryInformationProcess" class="headerlink" title="51.3 NtQueryInformationProcess()"></a>51.3 NtQueryInformationProcess()</h2><p>该函数用于查询进程信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">PROCESSINFOCLASS</span> &#123;</span></span><br><span class="line">ProcessDebugPort = <span class="number">0x7</span>,</span><br><span class="line">ProcessDebugObjectHandle = <span class="number">0x1e</span>,</span><br><span class="line">ProcessDebugFlags = <span class="number">0x1f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MSDN</span></span><br><span class="line"><span class="function">__kernel_entry NTSTATUS <span class="title">NtQueryInformationProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE           ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  PROCESSINFOCLASS ProcessInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">  PVOID            ProcessInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG            ProcessInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">  PULONG           ReturnLength</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>第二个参数指定查询的信息。</p><p>非调试情况第三个参数指向地址被填充的值：<br>ProcessDebugPort 填充为0<br>ProcessDebugObjectHandle 填充为0<br>ProcessDebugFlags 填充为1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckNtQfP_API</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// get api</span></span><br><span class="line"></span><br><span class="line">HMODULE hNtdll = GetModuleHandleW(<span class="string">L&quot;NtDll.dll&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> pNtQueryInformationProcess = (PNtQueryInformationProcess)GetProcAddress(hNtdll, <span class="string">&quot;NtQueryInformationProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// temp values</span></span><br><span class="line"></span><br><span class="line">HANDLE hCurProc = GetCurrentProcess();</span><br><span class="line"><span class="keyword">bool</span> beingDebug = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process Debug Port (0x7)</span></span><br><span class="line"></span><br><span class="line">DWORD dwDebugPort;</span><br><span class="line">pNtQueryInformationProcess(hCurProc, ProcessDebugPort, &amp;dwDebugPort, <span class="keyword">sizeof</span>(dwDebugPort), <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (dwDebugPort) beingDebug = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process Debug Object Handle (0x1E)</span></span><br><span class="line"></span><br><span class="line">HANDLE hDebugObject = <span class="literal">NULL</span>;</span><br><span class="line">pNtQueryInformationProcess(hCurProc, ProcessDebugObjectHandle, &amp;hDebugObject, <span class="keyword">sizeof</span>(hDebugObject), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hDebugObject) beingDebug = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process Debug Flags (0x1F)</span></span><br><span class="line"></span><br><span class="line">BOOL bDebugFlag = <span class="literal">true</span>;</span><br><span class="line">pNtQueryInformationProcess(hCurProc, ProcessDebugFlags, &amp;bDebugFlag, <span class="keyword">sizeof</span>(bDebugFlag), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bDebugFlag == <span class="number">0</span>) beingDebug = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> beingDebug;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51-4-NtQuerySystemInformation"><a href="#51-4-NtQuerySystemInformation" class="headerlink" title="51.4 NtQuerySystemInformation()"></a>51.4 NtQuerySystemInformation()</h2><p>该函数用于查询系统信息，可以检测系统是否在调试模式下运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">SYSTEM_INFORMATION_CLASS</span> &#123;</span></span><br><span class="line">SystemKernelDebuggerInformation = <span class="number">0x23</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_KERNEL_DEBUGGER_INFORMATION</span> &#123;</span></span><br><span class="line">BOOLEAN DebuggerEnabled;</span><br><span class="line">BOOLEAN DebuggerNotPresent;</span><br><span class="line">&#125;SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MSDN</span></span><br><span class="line"><span class="function">__kernel_entry NTSTATUS <span class="title">NtQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">  PVOID                    SystemInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG                    SystemInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">  PULONG                   ReturnLength</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>非调试情况，debuggerInfo.DebuggerEnabled = 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckNtQSI_API</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// get api</span></span><br><span class="line"></span><br><span class="line">HMODULE hNtdll = GetModuleHandleW(<span class="string">L&quot;NtDll.dll&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> pNtQuerySystemInformation = (PNtQuerySystemInformation)GetProcAddress(hNtdll, <span class="string">&quot;NtQuerySystemInformation&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SystemKernelDebuggerInformation(0x23)</span></span><br><span class="line"></span><br><span class="line">SYSTEM_KERNEL_DEBUGGER_INFORMATION debuggerInfo = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">pNtQuerySystemInformation(SystemKernelDebuggerInformation, &amp;debuggerInfo, <span class="keyword">sizeof</span>(debuggerInfo), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> debuggerInfo.DebuggerEnabled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应对</strong></p><p>xp中修改boot.ini，删除<code>/debugport=coml /baudrate=115200 /Debug</code></p><p>win7 cmd中执行<code>bcdedit /debug off</code></p><h2 id="51-5-NtQueryObject"><a href="#51-5-NtQueryObject" class="headerlink" title="51.5 NtQueryObject()"></a>51.5 NtQueryObject()</h2><p>该函数用于查询内核对象，可以用于检测是否存在调试对象类型的内核对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">OBJECT_INFORMATION_CLASS</span> &#123;</span></span><br><span class="line">ObjectAllTypesInformation = <span class="number">3</span></span><br><span class="line">&#125; OBJECT_INFORMATION_CLASS;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span> <span class="comment">// sizeof = 8</span></span><br><span class="line">USHORT Length;</span><br><span class="line">USHORT MaximumLength;</span><br><span class="line">PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING, * PUNICODE_STRING;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INFORMATION</span> &#123;</span> <span class="comment">// sizeof = 16</span></span><br><span class="line">UNICODE_STRING TypeName;</span><br><span class="line">ULONG TotalNumberOfHandles;</span><br><span class="line">ULONG TotalNumberOfObjects;</span><br><span class="line">&#125; OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_ALL_INFORMATION</span> &#123;</span></span><br><span class="line">ULONG NumberOfObjectsTypes;</span><br><span class="line">OBJECT_TYPE_INFORMATION ObjectTypeInformation[<span class="number">1</span>];</span><br><span class="line">&#125; OBJECT_ALL_INFORMATION, *POBJECT_ALL_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MSDN</span></span><br><span class="line"><span class="function">__kernel_entry NTSYSCALLAPI NTSTATUS <span class="title">NtQueryObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE                   Handle,</span></span></span><br><span class="line"><span class="function"><span class="params">  OBJECT_INFORMATION_CLASS ObjectInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">  PVOID                    ObjectInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG                    ObjectInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">  PULONG                   ReturnLength</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="分析返回的OBJECT-ALL-INFORMATION"><a href="#分析返回的OBJECT-ALL-INFORMATION" class="headerlink" title="分析返回的OBJECT_ALL_INFORMATION"></a>分析返回的OBJECT_ALL_INFORMATION</h3><p>ObjectInformation中会填充OBJECT_ALL_INFORMATION，需要遍历这个结构，我在一次调试中记录下了一些地址用于分析该结构<br>下面是返回的ObjectInformation指向的buf的数据内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0x750000: OBJECT_ALL_INFORMATION</span><br><span class="line">  +0h : NumberOfObjectsTypes(ULONG)&#x3D; 67</span><br><span class="line">  +4h : ObjectTypeInformation(STRUCT)</span><br><span class="line"></span><br><span class="line">0x750004: (OBJECT_TYPE_INFORMATION)</span><br><span class="line">  +0h : ObjectTypeInformation[0].TypeName.Length(USHORT)&#x3D; 8</span><br><span class="line">  +2h : ObjectTypeInformation[0].TypeName.LengthMaximumLength(USHORT)&#x3D; 10</span><br><span class="line">  +4h : ObjectTypeInformation[0].TypeName.Buffer(wchar_t*)&#x3D; 0x750064</span><br><span class="line">  +8h : ObjectTypeInformation[0].TotalNumberOfHandles(ULONG)&#x3D; 67</span><br><span class="line">  +ch: ObjectTypeInformation[0].TotalNumberOfObjects(ULONG)&#x3D; 0</span><br><span class="line"></span><br><span class="line">0x750014: (BYTE[80]) &#x2F;&#x2F; unknown</span><br><span class="line"></span><br><span class="line">0x750064: (wchar[5]) &#x3D; L&quot;Type&quot;</span><br><span class="line"></span><br><span class="line">0x75006E: (BYTE[2]) &#x3D; \x00\x00</span><br><span class="line"></span><br><span class="line">0x750070: (OBJECT_TYPE_INFORMATION)</span><br><span class="line">  +0h : ObjectTypeInformation[1].TypeName.Length(USHORT)&#x3D; 18</span><br><span class="line">  +2h : ObjectTypeInformation[1].TypeName.LengthMaximumLength(USHORT)&#x3D; 20</span><br><span class="line">  +4h : ObjectTypeInformation[1].TypeName.Buffer(wchar_t*)&#x3D; 0x7500D0</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">0x750080: (BYTE[80]) &#x2F;&#x2F; unknown</span><br><span class="line"></span><br><span class="line">0x7500D0: (wchar[10]) &#x3D; L&quot;Directory&quot;</span><br><span class="line"></span><br><span class="line">0x7500E4: (OBJECT_TYPE_INFORMATION)</span><br><span class="line">  +0h : ObjectTypeInformation[2].TypeName.Length(USHORT)&#x3D; 24</span><br><span class="line">  +2h : ObjectTypeInformation[2].TypeName.LengthMaximumLength(USHORT)&#x3D; 26</span><br><span class="line">  +4h : ObjectTypeInformation[2].TypeName.Buffer(wchar_t*)&#x3D; 0x750144</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">0x7500F4: (BYTE[80]) &#x2F;&#x2F; unknown</span><br><span class="line"></span><br><span class="line">0x750144: (wchar[13]) &#x3D; L&quot;SymbolicLink&quot;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到内存布局可简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NumberOfObjectsTypes</span><br><span class="line">ObjectTypeInformation[0]</span><br><span class="line">80bytes undocument date</span><br><span class="line">wchar[]</span><br><span class="line">ObjectTypeInformation[1]</span><br><span class="line">80bytes undocument date</span><br><span class="line">wchar[]</span><br><span class="line">ObjectTypeInformation[2]</span><br><span class="line">80bytes undocument date</span><br><span class="line">wchar[]</span><br></pre></td></tr></table></figure><p>我的理解是<code>OBJECT_ALL_INFORMATION</code>中的<code>OBJECT_TYPE_INFORMATION[]</code>是个元素长度可变的”数组”</p><p><code>OBJECT_TYPE_INFORMATION[]</code>“数组”每个元素由已知的<code>OBJECT_TYPE_INFORMATION（16bytes）+ 未文档化数据（80bytes）+ wchar[]（长度不定）</code>组成</p><p>同时根据书中代码的<code>&amp;0xfffffffc</code>可知是4字节对齐，也就是元素起始地址为4的倍数</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>这里着重分析next那部分代码。</p><p>书中的做法是：<br>首先是找到<code>最后一个字符地址</code>（wchar字符串以\x00\x00结尾）<br>然后清楚低两位（实现4字节对齐）<br>然后加上4</p><p>不考虑对齐，<code>最后一个字符地址+2</code>=<code>下一个元素地址</code>（wchar字符串以\x00\x00结尾）</p><p>如果最后一个字符地址已经对齐，那么下一个元素地址就不对齐，偏移原本为+2，为了对齐变成+4</p><p>如果最后一个字符地址不对其，那么下一个元素地址就对齐，偏移原本为+2，但字符地址清楚了低两位，所以变成+4</p><p>所以最后不管是否对齐都是+4</p><p>也可以先猜测下一个元素地址，然后再判断是否对齐，不对齐就+2，但这样更费劲</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckNtQO_API</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> beingDebug = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get api</span></span><br><span class="line"></span><br><span class="line">HMODULE hNtdll = GetModuleHandleW(<span class="string">L&quot;NtDll.dll&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> pNtQueryObject = (PNtQueryObject)GetProcAddress(hNtdll, <span class="string">&quot;NtQueryObject&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectAllTypesInformation(0x3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get size</span></span><br><span class="line">ULONG lSize = <span class="number">0</span>;</span><br><span class="line">pNtQueryObject(<span class="number">0</span>, ObjectAllTypesInformation, &amp;lSize, <span class="keyword">sizeof</span>(lSize), &amp;lSize);</span><br><span class="line"><span class="comment">// alloc memory</span></span><br><span class="line"><span class="keyword">char</span>* buf = <span class="number">0</span>;</span><br><span class="line">buf = (<span class="keyword">char</span>*)VirtualAlloc(<span class="literal">NULL</span>, lSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="comment">// get info</span></span><br><span class="line">NTSTATUS sta;</span><br><span class="line">sta = pNtQueryObject((HANDLE)<span class="number">0xFFFFFFFF</span>, ObjectAllTypesInformation, buf, lSize, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">auto</span> pObjAllInfo = (POBJECT_ALL_INFORMATION)buf;</span><br><span class="line"><span class="comment">// check</span></span><br><span class="line">ULONG objNum = pObjAllInfo-&gt;NumberOfObjectsTypes;</span><br><span class="line"><span class="keyword">auto</span> pObjTypeInfo = pObjAllInfo-&gt;ObjectTypeInformation;</span><br><span class="line"><span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; objNum; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (wcscmp(<span class="string">L&quot;DebugObject&quot;</span>, pObjTypeInfo-&gt;TypeName.Buffer) == <span class="number">0</span>) &#123;</span><br><span class="line">beingDebug = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line">        <span class="comment">// go to last wchar</span></span><br><span class="line">pObjTypeInfo = (POBJECT_TYPE_INFORMATION)((ULONG)pObjTypeInfo-&gt;TypeName.Buffer + pObjTypeInfo-&gt;TypeName.Length);</span><br><span class="line">        <span class="comment">// alignment</span></span><br><span class="line">pObjTypeInfo = (POBJECT_TYPE_INFORMATION)(((ULONG)pObjTypeInfo) &amp; <span class="number">0xFFFFFFFC</span>);</span><br><span class="line">        <span class="comment">// alignment offset</span></span><br><span class="line">pObjTypeInfo = (POBJECT_TYPE_INFORMATION)((ULONG)pObjTypeInfo + <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buf)</span><br><span class="line">VirtualFree(buf, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> beingDebug;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51-6-ZwSetInformationThread"><a href="#51-6-ZwSetInformationThread" class="headerlink" title="51.6 ZwSetInformationThread()"></a>51.6 ZwSetInformationThread()</h2><p>该函数用于设置线程信息，可将线程隐藏起来，使调试器收不到消息</p><p>DebugActiveProcessStop()则可以分离调试器和被调试线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">THREADINFOCLASS</span> &#123;</span></span><br><span class="line">ThreadHideFromDebugger = <span class="number">0x11</span></span><br><span class="line">&#125; THREADINFOCLASS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MSDN</span></span><br><span class="line"><span class="function">NTSYSAPI NTSTATUS <span class="title">ZwSetInformationThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE          ThreadHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  THREADINFOCLASS ThreadInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">  PVOID           ThreadInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG           ThreadInformationLength</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// get api</span></span><br><span class="line"></span><br><span class="line">HMODULE hNtdll = GetModuleHandleW(<span class="string">L&quot;NtDll.dll&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> pZwSetInformationThread = (PZwSetInformationThread)GetProcAddress(hNtdll, <span class="string">&quot;ZwSetInformationThread&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// detach</span></span><br><span class="line">pZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, <span class="number">0</span>, <span class="number">0</span>);·</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// #include &lt;windows.h&gt;</span></span><br><span class="line">    DebugActiveProcessStop(GetCurrentProcessId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51-7-TLS"><a href="#51-7-TLS" class="headerlink" title="51.7 TLS"></a>51.7 TLS</h2><p>tls回调函数会在ep之前执行（实际上是在创建终止进程时都会执行）</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/INCLUDE:__tls_used&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> NTAPI <span class="title">TLS_CALLBACK1</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;.CRT$XLX&quot;</span>)</span></span><br><span class="line">PIMAGE_TLS_CALLBACK pTLS_callbacks[] = &#123; TLS_CALLBACK1, TLS_CALLBACK2 &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> NTAPI <span class="title">TLS_CALLBACK1</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (Reason) &#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;tls:process attach\n\n&quot;</span>;</span><br><span class="line">        <span class="comment">// YourAntiDebug();</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;tls:thread attach\n\n&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;tls:thread detach\n\n&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;tls:process detach\n\n&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51-8-ETC"><a href="#51-8-ETC" class="headerlink" title="51.8 ETC"></a>51.8 ETC</h2><p>检测窗口 FindWindow()</p><p>检测进程 CreateToolhelp32Snapshot()</p><p>检测计算机名</p><p>检测运行路径</p><p>检测虚拟机</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/reversecore/">reversecore</category>
      
      <category domain="https://windgodm.github.io/blog/tags/antiDebug/">antiDebug</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/10/16/recoreR3StaAntiDebug/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>pbctf21 btree wp</title>
      <link>https://windgodm.github.io/blog/2021/10/09/pbctf21-btree-Wp/</link>
      <guid>https://windgodm.github.io/blog/2021/10/09/pbctf21-btree-Wp/</guid>
      <pubDate>Sat, 09 Oct 2021 04:00:00 GMT</pubDate>
      
      <description>pbctf 21 btree wp, beaengine+dij</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="PBCTF21-RE-BinaryTree-Beaengine-dijkstra解法"><a href="#PBCTF21-RE-BinaryTree-Beaengine-dijkstra解法" class="headerlink" title="PBCTF21 RE BinaryTree Beaengine+dijkstra解法"></a>PBCTF21 RE BinaryTree Beaengine+dijkstra解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>代码是动态解密的，简单的xor，解密一块执行一块。每一块结尾会设置rbx，rbx决定下一块被解密的代码。</p><p>实际上每一块代码相当于一个节点，里面有一个根据输入的jz，决定下一个rbx以及一个cost，所以相当于一颗二叉树。</p><p>每次经过一个节点都会累加cost。</p><p>根节点对应的代码块会判断cost是否小于等于某个值，然后输出成功信息。</p><p>如果只有唯一解那么显然是找最短路。</p><p>解题思路是beaengine解析代码生成图，用dijkstra算法求最短路并输出路径。<br>事实上只有一条最短路，刚刚等于那个值。</p><h2 id="beaengine提取图"><a href="#beaengine提取图" class="headerlink" title="beaengine提取图"></a>beaengine提取图</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEA_ENGINE_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BeaEngine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;legacy_stdio_definitions.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;BeaEngine.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> path[<span class="number">25503</span>][<span class="number">4</span>] = &#123; <span class="number">0</span>, &#125;; <span class="comment">// 0(path/rbx,cost) 1(path/rbx,cost)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, Block*&gt;&gt; rbxs; <span class="comment">// rbx(xor offset), lastBlock</span></span><br><span class="line"><span class="keyword">int</span> sa = <span class="number">0x176</span>;</span><br><span class="line">BYTE* firstBlock;</span><br><span class="line"><span class="keyword">int</span> blockNum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; dised;</span><br><span class="line">Block xorBlock = &#123;</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0xc7</span>, <span class="number">0xc0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0xc7</span>, <span class="number">0xc7</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0xc7</span>,</span><br><span class="line"><span class="number">0xc2</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x81</span>, <span class="number">0xf9</span>,</span><br><span class="line"><span class="number">0xda</span>, <span class="number">0x49</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7f</span>, <span class="number">0x07</span>, <span class="number">0x4c</span>, <span class="number">0x89</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Block* <span class="title">Xor</span><span class="params">(<span class="keyword">char</span>* firstBlock, UInt64 offset, Block &amp;oldBlock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Block* pB = <span class="keyword">new</span> Block();</span><br><span class="line">pB-&gt;index = offset &gt;&gt; <span class="number">5</span>;</span><br><span class="line">blockNum++;</span><br><span class="line"><span class="keyword">char</span>* xorBuf = firstBlock + offset;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">pB-&gt;buf[i] = xorBuf[i] ^ oldBlock.buf[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Jmp</span><span class="params">(DISASM&amp; infos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UINT64 nextVA = infos.Instruction.AddrValue;</span><br><span class="line">UINT64 curVA = infos.VirtualAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jmp</span></span><br><span class="line">infos.EIP += nextVA - curVA;</span><br><span class="line">infos.VirtualAddr = nextVA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisasmCode</span><span class="params">(<span class="keyword">char</span>* stBuf, UINT64 stVA, Block* curBlock, <span class="keyword">int</span> rbx, <span class="keyword">int</span> branch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DISASM infos;</span><br><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;infos, <span class="number">0</span>, <span class="keyword">sizeof</span>(DISASM));</span><br><span class="line">infos.EIP = (UINT64)stBuf;</span><br><span class="line">infos.VirtualAddr = (UINT64)stVA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (infos.Error == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// limit</span></span><br><span class="line">UInt64 offset = infos.EIP - (UINT64)curBlock-&gt;buf;</span><br><span class="line"><span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= <span class="number">32</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (infos.VirtualAddr == <span class="number">0x400080</span>) &#123;<span class="comment">// xor</span></span><br><span class="line">rbxs.push(<span class="built_in">make_pair</span>(rbx, curBlock));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//disasm</span></span><br><span class="line">len = Disasm(&amp;infos);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; infos.VirtualAddr &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; infos.CompleteInstr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jmp</span></span><br><span class="line"><span class="keyword">if</span> (infos.Instruction.BranchType == JmpType) &#123;</span><br><span class="line"><span class="keyword">if</span> (infos.Instruction.AddrValue == <span class="number">0x400080</span>) &#123; <span class="comment">// xor</span></span><br><span class="line">rbxs.push(<span class="built_in">make_pair</span>(rbx, curBlock));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Jmp(infos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jmp</span></span><br><span class="line"><span class="keyword">if</span> (infos.Instruction.BranchType) &#123;</span><br><span class="line"><span class="comment">// false branch</span></span><br><span class="line">DisasmCode((<span class="keyword">char</span>*)(infos.EIP + len), infos.VirtualAddr + len, curBlock, rbx, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// true branch</span></span><br><span class="line">branch = <span class="number">1</span>;</span><br><span class="line">Jmp(infos);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if modified rbx (0x8)</span></span><br><span class="line"><span class="keyword">if</span> (((infos.Operand1.AccessMode == WRITE) &amp;&amp; (infos.Operand1.Registers.gpr &amp; REG3))) &#123;</span><br><span class="line">rbx += infos.Operand2.Memory.Displacement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if add r9 (0x200)</span></span><br><span class="line"><span class="keyword">if</span> ((infos.Operand1.AccessMode == <span class="number">3</span>) &amp;&amp; (infos.Operand1.Registers.gpr &amp; <span class="number">0x200</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (branch &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">path[curBlock-&gt;index][branch * <span class="number">2</span>] = rbx &gt;&gt; <span class="number">5</span>;</span><br><span class="line">path[curBlock-&gt;index][branch * <span class="number">2</span> + <span class="number">1</span>] = infos.Instruction.Immediat;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// go on</span></span><br><span class="line">infos.EIP += len;</span><br><span class="line">infos.VirtualAddr += len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream fin;</span><br><span class="line">ofstream fout;</span><br><span class="line">BYTE* fileBuf;</span><br><span class="line">Block* lastBlock;</span><br><span class="line">Block* pB;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read file</span></span><br><span class="line"></span><br><span class="line">fin.open(<span class="string">&quot;E:\\works\\ctf\\21pbctf\\re_BinaryTree\\main.elf&quot;</span>, ios::in | ios::binary);</span><br><span class="line"></span><br><span class="line">fin.seekg(<span class="number">0</span>, ios::end);</span><br><span class="line"><span class="keyword">size_t</span> fileSize = fin.tellg();</span><br><span class="line">fin.seekg(<span class="number">0</span>, ios::beg);</span><br><span class="line">fileBuf = (BYTE*)<span class="built_in">malloc</span>(fileSize);</span><br><span class="line">fin.read((<span class="keyword">char</span>*)fileBuf, fileSize);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fileSize:&quot;</span> &lt;&lt; dec &lt;&lt; fileSize &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">fin.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// disasm</span></span><br><span class="line"></span><br><span class="line">firstBlock = fileBuf + sa;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rbx:0&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pB = Xor((<span class="keyword">char</span>*)firstBlock, <span class="number">0</span>, xorBlock);</span><br><span class="line">dised.insert(<span class="number">0</span>);</span><br><span class="line">DisasmCode(pB-&gt;buf, <span class="number">0x4000AD</span>, pB, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (!rbxs.empty()) &#123;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, Block*&gt; t = rbxs.front();</span><br><span class="line">rbxs.pop();</span><br><span class="line"></span><br><span class="line">lastBlock = t.second;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; dec &lt;&lt; blockNum &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0x639f * 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dised.insert(t.first).second) &#123;</span><br><span class="line"><span class="comment">// not disasm</span></span><br><span class="line">pB = Xor((<span class="keyword">char</span>*)firstBlock, t.first, *lastBlock);</span><br><span class="line"><span class="comment">// disasm</span></span><br><span class="line">DisasmCode(pB-&gt;buf, <span class="number">0x4000AD</span>, pB, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write file</span></span><br><span class="line"></span><br><span class="line">fout.open(<span class="string">&quot;E:\\works\\ctf\\21pbctf\\re_BinaryTree\\main_.elf&quot;</span>, ios::out | ios::binary);</span><br><span class="line">fout.write((<span class="keyword">char</span>*)fileBuf, fileSize);</span><br><span class="line">fout.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// write file</span></span><br><span class="line"></span><br><span class="line">fout.open(<span class="string">&quot;E:\\works\\ctf\\21pbctf\\re_BinaryTree\\path.txt&quot;</span>, ios::out);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blockNum; i++) &#123;</span><br><span class="line">fout &lt;&lt; path[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; path[i][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; path[i][<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; path[i][<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">fout.close();</span><br><span class="line"></span><br><span class="line">fout.open(<span class="string">&quot;E:\\works\\ctf\\21pbctf\\re_BinaryTree\\pathDij.txt&quot;</span>, ios::out);</span><br><span class="line"><span class="keyword">int</span> E = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blockNum; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (path[i][<span class="number">1</span>]) &#123;</span><br><span class="line">fout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; path[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; path[i][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">fout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; path[i][<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; path[i][<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">E += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">fout.close();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;N E\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dec &lt;&lt; blockNum &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; E &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 25503 50942 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h2><p>自己打oi时留下的板子，忘记有没有加优化了，不过这个版本比较方便记录path</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 有向+无向，不能用于负权图</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; TR;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> roots[] = &#123; <span class="number">1225</span>,<span class="number">1226</span>,<span class="number">1891</span>,<span class="number">1892</span>,<span class="number">3929</span>,<span class="number">3930</span>,<span class="number">4929</span>,<span class="number">4930</span>,<span class="number">6295</span>,<span class="number">6296</span>,<span class="number">9313</span>,<span class="number">9314</span>,<span class="number">9813</span>,<span class="number">9814</span>,<span class="number">15465</span>,<span class="number">15466</span>,<span class="number">15713</span>,<span class="number">15714</span>,<span class="number">17301</span>,<span class="number">17302</span>,<span class="number">18767</span>,<span class="number">18768</span>,<span class="number">18841</span>,<span class="number">18842</span>,<span class="number">19145</span>,<span class="number">19146</span>,<span class="number">19279</span>,<span class="number">19280</span>,<span class="number">19927</span>,<span class="number">19928</span>,<span class="number">22501</span>,<span class="number">22502</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> path[<span class="number">50943</span>];</span><br><span class="line"><span class="keyword">int</span> path1[<span class="number">50943</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a != <span class="number">-1</span> &amp;&amp; (a &lt; b || b == <span class="number">-1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* r = freopen(<span class="string">&quot;E:\\works\\ctf\\21pbctf\\re_BinaryTree\\pathDij.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j, u, v, w;</span><br><span class="line">Edge edge;</span><br><span class="line"><span class="built_in">list</span>&lt;Edge&gt;::iterator it;</span><br><span class="line">TR tr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, E, start, iMin, nMin;</span><br><span class="line"><span class="keyword">int</span>* flag;</span><br><span class="line"><span class="built_in">set</span>&lt;TR&gt; ds;</span><br><span class="line"><span class="keyword">int</span>* d;</span><br><span class="line"><span class="built_in">list</span>&lt;Edge&gt;* es;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;E);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;start);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">flag = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">d = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">flag[i] = <span class="number">0</span>;</span><br><span class="line">d[i] = <span class="number">-1</span>;</span><br><span class="line">path[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ds.insert(<span class="built_in">make_pair</span>(<span class="number">0</span>, start));</span><br><span class="line">d[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读图</span></span><br><span class="line">es = <span class="keyword">new</span> <span class="built_in">list</span>&lt;Edge&gt;[N];</span><br><span class="line"><span class="keyword">int</span> boo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">edge.v = v;</span><br><span class="line">edge.w = w;</span><br><span class="line">es[u].push_back(edge);</span><br><span class="line"><span class="keyword">if</span> (boo) &#123;</span><br><span class="line">boo = <span class="number">0</span>;</span><br><span class="line">path1[u] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">boo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dij</span></span><br><span class="line"><span class="keyword">while</span> (!ds.empty()) &#123;</span><br><span class="line"><span class="comment">// 找最小未完成节点（确保d[iMin] != -1）</span></span><br><span class="line">iMin = ds.begin()-&gt;second;</span><br><span class="line">nMin = ds.begin()-&gt;first;</span><br><span class="line">ds.erase(ds.begin());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记完成</span></span><br><span class="line">u = iMin;</span><br><span class="line">flag[u] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次松弛</span></span><br><span class="line"><span class="keyword">for</span> (it = es[u].begin(); it != es[u].end(); it++) &#123;</span><br><span class="line">v = it-&gt;v;</span><br><span class="line">w = d[iMin] + it-&gt;w;</span><br><span class="line"><span class="keyword">if</span> (w == d[v])</span><br><span class="line">path[v] = u;</span><br><span class="line"><span class="keyword">if</span> (min(w, d[v])) &#123;</span><br><span class="line">d[v] = w;</span><br><span class="line"><span class="comment">// 加入set</span></span><br><span class="line">tr = <span class="built_in">make_pair</span>(w, v);</span><br><span class="line"><span class="keyword">if</span> (ds.find(tr) != ds.end()) ds.erase(tr);</span><br><span class="line">ds.insert(tr);</span><br><span class="line">path[v] = u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// for (i = 0; i &lt; N; i++)</span></span><br><span class="line"><span class="comment">//printf(&quot;%d:%d\n&quot;, i, d[i]);</span></span><br><span class="line"><span class="comment">// putchar(10);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nans:\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[roots[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nshortest:\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (d[roots[i]] &lt;= <span class="number">0x49DA</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; roots[i] &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; d[roots[i]] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\npath\n&quot;</span>;</span><br><span class="line">i = <span class="number">19279</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">i = path[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\npath\n&quot;</span>;</span><br><span class="line">i = <span class="number">19279</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// path[i] -&gt; i</span></span><br><span class="line"><span class="keyword">if</span> (path1[path[i]] == i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">i = path[i];</span><br><span class="line">&#125; <span class="keyword">while</span> (i);</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!es[i].empty()) &#123;</span><br><span class="line">i = es[i].begin()-&gt;v;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nl:&quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">delete</span>[] flag;</span><br><span class="line"><span class="keyword">delete</span>[] es;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="long2bytes"><a href="#long2bytes" class="headerlink" title="long2bytes"></a>long2bytes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">ans = <span class="string">&#x27;01111101001101110110010101100101011001100110001001100001001110000011000000110110001100100110001000110001011001100011011100110001001100000011100101100011001100110011000100110101011000110110000100111000001101110011010001100001001100100011001001100010011000100011000000110011011001010011000000110011011000110011010000110111011001010101111100100001001000010110010101100100011011110110001101011111011001110110111001101001011110010110011001101001011001000110111101101101001011010110011001101100011001010111001101011111011011100110100101011111011010000111010001100001011100000101111101110100011100110110010101110100011100100110111101101000011100110101111101100101011010000111010001011111011001110110111001101001011001000110111001101001011001100010000100100001011110110110011001110100011000110110001001110000&#x27;</span></span><br><span class="line">ans = <span class="built_in">int</span>(ans, <span class="number">2</span>)</span><br><span class="line">print(long_to_bytes(ans)[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[<a href="https://bbs.pediy.com/thread-269815.htm">原创]PBCTF21 RE BinaryTree Beaengine+dijkstra解法-bbs.pediy.com</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/10/09/pbctf21-btree-Wp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>vmp2 (3) handler类型总结</title>
      <link>https://windgodm.github.io/blog/2021/09/28/vmp2-p3/</link>
      <guid>https://windgodm.github.io/blog/2021/09/28/vmp2-p3/</guid>
      <pubDate>Tue, 28 Sep 2021 04:00:00 GMT</pubDate>
      
      <description>分析handler后的总结</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="VMP2（3）handler类型总结"><a href="#VMP2（3）handler类型总结" class="headerlink" title="VMP2（3）handler类型总结"></a>VMP2（3）handler类型总结</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>详细分析push、pop、计算类handler以及粗略分析其余handler后对handler进行分类并做一些总结。</p><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>vm字节码结构有三种：</p><ul><li>opcode(1B)</li><li>opcode(1B) + Imm(1~8B)</li><li>opcode(1B) + VmRegOffset(1B)</li></ul><p>所有字节码都是经过加密的，解析时需要根据rbx动态解密。</p><p>vm字节码各部分是倒序排列的，也就是说后一条指令在前面，Imm、VmRegOffset在opcode前面。</p><h2 id="vm虚拟栈与虚拟寄存器"><a href="#vm虚拟栈与虚拟寄存器" class="headerlink" title="vm虚拟栈与虚拟寄存器"></a>vm虚拟栈与虚拟寄存器</h2><p>通过分析涉及vm栈的handler（如push、pop、add等），得出vm栈是2字节对齐的。vm寄存器实质可以理解为一个全局数组，也是2字节对齐的。</p><h2 id="push类"><a href="#push类" class="headerlink" title="push类"></a>push类</h2><p>push类指令push数据到栈上。分为三种：</p><ul><li>push 立即数</li><li>push vm寄存器</li><li>push 真实寄存器</li></ul><p>立即数即指令的Imm部分，push到vm寄存器时则根据VmRegOffset部分。</p><p>push压栈元素的大小不小于被压栈数据的长度。比如push 4字节的立即数有两条指令：一条是压入4字节(VmRsp-=4)；一条是压入8字节(VmRsp-=8)，其中被压入的立即数在栈顶的低4字节([VmRsp] = ImmD)。</p><h2 id="pop类"><a href="#pop类" class="headerlink" title="pop类"></a>pop类</h2><p>pop类指令从vm栈上pop数据。分为两种：</p><ul><li>pop到vm寄存器中</li><li>pop到真实寄存器中（包括popfq）。</li></ul><p>显然pop到vm寄存器的指令长度为2字节，第二个字节指示了vm寄存器的偏移。</p><h2 id="计算类"><a href="#计算类" class="headerlink" title="计算类"></a>计算类</h2><p>计算类指令有七种：</p><ul><li>nor</li><li>add</li><li>div</li><li>shl</li><li>shld</li><li>shr</li><li>shrd</li></ul><p>逻辑运算由nor组合实现，减法可以通过逻辑运算和加法实现，乘法可以由位移和加法组合实现。</p><p>各种指令的操作数也是分长度的。</p><p>计算类指令基于栈实现，可以等价成以下4步：</p><ul><li>所有操作数出栈</li><li>计算结果</li><li>入栈结果</li><li>入栈RFLAGS</li></ul><p>也就是计算以后操作数将清除，栈顶为RFLAGS(8Byte)、栈顶第二项为结果(长度由指令决定)</p><h2 id="Indirection类"><a href="#Indirection类" class="headerlink" title="Indirection类"></a>Indirection类</h2><p>该类指令用于解除应用。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top = *top</span><br></pre></td></tr></table></figure><p>等价于以下3步：</p><ul><li>出栈（8字节指针）</li><li>解除引用</li><li>入栈结果</li></ul><h2 id="subscript类"><a href="#subscript类" class="headerlink" title="subscript类"></a>subscript类</h2><p>该类指令用于给内存地址赋值。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*top = top2</span><br></pre></td></tr></table></figure><p>等价于以下3步：</p><ul><li>出栈左值（8字节指针）</li><li>出栈右值</li><li>往指针指向地址赋值</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有初始化虚拟机、call、ret、修改rbx、修改bp、基于vm栈的cpuid等指令。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Re/">Re</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/vmp2/">vmp2</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/09/28/vmp2-p3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>BeaEngine</title>
      <link>https://windgodm.github.io/blog/2021/09/20/BeaEngine/</link>
      <guid>https://windgodm.github.io/blog/2021/09/20/BeaEngine/</guid>
      <pubDate>Mon, 20 Sep 2021 04:00:00 GMT</pubDate>
      
      <description>一个反汇编引擎,vs19中用c++以静态连接调用BeaEngine的配置，以及一些笔记。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="BeaEngine"><a href="#BeaEngine" class="headerlink" title="BeaEngine"></a>BeaEngine</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>一个反汇编引擎，支持c++、python等。</p><p>具体使用参照官方github的example，非常详细。</p><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf;</span><br><span class="line">UINT64 va;</span><br><span class="line"></span><br><span class="line">DISASM infos;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;infos, <span class="number">0</span>, <span class="keyword">sizeof</span>(DISASM));</span><br><span class="line">infos.EIP = buf;</span><br><span class="line">infos.VirtualAddr = va;</span><br><span class="line"></span><br><span class="line"><span class="comment">// disasm</span></span><br><span class="line">len = Disasm(&amp;infos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Branch type</span></span><br><span class="line"><span class="keyword">if</span> (infos.Instruction.BranchType == JmpType); <span class="comment">// RetType, CallType</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operater</span></span><br><span class="line">infos.Instruction.Mnemonic; <span class="comment">// &quot;add&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reg</span></span><br><span class="line">infos.Operand1.OpMnemonic; <span class="comment">// &quot;rax&quot;</span></span><br><span class="line">infos.Operand1.Registers.gpr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Continue</span></span><br><span class="line">infos.EIP += len;</span><br><span class="line">infos.VirtualAddr += len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jmp</span></span><br><span class="line">UINT64 nextVA = infos.Instruction.AddrValue;</span><br><span class="line">UINT64 curVA = infos.VirtualAddr;</span><br><span class="line">infos.EIP += nextVA - curVA;</span><br><span class="line">infos.VirtualAddr = nextVA;</span><br></pre></td></tr></table></figure><h2 id="vs2019-amp-static-lib"><a href="#vs2019-amp-static-lib" class="headerlink" title="vs2019 &amp; static lib"></a>vs2019 &amp; static lib</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>项目属性页 -&gt; C/C++ -&gt; 常规 -&gt; 附加包含目录 添加beaengine的headers目录</p><p>项目属性页 -&gt; C/C++ -&gt; 代码生成 -&gt; 运行库 /MD /MDd改成/MT /MTd</p><p>项目属性页 -&gt; 链接器 -&gt; 输入 -&gt; 忽略特定默认库 添加crt64.lib</p><p>然后在代码开头添加以下语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEA_ENGINE_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BeaEngine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;legacy_stdio_definitions.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;D:\\beaengine-5.3.0\\lib_static_x64\\BeaEngine.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>重点是：第一行在include”BeaEngine.h”前指明是静态，修改运行库、忽略crt64.lib以及第三行链接兼容库。</p><h3 id="可能的错误"><a href="#可能的错误" class="headerlink" title="可能的错误"></a>可能的错误</h3><h4 id="无法解析的外部符号"><a href="#无法解析的外部符号" class="headerlink" title="无法解析的外部符号"></a>无法解析的外部符号</h4><p>如果缺少第一行，报错如下：</p><p><code>error LNK2019: 无法解析的外部符号 __imp_Disasm</code></p><p>使用静lib库时必须在include前通过define指明使用静态库</p><h4 id="无法打开crt64-lib-或-sprintf无效引用"><a href="#无法打开crt64-lib-或-sprintf无效引用" class="headerlink" title="无法打开crt64.lib 或 sprintf无效引用"></a>无法打开crt64.lib 或 sprintf无效引用</h4><p>如果没有忽略crt64.lib或者没有修改运行库，报错如下：</p><p><code>LINK : fatal error LNK1104: 无法打开文件“crt64.lib”</code></p><p>这时尝试在配置链接器中忽略掉crt64.lib这个库，就会报<code>_sprintf无效引用</code></p><p>这时需要链接兼容库<code>legacy_stdio_definitions.lib</code></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Programing/">Programing</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/Programing/">Programing</category>
      
      <category domain="https://windgodm.github.io/blog/tags/BeaEngine/">BeaEngine</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/09/20/BeaEngine/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>neo4j与CQL</title>
      <link>https://windgodm.github.io/blog/2021/09/20/neo4j-CQL/</link>
      <guid>https://windgodm.github.io/blog/2021/09/20/neo4j-CQL/</guid>
      <pubDate>Mon, 20 Sep 2021 04:00:00 GMT</pubDate>
      
      <description>neo4j是个非关系型数据库，用docker装了个neo4j玩玩。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="ne04j与CQL"><a href="#ne04j与CQL" class="headerlink" title="ne04j与CQL"></a>ne04j与CQL</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>neo4j是个nosql数据库，通过docker安装可以启动一个本地服务器，在浏览器中访问。能画出数据的关系图。通过CQL语言进行操作。</p><p>主要用途是构建社会关系、知识图谱这种类型的数据库。自带图形化展示数据的功能。</p><h2 id="通过docker安装"><a href="#通过docker安装" class="headerlink" title="通过docker安装"></a>通过docker安装</h2><p>首先安装docker，win10需要先装wsl2，可以通过下载离线安装包的方z式，安装某个wsl2子系统到指定位置，具体不在絮述。</p><p>官网查询最新版本，比如是4.3.3，在wsl2的shell中执行以下命令拉取neo4j的docker。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull neo4j:4.3.3-community</span><br></pre></td></tr></table></figure><p>执行以下命令运行。其中NEO4J_AUTH后跟着的是初始 账号/密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name container_name -p 7474:7474 -p 7687:7687 -v /home/neo4j/data:/data -v /home/neo4j/logs:/logs -v /home/neo4j/conf:/var/lib/neo4j/conf -v /home/neo4j/import:/var/lib/neo4j/import --env NEO4J_AUTH=neo4j/password neo4j:4.3.3-community</span><br></pre></td></tr></table></figure><h2 id="CQL"><a href="#CQL" class="headerlink" title="CQL"></a>CQL</h2><blockquote><p>1、Neo4j数据库服务器使用此&lt;node-name&gt;将此节点详细信息存储在Database.As中作为Neo4j DBA或Developer，我们不能使用它来访问节点详细信息。———为何不能呢？</p><p>2、Neo4j数据库服务器创建一个&lt;label-name&gt;作为内部节点名称的别名。作为Neo4j DBA或Developer，我们应该使用此标签名称来访问节点详细信息。</p></blockquote><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p><code>CREATE (&lt;node-name&gt;:&lt;label-name&gt;)</code></p><p>node-name可以理解成编程语言里的变量名，是一条数据的别名、句柄，用于操作这一条数据。可以当成是一个临时变量。（可以参照下面第三、四个示例理解）<br>可以省略。</p><p>label-name是数据的标签，或者说类型，有人把它类比成sql中的表名。</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个标签为person，没有其他属性、关系的节点。</span><br><span class="line">&#x2F;&#x2F; 写法1</span><br><span class="line">CREATE (a:person)</span><br><span class="line">&#x2F;&#x2F; 写法2，省略节点名</span><br><span class="line">CREATE (:person)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个带有name、phone两个属性的节点。</span><br><span class="line">CREATE (a:person&#123;name:&#39;abc&#39;, phone:114514&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建两个节点，并添加关系</span><br><span class="line">&#x2F;&#x2F; 写法1，创建时添加关系</span><br><span class="line">CREATE (p1:person) CREATE (p2:person)-[r:&#39;friend&#39;]-&gt;(p2)</span><br><span class="line">&#x2F;&#x2F; 写法2，创建后添加关系</span><br><span class="line">CREATE (p1:person) CREATE (p2:person) CREATE (p1)-[r:&#39;friend&#39;]-&gt;(p2)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个节点，并在图中显示该节点</span><br><span class="line">CREATE (a:person) RETURN a</span><br></pre></td></tr></table></figure><h3 id="搜索节点"><a href="#搜索节点" class="headerlink" title="搜索节点"></a>搜索节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示所有的节点及其关系</span><br><span class="line">MATCH (n) RETURN n</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示所有标签为person的节点及其关系</span><br><span class="line">MATCH (n:person) RETURN n</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示所有标签为person，属性id&#x3D;1的节点及其关系</span><br><span class="line">MATCH (n:person&#123;id:1&#125;) RETURN n</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示所有关系为friend的节点</span><br><span class="line">MATCH p&#x3D;()-[r:&#39;friend&#39;]-&gt;() RETURN p</span><br></pre></td></tr></table></figure><h3 id="添加属性、关系"><a href="#添加属性、关系" class="headerlink" title="添加属性、关系"></a>添加属性、关系</h3><p>需要配合MATCH使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加修改属性</span><br><span class="line">MATCH (n:person&#123;id:1&#125;) SET n.name&#x3D;&#39;abc&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加关系</span><br><span class="line">MATCH (p:person&#123;id:1&#125;) MATCH (n:person&#123;id:1&#125;) CREATE (p)-[r:&#39;friend&#39;]-&gt;(n)</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>需要配合MATCH使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:person&#123;id:1&#125;) DELETE p</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:person&#123;id:1&#125;)-[r]-(n:person&#123;id:2&#125;) DELETE p,r,n</span><br></pre></td></tr></table></figure><h3 id="删除属性、关系"><a href="#删除属性、关系" class="headerlink" title="删除属性、关系"></a>删除属性、关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:person&#123;id:1&#125;) REMOVE n.name</span><br></pre></td></tr></table></figure><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>csv文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id, name1, aaa2, bbb</span><br></pre></td></tr></table></figure><p>读取并创建节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV FROM &#39;pathname&#39; AS line FILEDTERMINATOR &#39;,&#39; CREATE (:p&#123;id:toInterger(line[0]), name:line[1]&#125;)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Database/">Database</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/Database/">Database</category>
      
      <category domain="https://windgodm.github.io/blog/tags/neo4j/">neo4j</category>
      
      <category domain="https://windgodm.github.io/blog/tags/CQL/">CQL</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/09/20/neo4j-CQL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>vmp2 (2) 初步分析handler(BeaEngine)</title>
      <link>https://windgodm.github.io/blog/2021/09/15/vmp2-p2/</link>
      <guid>https://windgodm.github.io/blog/2021/09/15/vmp2-p2/</guid>
      <pubDate>Wed, 15 Sep 2021 04:00:00 GMT</pubDate>
      
      <description>初步分析handler,用BeaEngine辅助分析。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="VMP2（2）初步分析handler-BeaEngine"><a href="#VMP2（2）初步分析handler-BeaEngine" class="headerlink" title="VMP2（2）初步分析handler(BeaEngine)"></a>VMP2（2）初步分析handler(BeaEngine)</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>基于手动初步分析的基础，了解了vmp2的结构以及handler表及解密方式。<br>现在写些工具用于辅助分析。</p><p>流程为：</p><ul><li>获取handler RVA</li><li>分析跳转并dump handler</li></ul><p>由subs1(*top = top2)这类涉及栈的一字节操作handler可知vmp栈是两字节对齐。</p><p>dump handler的目的是为了方便分析，具体原因见“条件与无条件jmp”。</p><p>有一个handler存在循环，在自动分析中导致了栈溢出，无法dump出来（需要检查是否重复解析同一地址才能正确dump）。</p><h2 id="获取handler的RVA"><a href="#获取handler的RVA" class="headerlink" title="获取handler的RVA"></a>获取handler的RVA</h2><h3 id="获取handler表"><a href="#获取handler表" class="headerlink" title="获取handler表"></a>获取handler表</h3><p>根据手动调试的结果，可以得到handler表的va，计算出rva，再转换成fa即可通过读取文件获取handler表。</p><p>rva转fa解析pe头的section header即可，这里不做絮述。</p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UINT64 handlers[<span class="number">256</span>];</span><br><span class="line">UINT64 imageBase = <span class="number">0x140000000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// ror 5</span></span><br><span class="line">    handlers[i] = (handlers[i] &gt;&gt; <span class="number">5</span>) | ((handlers[i] &amp; <span class="number">31</span>) &lt;&lt; <span class="number">59</span>);</span><br><span class="line">    <span class="comment">// get rva</span></span><br><span class="line">    handlers[i] -= imageBase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vmp2默认 Image Base 是0x140000000。</p><h2 id="BeaEngine"><a href="#BeaEngine" class="headerlink" title="BeaEngine"></a>BeaEngine</h2><p>BeaEngine是一个反汇编引擎，可以辅助分析。</p><p>这里给出一个大概的框架，用于辅助分析handler中的跳转，以及折叠jmp和部分意义不大的jmp。<br>具体可以查看官网文档。</p><p>通过下述代码可以遍历handler，然后可以输出为文本（<code>infos.VirtualAddr</code>,<code>infos.CompleteInstr</code>），借助vsc、md等文本工具分析汇编代码。<br>其中vsc有一个提供asm高亮的插件<code>x86 and x86_64 Assembly</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisasmCode</span><span class="params">(<span class="keyword">char</span>* stBuf, UINT64 stVA, UINT64 edVA)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DISASM infos;</span><br><span class="line">PDISASM prevInfos = <span class="keyword">new</span> DISASM();</span><br><span class="line">PDISASM prev2Infos = <span class="keyword">new</span> DISASM();</span><br><span class="line">PDISASM tpInfos;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">UINT64 curVA, nextVA;</span><br><span class="line"><span class="keyword">int</span> isJmp; <span class="comment">// -1: undefine, 0: false, 1: true</span></span><br><span class="line">    </span><br><span class="line">    BYTE cmp_rbp_rax[<span class="number">3</span>] = &#123; <span class="number">0x48</span>, <span class="number">0x39</span>, <span class="number">0xC5</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (infos.Error == <span class="number">0</span>) &#123;</span><br><span class="line">curVA = infos.VirtualAddr;</span><br><span class="line"><span class="keyword">if</span> (curVA == edVA) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// disasm</span></span><br><span class="line">len = Disasm(&amp;infos);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; curVA &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; infos.CompleteInstr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jmp</span></span><br><span class="line"><span class="keyword">if</span> (infos.Instruction.BranchType == JmpType) &#123;</span><br><span class="line">Jmp(infos);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ret</span></span><br><span class="line"><span class="keyword">if</span> (infos.Instruction.BranchType == RetType) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="keyword">if</span> (infos.Instruction.BranchType == CallType) &#123;</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line">infos.EIP += len;</span><br><span class="line">infos.VirtualAddr += len;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not branch instruction</span></span><br><span class="line"><span class="keyword">if</span> (infos.Instruction.BranchType == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// save</span></span><br><span class="line">tpInfos = prevInfos;</span><br><span class="line">prevInfos = prev2Infos;</span><br><span class="line">prev2Infos = tpInfos;</span><br><span class="line"><span class="built_in">memcpy</span>(prevInfos, &amp;infos, <span class="keyword">sizeof</span>(DISASM));</span><br><span class="line"></span><br><span class="line"><span class="comment">// next</span></span><br><span class="line">infos.EIP += len;</span><br><span class="line">infos.VirtualAddr += len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isJmp = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(infos.Instruction.BranchType == JA)&#123;</span><br><span class="line">            <span class="comment">// 此处下断点即可检查所有JA语句</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>((<span class="keyword">void</span>*)prevInfos-&gt;EIP, cmp_rbp_rax, <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// cmp rbp, rax : 48 39 c5</span></span><br><span class="line"><span class="comment">// 48: REX.W</span></span><br><span class="line"><span class="comment">// 39: cmp Ev, Gv</span></span><br><span class="line"><span class="comment">// c5: Ev = bp, Gv = ax</span></span><br><span class="line">isJmp = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 此处下断点即可检查漏掉的跳转语句</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isJmp == <span class="number">1</span>) &#123;</span><br><span class="line">Jmp(infos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(isJmp == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line">infos.EIP += len;</span><br><span class="line">infos.VirtualAddr += len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// false branch</span></span><br><span class="line">DisasmCode((<span class="keyword">char</span>*)(infos.EIP+len), infos.VirtualAddr+len, edVA);</span><br><span class="line"><span class="comment">// true branch</span></span><br><span class="line">Jmp(infos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* fileBuf; <span class="comment">// 指向被加壳文件的拷贝</span></span><br><span class="line">    <span class="comment">// 读取被加壳文件，此处略过</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        rva = handlers[i];</span><br><span class="line">        fa = RVA2FA(rva); <span class="comment">// rva-&gt;fa函数略过</span></span><br><span class="line">handler_Rva_Fa[rva] = fa;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> getHandlerRVA = <span class="number">0x190438</span>; <span class="comment">// 这个是获取字节码的那段shellcode</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> enVA += <span class="number">0x140000000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span> (iter = handler_Rva_Fa.begin(); iter != handler_Rva_Fa.end(); iter++) &#123;</span><br><span class="line"><span class="keyword">char</span>* buf = (<span class="keyword">char</span>*)((UINT64)fileBuf + (UINT64)iter-&gt;second);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> va = imageBase + (UINT64)iter-&gt;first;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dis(rva):0x&quot;</span> &lt;&lt; hex &lt;&lt; iter-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (iter-&gt;first == <span class="number">0x18e53b</span>) &#123; <span class="comment">// 这个handler有点奇怪的问题，会造成栈溢出，解析不了</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">DisasmCode(buf, va, edVA);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件与无条件jmp"><a href="#条件与无条件jmp" class="headerlink" title="条件与无条件jmp"></a>条件与无条件jmp</h2><p>handler中大量的jmp和有条件跳转，严重影响分析handler的效率。所以需要折叠jmp和一些意义不大的条件jmp，再dump出来方便分析。</p><h2 id="ja的所有情况"><a href="#ja的所有情况" class="headerlink" title="ja的所有情况"></a>ja的所有情况</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>跳转标志位：<strong>CF==0 &amp;&amp; ZF==0</strong></p><p>跳转意义：</p><ul><li>无符号&gt;</li><li>加法无进位（CF=0）</li></ul><p>stc设置cf = 1</p><p>xor设置cf = 0</p><p>运算结果为0 zf = 0</p><h3 id="vm栈溢出-检查"><a href="#vm栈溢出-检查" class="headerlink" title="vm栈溢出 检查"></a>vm栈溢出 检查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lea rax, [rdi+0xE0]</span><br><span class="line">cmp rbp, rax</span><br><span class="line">jmp ImageBase+0x18F29A</span><br><span class="line">ja ImageBase+0x190438 # Jmp if no vmp&#39;s StackOverflow</span><br></pre></td></tr></table></figure><p>在push中会有上述代码，没有栈溢出时满足ja，直接跟踪true分支即可。</p><p>分析时检查到前一条非jmp指令为<code>cmp rbp, rax</code>即可直接ja。</p><h3 id="vm栈指针-无条件加法-检查"><a href="#vm栈指针-无条件加法-检查" class="headerlink" title="vm栈指针 无条件加法 检查"></a>vm栈指针 无条件加法 检查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add rbp, 0x10</span><br><span class="line">ja ImageBase+0x18cc56 # Jmp if no add overflow</span><br></pre></td></tr></table></figure><p>参照概述，直接跟踪true分支即可。</p><p>分析时检查到前一条非jmp指令为<code>add rbp</code> 即可直接ja。</p><h3 id="shl"><a href="#shl" class="headerlink" title="shl"></a>shl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shl ax, cl</span><br><span class="line">ja ImageBase+0x18ebef</span><br></pre></td></tr></table></figure><p>两条分支一样，可以不做处理。</p><h3 id="xor-eax-eax"><a href="#xor-eax-eax" class="headerlink" title="xor eax, eax"></a>xor eax, eax</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">je # true</span><br><span class="line">stc # cf &#x3D; 1</span><br><span class="line">xor eax, eax # cf &#x3D; 0</span><br><span class="line">ja ImageBase+0x18f460</span><br></pre></td></tr></table></figure><p><code>xor eax, eax</code>的结果为0，所以zf=1，所以这个ja为false，直接忽略。</p><h3 id="其他（未知）"><a href="#其他（未知）" class="headerlink" title="其他（未知）"></a>其他（未知）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea rdx, [8682618a + rax*2]</span><br><span class="line">ja</span><br></pre></td></tr></table></figure><p>前面有个xor是的cf=0，没有找到影响zf的语句，直接忽略。</p><h2 id="jl的所有情况"><a href="#jl的所有情况" class="headerlink" title="jl的所有情况"></a>jl的所有情况</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>跳转标志位：<strong>SF != OF</strong></p><p>跳转意义：</p><ul><li>有符号&lt;</li></ul><h3 id="signed-bh-lt-0xf9（可疑）"><a href="#signed-bh-lt-0xf9（可疑）" class="headerlink" title="signed: bh &lt; 0xf9（可疑）"></a>signed: bh &lt; 0xf9（可疑）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmp bh, 0xf9</span><br><span class="line">stc # cf &#x3D; 1</span><br><span class="line">jl</span><br></pre></td></tr></table></figure><p>这个jl就是 if(bh &lt; -7) 或者说 0x7f &lt; bh &lt; 0xf9，不知道想干嘛，在调试中发现bh一般为f4，这里当成true。</p><h3 id="NOR"><a href="#NOR" class="headerlink" title="NOR"></a>NOR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and rax, rdxjl</span><br></pre></td></tr></table></figure><p>经观察这是个NOR handle，jl以后的代码和没有jl的是一样的，所以当成什么都无所谓。</p><h3 id="Add-rbp"><a href="#Add-rbp" class="headerlink" title="Add rbp"></a>Add rbp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rbp, 0xajl</span><br></pre></td></tr></table></figure><p>这个add最高位是0+0=0，相同，of=0；sf=结果最高位=0。</p><p>所以jl是false。</p><h3 id="Sub-rbp"><a href="#Sub-rbp" class="headerlink" title="Sub rbp"></a>Sub rbp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub rbp, 4jl</span><br></pre></td></tr></table></figure><p>同add rbp，这个jl也是false。</p><h2 id="部分其余的条件跳转"><a href="#部分其余的条件跳转" class="headerlink" title="部分其余的条件跳转"></a>部分其余的条件跳转</h2><h3 id="JC"><a href="#JC" class="headerlink" title="JC"></a>JC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add dword ptr [rpb+8], eaxjc</span><br></pre></td></tr></table></figure><p>两条分支一样，可以不做处理。</p><h3 id="JE"><a href="#JE" class="headerlink" title="JE"></a>JE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pushfqje</span><br></pre></td></tr></table></figure><p>两条分支一样，可以不做处理。</p><h3 id="JG"><a href="#JG" class="headerlink" title="JG"></a>JG</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp bp, sijg</span><br></pre></td></tr></table></figure><p>两条分支一样，可以不做处理。</p><h3 id="JNO"><a href="#JNO" class="headerlink" title="JNO"></a>JNO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc clmov cl, byte ptr [rbp+8]jno</span><br></pre></td></tr></table></figure><p>可能循环相关，跟踪两条分支。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Re/">Re</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/vmp2/">vmp2</category>
      
      <category domain="https://windgodm.github.io/blog/tags/BeaEngine/">BeaEngine</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/09/15/vmp2-p2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>vmp2 (1) 初步分析</title>
      <link>https://windgodm.github.io/blog/2021/09/13/vmp2-p1/</link>
      <guid>https://windgodm.github.io/blog/2021/09/13/vmp2-p1/</guid>
      <pubDate>Mon, 13 Sep 2021 04:00:00 GMT</pubDate>
      
      <description>初步分析VMProtect Ultimate v 2.13.5加密后的程序,vmp基本概况。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="VMP2（1）初步分析"><a href="#VMP2（1）初步分析" class="headerlink" title="VMP2（1）初步分析"></a>VMP2（1）初步分析</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>初步分析VMProtect Ultimate v 2.13.5加密后的程序，得出vmp基本结构的总结。</p><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><blockquote><p>版本：VMProtect Ultimate v 2.13.5</p></blockquote><p>vmp代码在tls中。</p><p>下面是分析出的一些寄存器在vmp中的作用：</p><table><thead><tr><th>寄存器</th><th>描述</th></tr></thead><tbody><tr><td>RSI</td><td>字节码数组（逆序）</td></tr><tr><td>R12</td><td>Handler表</td></tr><tr><td>R13</td><td>Handler基址</td></tr><tr><td>RBP</td><td>VMP栈顶指针（栈从高到低）</td></tr><tr><td>RDI</td><td>VMP寄存器指针</td></tr><tr><td>RBX</td><td>解码密钥（动态）</td></tr></tbody></table><p>rsi指向当前字节码，rsi-1指向下一条字节码。</p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>14019065C~140190E54（256个x8byte）</p><h3 id="Handler分析"><a href="#Handler分析" class="headerlink" title="Handler分析"></a>Handler分析</h3><p><strong>POP_Q</strong></p><p>从vmp栈pop8字节数据到指定vmp寄存器。</p><p>2字节命令，后1字节解密后为VMP寄存器偏移（rdi）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取pop8目标vmp寄存器的偏移</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">GetPOP8Offset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> al, bl;</span><br><span class="line">    </span><br><span class="line">    al = <span class="built_in">stack</span>[--_rsi];</span><br><span class="line">    bl = _rbx &amp; <span class="number">0xff</span>;</span><br><span class="line">    </span><br><span class="line">    al -= bl;</span><br><span class="line">    al ^= <span class="number">0x2f</span>;</span><br><span class="line">    al++;</span><br><span class="line">    al ^= <span class="number">0xf1</span>;</span><br><span class="line">    _rbx = _rbx - bl + (bl - al); <span class="comment">// bl -= al</span></span><br><span class="line">    <span class="keyword">return</span> al;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PUSH_Q_ID</strong></p><p>从字节码push4字节数据到vmp栈。</p><p>5字节命令，后4字节解密后为数据。</p><p><code>sub rbp, 8</code>：push的数据为4字节，而VMP栈指针减8。</p><p>在最后有如下一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea rax, qword ptr ds:[rdi+0xE0] # 108</span><br><span class="line">cmp rbp, rax                   # 10D</span><br><span class="line">ja &lt;VmGetHandle&gt;               # 10F</span><br></pre></td></tr></table></figure><p>当rbp&gt;rax时跳转到正常代码，rbp是vmp栈顶，可知rbp&gt;rdi+0xE0。</p><p>由此得知虚拟寄存器在低地址、虚拟栈在高地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取push4的数据</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GetPUSH4Data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> eax, ebx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> _bl;</span><br><span class="line">    </span><br><span class="line">    _rsi -= <span class="number">4</span>;</span><br><span class="line">    eax = *(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(<span class="built_in">stack</span>+_rsi);</span><br><span class="line">    ebx = _rbx &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    </span><br><span class="line">    bswap(eax);</span><br><span class="line">    eax ^= ebx;</span><br><span class="line">    eax -= <span class="number">0xcc3ff88a</span>;</span><br><span class="line">    eax ^= <span class="number">0x9b616bfd</span>;</span><br><span class="line">    eax = !eax;</span><br><span class="line">    bl = _rbx &amp; <span class="number">0xff</span>;</span><br><span class="line">    _rbx = _rbx - bl + <span class="number">0xfa</span>; <span class="comment">// bl = 0xfb; bx--;</span></span><br><span class="line">    cdqe;</span><br><span class="line">    <span class="keyword">return</span> eax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ADD_Q_Q</strong></p><p>基于栈的二元加法。实现的功能为<code>top2 = top2+top1</code>，<code>top1 = RFLAGS</code>。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Re/">Re</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/vmp2/">vmp2</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/09/13/vmp2-p1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MEMZ彩虹猫分析</title>
      <link>https://windgodm.github.io/blog/2021/08/13/memz/</link>
      <guid>https://windgodm.github.io/blog/2021/08/13/memz/</guid>
      <pubDate>Fri, 13 Aug 2021 04:00:00 GMT</pubDate>
      
      <description>MEMZ彩虹猫详细分析（不包括mbr部分）。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="MEMZ彩虹猫分析"><a href="#MEMZ彩虹猫分析" class="headerlink" title="MEMZ彩虹猫分析"></a>MEMZ彩虹猫分析</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="https://z3.ax1x.com/2021/09/05/hWm3QA.png" alt="MEMZ流程"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 紫色部分</span></span><br><span class="line"><span class="keyword">if</span>(arbc &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!lstrcmpW(argv[<span class="number">1</span>], <span class="string">L&quot;/watchdog&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 红色部分</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 绿色部分</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 蓝色部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据命令行参数不同，实际上会有三种效果。</p><p>第一种（蓝色部分）是不带参数，会弹两次警告窗口，然后带参数的打开自身。</p><p>第二种（绿色部分）是带参数且argv[1] != “/watchdog”。会往硬盘写入恶意代码，修改mbr；然后打开一个notepad；接着是捣乱十阶段：依次创建十个线程分别搞破坏。</p><p>第三种（红色部分）是argv[1] != “/watchdog”，会创建一个线程用于检测除彩虹猫以外的进程数量，如果有减少，会触发蓝屏与重启。主线程会创建一个消息循环，接收到关闭消息也会触发蓝屏与重启。</p><h2 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LPVOID pFunc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sleepTime;</span><br><span class="line">&#125;struc_1;</span><br></pre></td></tr></table></figure><h3 id="无参数部分代码"><a href="#无参数部分代码" class="headerlink" title="无参数部分代码"></a>无参数部分代码</h3><p><img src="https://z3.ax1x.com/2021/09/05/hWmHw6.png" alt="MEMZ_none"></p><p>这部分代码比较普通，api都有符号，直接查MSDN即可。</p><h3 id="非-watchdog部分代码"><a href="#非-watchdog部分代码" class="headerlink" title="非/watchdog部分代码"></a>非/watchdog部分代码</h3><p>运行这部分的进程优先级会被设为高。</p><p>这部分代码的结尾有个死循环sleep，所以不会运行无参数部分的代码。</p><p><strong>修改MBR，写入恶意代码</strong></p><p><img src="https://z3.ax1x.com/2021/09/05/hWmIyR.png" alt="MEMZ_main1"></p><p>比较有意思的是文件名为<code>\\.PhysicalDrive0</code>可以打开磁盘0，并覆写MBR</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hFile = CreateFileA(<span class="string">&quot;\\\\.\\PhysicalDrive0&quot;</span>, <span class="number">0xC0000000</span>, <span class="number">3u</span>, <span class="number">0</span>, <span class="number">3u</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 打开物理驱动器0</span></span><br></pre></td></tr></table></figure><p>写入的shellcode没有分析。</p><p><strong>打开记事本嘲讽</strong></p><p><img src="https://z3.ax1x.com/2021/09/05/hWmoO1.png" alt="MEMZ_main2"></p><p>然后写入记事本并打开。</p><p><strong>捣乱十连</strong></p><p><img src="https://z3.ax1x.com/2021/09/05/hWm5l9.png" alt="MEMZ_main3"></p><p>随后有个捣乱十阶段，间隔一定时间，创建十个线程，分别执行十个函数，下面是我稍微整理了下的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Sleep(messFuncs[i].sleepTime);</span><br><span class="line">    CreateThread(<span class="number">0</span>, <span class="number">0</span>, LoopCallMess, &amp;messFuncs[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中messFuncs是一个结构体数组，猜测定义如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">struc_1</span>&#123;</span></span><br><span class="line">    LPVOID pFunc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sleepTime;</span><br><span class="line">&#125;struc_1;</span><br><span class="line">struc_1 messFuncs[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>执行的那十个函数的分析见下面的捣乱十阶段。</p><h3 id="watchdog部分代码"><a href="#watchdog部分代码" class="headerlink" title="/watchdog部分代码"></a>/watchdog部分代码</h3><p>创建一个线程，然后创建一个消息循环。</p><p><strong>创建的线程</strong></p><p>创建的线程会不断的创建快照，然后统计除MEMZ以外的进程数，如果有减少就执行一个导致蓝屏与重启的函数。</p><p>判断是否是MEMZ的方法是检测进程路径。</p><p><strong>消息循环</strong></p><p>消息循环函数在接收到关闭信息也会执行导致蓝屏与重启的函数。</p><h3 id="蓝屏与重启"><a href="#蓝屏与重启" class="headerlink" title="蓝屏与重启"></a>蓝屏与重启</h3><p><img src="https://z3.ax1x.com/2021/09/05/hWm7ex.png" alt="MEMZ_reboot"></p><p>先循环创建20个线程执行一个函数。</p><p>然后直接获取ntdll的api，然后调用触发蓝屏的函数。随后重启。</p><p>那20个线程执行的函数，会SetWindowsHook，hook函数会在窗口创建时随机随机修改窗口位置，随后调用MessageBoxA创建一个窗口，随机弹出嘲讽信息，由于设置了钩子，这个窗口位置是随机的。最后撤销钩子。</p><h3 id="捣乱十阶段"><a href="#捣乱十阶段" class="headerlink" title="捣乱十阶段"></a>捣乱十阶段</h3><h4 id="阶段一：乱开网页和窗口"><a href="#阶段一：乱开网页和窗口" class="headerlink" title="阶段一：乱开网页和窗口"></a>阶段一：乱开网页和窗口</h4><p>从46条字符串里随机挑一条作为ShellExecuteA的参数，相当于在运行一个shell，字符串是shell的输入。如果字符串是网页链接，就会打开网页。还可以是<code>calc</code>，<code>notepad</code>等，将打开对应的程序。</p><h4 id="阶段二：乱动鼠标"><a href="#阶段二：乱动鼠标" class="headerlink" title="阶段二：乱动鼠标"></a>阶段二：乱动鼠标</h4><p>获取鼠标坐标，然后加上随机数，最后再修改鼠标坐标，达到让鼠标乱抖的效果。</p><h4 id="阶段三：乱按键盘"><a href="#阶段三：乱按键盘" class="headerlink" title="阶段三：乱按键盘"></a>阶段三：乱按键盘</h4><p>调用SendInput api。</p><h4 id="阶段四：乱放系统声音"><a href="#阶段四：乱放系统声音" class="headerlink" title="阶段四：乱放系统声音"></a>阶段四：乱放系统声音</h4><p>调用PlaySoundA api。</p><h4 id="阶段五：反转桌面窗口颜色"><a href="#阶段五：反转桌面窗口颜色" class="headerlink" title="阶段五：反转桌面窗口颜色"></a>阶段五：反转桌面窗口颜色</h4><p>获取窗口句柄，然后用BitBlt()反转颜色。</p><h4 id="阶段六：嘲讽弹窗"><a href="#阶段六：嘲讽弹窗" class="headerlink" title="阶段六：嘲讽弹窗"></a>阶段六：嘲讽弹窗</h4><p>创建一个线程，该线程做的东西和前面StartAddresss那个函数差不多，也是通过SetWindowsHook实现随机位置弹出MessageBox，显示嘲讽信息。</p><h4 id="阶段七：错误图标"><a href="#阶段七：错误图标" class="headerlink" title="阶段七：错误图标"></a>阶段七：错误图标</h4><p>获取鼠标坐标，然后在鼠标旁边画图标。</p><h4 id="阶段八：反转文字"><a href="#阶段八：反转文字" class="headerlink" title="阶段八：反转文字"></a>阶段八：反转文字</h4><p>通过EnumChildWindows给全部窗口设一个回调函数，这个回调函数通过SendMessageTimeoutW发送信号给窗口，获取窗口的文字，然后把文字顺序反转，再发送信号给窗口更改文字。</p><h4 id="阶段九：无限桌面"><a href="#阶段九：无限桌面" class="headerlink" title="阶段九：无限桌面"></a>阶段九：无限桌面</h4><p>有点类似阶段五，不过这次不是反转颜色，可以理解为把桌面截图，然后向右和向下各平移50像素后覆盖到原来桌面。</p><h4 id="阶段十：混乱桌面"><a href="#阶段十：混乱桌面" class="headerlink" title="阶段十：混乱桌面"></a>阶段十：混乱桌面</h4><p>类似阶段九，不过这次是随机覆盖。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Virus/">Virus</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/virus/">virus</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/08/13/memz/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>简易压缩壳笔记</title>
      <link>https://windgodm.github.io/blog/2021/08/04/SimplePack/</link>
      <guid>https://windgodm.github.io/blog/2021/08/04/SimplePack/</guid>
      <pubDate>Wed, 04 Aug 2021 04:00:00 GMT</pubDate>
      
      <description>写一个简易的压缩壳的笔记。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="简易压缩壳笔记"><a href="#简易压缩壳笔记" class="headerlink" title="简易压缩壳笔记"></a>简易压缩壳笔记</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">加壳器：</span><br><span class="line">读取被加壳文件</span><br><span class="line">加载壳代码</span><br><span class="line">复制壳代码的section header</span><br><span class="line">修改ep并保存oep</span><br><span class="line">加密</span><br><span class="line">压缩</span><br><span class="line">清空import、iat directory，保存import directory</span><br><span class="line">清空tls directoru，保存directory的AddressOfCallBacks</span><br><span class="line">重定位壳代码</span><br><span class="line">复制壳代码重定位表，并修改reloc directory</span><br><span class="line">修复壳代码重定位表</span><br><span class="line">写入文件</span><br><span class="line"></span><br><span class="line">壳代码：</span><br><span class="line">遍历ldr获取ntdll中的函数</span><br><span class="line">获取用于解壳的函数的地址</span><br><span class="line">解压</span><br><span class="line">解密</span><br><span class="line">修复并加密iat</span><br><span class="line">重定位</span><br><span class="line">tls</span><br><span class="line">反调试</span><br><span class="line">跳转到oep</span><br></pre></td></tr></table></figure><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>替换reloc等section时，只需要修改data directory即可。</p><p>增加section可以只增加header，写入文件时再追加写入。</p><p>通过dll形式写壳代码可以比较方便生成重定位表、iat等。</p><h3 id="关于导入表"><a href="#关于导入表" class="headerlink" title="关于导入表"></a>关于导入表</h3><p>关于加密iat，常见的做法对每一个api申请一块可执行内存作为跳转函数，然后把iat中api地址换成跳转函数地址。<br>此做法需要判断导入表中导入的是函数还是变量。如果是变量显然会出错。我采取的做法是判断地址是否位于dll的text段。</p><p>关于import_descriptor。该结构有OriginalFirstThunk和FirstThunk两个结构体数组的指针。理论上文件中时两个结构体应该都指向同一个地址，加载为image后FT指向IAT的RVA。<br>有时可能会出现OFT为0，只有FT的情况。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/pack/">pack</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/08/04/SimplePack/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WX数据库自动解密（已失效）</title>
      <link>https://windgodm.github.io/blog/2021/07/22/WeChatDBDecrypt/</link>
      <guid>https://windgodm.github.io/blog/2021/07/22/WeChatDBDecrypt/</guid>
      <pubDate>Thu, 22 Jul 2021 04:00:00 GMT</pubDate>
      
      <description>wx数据库解密，用hook dump密钥。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="微信-PC端-数据库-自动解密"><a href="#微信-PC端-数据库-自动解密" class="headerlink" title="微信 PC端 数据库 自动解密"></a>微信 PC端 数据库 自动解密</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><p>环境:</p><p>win10家庭中文版 10.0.19043 x64（本机）</p><p>微信 3.3.0.115</p><p>openssl-1.0.2r</p></blockquote><p>PC密码为32字节。</p><h2 id="手动流程"><a href="#手动流程" class="headerlink" title="手动流程"></a>手动流程</h2><h3 id="获取密码"><a href="#获取密码" class="headerlink" title="获取密码"></a>获取密码</h3><p>打开微信（不点登录）。</p><p>打开Odb附加WeChat.exe。</p><p>查找-&gt;可执行模块-&gt;WeChatWin。</p><p>用插件找ASCII字符串（我打了中文搜索补丁，直接用中文搜索的搜索ASCII字符串）。</p><p>然后搜索字符串<code>DBFactory::encryptDB</code>，跳转到第一次出现该字符串的位置。这里旧版本可能是第二个字符串的位置。3.3版本我找到了两个，都跳转过去看看，其中一个push语句下面有一个TEST，另一个只有一个call就return了。要找的是有TEST那个。</p><p>该TEST语句就是比较密码的地方，双击设置断点。然后运行并登录。</p><p>停在断点时，选择edx在数据窗口中跟随。</p><p>然后把从edx开始的32字节的数据dump出来，该32字节的数据就是密码。</p><h3 id="从源码安装openssl"><a href="#从源码安装openssl" class="headerlink" title="从源码安装openssl"></a>从源码安装openssl</h3><p>需要用到openssl，据说sqlcipher用的是最低版本的openssl。这里使用1.0.2u。</p><p>首先安装perl。（<a href="http://www.activestate.com/activeperl/downloads/%EF%BC%89">http://www.activestate.com/activeperl/downloads/）</a></p><p>然后运行 x86 Native Tools Command Prompt for VS 2019 这个shell。</p><p>激活perl环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">state activate</span><br><span class="line">cd /d D:\openssl-1.0.2u\</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perl Configure VC-WIN64A no-asm -prefix=D:\Program Files\openssl102u</span><br><span class="line">ms\do_ms.bat</span><br><span class="line">nmake -f ms\ntdll.mak</span><br></pre></td></tr></table></figure><p>检查</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmake -f ms\ntdll.mak test</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmake -f ms\ntdll.mak install</span><br></pre></td></tr></table></figure><p>奇怪的是最后还是安装到了E:\usr\local\ssl\这个目录下</p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>这里分享vs2019解密的过程。</p><p>在项目的属性页 -&gt; C/C++ -&gt; 常规 -&gt; 附加包含目录 中添加openssl的include目录。</p><p>在项目的属性页 -&gt; 链接器 -&gt; 常规 -&gt; 附加库目录 中添加openssl的include目录。</p><p>在项目的属性页 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项 中添加libeay32.lib和ssleay32.lib。</p><p>然后编译运行看雪文章中的代码。（链接见参考）</p><p>然后把E:\usr\local\ssl\bin\中的两个dll复制exe的根目录，exe才能正常运行。</p><p>接着把exe和两个dll复制到微信缓存文件的目录/对应用户目录/Msg/里，微信缓存目录名为WeChat Files，可以在微信设置中查到。</p><p>复制过去后运行exe即可。</p><h2 id="自动获取（代码修改api-hook）"><a href="#自动获取（代码修改api-hook）" class="headerlink" title="自动获取（代码修改api hook）"></a>自动获取（代码修改api hook）</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>代码参考附件。</p><p>总流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">复制dll到wx根目录</span><br><span class="line">打开微信</span><br><span class="line">注入dll</span><br><span class="line">微信登录</span><br><span class="line">dll把密钥dump出来</span><br><span class="line">复制聊天记录文件</span><br><span class="line">解密</span><br></pre></td></tr></table></figure><p>其中dll所做的是修改目标函数的起始字节为jmp，跳转到hook函数中，然后读取原函数的参数，把密钥写到文件里，再unhook并跳回原来的位置继续运行。</p><p>因为比较懒，自动化代码没有写卸载dll的东西。另外有时会出现dump出密码后，微信直接闪退的情况。</p><h3 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h3><p>通过注入dll实现修改代码的hook来dump出密钥。</p><p>通过GetModuleHandle获取WeChatWin.dll的基址，然后加上目标api的偏移得到api的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hApi = GetModuleHandleW(<span class="string">L&quot;WeChatWin&quot;</span>) + apiOffset;</span><br><span class="line">hook_by_5b_code(hApi, (PROC)HookFunc);</span><br></pre></td></tr></table></figure><p>然后查看api的代码可以推算出密钥首地址为*(*(esp - 4 + 0x10))，减4是因为有个push ebp。然后剩下的照抄test edx, edx前的代码得到。</p><p>当然也可以直接在test edx, edx的地方跳转，这样直接读edx就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">HookFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD _esp = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        __asm &#123;</span><br><span class="line">            mov _esp, esp;</span><br><span class="line">            pusha;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        DWORD addr = *(DWORD*)(*(DWORD*)(_esp + <span class="number">0xc</span>));</span><br><span class="line">        HANDLE hFile = CreateFileW(<span class="string">L&quot;./pw.bin&quot;</span>, GENERIC_WRITE, <span class="number">0</span>, <span class="number">0</span>, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">        WriteFile(hFile, (LPCVOID)addr, <span class="number">32</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line">        unhook_by_5b_code(hApi);</span><br><span class="line"> </span><br><span class="line">        __asm &#123;</span><br><span class="line">            popa;</span><br><span class="line">            mov ecx, <span class="number">0x53677E70</span>;</span><br><span class="line">            jmp ecx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="食用指南"><a href="#食用指南" class="headerlink" title="食用指南"></a>食用指南</h3><p>GetPwHookCodeDll.cpp是dll的代码。AllInOne.cpp是自动解密的代码。需要提供wx根目录位置和微信用户文件的位置。</p><p>wx用户文件的位置：在wx的缓存文件（该目录在wx设置中有）中，有一个叫wxid_xxxxxxx的文件夹，xxxxx是你的初始wx id，这个就是对应wx账户的本地文件。</p><p>假设wx根目录是<code>D:\WeChat</code>，用户目录是<code>D:\WeChat Files\wxid_bravetroops</code>。<br>方法一：在自动程序根目录中打开shell，输入<code>AllInOne.exe D:\WeChat D:\WeChat Files\wxid_bravetroops</code>即可。<br>方法二：在程序根目录中有个aio_cf.txt，第一行输入wx根目录，第二行输入用户目录即可。</p><p>最后会在根目录生成一个dec_ChatMsg.db的文件，就是解密后的聊天记录。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[<a href="https://bbs.pediy.com/thread-251303.htm">原创]PC版微信数据库解密详细教程|bbs.pediy.com</a></p><p><a href="https://blog.csdn.net/qq_35014708/article/details/89354694">window10 安装 OpenSSL_sun-CSDN博客</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/WX/">WX</category>
      
      <category domain="https://windgodm.github.io/blog/tags/Database/">Database</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/07/22/WeChatDBDecrypt/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HammingCode</title>
      <link>https://windgodm.github.io/blog/2021/07/14/HammingCode/</link>
      <guid>https://windgodm.github.io/blog/2021/07/14/HammingCode/</guid>
      <pubDate>Wed, 14 Jul 2021 04:00:00 GMT</pubDate>
      
      <description>HammingCode笔记。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Hamming-Code"><a href="#Hamming-Code" class="headerlink" title="Hamming Code"></a>Hamming Code</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>多次奇偶校验，下标为2<sup>n</sup>的位作为奇偶校验位，校验对象为所有位中小标第n位为1的位，显然包括了一半的数据。</p><p>第0位一般弃置，或者作为奇偶校验位的奇偶校验位，这样就可以判断是否存在多个错误。</p><p>每一个奇偶校验位都校验了一半的数据，通过检测哪些校验位是错的即可找到哪一位数据出错。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>三种理解思路：一是多组奇偶校验；二是异或；三是线性代数。</p><p>只能纠错一个位，以及判断是否有多个错误，校验结果即为错误位。</p><p>若奇偶校验位的个数为n：</p><p>汉明码的位数：2<sup>n</sup> = 1 &lt;&lt; n</p><p>数据位的位数：2<sup>n</sup>-n-1 = (1&lt;&lt;n)-n-1</p><p>校验位按下标排序，错误的置一，其余置零，若结果不为0，得到的就是错误位的下标。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>该算法目前已经不常用。实际使用通常配合其他通信技巧使用。下面是我分别用python和c++实现的代码。实现方式为把原始数据分块再编码成汉明码。</p><p><a href="https://github.com/windgodm/Algorithm/tree/master/HammingCode">Algorithm/HammingCode at master · windgodm/Algorithm (github.com)</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1WK411N7kz">https://www.bilibili.com/video/BV1WK411N7kz</a></p><p><a href="https://www.bilibili.com/video/BV1pV411y7E8">https://www.bilibili.com/video/BV1pV411y7E8</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Algorithm/">Algorithm</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/Error-Correction/">Error_Correction</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/07/14/HammingCode/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>APIHook DLL注入实现代码钩取 笔记</title>
      <link>https://windgodm.github.io/blog/2021/06/24/APIHookDllCodeHideProc/</link>
      <guid>https://windgodm.github.io/blog/2021/06/24/APIHookDllCodeHideProc/</guid>
      <pubDate>Thu, 24 Jun 2021 06:44:00 GMT</pubDate>
      
      <description>逆向工程核心原理中利用dll注入修改代码来实现钩取的笔记,&lt;br&gt;钩取了ZwQuerySystemInformation()以隐藏进程。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="APIHook-DLL注入实现代码钩取-笔记"><a href="#APIHook-DLL注入实现代码钩取-笔记" class="headerlink" title="APIHook - DLL注入实现代码钩取 笔记"></a>APIHook - DLL注入实现代码钩取 笔记</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><p>技术摘要：</p><p><strong>动态</strong>修改<strong>进程内存</strong>中的<strong>代码</strong>。利用<strong>DLL注入</strong>修改代码开头跳转到补丁代码。</p></blockquote><p>起源是逆向工程核心原理里面以任务管理器ZwQuerySystemInformation()API钩取为例讲解利用dll注入修改api的起始代码为jmp实现api钩取。<br>该例子目标是隐藏某个进程。</p><p>大概流程如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">调用者:</span><br><span class="line">1: call api</span><br><span class="line">api:</span><br><span class="line">2: jmp patch</span><br><span class="line">patch:</span><br><span class="line">3: unhook</span><br><span class="line">4: call api（正常执行api功能）</span><br><span class="line">5: hook</span><br><span class="line">6: patch</span><br><span class="line">7: retn 到调用者</span><br></pre></td></tr></table></figure><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>有一些未公开的函数或者枚举类型一定要找尽可能正确的。可能因为资料的不正确导致钩取失败或没有效果。如果出现问题，要对比正常流程看钩取后传递的参数是否符合预期，一些标志位的设置是否正确。</p><p>不可避免的一个问题是会出现<strong>漏网之鱼</strong>，也就unhook期间原api被调用会暴露隐藏进程。我在测试时遇到过隐藏进程突然在任务管理器中闪出来几下的情况。</p><p>隐藏进程实际上是修改了ZwQuerySystemInformation返回的一个包含进程信息的链表，如果要隐藏的进程在链表中排第一个的话会出错，原因详见 实例 中。而实际中似乎链表的第一个一定是System(进程号为4)，随后是Registry和svchost。所以只有不隐藏System这个进程就不会有问题。</p><h2 id="实例：隐藏进程ZwQuerySystemInformation-（x64）"><a href="#实例：隐藏进程ZwQuerySystemInformation-（x64）" class="headerlink" title="实例：隐藏进程ZwQuerySystemInformation()（x64）"></a>实例：隐藏进程ZwQuerySystemInformation()（x64）</h2><p>该例子对象是任何直接或间接使用了ZwQuerySystemInformation查询进程信息的64位程序，比如任务管理器。</p><p>下面的步骤按运行时的执行顺序来写。</p><h3 id="1-dll注入"><a href="#1-dll注入" class="headerlink" title="1 dll注入"></a>1 dll注入</h3><p>第一步是把后面编写好的dll注入到目标程序中，关于dll注入的内容在此略过。</p><h3 id="2-dll"><a href="#2-dll" class="headerlink" title="2 dll"></a>2 dll</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/SECTION:.SHARE,RWS&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;.SHARE&quot;</span>)</span></span><br><span class="line"><span class="keyword">wchar_t</span> g_wszProcName[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetProcName</span><span class="params">(LPCTSTR wszProcName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wcscpy_s(g_wszProcName, wszProcName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> pszCurProc[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check</span></span><br><span class="line">    GetModuleFileNameA(<span class="literal">NULL</span>, pszCurProc, MAX_PATH);</span><br><span class="line">    p = <span class="built_in">strrchr</span>(pszCurProc, <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((p != <span class="literal">NULL</span>) &amp;&amp; !_stricmp(p + <span class="number">1</span>, <span class="string">&quot;remote_inject_x64.exe&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="comment">// set</span></span><br><span class="line">        SetProcName(<span class="string">L&quot;notepad.exe&quot;</span>);</span><br><span class="line">        <span class="comment">// get api</span></span><br><span class="line">        hApi = GetProcAddress(GetModuleHandleW(pwszDllName), <span class="string">&quot;ZwQuerySystemInformation&quot;</span>);</span><br><span class="line">        <span class="comment">// hook</span></span><br><span class="line">        hook_by_5b_code(pszDllName, hApi, (PROC)MyZwQuerySystemInformation);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="comment">//unhook</span></span><br><span class="line">        unhook_by_5b_code(pszDllName, hApi);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是普通的dll，加载时钩取、卸载时脱钩。在加载时还会获取目标api的地址，以及设置要隐藏的dll名称。设置隐藏dll名称这一步可以换到别的地方设置。因为保存隐藏dll名称的变量是个共享变量，所以完全可以再写一个程序复制管理这个共享变量。只需要在管理程序中主动加载该dll，然后调用导出的SetProcName()即可，可以实现动态改变隐藏目标。当然也可以拓展代码实现隐藏多个不同名进程或按pid隐藏等。（这里SetProcName定义在dll的头文件中）</p><h3 id="3-hook-by-5bytes-code"><a href="#3-hook-by-5bytes-code" class="headerlink" title="3 hook by 5bytes code"></a>3 hook by 5bytes code</h3><p>hook_by_5b_code函数修改api开头的5字节内容，改成jmp指令。32和64的jmp都是e9+4字节的相对偏移，这个相对偏移是以jmp下一条指令的地址作为起始地址来计算的，具体见下面的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hook_by_5b_code</span><span class="params">(<span class="keyword">char</span>* pszDllName, HANDLE api, PROC newApi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    byte pNewBytes[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0</span>, &#125;;</span><br><span class="line">    DWORD jmpOffset;</span><br><span class="line"></span><br><span class="line">    VirtualProtect(api, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((PBYTE)api)[<span class="number">0</span>] == <span class="number">0xE9</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bak origin byte</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pOriginBytes, api, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count jmp offset</span></span><br><span class="line">    jmpOffset = (DWORD)((<span class="keyword">size_t</span>)newApi - (<span class="keyword">size_t</span>)api - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// e9 offset(4bytes)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;pNewBytes[<span class="number">1</span>], &amp;jmpOffset, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hook</span></span><br><span class="line">    <span class="built_in">memcpy</span>(api, pNewBytes, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    VirtualProtect(api, <span class="number">9</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unhook就是恢复api原始字节即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unhook_by_5b_code</span><span class="params">(<span class="keyword">char</span>* pszDllName, HANDLE api)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line"></span><br><span class="line">    VirtualProtect(api, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((PBYTE)api)[<span class="number">0</span>] != <span class="number">0xE9</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unhook</span></span><br><span class="line">    <span class="built_in">memcpy</span>(api, pOriginBytes, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    VirtualProtect(api, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新api（补丁代码-ZwQuerySystemInformation）"><a href="#新api（补丁代码-ZwQuerySystemInformation）" class="headerlink" title="新api（补丁代码 ZwQuerySystemInformation）"></a>新api（补丁代码 ZwQuerySystemInformation）</h3><p>1~4对应摘要中的3~6，具体看代码及注释。在执行patch之前会检测返回值判断调用原api是否成功，以及判断此次调用是否为查询进程信息。</p><p>PSYSTEM_PROCESS_INFORMATION结构是一个链表，具体遍历方式参考代码即可。</p><p>SYSTEM_INFORMATION_CLASS是一个枚举类型，说明函数SystemInformation这个参数的类似是什么。如果 SystemInformationClass == SystemProcessorInformation(5) 即代表SystemInformation类型为PSYSTEM_PROCESS_INFORMATION。</p><p>可以看到代码中没有对链表第一个元素做特殊处理，这里算是一个不会产生太大影响的bug。如果要隐藏的进程在链表的第一个位置，此时prev和cur指向的都是第一个元素，执行操作以后会错误修改第一个元素的next偏移，导致无法正确找到第二个元素，同时也没有隐藏第一个。实际中第一个元素好像一般为System进程，只要不隐藏这个一般不会触发问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">ULONG NextEntryOffset;</span><br><span class="line">ULONG NumberOfThreads;</span><br><span class="line">BYTE Reserved1[<span class="number">48</span>];</span><br><span class="line">PVOID Reserved2[<span class="number">3</span>];</span><br><span class="line">HANDLE UniqueProcessId;</span><br><span class="line">PVOID Reserved3;</span><br><span class="line">ULONG HandleCount;</span><br><span class="line">BYTE Reserved4[<span class="number">4</span>];</span><br><span class="line">PVOID Reserved5[<span class="number">11</span>];</span><br><span class="line">SIZE_T PeakPagefileUsage;</span><br><span class="line">SIZE_T PrivatePageCount;</span><br><span class="line">LARGE_INTEGER Reserved6[<span class="number">6</span>];</span><br><span class="line">&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS WINAPI <span class="title">MyZwQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    _Inout_   PVOID                    SystemInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_      ULONG                    SystemInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    _Out_opt_ PULONG                   ReturnLength</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS nts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1: unhook</span></span><br><span class="line">    unhook_by_5b_code(pszDllName, hApi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2: call origin api</span></span><br><span class="line">    nts = ((ZwQuerySystemInformation)hApi)(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3: hook</span></span><br><span class="line">    hook_by_5b_code(pszDllName, hApi, (PROC)MyZwQuerySystemInformation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SystemProcessorInformation(5)</span></span><br><span class="line">    <span class="keyword">if</span> ((nts != CMC_STATUS_SUCCESS) || SystemInformationClass != <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4: patch: hide</span></span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;</span><br><span class="line">    pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;</span><br><span class="line">    pPrev = pCur; <span class="comment">// warning</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// hide</span></span><br><span class="line">        <span class="keyword">if</span> (pCur-&gt;Reserved2[<span class="number">1</span>] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_wcsicmp((PWSTR)pCur-&gt;Reserved2[<span class="number">1</span>], g_wszProcName) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pCur-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">                    pPrev-&gt;NextEntryOffset = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pPrev = pCur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// break</span></span><br><span class="line">        <span class="keyword">if</span> (pCur-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next</span></span><br><span class="line">        pCur = (PSYSTEM_PROCESS_INFORMATION)((<span class="keyword">size_t</span>)pCur + (<span class="keyword">size_t</span>)pCur-&gt;NextEntryOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>逆向工程核心原理：part4-API钩取：第33章-隐藏进程</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/api-hook/">api_hook</category>
      
      <category domain="https://windgodm.github.io/blog/tags/reversecore/">reversecore</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/06/24/APIHookDllCodeHideProc/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>APIHook DLL注入实现IAT钩取 笔记</title>
      <link>https://windgodm.github.io/blog/2021/06/19/APIHookDllIATCalc/</link>
      <guid>https://windgodm.github.io/blog/2021/06/19/APIHookDllIATCalc/</guid>
      <pubDate>Sat, 19 Jun 2021 06:22:00 GMT</pubDate>
      
      <description>逆向工程核心原理中利用dll注入修改iat来实现钩取的笔记,&lt;br&gt;钩取了计算器的SetWindowText()以显示中文数字。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="APIHook-DLL注入实现IAT钩取-笔记"><a href="#APIHook-DLL注入实现IAT钩取-笔记" class="headerlink" title="APIHook - DLL注入实现IAT钩取 笔记"></a>APIHook - DLL注入实现IAT钩取 笔记</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><p>技术摘要：</p><p><strong>动态</strong>修改<strong>进程内存</strong>中的<strong>IAT</strong>。利用<strong>DLL注入</strong>修改API的IAT。</p></blockquote><p>起源是逆向工程核心原理里面以计算器SetWindowText()API钩取为例讲解利用dll注入修改api的iat来实现钩取。<br>该例子目标是把显示的阿拉伯数字改成中文数字。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>补丁函数（新api）要申明为WINAPI，即stdcall。c++默认的是cdecl，由调用者处理栈。而api使用的stdcall是由被调用者处理的。如果不声明为stdcall，调用钩取api结束时本应该清理栈，而实际上不会清理。同样钩取api中调用原api时，原api结束时清理了一次栈，而我们的钩取api又会再处理一次栈。这时esp指向的不是旧ebp，pop ebp时就会触发错误。<br>实际上由于win32 api为stdcall，使得我们的新函数对栈不需要做特殊操作。</p><h2 id="实例：计算器SetWindowTextW-（x32）"><a href="#实例：计算器SetWindowTextW-（x32）" class="headerlink" title="实例：计算器SetWindowTextW()（x32）"></a>实例：计算器SetWindowTextW()（x32）</h2><p>该例子对象是xp的x32的calc.exe，运行环境是在win10中。（我把xp虚拟机里的计算机复制出来了）在win10的计算机中尝试失败了，还没找到原因。</p><p>下面的步骤按运行时的执行顺序来写。</p><h3 id="1-dll注入"><a href="#1-dll注入" class="headerlink" title="1 dll注入"></a>1 dll注入</h3><p>第一步是把后面编写好的dll注入到目标程序中，关于dll注入的内容在此略过。</p><h3 id="2-dll"><a href="#2-dll" class="headerlink" title="2 dll"></a>2 dll</h3><p>当 dll第一次加载进进程(DLL_PROCESS_ATTACH) 时先记录原本api的地址，如何再hook。</p><p>当 卸载dll(DLL_PROCESS_DETACH) 时unhook。</p><p>因为hook实际上就是把iat中被钩取api的地址换成补丁函数的地址，而unhook的过程则反过来把iat中补丁函数地址换回原本地址，所以可以统一写成一个函数hook_iat()。该函数会将oldFunc替换成newFunc。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hook_iat</span><span class="params">(<span class="keyword">char</span>* pszDllName, HANDLE oldFunc, HANDLE newFunc)</span></span>;</span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">MySetWindowTextW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HWND    hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCWSTR lpString</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="comment">// save origin api</span></span><br><span class="line">        pOriginFunc = GetProcAddress(GetModuleHandleW(<span class="string">L&quot;user32.dll&quot;</span>), <span class="string">&quot;SetWindowTextW&quot;</span>);</span><br><span class="line">        <span class="comment">// hook</span></span><br><span class="line">        hook_iat(<span class="string">&quot;user32.dll&quot;</span>, pOriginFunc, MySetWindowTextW);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="comment">//unhook</span></span><br><span class="line">        hook_iat(<span class="string">&quot;user32.dll&quot;</span>, MySetWindowTextW, pOriginFunc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-改写iat（hook-iat-）"><a href="#3-改写iat（hook-iat-）" class="headerlink" title="3 改写iat（hook_iat()）"></a>3 改写iat（hook_iat()）</h3><p>这个函数用于把iat中名为 pszDllName 的 library 中的 oldFunc 换成 newFunc。本质上整段代码就是在解析pe文件以及遍历iat。这里不做详细解析，详见反射注入文章[2]中 处理导入表 部分内容。</p><p>其中用到了size_t，这是个与机器有关的unsigned类型。说人话就是按32位编译时是32位；按64位编译时是64位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hook_iat</span><span class="params">(<span class="keyword">char</span>* pszDllName, HANDLE oldFunc, HANDLE newFunc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// pe</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandleW(<span class="literal">NULL</span>);</span><br><span class="line">    PIMAGE_NT_HEADERS32 pNtHeader = (PIMAGE_NT_HEADERS32)padd(pDosHeader, pDosHeader-&gt;e_lfanew);</span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)padd(pDosHeader, pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find dll</span></span><br><span class="line">    LPCSTR pszLibName;</span><br><span class="line">    <span class="keyword">for</span> (; pImportDescriptor-&gt;Name; pImportDescriptor++) &#123;</span><br><span class="line">        pszLibName = (LPCSTR)padd(pDosHeader, pImportDescriptor-&gt;Name);</span><br><span class="line">        <span class="keyword">if</span> (_stricmp(pszLibName, pszDllName) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// find old func</span></span><br><span class="line">            PIMAGE_THUNK_DATA32 pThunk = (PIMAGE_THUNK_DATA32)padd(pDosHeader, pImportDescriptor-&gt;FirstThunk);</span><br><span class="line">            <span class="keyword">for</span> (; pThunk-&gt;u1.Function; pThunk++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pThunk-&gt;u1.Function == (<span class="keyword">size_t</span>)oldFunc) &#123;</span><br><span class="line">                    <span class="comment">// replace</span></span><br><span class="line">                    DWORD dwOldProt;</span><br><span class="line">                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">4</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProt);</span><br><span class="line">                    pThunk-&gt;u1.Function = (<span class="keyword">size_t</span>)newFunc;</span><br><span class="line">                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">4</span>, dwOldProt, &amp;dwOldProt);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-新api（补丁代码-MySetWindowTextW-）"><a href="#4-新api（补丁代码-MySetWindowTextW-）" class="headerlink" title="4 新api（补丁代码 MySetWindowTextW()）"></a>4 新api（补丁代码 MySetWindowTextW()）</h3><p>这部分代码参考逆向工程核心原理[1]，这个函数用于将unicode的数字转换成中文数字。temp数组的目的是构造一个0结尾的字符串，用于_wtoi。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI *SETWINDOWTEXTW)</span><span class="params">(HWND, LPCWSTR)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">MySetWindowTextW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HWND    hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCWSTR lpString</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">wchar_t</span> pNumTab[] = <span class="string">L&quot;零一二三四五六七八九&quot;</span>;</span><br><span class="line">    <span class="keyword">wchar_t</span> temp[<span class="number">2</span>] = &#123; <span class="number">0</span>, &#125;; <span class="comment">// for wtoi</span></span><br><span class="line">    <span class="keyword">size_t</span> i, nLen, nIndex;</span><br><span class="line"></span><br><span class="line">    nLen = wcslen(lpString);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nLen; i++) &#123;</span><br><span class="line">        <span class="comment">// translate</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">L&#x27;0&#x27;</span> &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= <span class="string">L&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            temp[<span class="number">0</span>] = lpString[i];</span><br><span class="line">            nIndex = _wtoi(temp);</span><br><span class="line">            ((<span class="keyword">wchar_t</span>*)lpString)[i] = pNumTab[nIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((SETWINDOWTEXTW)pOriginFunc)(hWnd, lpString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 逆向工程核心原理：part4-API钩取：第32章-计算器显示中文数字</p><p>[2] 反射注入 <a href="https://bbs.pediy.com/thread-266929.htm">看雪文章链接</a> <a href="https://windgodm.github.io/blog/2021/04/11/reflectiveDllInjection/">博客文章链接</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/api-hook/">api_hook</category>
      
      <category domain="https://windgodm.github.io/blog/tags/reversecore/">reversecore</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/06/19/APIHookDllIATCalc/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>APIHook 调试技术 笔记</title>
      <link>https://windgodm.github.io/blog/2021/06/17/APIHookDebugNotebook/</link>
      <guid>https://windgodm.github.io/blog/2021/06/17/APIHookDebugNotebook/</guid>
      <pubDate>Thu, 17 Jun 2021 14:10:00 GMT</pubDate>
      
      <description>逆向工程核心原理中利用调试技术附加到目标进程实现钩取API的笔记,&lt;br&gt;钩取了记事本的WriteFile()实现大小写转换。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="APIHook-调试技术-笔记"><a href="#APIHook-调试技术-笔记" class="headerlink" title="APIHook-调试技术 笔记"></a>APIHook-调试技术 笔记</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote><p>技术摘要：</p><p><strong>动态</strong>修改<strong>进程内存</strong>中的<strong>代码</strong>。利用<strong>调试</strong>技术附加到目标进程钩取API。</p></blockquote><blockquote><p>术语：</p><p>debuger：调试器<br>debugee：被调试者</p></blockquote><p>起源是逆向工程核心原理里面以记事本WriteFile()API钩取为例讲解利用调试来实现API钩取。<br>该例子目标是在文件保存时把小写转成大写。</p><p>概括来说就是实现一个调试器，给对应api下断点。</p><p>以记事本WriteFile()API为例，大概流程是作为调试器附加到notepad上，然后给WriteFile()的起始地址下个int 3断点，这样控制流就能回到调试器，就可以读取栈获得api参数了。</p><p>大概流程如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1: 作为调试器附加</span><br><span class="line">2: 进入调试循环</span><br><span class="line"></span><br><span class="line">判断是否为int3断点，且断点位置为目标api起始地址</span><br><span class="line">OnException:</span><br><span class="line">  1: unhook</span><br><span class="line">  2: get thread context</span><br><span class="line">  3: your patch</span><br><span class="line">  4: change ctx(eip&#x2F;rip)</span><br><span class="line">  5: continue debugee</span><br><span class="line">  Sleep(0)</span><br><span class="line">  6: hook</span><br><span class="line"></span><br><span class="line">对于其他异常，交回给debugee的seh处理</span><br></pre></td></tr></table></figure><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>首先是要注意32和64位的问题，然后可能需要获取Debug权限。</p><h2 id="实例：记事本WriteFile-API（x32）"><a href="#实例：记事本WriteFile-API（x32）" class="headerlink" title="实例：记事本WriteFile()API（x32）"></a>实例：记事本WriteFile()API（x32）</h2><p>该例子对象是win10的x32的notepad.exe。</p><h3 id="1-作为调试器附加"><a href="#1-作为调试器附加" class="headerlink" title="1 作为调试器附加"></a>1 作为调试器附加</h3><p>代码如下只有一行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DebugActiveProcess(dwPID);</span><br></pre></td></tr></table></figure><p>附加失败会返回0，通过GetLastError()可以获取错误代码，x32的debuger附加x64的debugee会失败并得到0x32这个错误代码。</p><p>成功后会发送一个CREATE_PROCESS_DEBUG_EVENT事件，可以被WaitForDebugEvent()获取。</p><p>还有另外一种方法是用CreateProcess()来创建并附加一个进程。</p><h3 id="2-调试循环"><a href="#2-调试循环" class="headerlink" title="2 调试循环"></a>2 调试循环</h3><p>附加成功后就要进入调试循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DEBUG_EVENT de;</span><br><span class="line">DWORD dwDECode;</span><br><span class="line">DWORD dwContinueStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for debug event</span></span><br><span class="line"><span class="keyword">while</span> (WaitForDebugEvent(&amp;de, INFINITE)) &#123;</span><br><span class="line">    dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;</span><br><span class="line">    dwDECode = de.dwDebugEventCode;</span><br><span class="line">    <span class="comment">// exception</span></span><br><span class="line">    <span class="keyword">if</span> (dwDECode == EXCEPTION_DEBUG_EVENT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (OnException(&amp;de))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// on create or attach debug event</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dwDECode == CREATE_PROCESS_DEBUG_EVENT) &#123;</span><br><span class="line">        OnCreate(&amp;de);</span><br><span class="line">        dwContinueStatus = DBG_CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debuggee exit</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dwDECode == EXIT_PROCESS_DEBUG_EVENT) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// continue to run debuggee</span></span><br><span class="line">    ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WaitForDebugEvent()用于等待调试事件。第一个参数用于接收调试信息；第二个为等待时间(ms)，如果等待时间为INFINITE(0xFFFFFFFF)则会一直等待直到有调试时间再返回，这时debugee会被挂起。</p><h3 id="3-处理调试事件"><a href="#3-处理调试事件" class="headerlink" title="3 处理调试事件"></a>3 处理调试事件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minwinbase.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_EVENT</span> &#123;</span></span><br><span class="line">    DWORD dwDebugEventCode;</span><br><span class="line">    DWORD dwProcessId;</span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        EXCEPTION_DEBUG_INFO Exception;</span><br><span class="line">        CREATE_THREAD_DEBUG_INFO CreateThread;</span><br><span class="line">        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;</span><br><span class="line">        EXIT_THREAD_DEBUG_INFO ExitThread;</span><br><span class="line">        EXIT_PROCESS_DEBUG_INFO ExitProcess;</span><br><span class="line">        LOAD_DLL_DEBUG_INFO LoadDll;</span><br><span class="line">        UNLOAD_DLL_DEBUG_INFO UnloadDll;</span><br><span class="line">        OUTPUT_DEBUG_STRING_INFO DebugString;</span><br><span class="line">        RIP_INFO RipInfo;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; DEBUG_EVENT, *LPDEBUG_EVENT;</span><br></pre></td></tr></table></figure><p><strong>EXCEPTION_DEBUG_EVENT</strong><br>(u.Exception = EXCEPTION_DEBUG_INFO)<br>为异常调试事件，<strong>int 3</strong>中断时会触发该事件，这时我们需要执行自己的代码，具体见“6 异常调试事件”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minwinbase.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_DEBUG_INFO</span> &#123;</span></span><br><span class="line">    EXCEPTION_RECORD ExceptionRecord;</span><br><span class="line">    DWORD dwFirstChance;</span><br><span class="line">&#125; EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;</span><br><span class="line"><span class="comment">// winnt.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span></span><br><span class="line">    DWORD    ExceptionCode;</span><br><span class="line">    DWORD ExceptionFlags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span></span><br><span class="line">    PVOID ExceptionAddress;</span><br><span class="line">    DWORD NumberParameters;</span><br><span class="line">    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure><p><strong>CREATE_PROCESS_DEBUG_EVENT</strong><br>(u.CreateProcessInfo = CREATE_PROCESS_DEBUG_INFO)<br>在<strong>刚附加</strong>到debugee时会触发，这时需要完成hook，具体见“5 首次hook”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minwinbase.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CREATE_PROCESS_DEBUG_INFO</span> &#123;</span></span><br><span class="line">    HANDLE hFile;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    LPVOID lpBaseOfImage;</span><br><span class="line">    DWORD dwDebugInfoFileOffset;</span><br><span class="line">    DWORD nDebugInfoSize;</span><br><span class="line">    LPVOID lpThreadLocalBase;</span><br><span class="line">    LPTHREAD_START_ROUTINE lpStartAddress;</span><br><span class="line">    LPVOID lpImageName;</span><br><span class="line">    WORD fUnicode;</span><br><span class="line">&#125; CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;</span><br></pre></td></tr></table></figure><p><strong>EXIT_PROCESS_DEBUG_EVENT</strong><br>(u.ExitProcess = EXIT_PROCESS_DEBUG_INFO)<br>在debugee退出时触发。</p><h3 id="4-继续运行debugee"><a href="#4-继续运行debugee" class="headerlink" title="4 继续运行debugee"></a>4 继续运行debugee</h3><p>处理完调试事件后，调用ContinueDebugEvent()以继续运行debugee。</p><p>ContinueDebugEvent第三个参数比较特殊，如果处理成功设置为DBG_CONTINUE即可，如果不能处理设置成DBG_EXCEPTION_NOT_HANDLED让seh来处理。</p><h3 id="5-首次hook"><a href="#5-首次hook" class="headerlink" title="5 首次hook"></a>5 首次hook</h3><p>该事件在刚附加时触发一次，这时我们需要完成对API的hook：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnCreate</span><span class="params">(DEBUG_EVENT* pde)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get api address</span></span><br><span class="line"></span><br><span class="line">    hKernel32 = GetModuleHandleW(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hKernel32 == <span class="number">0</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Get kernel32.dll failed.\n&quot;</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    pWriteFile = GetProcAddress(hKernel32, <span class="string">&quot;WriteFile&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pWriteFile == <span class="number">0</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Get WriteFile() failed.\n&quot;</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hook</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;cpdi, &amp;pde-&gt;u.CreateProcessInfo, <span class="keyword">sizeof</span>(CREATE_PROCESS_DEBUG_INFO));</span><br><span class="line">    ReadProcessMemory(cpdi.hProcess, pWriteFile, &amp;chOrigin, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chINT3, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kernel32在不同进程中加载到同样位置，直接在本进程GetModuleHandleW就行。</p><p>需要注意的是把CreateProcessInfo保存下来，其中有一些信息比如debugee的进程、线程id我们在接下来的再次hook时也需要使用。</p><h3 id="6-异常调试事件（补丁代码）"><a href="#6-异常调试事件（补丁代码）" class="headerlink" title="6 异常调试事件（补丁代码）"></a>6 异常调试事件（补丁代码）</h3><p>发生异常调试事件时触发，如果为int3且断点为目标api地址就执行我们的补丁，这里我们的补丁是把文本的小写字母转换成大写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnException</span><span class="params">(DEBUG_EVENT* pde)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CONTEXT ctx;</span><br><span class="line">    PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExceptionRecord;</span><br><span class="line">    DWORD dwBuffer, dwNum; <span class="comment">// WriteFile() param 2, 3</span></span><br><span class="line">    PBYTE lpBuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int 3</span></span><br><span class="line">    <span class="keyword">if</span> (per-&gt;ExceptionCode == EXCEPTION_BREAKPOINT) &#123;</span><br><span class="line">        <span class="comment">// breakpoint address</span></span><br><span class="line">        <span class="keyword">if</span> (per-&gt;ExceptionAddress == pWriteFile) &#123;</span><br><span class="line">            <span class="comment">// 1: unhook</span></span><br><span class="line">            WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chOrigin, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2: get thread context</span></span><br><span class="line">            ctx.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line">            GetThreadContext(cpdi.hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.1: get WriteFile() param 2, 3</span></span><br><span class="line">            ReadProcessMemory(cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="number">0x8</span>), &amp;dwBuffer, <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ReadProcessMemory(cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="number">0xC</span>), &amp;dwNum, <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2: malloc buffer</span></span><br><span class="line">            lpBuffer = (PBYTE)<span class="built_in">malloc</span>(dwNum + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">memset</span>(lpBuffer, <span class="number">0</span>, dwNum + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.3: copy to buffer</span></span><br><span class="line">            ReadProcessMemory(cpdi.hProcess, (LPVOID)dwBuffer, lpBuffer, dwNum, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nOrigin:\n&quot;</span> &lt;&lt; lpBuffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.4: Convert</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dwNum; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">                    lpBuffer[i] -= <span class="number">0x20</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nConverted:\n&quot;</span> &lt;&lt; lpBuffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.5: copy back</span></span><br><span class="line">            WriteProcessMemory(cpdi.hProcess, (LPVOID)dwBuffer, lpBuffer, dwNum, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">free</span>(lpBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4: change ctx(eip)</span></span><br><span class="line">            ctx.Eip = (DWORD)pWriteFile;</span><br><span class="line">            SetThreadContext(cpdi.hThread, &amp;ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5: run</span></span><br><span class="line">            ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE);</span><br><span class="line"></span><br><span class="line">            Sleep(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6: hook</span></span><br><span class="line">            WriteProcessMemory(cpdi.hProcess, pWriteFile, &amp;chINT3, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程是unhook -&gt; 获取上下文 -&gt; 补丁 -&gt; 恢复eip/rip -&gt; 继续运行debugee -&gt; 恢复hook</p><p>在继续运行debugee之后需要Sleep(0)再恢复hook，是因为hook会修改内存中的代码，此时debugee也在运行同一段内存的代码，可能会发生内存访问异常。Sleep(0)可以释放当前线程的剩余时间，让cpu先去执行其他线程，然后再回来恢复hook。</p><p>其中需要用到api的参数，这里简单分析下此时的栈。此时刚刚进入函数，还未push ebp，所以esp指向旧的栈顶，也就是函数放回地址。32位以寄存器传参，第n的参数此时在esp+4*n的位置。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>逆向工程核心原理：part4-API钩取：第30章-记事本WriteFile()API钩取</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/api-hook/">api_hook</category>
      
      <category domain="https://windgodm.github.io/blog/tags/reversecore/">reversecore</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/06/17/APIHookDebugNotebook/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>21KctfSpring</title>
      <link>https://windgodm.github.io/blog/2021/06/02/21KctfSpring/</link>
      <guid>https://windgodm.github.io/blog/2021/06/02/21KctfSpring/</guid>
      <pubDate>Wed, 02 Jun 2021 12:43:07 GMT</pubDate>
      
      <description>21kctf春季赛 re部分题解</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="21-kctf-春"><a href="#21-kctf-春" class="headerlink" title="21 kctf 春"></a>21 kctf 春</h1><h2 id="2-南冥神功"><a href="#2-南冥神功" class="headerlink" title="2 南冥神功"></a>2 南冥神功</h2><p>分析main函数</p><h3 id="1-char-2-int"><a href="#1-char-2-int" class="headerlink" title="1 char 2 int"></a>1 char 2 int</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chars_table = <span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(v24 != ++v23)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(chars_table[v23] == input_i)</span><br><span class="line">        <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中input_i是输入的第i个字符，goto执行时，v23 = int(input_i)。</p><h3 id="2-找出二维数组"><a href="#2-找出二维数组" class="headerlink" title="2 找出二维数组"></a>2 找出二维数组</h3><p>有一句 <code>&amp;aS_1[10*row+col]</code>可以判断出是二维数组。<br>该句上面是一个switch，对row和col操作，然后判断越界，然后才到v13 = &amp;aS_1。紧接着又有一个if(*v13) break猜测是走二维数组地图的题。且1为墙，0为空。</p><h3 id="3-主要循环"><a href="#3-主要循环" class="headerlink" title="3 主要循环"></a>3 主要循环</h3><p>switch外面套了个for，然后还有一些向前的goto，构成了主要循环。下面是该循环的部分代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">x2 = (i + int_inputs[i] / <span class="number">6</span>) % <span class="number">6</span>;</span><br><span class="line">x = <span class="number">5</span> - (i + int_inputs[i]) % <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ;; j = <span class="number">1</span>) &#123; <span class="comment">// 一共循环两次</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span>(x) &#123;&#125; <span class="comment">// 移动</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 越界撞墙判断</span></span><br><span class="line">    <span class="keyword">if</span> (col &gt; <span class="number">9</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (row &gt; <span class="number">8</span>) <span class="keyword">break</span>;</span><br><span class="line">    v13 = &amp;aS_1[<span class="number">10</span> * row + col];</span><br><span class="line">    <span class="keyword">if</span> ( *v13 ) <span class="keyword">break</span>;</span><br><span class="line">    *v13 = <span class="number">1</span>; <span class="comment">// 走过的位置填充</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[++i])</span><br><span class="line">        <span class="keyword">goto</span> LABEL_4; <span class="comment">// 去把inputs[i]转换成数字</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">goto</span> LABEL_19; <span class="comment">// 到了输入结尾，去判断有没有全部被填充</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    x = x2; <span class="comment">// x = x2 再循环一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际上这个for循环执行了两次，也就是每个inputs[i]对应两次移动。</p><p>其中LABEL_19对应的代码会检测aS_1是否全为1，全为1就输出”Good job!”</p><h3 id="4-switch"><a href="#4-switch" class="headerlink" title="4 switch"></a>4 switch</h3><p>接着分析switch，即移动的方式。这里直接给结论。实际上可以不分析，直接复制这个switch去写暴力解码脚本。</p><p>case 1：col += 1</p><p>case 2：!(row&amp;1) 时col += 1，然后 row += 1</p><p>case 3：row&amp;1 时col -= 1，然后 row += 1</p><p>case 4：col -= 1</p><p>case 5：row&amp;1 时col -= 1，然后 row -= 1</p><p>case 0：!(row&amp;1) 时col += 1，然后 row -= 1</p><h3 id="5-接下来就可以爆破了"><a href="#5-接下来就可以爆破了" class="headerlink" title="5 接下来就可以爆破了"></a>5 接下来就可以爆破了</h3><p>刚刚打完acm不想写爆破了。要不是每一个字符对应两次位移，可以建一个图来跑。</p><h2 id="4-英雄救美"><a href="#4-英雄救美" class="headerlink" title="4 英雄救美"></a>4 英雄救美</h2><p>分析main函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scanf_s(<span class="string">&quot;%s&quot;</span>, pszIn, <span class="number">81</span>);</span><br><span class="line">nLen = <span class="built_in">strlen</span>(pszIn);</span><br><span class="line"><span class="keyword">if</span> (nLen &lt;= <span class="number">64</span> &amp;&amp; fun2(nLen, pszIn, v10) == <span class="number">1</span> &amp;&amp; fun1(v10, nLen - <span class="number">9</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// pass</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有三个判定。fun2有三个参数，但我的ida在main中只识别出两个。通过看汇编把缺的参数补全了。</p><h3 id="1-fun2"><a href="#1-fun2" class="headerlink" title="1 fun2"></a>1 fun2</h3><p>下面给出数据和重构的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> v60[<span class="number">16</span>] = &#123;<span class="number">0x46</span>, <span class="number">0x53</span>, <span class="number">0x4c</span>, <span class="number">0x52</span>, <span class="number">0x41</span>, <span class="number">0x3b</span>, <span class="number">0x2e</span>, <span class="number">0x6c</span>, <span class="number">0x3d</span>, <span class="number">0x43</span>, <span class="number">0x45</span>, <span class="number">0x6b</span>, <span class="number">0x76</span>, <span class="number">0x4b</span>, <span class="number">0x2d</span>, <span class="number">0x28</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> v70[<span class="number">16</span>] = &#123;<span class="number">0x6a</span>, <span class="number">0x69</span>, <span class="number">0x63</span>, <span class="number">0x30</span>, <span class="number">0x21</span>, <span class="number">0x68</span>, <span class="number">0x64</span>, <span class="number">0x79</span>, <span class="number">0x7b</span>, <span class="number">0x6f</span>, <span class="number">0x5a</span>, <span class="number">0x7a</span>, <span class="number">0x2d</span>, <span class="number">0x40</span>, <span class="number">0x6e</span>, <span class="number">0x2b</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> v80[<span class="number">16</span>] = &#123;<span class="number">0x24</span>, <span class="number">0x42</span>, <span class="number">0x50</span>, <span class="number">0x56</span>, <span class="number">0x3a</span>, <span class="number">0x75</span>, <span class="number">0x62</span>, <span class="number">0x66</span>, <span class="number">0x59</span>, <span class="number">0x70</span>, <span class="number">0x7d</span>, <span class="number">0x5d</span>, <span class="number">0x44</span>, <span class="number">0x74</span>, <span class="number">0x4e</span>, <span class="number">0x3e</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> v90[<span class="number">16</span>] = &#123;<span class="number">0x3f</span>, <span class="number">0x26</span>, <span class="number">0x25</span>, <span class="number">0x73</span>, <span class="number">0x5f</span>, <span class="number">0x2f</span>, <span class="number">0x67</span>, <span class="number">0x3c</span>, <span class="number">0x65</span>, <span class="number">0x5b</span>, <span class="number">0x57</span>, <span class="number">0x29</span>, <span class="number">0x58</span>, <span class="number">0x55</span>, <span class="number">0x78</span>, <span class="number">0x52</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> vA0[<span class="number">16</span>] = &#123;<span class="number">0x61</span>, <span class="number">0x54</span>, <span class="number">0x5e</span>, <span class="number">0x4d</span>, <span class="number">0x47</span>, <span class="number">0x6d</span>, <span class="number">0x4a</span>, <span class="number">0x51</span>, <span class="number">0x23</span>, <span class="number">0x2a</span>, <span class="number">0x48</span>, <span class="number">0x72</span>, <span class="number">0x60</span>, <span class="number">0x4f</span>, <span class="number">0x27</span>, <span class="number">0x77</span>&#125;</span><br><span class="line"><span class="comment">// psTable = v80+vA0+v70+v90+v60+0x71</span></span><br><span class="line"><span class="keyword">char</span> psTable[<span class="number">82</span>] = <span class="string">&quot;$BPV:ubfYp&#125;]DtN&gt;aT^MGmJQ#*Hr`O&#x27;wjic0!hdy&#123;oZz-@n+?&amp;%s_/g&lt;e[W)XUxRFSLRA;.l=CEkvK-(q&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">v5 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// psTable[81]</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pszIn[i] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; pszIn[i] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j + pszIn[i] == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            v5 += <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        v7 = v5;</span><br><span class="line">        <span class="keyword">if</span>(v5 &gt;= <span class="number">81</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// v7 = pszIn[i]对应psTable[]中相同字符的下标</span></span><br><span class="line">        <span class="keyword">while</span>(pszIn[i] != *(psTable+v7)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(++v7 &gt;= <span class="number">81</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        v9 = v7 % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( v9 == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        *pcV10 = v9; <span class="comment">// 重构输入</span></span><br><span class="line">        j++;</span><br><span class="line">        pcV10++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(++i &gt;= nLen)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搞了一大堆，其中一个退出条件是，如果输入全都是9，就能return 1，但显然答案不是这个。</p><p>相反，只要输入中没有1-9，v5就一直为0，这样就会根据输入字符在psTable中的相同字符的下标重构一个pcV10。</p><p>比如 <code>pszIn = &quot;$$V:$V&quot;</code>，<code>pcV10 = &#123;1, 1, 4, 5, 1, 4&#125;</code></p><h3 id="2-算flag"><a href="#2-算flag" class="headerlink" title="2 算flag"></a>2 算flag</h3><p>fun1实际上就是检测是否符合数独情况。</p><p>解出数独答案来，然后推出输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">table = [<span class="number">0x24</span>, <span class="number">0x42</span>, <span class="number">0x50</span>, <span class="number">0x56</span>, <span class="number">0x3A</span>, <span class="number">0x75</span>, <span class="number">0x62</span>, <span class="number">0x66</span>, <span class="number">0x59</span>, <span class="number">0x70</span>, <span class="number">0x7D</span>, <span class="number">0x5D</span>, <span class="number">0x44</span>, <span class="number">0x74</span>, <span class="number">0x4E</span>, <span class="number">0x3E</span>, <span class="number">0x61</span>, <span class="number">0x54</span>, <span class="number">0x5E</span>, <span class="number">0x4D</span>, <span class="number">0x47</span>, <span class="number">0x6D</span>, <span class="number">0x4A</span>, <span class="number">0x51</span>, <span class="number">0x23</span>, <span class="number">0x2A</span>, <span class="number">0x48</span>, <span class="number">0x72</span>, <span class="number">0x60</span>, <span class="number">0x4F</span>, <span class="number">0x27</span>, <span class="number">0x77</span>, <span class="number">0x6A</span>, <span class="number">0x69</span>, <span class="number">0x63</span>, <span class="number">0x30</span>, <span class="number">0x21</span>, <span class="number">0x68</span>, <span class="number">0x64</span>, <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x6F</span>, <span class="number">0x5A</span>, <span class="number">0x7A</span>, <span class="number">0x2D</span>, <span class="number">0x40</span>, <span class="number">0x6E</span>, <span class="number">0x2B</span>, <span class="number">0x3F</span>, <span class="number">0x26</span>, <span class="number">0x25</span>, <span class="number">0x73</span>, <span class="number">0x5F</span>, <span class="number">0x2F</span>, <span class="number">0x67</span>, <span class="number">0x3C</span>, <span class="number">0x65</span>, <span class="number">0x5B</span>, <span class="number">0x57</span>, <span class="number">0x29</span>, <span class="number">0x58</span>, <span class="number">0x55</span>, <span class="number">0x78</span>, <span class="number">0x52</span>, <span class="number">0x46</span>, <span class="number">0x53</span>, <span class="number">0x4C</span>, <span class="number">0x52</span>, <span class="number">0x41</span>, <span class="number">0x3B</span>, <span class="number">0x2E</span>, <span class="number">0x6C</span>, <span class="number">0x3D</span>, <span class="number">0x43</span>, <span class="number">0x45</span>, <span class="number">0x6B</span>, <span class="number">0x76</span>, <span class="number">0x4B</span>, <span class="number">0x2D</span>, <span class="number">0x28</span>, <span class="number">0x71</span>]</span><br><span class="line"></span><br><span class="line">o = [[<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>],</span><br><span class="line"> [<span class="number">8</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">1</span>],</span><br><span class="line"> [<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">4</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">r = [[<span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>],</span><br><span class="line"> [<span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>],</span><br><span class="line"> [<span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>],</span><br><span class="line"> [<span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line"> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>],</span><br><span class="line"> [<span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>],</span><br><span class="line"> [<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>],</span><br><span class="line"> [<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">print(<span class="string">&#x27;#1&#x27;</span>)</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">if</span> o[y][x] == <span class="number">0</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            flag += <span class="built_in">chr</span>(table[r[y][x] - <span class="number">1</span> + y * <span class="number">9</span>])</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;9&#x27;</span>) - j)</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">print(<span class="string">&#x27;#2&#x27;</span>)</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">n9 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">if</span> o[y][x] == <span class="number">0</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            flag += <span class="built_in">chr</span>(table[r[y][x] - <span class="number">1</span> + n9 * <span class="number">9</span>])</span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="number">8</span>:</span><br><span class="line">            flag += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            n9 += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n9 &lt; <span class="number">9</span>:</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;9&#x27;</span>) - j)</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    n9 += <span class="number">1</span></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>第一个flag是正确的，第二个只能过输入转换fun2和数独检测fun1，而不能弹出窗口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:u$YBPf2pa]Dt4#QM^H4ic&#39;j0&#96;w2y&#123;d-Zzo2%&#x2F;n_s@+2&lt;UW)e4AR;F.4&#x3D;-qEkvC2</span><br><span class="line">:u$YBPf$1a]Dt&gt;N&#125;p1H#*mQHMJ1&#39;wO0icjj1-hzZ!dhz1&amp;%+%@sn_1gXxe[W&lt;299</span><br></pre></td></tr></table></figure><p>在VA之前有几个函数，这个函数会检测转换前的原始输入。如果原始输入不符合要求，将不能正确弹窗，（弹窗的代码依赖于正确的输入来生成，但前面的if检查并不严格，错误的原始输入产生了错误的代码）会报错0xc0000096然后崩溃。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/06/02/21KctfSpring/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>games101笔记</title>
      <link>https://windgodm.github.io/blog/2021/05/24/games101Note/</link>
      <guid>https://windgodm.github.io/blog/2021/05/24/games101Note/</guid>
      <pubDate>Mon, 24 May 2021 14:12:26 GMT</pubDate>
      
      <description>cg入门课程games101的笔记，内容比较随缘，有重点内容会单独写,&lt;br&gt;只是个人爱好，大概率会咕咕咕,&lt;br&gt;更新到第五课(21-08-10)</description>
      
      
      
      <content:encoded><![CDATA[<p>games101-5</p><p><a href="/blog/note/games101Note.html">games 101 note</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/ComputerGraphics/">ComputerGraphics</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/ComputerGraphics/">ComputerGraphics</category>
      
      <category domain="https://windgodm.github.io/blog/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/">持续更新</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/05/24/games101Note/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CPP编写类库给其他语言使用的总结</title>
      <link>https://windgodm.github.io/blog/2021/04/23/CppDllForOthers/</link>
      <guid>https://windgodm.github.io/blog/2021/04/23/CppDllForOthers/</guid>
      <pubDate>Thu, 22 Apr 2021 17:05:59 GMT</pubDate>
      
      <description>主要是使用vs2019作为ide，cpp为语言编写类库，然后编译成dll，供其他cpp、c#、python等语言的工程调用类库,&lt;br&gt;目的是一次编写与编译某个类库，然后给多语言使用。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="CPP编写类库给其他语言使用"><a href="#CPP编写类库给其他语言使用" class="headerlink" title="CPP编写类库给其他语言使用"></a>CPP编写类库给其他语言使用</h1><p>主要是使用vs2019作为ide，cpp为语言编写类库，然后编译成dll，供其他cpp、c#、python等语言的工程调用类库。目的是一次编写与编译某个类库，然后给多语言使用。</p><p>这里是个傻瓜式操作总结贴（我总是忘记细节emm），总结网上及书里提供的一些方法，尽量用简单的方式实现目的。</p><h2 id="用cpp写类库（VS2019）"><a href="#用cpp写类库（VS2019）" class="headerlink" title="用cpp写类库（VS2019）"></a>用cpp写类库（VS2019）</h2><h3 id="类库项目"><a href="#类库项目" class="headerlink" title="类库项目"></a>类库项目</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>直接新建空白项目，然后在项目属性页中进行如下配置：</p><blockquote><p>常规-常规属性-配置类型：动态库(.dll)</p></blockquote><h4 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h4><p>下面给出项目的框架。直接编译就可以得到MyDll.dll</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 项目（MyDll）：头文件：MyDll.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYDLL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYDLL_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是输出的函数</span></span><br><span class="line">_declspec(dllexport) <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是输出的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">declspec</span>(<span class="title">dllexport</span>) <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass();</span><br><span class="line">    ~MyClass();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !MYDLL_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 项目（MyDll）：源文件：MyDll.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyDll.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现头文件中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现头文件中类的函数</span></span><br><span class="line">MyClass::MyClass()</span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::~MyClass()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyClass::Set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[index] = x;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] + a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加类库对应的共享项目"><a href="#添加类库对应的共享项目" class="headerlink" title="添加类库对应的共享项目"></a>添加类库对应的共享项目</h3><p>这一步的目的主要是为了解决<strong>调用类库项目</strong>和<strong>类库项目</strong> <strong>不在同一个解决方案</strong>的情况。</p><p>在同一个解决方案中，新建一个<strong>共享项目</strong>项目，然后在<strong>解决方案资源管理器</strong>-<strong>共享项目</strong>上右键<strong>添加</strong>-<strong>添加现有项</strong>，找到MyDll.h、MyDll.cpp添加进去。</p><h2 id="cpp项目-调用-cpp写的类库（VS2019）"><a href="#cpp项目-调用-cpp写的类库（VS2019）" class="headerlink" title="cpp项目 调用 cpp写的类库（VS2019）"></a>cpp项目 调用 cpp写的类库（VS2019）</h2><h3 id="方案一：隐式链接"><a href="#方案一：隐式链接" class="headerlink" title="方案一：隐式链接"></a>方案一：隐式链接</h3><ul><li><p><strong>添加引用：</strong><br>在<strong>解决方案资源管理器</strong>中<strong>你的cpp项目</strong>的<strong>引用</strong>处右键选择<strong>添加引用</strong></p><ul><li>cpp项目和dll项目在<strong>同一个解决方案</strong>：<br>然后在弹出窗口的左侧菜单选择<strong>项目</strong>-<strong>解决方案</strong>，然后找到刚刚写好的<strong>dll项目</strong>，点击勾选框。</li><li>两者不在同一个解决方案：<br>先参考<strong>cpp写类库</strong>-<strong>配置共享项目</strong>配置好，然后在弹出窗口的左侧菜单选择<strong>共享的项目</strong>-<strong>解决方方案</strong>，找到<strong>dll项目对应的共享项目</strong>，点击勾选框。</li></ul></li><li><p><strong>包含头文件</strong>：通过相对或绝对<strong>路径引用</strong>dll项目的头文件。</p></li></ul><h3 id="方案二：显示链接"><a href="#方案二：显示链接" class="headerlink" title="方案二：显示链接"></a>方案二：显示链接</h3><p>没有需求，所以还没有测试这种方案这么处理比较方便。// todo</p><h2 id="C-（WPF）项目-调用-cpp写的类库（vs2019）"><a href="#C-（WPF）项目-调用-cpp写的类库（vs2019）" class="headerlink" title="C#（WPF）项目 调用 cpp写的类库（vs2019）"></a>C#（WPF）项目 调用 cpp写的类库（vs2019）</h2><p>我的情况是涉及一个大量使用指针的类。通过一个托管类把类的函数都暴露出来，实际上就是在托管类中做一个跳转，有时候还需要在这个跳转的函数中做c#和c++间的类型转换。</p><p>流程大概是先写个托管类，然后再在wpf项目中导入。</p><p>需要<strong>注意</strong>的是，Debug调试时，应该把 MyDll.dll 放到WPF的 /bin/Debug 目录中，原因是 MyDllCSWrapper.dll 需要导入 MyDll.dll。所以需要把 <strong>MyDll.dll</strong> 放到项目的<strong>可执行文件的根目录</strong>（当然系统目录啥的好像也行）。<br>至于MyDllCSWrapper.dll放哪里都行，c#中ImportDll的路径填对就行。</p><h3 id="托管类"><a href="#托管类" class="headerlink" title="托管类"></a>托管类</h3><p>首先参考“用cpp写类库”新建一个项目写托管。</p><p>这里直接给出托管类代码框架，原型类参考前面“用cpp写类库”。</p><p>这里MyDll.h中的Add不是类中的函数，我没有这个需求没有去研究，不确定该如何暴露，欢迎补充。// todo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 项目（MyDllCSWrapper）：头文件：MyDllCSWrapper.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里通过相对或绝对路径引用MyDll的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../MyDll/MyDll.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyDllCSWrapper</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="keyword">int</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 项目（MyDllCSWrapper）：源文件：MyDllCSWrapper.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyDllCSWrapper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyDllCSWrapper</span><br><span class="line">&#123;</span><br><span class="line">MyClass* pmc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ppe-&gt;Set(index, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>c++中的类型与c#不是完全对应的。int、double、float啥的好像是一一对应的，但指针就不一定了，要小心处理。</p><p>我遇到的一个特殊情况就是我需要传递一个数组过去，c#中使用类型 char[]、ref char[] 只能传递第一个元素过去。需要使用 byte[] 才行。</p><p>下面是我遇到一些的情况。</p><blockquote><p>c++类型 —- c# 类型</p><p>unsigned int、unsigned long、DWORD —- uint</p><p>char*（数组）—- byte[]</p></blockquote><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>暂时没有需求，没有了解，可能下个星期就会需要。// todo</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Programing/">Programing</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/dll/">dll</category>
      
      <category domain="https://windgodm.github.io/blog/tags/Programing/">Programing</category>
      
      <category domain="https://windgodm.github.io/blog/tags/cpp/">cpp</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/04/23/CppDllForOthers/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>21虎符CTF-RE-wp</title>
      <link>https://windgodm.github.io/blog/2021/04/15/HufuCtfReWp/</link>
      <guid>https://windgodm.github.io/blog/2021/04/15/HufuCtfReWp/</guid>
      <pubDate>Thu, 15 Apr 2021 14:04:21 GMT</pubDate>
      
      <description>21虎符ctf re部分题解</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="虎符-2021-RE"><a href="#虎符-2021-RE" class="headerlink" title="虎符 2021 RE"></a>虎符 2021 RE</h1><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>mips架构什么的，完全不了解，溜了</p><h2 id="gocrypt"><a href="#gocrypt" class="headerlink" title="gocrypt"></a>gocrypt</h2><p>是个go语言程序</p><p>里面有个encodeing_hex_Decode，作用是string转hex（”b0a0” =&gt; [0xa0, 0xb0]）<br>第7个参数是dest<br>第10个参数是source<br>第11个参数是source的长度</p><p>有个runtime_check会检查格式，推出格式是flag{hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh}</p><p>main_myCipher_Encrypt中有(a+(a&gt;&gt;5)&amp;(16*a))猜出加密方式是xtea</p><p>解密脚本就不贴了，实际上异或的另一边是密钥，利用异或的可逆很快就能推出解密脚本</p><p>在打极客时就有个想法，这种简单的re题核心都是推导加密函数的逆函数，不知道能不能写个逻辑分析程序一把梭。</p><h2 id="CrackMe"><a href="#CrackMe" class="headerlink" title="CrackMe"></a>CrackMe</h2><p>运行什么提示都没，但还是搜字符串试试，rva=2A90，2AB0的两个函数似乎有点重要。</p><p>main里面有两次输入，判定两次。sub_1360这个函数ida似乎识别出了问题，不知道是不是bug。</p><p>第一次输入后有两个循环，会把17个输入分成前7个和后10个</p><p>第二次输入后有几个循环</p><p>第一个循环是在求dx = 0.001，[0,100]，sub_1360(x, (v94/12379) + 1)*dx的积分 a</p><p>然后int(2a+3) == 0x13AFA + 9 == 0x13B03 (sub_13A0中v7044+=9)</p><p>第二个循环同样求和第一个差不多的积分 b，不过第二个参数变成了(v94%12379 + 1)</p><p>然后int(2b+3) == 0x59D + 5 == 0x5A2 (sub_13A0中v7048+=5)</p><p>爆破脚本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> tmp = <span class="built_in">pow</span>(a, b - <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">double</span> ret = tmp / <span class="built_in">exp</span>(a);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> s = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12379</span>; ++i) &#123;</span><br><span class="line">x = <span class="number">0.0</span>;</span><br><span class="line">s = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">s += f(x, (<span class="keyword">double</span>)i) * <span class="number">0.001</span>;</span><br><span class="line">x += + <span class="number">0.001</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (x &lt;= <span class="number">100.0</span>);</span><br><span class="line"><span class="keyword">int</span> ans = (<span class="keyword">int</span>)(s + s + <span class="number">3.0</span>);</span><br><span class="line"><span class="keyword">if</span> (ans == <span class="number">0x5a2</span>) &#123; <span class="comment">// 0x59D + 5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d, v95 = %d\n&quot;</span>, i, i<span class="number">-1</span>); <span class="comment">// i = 7, v95 = 6</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = i - <span class="number">1</span>; ; i += <span class="number">12379</span>) &#123;</span><br><span class="line">x = <span class="number">0.0</span>;</span><br><span class="line">s = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> b = (<span class="keyword">double</span>)((<span class="keyword">int</span>)i / <span class="number">12379</span>) + <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">s += f(x, (<span class="keyword">double</span>)b) * <span class="number">0.001</span>;</span><br><span class="line">x += +<span class="number">0.001</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (x &lt;= <span class="number">100.0</span>);</span><br><span class="line"><span class="keyword">int</span> ans = (<span class="keyword">int</span>)(s + s + <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (ans == <span class="number">0x13B03</span>) &#123; <span class="comment">// 0x13AFA + 9</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;v95 = %d\n&quot;</span>, i); <span class="comment">// v95 = 99038</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后与第一次输入的内容处理后，得到flag</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">8</span>] = <span class="string">&quot;9903819&quot;</span>;</span><br><span class="line"><span class="keyword">short</span> s1[<span class="number">7</span>] = &#123;<span class="number">0x8</span>, <span class="number">0x4d</span>, <span class="number">0x59</span>, <span class="number">0x06</span>, <span class="number">0x73</span>, <span class="number">0x02</span>, <span class="number">0x40</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">c[i] = a[i] ^ s1[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">10</span>] = &#123; <span class="number">0xb2</span>, <span class="number">0xd6</span>, <span class="number">0x8e</span>, <span class="number">0x3f</span>, <span class="number">0xaa</span>, <span class="number">0x14</span>, <span class="number">0x53</span>, <span class="number">0x54</span>, <span class="number">0xc6</span>, <span class="number">0x06</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> key[<span class="number">10</span>] = &#123; <span class="number">0xe0</span>, <span class="number">0x95</span>, <span class="number">0xba</span>, <span class="number">0x60</span>, <span class="number">0xc9</span>, <span class="number">0x66</span>, <span class="number">0x2a</span>, <span class="number">0x24</span>, <span class="number">0xb2</span>, <span class="number">0x36</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">c[i + <span class="number">7</span>] = s2[i] ^ key[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/04/15/HufuCtfReWp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>反射式dll注入源码笔记</title>
      <link>https://windgodm.github.io/blog/2021/04/11/reflectiveDllInjection/</link>
      <guid>https://windgodm.github.io/blog/2021/04/11/reflectiveDllInjection/</guid>
      <pubDate>Sun, 11 Apr 2021 10:31:55 GMT</pubDate>
      
      <description>读msf的反射注入源码学习了下反射注入,&lt;br&gt;学习了下pe结构和windows加载模块的过程，如填写iat、重定位</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="从反射注入学习pe文件加载"><a href="#从反射注入学习pe文件加载" class="headerlink" title="从反射注入学习pe文件加载"></a>从反射注入学习pe文件加载</h1><h2 id="前言？后记与总结"><a href="#前言？后记与总结" class="headerlink" title="前言？后记与总结"></a>前言？后记与总结</h2><p>这是我写完代码后写的总结。重新梳理一下反射注入到底想干什么、以及怎么干。以及从中学到了什么。</p><h3 id="收获？目标？反射注入是什么"><a href="#收获？目标？反射注入是什么" class="headerlink" title="收获？目标？反射注入是什么"></a>收获？目标？反射注入是什么</h3><p>首先是学习反射注入的收获，当然也可以作为学习的目标，同时也是反射注入实际做的东西。</p><p>我的理解是反射注入实际上就是手工加载模块。通过LoadLibrary加载dll会在peb中留下记录，通过手工实现加载过程，我们的dll能像正常dll那样工作，且不再peb中留下痕迹。</p><p>也就是说，通过学习反射注入，可以了解到windows系统加载一个pe文件的流程。其中涉及到了部分的peb以及大量的pe结构。</p><p>我们主要需要peb中的ldr结构，这个结构中保存了该进程已经加载了的dll。</p><p>既然我们的主要工作是手工加载pe文件，自然要对pe文件格式有一定了解。但笔记中不会多提pe文件结构，实际上只要大概了解pe文件格是是个什么，然后在写代码时多去看pe结构的定义，就可以对pe文件结构有一个更深的理解。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>在学习过程中参考了许多资料，最主要的就是msf的反射注入payload的源码。其他如有不懂通过百度也可以找到详细的解释。相关文章比较多，dddd，就不一一列举了。</p><h3 id="关于这篇东西"><a href="#关于这篇东西" class="headerlink" title="关于这篇东西"></a>关于这篇东西</h3><p>这篇东西由我阅读源码，查资料时做的笔记发展而来。国内虽然少但也有一些优秀的反射注入的文章，看雪中也有类似文章，但阅读门槛稍微有点高。因为是由笔记发展而来，这更像是一个零基础初学者的学习笔记（实际上在开始学反射注入之前，只知道pe文件格是是什么东西，几乎完全不了解。对windows的机制也完全不了解），希望能帮助到初学者，这项技术对我学习windows有很大帮助，虽然我只是一个初学者，但这项实践使我之后对书本、资料上的内容有了更深的了解。可能会有错误，希望发现错误的dalao可以帮帮我这个初学者纠正。</p><h3 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h3><p>va、fa、rva这几个概念搞清楚好像就行。实际上就是对pe文件如何从文件映射到内存有一个大体的认识。我们的工作就是具体完成这个过程。可以参考下图。</p><p><img src="https://z3.ax1x.com/2021/04/11/c0exl4.png" alt="pe文件到内存的映射"></p><p>pe文件的格式网上有比较多的图片，这里就不贴了。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(前置条件序号) 序号 流程内容</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">注入器：</span><br><span class="line">============</span><br><span class="line">(0)   1 打开dll文件(CreateFile)，获取dll长度(GetFileSize)</span><br><span class="line">(1)   2 分配内存(HealAlloc)，读取文件(ReadFile)</span><br><span class="line">(0)   3 打开目标进程(OpenProcess)</span><br><span class="line">(2,3) 4 调用反射注入函数(LoadLibraryR.c&gt;LoadRemoteLibraryR)</span><br><span class="line">(2)   5 获取反射加载函数的文件偏移(LoadLibraryR.c&gt;GetReflectiveLoaderOffset)</span><br><span class="line">(2,3) 6 在目标进程中分配空间(VirtualAllocEx)，写入dll(WriteProcessMemory)</span><br><span class="line">(6)   7 修改目标进程中的空间为可执行(VirtualProtectEx)</span><br><span class="line">(5,7) 8 创建远程线程，执行反射加载函数(CreateRemoteThread)</span><br><span class="line"></span><br><span class="line">=======================</span><br><span class="line">反射加载函数（运行在被注入进程的新建线程中）：</span><br><span class="line">=======================</span><br><span class="line">1 获取基地址</span><br><span class="line">2 获取需要的kernel32.dll及ntdll.dll的函数的va</span><br><span class="line">3 分配空间作为映像空间，并复制pe头到新的位置</span><br><span class="line">4 复制所有段到映像的对应位置</span><br><span class="line">5 处理导入表，填写iat</span><br><span class="line">6 重定位</span><br><span class="line">7 跳转到ep（_DllMainCRTStartup）</span><br><span class="line">8 返回entry point地址</span><br></pre></td></tr></table></figure><h2 id="注入器"><a href="#注入器" class="headerlink" title="注入器"></a>注入器</h2><h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><p>首先打开dll文件，获取长度，并在堆中分配空间读取文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hFile = CreateFileW(dllPathname, GENERIC_READ, <span class="number">0</span>, <span class="number">0</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line">dwDllLen = GetFileSize(hFile, <span class="number">0</span>);</span><br><span class="line">lpDll = HeapAlloc(GetProcessHeap(), <span class="number">0</span>, dwDllLen);</span><br></pre></td></tr></table></figure><p>然后找到dll中ReflectiveLoader的入口点。</p><p>最后以RW申请空间，写入dll后改成RX，然后以ReflectiveLoader作为线程函数创建远程线程。</p><h3 id="计算fa"><a href="#计算fa" class="headerlink" title="计算fa"></a>计算fa</h3><p>LoadLibraryR中有个函数Rva2Offset用于获取rva对应的fa。</p><p>原理是遍历区块获取区块的section_rva和section_fa，然后比较rva和section_rva找到rva所在的section，最后计算出fa。再用fa+baseAddr得到内存中的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">Rva2Fa</span><span class="params">(DWORD rva, PIMAGE_SECTION_HEADER sections, <span class="keyword">int</span> sectionNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sectionNum; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sectionVa = sections[i].VirtualAddress;</span><br><span class="line">        <span class="keyword">if</span> ((rva &gt;= sectionVa) &amp;&amp; ((sectionVa + sections[i].SizeOfRawData) &gt; rva))</span><br><span class="line">            <span class="keyword">return</span> rva - (sectionVa - sections[i].PointerToRawData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取ReflectivelLoader位置（输出表）"><a href="#获取ReflectivelLoader位置（输出表）" class="headerlink" title="获取ReflectivelLoader位置（输出表）"></a>获取ReflectivelLoader位置（输出表）</h3><p>通过nt头，计算出sections的fa，以及通过nt头的optionalheader获取输出表的rva。</p><p>然后遍历section找到输出表的fa，接着遍历输出表的函数名字rva表，计算出rva对应fa得到导出函数名字，与需要的导出函数做对比，确定要找的函数在函数名表中的下标。用此下标在序号表中找到序号，最后再用序号去地址表找到地址。</p><h2 id="反射加载函数"><a href="#反射加载函数" class="headerlink" title="反射加载函数"></a>反射加载函数</h2><h3 id="1-获取基址"><a href="#1-获取基址" class="headerlink" title="1. 获取基址"></a>1. 获取基址</h3><p>首先获取代码的位置，然后再往前找dos头。</p><p>_ReturnAddress()返回当前调用函数的返回地址。所以在loader中调用一个函数，该函数再调用_ReturnAddress()，返回调用函数的返回地址，即loader中调用函数的下一条语句的地址。<br>其中 __declspec(noinline) 用于防止编译器优化该函数成内联函数，否则返回的就是loader的返回地址。</p><p>使用_ReturnAddress需要intrin.h，并使用#pragma intrinsic防止内联优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> intrinsic(_ReturnAddress)</span></span><br><span class="line">__declspec(noinline) <span class="function">PVOID <span class="title">NextAddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (PVOID)_ReturnAddress();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据pe格式可知，dos头(IMAGE_DOS_HEADER)中有有一个e_magic标志，值是0x5A4D(MZ)。<br>所以向前遍历内存，直到找到MZ标志，再检查pe头的PE标志，这样就找到dos头了。<br>需要注意的是，检查PE标志时要检查pe头偏移是否正确，防止错误的内存访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dosHeadAddr-&gt;e_magic == <span class="number">0x5A4D</span>) &#123;</span><br><span class="line">        LONG e_lfanew = dosHeadAddr-&gt;e_lfanew;</span><br><span class="line">        <span class="keyword">if</span> (e_lfanew &gt;= <span class="keyword">sizeof</span>(IMAGE_DOS_HEADER) &amp;&amp; e_lfanew &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">            ntHeadAddr = (PIMAGE_NT_HEADERS)((PVOID)dosHeadAddr + (PVOID)e_lfanew);</span><br><span class="line">            <span class="keyword">if</span> (ntHeadAddr-&gt;Signature == <span class="number">0x4550</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dosHeadAddr--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也可以取巧，远程线程是可以传递一个参数的，对于我们这个简单的dll，imagebase实际上就是分配空间的首地址，可以作为参数传入。</p><h3 id="2-获取需要的内核导出函数的va"><a href="#2-获取需要的内核导出函数的va" class="headerlink" title="2. 获取需要的内核导出函数的va"></a>2. 获取需要的内核导出函数的va</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>接下来的步骤中需要用到一些ntdll.dll，kernel32.dll中的导出函数，所以需要先找到这些函数的va。这些系统模块都是已经加载了的，可以在peb中找到其加载的位置。</p><p>这里利用hash避免直接比较字符串。</p><p>我们需要LoadLibraryA、GetProcAddress加载导入表中的dll的对应的函数。</p><p>需要VirtualAlloc分配内存给我们把pe文件加载到其中。</p><p>需要NtFlushInstructionCache刷新指令缓存。</p><h4 id="LDR-DATA-TABLE-ENTRY"><a href="#LDR-DATA-TABLE-ENTRY" class="headerlink" title="LDR_DATA_TABLE_ENTRY"></a>LDR_DATA_TABLE_ENTRY</h4><p>InMemoryOrderModuleList对应的链表是一个环形双向链表，且有一个头节点（或者说哨兵节点）。InMemoryOrderModuleList的Flink指向链表的第一个节点，Blink指向链表最后一个节点。头节点的Flink是第一个节点，可以以此为跳出条件遍历该链表。</p><p><img src="https://z3.ax1x.com/2021/04/11/c0mZ1e.jpg" alt="ldr链"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先从peb中找到ldr，然后遍历InMemoryOrderModuleList，通过hash(BaseName)找到kernel32.dll和ntdll.dll对应的LDR_DATA_TABLE_ENTRY结构。</p><p>找到dll对应的LDR_DATA_TABLE_ENTRY后，获取其imagebase，然后解析pe头，计算出导出表位置。同样利用hash比较字符串找到所需的导出函数，并计算出va。</p><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找pLdrDataTableEnrty</span></span><br><span class="line">DWORD pPeb = __readfsdword(<span class="number">0x30</span>);</span><br><span class="line">DWORD pLdr = *(DWORD*)(pPeb + <span class="number">0xc</span>);</span><br><span class="line">DWORD pInMemoryOrderModuleList = pLdr + <span class="number">0x14</span>; <span class="comment">// 第一个节点的二级指针</span></span><br><span class="line">DWORD pLdrDataTableEnrty = *(DWORD*)(pInMemoryOrderModuleList + <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 遍历LdrDataTableEnrty</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">WCHAR* name = (WCHAR*)*(DWORD*)(pLdrDataTableEnrty + <span class="number">0x24</span> + <span class="number">0x4</span>);</span><br><span class="line">hash = YourHashFun(name); <span class="comment">// 使用你自己的函数计算hash值</span></span><br><span class="line"><span class="keyword">if</span>(hash == DLLHASH) &#123; <span class="comment">// DLLHASH由你自己的函数计算得出</span></span><br><span class="line">DWORD baseAddr = *(DWORD*)(pLdrDataTableEnrty + <span class="number">0x10</span>);</span><br><span class="line"><span class="comment">// 解析pe头过程省略</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; funcNum; i++) &#123; <span class="comment">// funcNum是导出函数的个数</span></span><br><span class="line"><span class="keyword">char</span>* name = (<span class="keyword">char</span>*)(baseAddr + ((DWORD*)nameRvas)[i]);</span><br><span class="line">DWORD hash = YourHashFun(name);</span><br><span class="line"><span class="keyword">if</span> (hash == FUNCHASH) &#123;</span><br><span class="line">pFunc = (FUNC)(baseAddr + ((DWORD*)funcRvas)[((WORD*)ordRvas)[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(*(DWORD*)(pLdrDataTableEnrty) != *(DWORD*)(pInMemoryOrderModuleList))</span><br></pre></td></tr></table></figure><h3 id="3-给映像分配空间，并加载pe头"><a href="#3-给映像分配空间，并加载pe头" class="headerlink" title="3. 给映像分配空间，并加载pe头"></a>3. 给映像分配空间，并加载pe头</h3><p>新分配大小等于sizeOfImga的内存作为映像加载的空间，然后把pe头复制到新内存里，这里我只更新了新nt头的imagebase地址。太简单就不贴代码了。</p><h3 id="4-加载段"><a href="#4-加载段" class="headerlink" title="4. 加载段"></a>4. 加载段</h3><p>遍历section_header获取fa和rva，计算出section在旧内存中的va和新内存中的va。然后复制section到新内存中的对应位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldVA = oldImageBase + sections[i].PointerToRawData;</span><br><span class="line">newVA = newImageBase + sections[i].VirtualAddress; </span><br></pre></td></tr></table></figure><h3 id="5-处理导入表"><a href="#5-处理导入表" class="headerlink" title="5. 处理导入表"></a>5. 处理导入表</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><p>找到导入表，然后遍历导入表，依次加载对应的dll，及需要的dll的导出函数，并填写对应iat。</p><h4 id="导入表结构"><a href="#导入表结构" class="headerlink" title="导入表结构"></a>导入表结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// winnt.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD ForwarderString;      <span class="comment">// PBYTE </span></span><br><span class="line">        DWORD Function;             <span class="comment">// PDWORD</span></span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        <span class="comment">// PIMAGE_IMPORT_BY_NAME (补充一下，这是个rva)</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;</span><br><span class="line">    CHAR   Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p>和导出表不同，导入表是一个结构体数组。它不提供结构体数量，最后一个结构体仅作为结束标志，不包含导入信息，其成员Characteristics为0，这可以作为遍历的退出条件。</p><p>对于每个导入表，在文件中时OriginalFirstThunk和FirstThunk都是RVA，指向同一个IMAGE_THUNK_DATA结构体数组。<br>当加载到内存时，FirstThunk改为函数的VA，即iat。</p><p>文件中时，OriginalFirstThunk和FirstThunk指向的结构体数组中，每一个IMAGE_THUNK_DATA的成员u1都被解释为Ordinal，若该函数应该通过序号导入，则Ordinal的最高位会被置为1。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>见实现代码注释。</p><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pNewDosHeader + pNewNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; pImportDescriptor-&gt;Characteristics; pImportDes++) &#123;</span><br><span class="line">    <span class="comment">// 加载dll</span></span><br><span class="line">    HMODULE libraryAddress = pLoadLibraryA((LPCSTR)((DWORD)pNewDosHeader + pImportDes-&gt;Name));</span><br><span class="line">    <span class="keyword">if</span> (!libraryAddress)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// parsing pe structure</span></span><br><span class="line">    PIMAGE_THUNK_DATA32 pOriginalThunk = (PIMAGE_THUNK_DATA32)((DWORD)pNewDosHeader + pImportDes-&gt;OriginalFirstThunk);</span><br><span class="line">    PIMAGE_THUNK_DATA32 pThunk = (PIMAGE_THUNK_DATA32)((DWORD)pNewDosHeader + pImportDes-&gt;FirstThunk);</span><br><span class="line">    PIMAGE_NT_HEADERS32 pLibNtHeader = (PIMAGE_NT_HEADERS32)((DWORD)libraryAddress + ((PIMAGE_DOS_HEADER)libraryAddress)-&gt;e_lfanew);</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)((DWORD)libraryAddress + pLibNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">    PDWORD funcRvas = (PDWORD)((DWORD)libraryAddress + pExportDir-&gt;AddressOfFunctions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*(DWORD*)pThunk) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pOriginalThunk &amp;&amp; pOriginalThunk-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG) &#123;</span><br><span class="line">            <span class="comment">// import by ord</span></span><br><span class="line">            WORD ord = pOriginalThunk-&gt;u1.Ordinal - pExportDir-&gt;Base;</span><br><span class="line">            *(DWORD*)pThunk = ((DWORD)libraryAddress + funcRvas[ord]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// import by name (this is a rva)</span></span><br><span class="line">            *(DWORD*)pThunk = (DWORD)pGetProcAddress(libraryAddress, ((PIMAGE_IMPORT_BY_NAME)((DWORD)pNewDosHeader + pThunk-&gt;u1.AddressOfData))-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pThunk++;</span><br><span class="line">        <span class="keyword">if</span> (pOriginalThunk)</span><br><span class="line">            pOriginalThunk++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-重定位"><a href="#6-重定位" class="headerlink" title="6. 重定位"></a>6. 重定位</h3><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><p>完成重定位过程。</p><h4 id="重定位表结构"><a href="#重定位表结构" class="headerlink" title="重定位表结构"></a>重定位表结构</h4><p>重定位表是一个结构体数组，DataDirectory中的重定位表项保存着第一个重定位表的rva，遍历每一个重定位表，并遍历重定位表中的表项，根据其重定位类型，执行重定位操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    WORD offset : <span class="number">12</span>;</span><br><span class="line">    WORD type : <span class="number">4</span>;</span><br><span class="line">&#125; RELOC;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">DWORD VA;</span><br><span class="line">DWORD size;</span><br><span class="line"><span class="comment">// RELOC reloc[];</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><p>其中每一个重定位表保存着一个rva，重定位实际上就是遍历IMAGE_BASE_RELOCATION的成员reloc，然后执行<code>*(rva+baseAddr+reloc[i].offset) += baseAddr - ImageBase</code>。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>两层循环，遍历重定位表，再遍历每个表的 RELOC reloc[]。然后根据重定位类型进行重定位。</p><h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析pe，并计算offset</span></span><br><span class="line">PIMAGE_DATA_DIRECTORY pDDBaseReloc = &amp;pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];</span><br><span class="line">PIMAGE_BASE_RELOCATION pBaseRelocation;</span><br><span class="line">ULONG_PTR offset = (ULONG_PTR)pNewDosHeader - (ULONG_PTR)pNtHeaders-&gt;OptionalHeader.ImageBase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pDDBaseReloc-&gt;Size) &#123;</span><br><span class="line">    DWORD size = pDDBaseReloc-&gt;Size;</span><br><span class="line">    pBaseRelocation = (PIMAGE_BASE_RELOCATION)((DWORD)pNewDosHeader + pDDBaseReloc-&gt;VirtualAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历重定位表结构体</span></span><br><span class="line">    <span class="keyword">while</span> (size &amp;&amp; pBaseRelocation-&gt;SizeOfBlock) &#123;</span><br><span class="line"></span><br><span class="line">        DWORD va = (DWORD)pNewDosHeader + pBaseRelocation-&gt;VirtualAddress;</span><br><span class="line">        DWORD num = (pBaseRelocation-&gt;SizeOfBlock - <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="keyword">sizeof</span>(IMAGE_RELOC); <span class="comment">// 计算reloc[]大小</span></span><br><span class="line">        PIMAGE_RELOC reloc = (PIMAGE_RELOC)((DWORD)pBaseRelocation + <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历reloc[]，根据重定位类型重定位</span></span><br><span class="line">        <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">            DWORD type = reloc-&gt;type;</span><br><span class="line">            <span class="keyword">if</span> (type == IMAGE_REL_BASED_HIGH) &#123;</span><br><span class="line">                *(WORD*)(va + reloc-&gt;offset) += HIWORD(offset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (type == IMAGE_REL_BASED_LOW) &#123;</span><br><span class="line">                *(WORD*)(va + reloc-&gt;offset) += LOWORD(offset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (type == IMAGE_REL_BASED_HIGHLOW) &#123;</span><br><span class="line">                *(DWORD*)(va + reloc-&gt;offset) += (DWORD)offset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            reloc++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size -= pBaseRelocation-&gt;SizeOfBlock;</span><br><span class="line">        pBaseRelocation = (PIMAGE_BASE_RELOCATION)((DWORD)pBaseRelocation + pBaseRelocation-&gt;SizeOfBlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-跳转到ep"><a href="#7-跳转到ep" class="headerlink" title="7. 跳转到ep"></a>7. 跳转到ep</h3><p>跳转到dll的ep。实际上就是执行dll原本的_DllMainCRTStartup函数。该函数会完成一些初始化工作并转到dllMain，让我们的dllMain像正常dllmain那样运行，但又不在peb中留下dll加载的痕迹。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* DLLMAIN)</span><span class="params">(HINSTANCE, DWORD, LPVOID)</span></span>;</span><br><span class="line"></span><br><span class="line">PVOID entryPoint = (PVOID)((DWORD)pNewDosHeader + pNewNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line"></span><br><span class="line">pNtFlushInstructionCache((HANDLE)<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">((DLLMAIN)entryPoint)((HMODULE)pNewDosHeader, DLL_PROCESS_ATTACH, lpParameter);</span><br></pre></td></tr></table></figure><h3 id="8-返回"><a href="#8-返回" class="headerlink" title="8. 返回"></a>8. 返回</h3><p>最后返回entrypoint。</p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p>本文看雪链接：<a href="https://bbs.pediy.com/thread-266929.htm">https://bbs.pediy.com/thread-266929.htm</a></p><p>msf反射注入源码：<a href="https://github.com/rapid7/ReflectiveDLLInjection">https://github.com/rapid7/ReflectiveDLLInjection</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/dll/">dll</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/04/11/reflectiveDllInjection/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>hgame21</title>
      <link>https://windgodm.github.io/blog/2021/03/17/hgame21/</link>
      <guid>https://windgodm.github.io/blog/2021/03/17/hgame21/</guid>
      <pubDate>Wed, 17 Mar 2021 12:51:25 GMT</pubDate>
      
      <description>2021hgame wp</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="web-week1"><a href="#web-week1" class="headerlink" title="web week1"></a>web week1</h1><h2 id="智商检测鸡（150）"><a href="#智商检测鸡（150）" class="headerlink" title="智商检测鸡（150）"></a>智商检测鸡（150）</h2><p>我用的python requests+beautifulsoup。</p><p>这题是通过cookie当作账号，做出一题就会给出下一个cookie。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">getQ = <span class="string">&#x27;http://r4u.top:5000/api/getQuestion&#x27;</span></span><br><span class="line">getS = <span class="string">&#x27;http://r4u.top:5000/api/getStatus&#x27;</span></span><br><span class="line">submit = <span class="string">&#x27;http://r4u.top:5000/api/verify&#x27;</span></span><br><span class="line">getF = <span class="string">&#x27;http://r4u.top:5000/api/getFlag&#x27;</span></span><br><span class="line"></span><br><span class="line">res = requests.get(url=getQ)</span><br><span class="line">header = &#123;<span class="string">&#x27;Cookie&#x27;</span>: res.headers[<span class="string">&#x27;Set-Cookie&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> c/<span class="number">2</span>*x*x + d*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># 获取</span></span><br><span class="line">    res = requests.get(url=getQ, headers=header)</span><br><span class="line">    bs = BeautifulSoup(res.text, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    a = <span class="built_in">int</span>(bs.msubsup.contents[<span class="number">1</span>].mn.text)</span><br><span class="line">    <span class="keyword">if</span>(bs.msubsup.contents[<span class="number">1</span>].mo != <span class="literal">None</span>):</span><br><span class="line">        <span class="keyword">if</span>(bs.msubsup.contents[<span class="number">1</span>].mo.text == <span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">            a = -a</span><br><span class="line">    b = <span class="built_in">int</span>(bs.msubsup.contents[<span class="number">2</span>].mn.text)</span><br><span class="line">    <span class="keyword">if</span>(bs.msubsup.contents[<span class="number">2</span>].mo != <span class="literal">None</span>):</span><br><span class="line">        <span class="keyword">if</span>(bs.msubsup.contents[<span class="number">2</span>].mo.text == <span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">            b = -b</span><br><span class="line">    c = <span class="built_in">int</span>(bs.mrow.contents[<span class="number">2</span>].text)</span><br><span class="line">    d = <span class="built_in">int</span>(bs.mrow.contents[<span class="number">5</span>].text)</span><br><span class="line">    <span class="comment"># 计算</span></span><br><span class="line">    ans = <span class="built_in">round</span>(f(b)-f(a), <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 返回</span></span><br><span class="line">    res2 = requests.post(url=submit, headers=header, json=&#123;<span class="string">&#x27;answer&#x27;</span>:ans&#125;)</span><br><span class="line">    print(res2.headers[<span class="string">&#x27;Set-Cookie&#x27;</span>])</span><br><span class="line">    header = &#123;<span class="string">&#x27;Cookie&#x27;</span>: res2.headers[<span class="string">&#x27;Set-Cookie&#x27;</span>]&#125;</span><br><span class="line">    <span class="comment"># 检查</span></span><br><span class="line">    res = requests.get(url=getS, headers=header)</span><br><span class="line">    print(res.text)</span><br><span class="line"></span><br><span class="line">res = requests.get(url=getF, headers=header)</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure><h1 id="misc-week1"><a href="#misc-week1" class="headerlink" title="misc week1"></a>misc week1</h1><h2 id="Base全家福（50）"><a href="#Base全家福（50）" class="headerlink" title="Base全家福（50）"></a>Base全家福（50）</h2><p>base64+base32+base16</p><h1 id="pwn-week1"><a href="#pwn-week1" class="headerlink" title="pwn week1"></a>pwn week1</h1><h2 id="whitegive（50）"><a href="#whitegive（50）" class="headerlink" title="whitegive（50）"></a>whitegive（50）</h2><p>if(num == “paSsw0rd”)</p><p>ida中找到if语句中的字符串地址即可。</p><h1 id="re-week1"><a href="#re-week1" class="headerlink" title="re week1"></a>re week1</h1><h2 id="apacha（150）"><a href="#apacha（150）" class="headerlink" title="apacha（150）"></a>apacha（150）</h2><p>一个比较复杂的推理。需要注意的是，变量要用unsigned int。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> new_a1[<span class="number">35</span>] = &#123;&#125;; <span class="comment">// dump</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">6</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l, r;</span><br><span class="line"></span><br><span class="line">    v6 = v6s[i];</span><br><span class="line">    v7 = v6 &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个</span></span><br><span class="line">    v5 = new_a1[a2 - <span class="number">2</span>];</span><br><span class="line">    result = (v5 * <span class="number">16</span>) ^ (new_a1[<span class="number">0</span>] &gt;&gt; <span class="number">3</span>);</span><br><span class="line">    l = (a3[((a2 - <span class="number">1</span>) ^ (<span class="keyword">unsigned</span> __int8)v7) &amp; <span class="number">3</span>] ^ v5) + (new_a1[<span class="number">0</span>] ^ v6);</span><br><span class="line">    r = ((<span class="number">4</span> * new_a1[<span class="number">0</span>]) ^ (v5 &gt;&gt; <span class="number">5</span>)) + result;</span><br><span class="line">    old_a1[a2 - <span class="number">1</span>] = new_a1[a2 - <span class="number">1</span>] - (l ^ r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = a2 - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// j = v8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            v5 = new_a1[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v5 = old_a1[a2 - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l = ((v5 &gt;&gt; <span class="number">5</span>) ^ (<span class="number">4</span> * old_a1[j + <span class="number">1</span>])) + ((<span class="number">16</span> * v5) ^ (old_a1[j + <span class="number">1</span>] &gt;&gt; <span class="number">3</span>));</span><br><span class="line">        r = (a3[(((<span class="keyword">unsigned</span> __int8)j ^ (<span class="keyword">unsigned</span> __int8)v7) &amp; <span class="number">3</span>)] ^ v5) + ((old_a1[j + <span class="number">1</span>]) ^ (v6));</span><br><span class="line">        f = l ^ r;</span><br><span class="line">        old_a1[j] = new_a1[j] - f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">35</span>; j++)</span><br><span class="line">        new_a1[j] = old_a1[j];</span><br></pre></td></tr></table></figure><h2 id="hellowRe（150）"><a href="#hellowRe（150）" class="headerlink" title="hellowRe（150）"></a>hellowRe（150）</h2><p>一个异或。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0x97</span>, <span class="number">0x99</span>, <span class="number">0x9C</span>, <span class="number">0x91</span>, <span class="number">0x9E</span>, <span class="number">0x81</span>, <span class="number">0x91</span>, <span class="number">0x9D</span>, <span class="number">0x9B</span>, <span class="number">0x9A</span>, <span class="number">0x9A</span>,<span class="number">0xAB</span>, <span class="number">0x81</span>, <span class="number">0x97</span>, <span class="number">0x0AE</span>, <span class="number">0x80</span>, <span class="number">0x83</span>, <span class="number">0x8F</span>, <span class="number">0x94</span>, <span class="number">0x89</span>, <span class="number">0x99</span>,<span class="number">0x97</span>, <span class="number">0x0</span>, <span class="number">0x0</span>]</span><br><span class="line"></span><br><span class="line">b = <span class="number">0xff</span></span><br><span class="line">c = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">    c.append(a[i] ^ b)</span><br><span class="line">    b -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="pypy（150）"><a href="#pypy（150）" class="headerlink" title="pypy（150）"></a>pypy（150）</h2><p>python字节码转python代码。一个交换和异或。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">flag = <span class="number">0x30466633346f59213b4139794520572b45514d61583151576638643a</span></span><br><span class="line">cipher = long_to_bytes(flag)</span><br><span class="line">length = <span class="built_in">len</span>(cipher)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    cipher = <span class="built_in">list</span>(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length//<span class="number">2</span>):</span><br><span class="line">        cipher[i*<span class="number">2</span>], cipher[<span class="number">2</span>*i+<span class="number">1</span>] = cipher[i*<span class="number">2</span>+<span class="number">1</span>], cipher[<span class="number">2</span>*i]</span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        res.append(cipher[i] ^ i)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">re</span>(<span class="params">cipher</span>):</span></span><br><span class="line">    res = <span class="built_in">list</span>(cipher)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        res[i] ^= i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length//<span class="number">2</span>):</span><br><span class="line">        res[i*<span class="number">2</span>], res[<span class="number">2</span>*i+<span class="number">1</span>] = res[i*<span class="number">2</span>+<span class="number">1</span>], res[<span class="number">2</span>*i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(res)</span><br><span class="line"></span><br><span class="line">print(re(flag))</span><br></pre></td></tr></table></figure><h1 id="re-week2"><a href="#re-week2" class="headerlink" title="re week2"></a>re week2</h1><h2 id="ezApk"><a href="#ezApk" class="headerlink" title="ezApk"></a>ezApk</h2><p>找到位置后，看不太懂，是aes cbc加密。</p><h2 id="helloRe2"><a href="#helloRe2" class="headerlink" title="helloRe2"></a>helloRe2</h2><h3 id="sse2指令"><a href="#sse2指令" class="headerlink" title="sse2指令"></a>sse2指令</h3><p>sse2指令集是个扩展指令集。cpp中需要include &lt;emmintrin.h&gt;。</p><p>_mm_load_si128：加载128bits值，vs中试了以下相当于把字符串直接转数字。</p><p>_mm_cmpeq_epi8：判断是否相等</p><p>_mm_movemask_epi8：没查</p><h3 id="flag1"><a href="#flag1" class="headerlink" title="flag1"></a>flag1</h3><p>cmp(load(flag1), flag)</p><p>ida中flag = 0x981b02a3a6e5c0b2</p><p>所以flag1(input)是”2b0c5e6a3a20b189”</p><h3 id="flag2"><a href="#flag2" class="headerlink" title="flag2"></a>flag2</h3><p>flag1正确后会异或一次然后重启程序，接着进入输入flag2的分支。</p><p>BCrypt解密没看懂。后面补了AES的CBC和ECB才看懂。</p><h3 id="复现主函数及BCrypt-h的使用"><a href="#复现主函数及BCrypt-h的使用" class="headerlink" title="复现主函数及BCrypt.h的使用"></a>复现主函数及BCrypt.h的使用</h3><p>要先include windows.h再include BCrypt.h</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/seccng/cng-algorithm-identifiers">https://docs.microsoft.com/en-us/windows/win32/seccng/cng-algorithm-identifiers</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">BCryptGenerateSymmetricKey</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  BCRYPT_ALG_HANDLE hAlgorithm,  <span class="comment">// handle of algorithm</span></span></span></span><br><span class="line"><span class="function"><span class="params">  BCRYPT_KEY_HANDLE *phKey,      <span class="comment">// recive handle of key</span></span></span></span><br><span class="line"><span class="function"><span class="params">  PUCHAR            pbKeyObject, <span class="comment">// recive key object</span></span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG             cbKeyObject, <span class="comment">// sizeof(pbKeyObject)</span></span></span></span><br><span class="line"><span class="function"><span class="params">  PUCHAR            pbSecret,    <span class="comment">// pt a key witch to creat key</span></span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG             cbSecret,    <span class="comment">// sizeof(pbSecret)</span></span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG             dwFlags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>找到关键的参数如下。c实际上有32位，这里只得到16位，上网找脚本破解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">0x32</span>, <span class="number">0x63</span>, <span class="number">0x32</span>, <span class="number">0x60</span>, <span class="number">0x31</span>, <span class="number">0x60</span>, <span class="number">0x30</span>, <span class="number">0x66</span>, <span class="number">0x3b</span>, <span class="number">0x68</span>, <span class="number">0x38</span>, <span class="number">0x3b</span>, <span class="number">0x6e</span>, <span class="number">0x3c</span>, <span class="number">0x36</span>, <span class="number">0x36</span>]</span><br><span class="line"><span class="comment"># 32633260316030663b68383b6e3c3636</span></span><br><span class="line">iv = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0xa</span>, <span class="number">0xb</span>, <span class="number">0xc</span>, <span class="number">0xd</span> ,<span class="number">0xe</span> ,<span class="number">0xf</span>]</span><br><span class="line"><span class="comment"># 000102030405060708090a0b0c0d0e0f</span></span><br><span class="line">c = [<span class="number">0xB7</span>, <span class="number">0xFE</span>, <span class="number">0xFE</span>, <span class="number">0xD9</span>, <span class="number">7</span>, <span class="number">0x76</span>, <span class="number">0x79</span>, <span class="number">0x65</span>, <span class="number">0x3F</span>, <span class="number">0x4E</span>, <span class="number">0x5F</span>, <span class="number">0x62</span>, <span class="number">0xD5</span>, <span class="number">2</span>, <span class="number">0xF6</span>, <span class="number">0x7E</span>]</span><br><span class="line"><span class="comment"># b7fefed9077679653f4e5f62d502f67e</span></span><br><span class="line">m = <span class="string">&#x27;7a4ad6c5671fb313&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;hgame&#123;2b0c5e6a3a20b189</span></span><br><span class="line"><span class="string">_7a4ad6c5671fb313&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>复现了一下他的代码。这里解密失败了，不知道是什么原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">BCRYPT_HANDLE name;</span><br><span class="line">DWORD objLen = <span class="number">0</span>, blockLength = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> btw = <span class="number">0</span>, nts = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> mode[<span class="number">16</span>] = <span class="string">L&quot;ChainingModeCBC&quot;</span>;</span><br><span class="line">BCRYPT_KEY_HANDLE hKey;</span><br><span class="line">UCHAR pKey[<span class="number">618</span>] = &#123; <span class="number">0</span> &#125;, pbSecret[<span class="number">16</span>] = &#123; <span class="number">0x32</span>, <span class="number">0x63</span>, <span class="number">0x32</span>, <span class="number">0x60</span>, <span class="number">0x31</span>, <span class="number">0x60</span>, <span class="number">0x30</span>, <span class="number">0x66</span>, <span class="number">0x3b</span>, <span class="number">0x68</span>, <span class="number">0x38</span>, <span class="number">0x3b</span>, <span class="number">0x6e</span>, <span class="number">0x3c</span>, <span class="number">0x36</span>, <span class="number">0x36</span> &#125;, pKeyBLOB[<span class="number">560</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">UCHAR pIV[<span class="number">16</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0xa</span>, <span class="number">0xb</span>, <span class="number">0xc</span>, <span class="number">0xd</span>, <span class="number">0xe</span>, <span class="number">0xf</span> &#125;;</span><br><span class="line"></span><br><span class="line">name = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__try &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    nts = BCryptOpenAlgorithmProvider(&amp;name, <span class="string">L&quot;AES&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((nts &lt; <span class="number">0</span>) || name == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; nts &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        __leave;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取属性值</span></span><br><span class="line">    nts = BCryptGetProperty(name, <span class="string">L&quot;ObjectLength&quot;</span>, (PUCHAR)&amp;objLen, <span class="number">4</span>, &amp;btw, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ObjectLength(&quot;</span> &lt;&lt; btw &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; objLen &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 618</span></span><br><span class="line"></span><br><span class="line">    nts = BCryptGetProperty(name, <span class="string">L&quot;BlockLength&quot;</span>, (PUCHAR)&amp;blockLength, <span class="number">4</span>, &amp;btw, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BlockLength(&quot;</span> &lt;&lt; btw &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; blockLength &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (blockLength &lt;= <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置模式为CBC</span></span><br><span class="line">        nts = BCryptSetProperty(name, <span class="string">L&quot;ChainingMode&quot;</span>, (PUCHAR)mode, <span class="number">0x20</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成密钥对象</span></span><br><span class="line">        nts = BCryptGenerateSymmetricKey(name, &amp;hKey, pKey, objLen, pbSecret, <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取key BLOB长度</span></span><br><span class="line">        /nts = BCryptExportKey(hKey, <span class="number">0</span>, <span class="string">L&quot;OpaqueKeyBlob&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;btw, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;keyBLOBLen: &quot;</span> &lt;&lt; btw &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 560</span></span><br><span class="line">        <span class="comment">// 接收key BLOB</span></span><br><span class="line">        nts = BCryptExportKey(hKey, <span class="number">0</span>, <span class="string">L&quot;OpaqueKeyBlob&quot;</span>, pKeyBLOB, <span class="number">560</span>, &amp;btw, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取密文长度</span></span><br><span class="line">        nts = BCryptEncrypt(hKey, inputs, <span class="number">16</span>, <span class="number">0</span>, pIV, <span class="number">16</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;btw, BCRYPT_BLOCK_PADDING);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ciphertextLen: &quot;</span> &lt;&lt; btw &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 32</span></span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        nts = BCryptEncrypt(hKey, inputs, <span class="number">16</span>, <span class="number">0</span>, pIV, <span class="number">16</span>, c, <span class="number">32</span>, &amp;btw, BCRYPT_BLOCK_PADDING);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        nts = BCryptDecrypt(hKey, c, <span class="number">32</span>, <span class="number">0</span>, pIV, <span class="number">16</span>, m, <span class="number">16</span>, &amp;btw, BCRYPT_BLOCK_PADDING);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; btw &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">__finally &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/pwn/">pwn</category>
      
      <category domain="https://windgodm.github.io/blog/tags/misc/">misc</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      <category domain="https://windgodm.github.io/blog/tags/web/">web</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/03/17/hgame21/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>vnctf21ReWp</title>
      <link>https://windgodm.github.io/blog/2021/03/17/vnctf21ReWp/</link>
      <guid>https://windgodm.github.io/blog/2021/03/17/vnctf21ReWp/</guid>
      <pubDate>Wed, 17 Mar 2021 11:03:13 GMT</pubDate>
      
      <description>vnctf2021 re部分题解（没有安卓那两题）</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="notsudoku"><a href="#notsudoku" class="headerlink" title="notsudoku"></a>notsudoku</h1><p>这题是python打包的exe</p><p>首先用pyinstxtractor解包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.\pyinstxtractor.py:86: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module&#x27;s documentation for alternative uses</span><br><span class="line">  import imp</span><br><span class="line">[*] Processing .\notsudoku.exe</span><br><span class="line">[*] Pyinstaller version: 2.1+</span><br><span class="line">[*] Python version: 37</span><br><span class="line">[*] Length of package: 5560832 bytes</span><br><span class="line">[*] Found 60 files in CArchive</span><br><span class="line">[*] Beginning extraction...please standby</span><br><span class="line">[+] Possible entry point: pyiboot01_bootstrap</span><br><span class="line">[+] Possible entry point: 2</span><br><span class="line">[*] Found 133 files in PYZ archive</span><br><span class="line">[*] Successfully extracted pyinstaller archive: .\notsudoku.exe</span><br><span class="line"></span><br><span class="line">You can now use a python decompiler on the pyc files within the extracted directory</span><br></pre></td></tr></table></figure><p>得到主要代码在文件 2 ，把这个文件改名为2.pyc，并复制struct文件的E3前面的内容，然后粘贴到2.pyc的E3前面。接着用uncompyle6反编译成py文件。</p><p>最后改一下变量名，得到的是要解一个五阶幻方。本来有多组解，因为有个校验所以只有唯一解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, sys, hashlib</span><br><span class="line"></span><br><span class="line">num = <span class="number">65</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 124 126</span></span><br><span class="line">print(<span class="string">&#x27;welcome baby~ input your flag~:&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 128</span></span><br><span class="line">str1 = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 130 132</span></span><br><span class="line">print(<span class="string">&#x27;your input is:&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">print(str1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 134</span></span><br><span class="line">print(<span class="string">&quot;let&#x27;s check......&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 136</span></span><br><span class="line">time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 138 ~ 146</span></span><br><span class="line">list2 = []</span><br><span class="line">list2 += [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]]</span><br><span class="line">list2 += [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]]</span><br><span class="line">list2 += [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]]</span><br><span class="line">list2 += [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]]</span><br><span class="line">list2 += [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 148</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(str1) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(i) &gt; <span class="number">52</span> <span class="keyword">or</span> <span class="built_in">ord</span>(i) &lt; <span class="number">48</span>: <span class="comment"># [0, 4]</span></span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">str</span>(hashlib.new(<span class="string">&#x27;md5&#x27;</span>, <span class="built_in">bytes</span>((str1), encoding=<span class="string">&#x27;utf8&#x27;</span>)).hexdigest())</span><br><span class="line"><span class="keyword">if</span> x[:<span class="number">6</span>] != <span class="string">&#x27;e3a912&#x27;</span>:</span><br><span class="line">    sys.exit()</span><br><span class="line">flag = x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 150</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">b = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(str1), <span class="number">2</span>):</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    a = <span class="built_in">int</span>(str1[i])</span><br><span class="line">    b = <span class="built_in">int</span>(str1[(i + <span class="number">1</span>)])</span><br><span class="line">    list2[a][b] = j</span><br><span class="line"></span><br><span class="line"><span class="comment"># 152</span></span><br><span class="line"><span class="keyword">if</span> list2[<span class="number">0</span>][<span class="number">1</span>] != <span class="number">24</span> <span class="keyword">or</span> list2[<span class="number">4</span>][<span class="number">3</span>] != <span class="number">2</span>:</span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">if</span> list2[<span class="number">0</span>][<span class="number">2</span>] != <span class="number">1</span> <span class="keyword">or</span> list2[<span class="number">2</span>][<span class="number">3</span>] != <span class="number">20</span>:</span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">if</span> list2[<span class="number">1</span>][<span class="number">0</span>] != <span class="number">23</span> <span class="keyword">or</span> list2[<span class="number">3</span>][<span class="number">4</span>] != <span class="number">3</span>:</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 154 ~ 162</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">    tnum = <span class="number">0</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        tnum += cla.list2[a][i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tnum != num:</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 164 ~ 172</span></span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">    tnum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        tnum += list2[i][b]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tnum != num:</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 174 ~ 180</span></span><br><span class="line">print(<span class="string">&#x27;Goodjob!&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;The flag is vnctf&#123;&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">print(flag, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;&#125;&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#182</span></span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure><h1 id="FlipGame"><a href="#FlipGame" class="headerlink" title="FlipGame"></a>FlipGame</h1><p>ida中看到主函数中，有一个16x16的位数组，先是把16进制转10进制，然后翻转上下左右中间。</p><p>解法是暴力搜索第一行的情况，接着对于第i+1行，如果第i行对应位置为0，就在第i+1行的那一位执行翻转操作。这样就能得到解。</p><p>代码的话搜索poj 3279即可，是个noip题目。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/03/17/vnctf21ReWp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>远程线程注入逆向</title>
      <link>https://windgodm.github.io/blog/2021/03/16/dllRemoteInject/</link>
      <guid>https://windgodm.github.io/blog/2021/03/16/dllRemoteInject/</guid>
      <pubDate>Tue, 16 Mar 2021 09:08:49 GMT</pubDate>
      
      <description>对远程线程注入（CreateRemoteThread）所用到的函数做了一下逆向研究,&lt;br&gt;用native api实现了远程注入</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="远程线程注入逆向"><a href="#远程线程注入逆向" class="headerlink" title="远程线程注入逆向"></a>远程线程注入逆向</h1><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><h3 id="MSDN中的函数定义"><a href="#MSDN中的函数定义" class="headerlink" title="MSDN中的函数定义"></a>MSDN中的函数定义</h3><h4 id="OpenProcess-processthreadsapi-h"><a href="#OpenProcess-processthreadsapi-h" class="headerlink" title="OpenProcess (processthreadsapi.h)"></a>OpenProcess (processthreadsapi.h)</h4><blockquote><h4 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h4><p>HANDLE OpenProcess (<br>    DWORD dwDesiredAccess,<br>    BOOL bInheritHandle,<br>    DWORD dwProcessId);</p><h4 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h4><p>DLL：Kernel32.dll</p></blockquote><h4 id="NtOpenProcess-ntddk-h"><a href="#NtOpenProcess-ntddk-h" class="headerlink" title="NtOpenProcess (ntddk.h)"></a>NtOpenProcess (ntddk.h)</h4><blockquote><h4 id="Syntax-1"><a href="#Syntax-1" class="headerlink" title="Syntax"></a>Syntax</h4><p>__kernel_entry NTSYSCALLAPI NTSTATUS NtOpenProcess (<br>   PHANDLE ProcessHandle,<br>   ACCESS_MASK DesiredAccess,<br>   POBJECT_ATTRIBUTES ObjectAttributes,<br>   PCLIENT_ID ClientId);</p><h4 id="Requirements-1"><a href="#Requirements-1" class="headerlink" title="Requirements"></a>Requirements</h4><p>Header：ntddk.h (include Ntddk.h, Ntifs.h)</p></blockquote><h4 id="NtAllocateVirtualMemory-ntifs-h"><a href="#NtAllocateVirtualMemory-ntifs-h" class="headerlink" title="NtAllocateVirtualMemory (ntifs.h)"></a>NtAllocateVirtualMemory (ntifs.h)</h4><blockquote><h4 id="Syntax-2"><a href="#Syntax-2" class="headerlink" title="Syntax"></a>Syntax</h4><p>__kernel_entry NTSYSCALLAPI NTSTATUS NtAllocateVirtualMemory(<br>   HANDLE ProcessHandle,<br>   PVOID *BaseAddress,<br>   ULONG_PTR ZeroBits,<br>   PSIZE_T RegionSize,<br>   ULONG AllocationType,<br>   ULONG Protect);</p></blockquote><h3 id="第三方网站中的函数定义"><a href="#第三方网站中的函数定义" class="headerlink" title="第三方网站中的函数定义"></a>第三方网站中的函数定义</h3><h4 id="NtWriteVirtualMemory"><a href="#NtWriteVirtualMemory" class="headerlink" title="NtWriteVirtualMemory"></a>NtWriteVirtualMemory</h4><blockquote><p>__kernel_entry NTSYSCALLAPI NTSTATUS NtQueryVirtualMemory(<br>   HANDLE ProcessHandle,<br>   PVOID BaseAddress,<br>   MEMORY_INFORMATION_CLASS MemoryInformationClass,<br>   PVOID MemoryInformation,<br>   SIZE_T MemoryInformationLength,<br>   PSIZE_T ReturnLength );</p></blockquote><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><h4 id="UNICODE-STRING-ntdef-h"><a href="#UNICODE-STRING-ntdef-h" class="headerlink" title="UNICODE_STRING (ntdef.h)"></a>UNICODE_STRING (ntdef.h)</h4><p>似乎是一种安全的unicode字符串类型，下面是ntdef源码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unicode strings are counted 16-bit character strings. If they are</span></span><br><span class="line"><span class="comment">// NULL terminated, Length does not include trailing NULL.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MIDL_PASS</span></span><br><span class="line">    [size_is(MaximumLength / <span class="number">2</span>), length_is((Length) / <span class="number">2</span>) ] USHORT * Buffer;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// MIDL_PASS</span></span></span><br><span class="line">    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH   Buffer;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MIDL_PASS</span></span></span><br><span class="line">&#125; UNICODE_STRING;</span><br><span class="line"><span class="keyword">typedef</span> UNICODE_STRING *PUNICODE_STRING;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> UNICODE_STRING *PCUNICODE_STRING;</span><br><span class="line"><span class="comment">// end_sdfwdm</span></span><br><span class="line"><span class="comment">// end_wudfwdm</span></span><br></pre></td></tr></table></figure><h4 id="OBJECT-ATTRIBUTES-ntdef-h"><a href="#OBJECT-ATTRIBUTES-ntdef-h" class="headerlink" title="OBJECT_ATTRIBUTES (ntdef.h)"></a>OBJECT_ATTRIBUTES (ntdef.h)</h4><p>下面是ntdef源码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_ATTRIBUTES</span> &#123;</span></span><br><span class="line">    ULONG Length;</span><br><span class="line">    HANDLE RootDirectory;</span><br><span class="line">    PUNICODE_STRING ObjectName;</span><br><span class="line">    ULONG Attributes;</span><br><span class="line">    PVOID SecurityDescriptor;        <span class="comment">// Points to type SECURITY_DESCRIPTOR</span></span><br><span class="line">    PVOID SecurityQualityOfService;  <span class="comment">// Points to type SECURITY_QUALITY_OF_SERVICE</span></span><br><span class="line">&#125; OBJECT_ATTRIBUTES;</span><br><span class="line"><span class="keyword">typedef</span> OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;</span><br><span class="line"><span class="keyword">typedef</span> CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;</span><br></pre></td></tr></table></figure><h4 id="CLIENT-ID-MSDN"><a href="#CLIENT-ID-MSDN" class="headerlink" title="CLIENT_ID (MSDN)"></a>CLIENT_ID (MSDN)</h4><p>MSDN的解释是包括进程和线程的id，下面是MSDN中的定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> &#123;</span></span><br><span class="line">HANDLE UniqueProcess;</span><br><span class="line">HANDLE UniqueThread;</span><br><span class="line">&#125; CLIENT_ID;</span><br></pre></td></tr></table></figure><h3 id="文件地址"><a href="#文件地址" class="headerlink" title="文件地址"></a>文件地址</h3><blockquote><p>C:\Windows\System32\kernel32.dll<br>C:\Windows\System32\KernelBase.dll<br>C:\Windows\SysWOW64\kernel32.dll<br>C:\Windows\SysWOW64\KernelBase.dll<br>C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\um\windows.h<br>C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\ntdef.h</p></blockquote><h2 id="逆向重写OpenProcess（NtOpenProcess）"><a href="#逆向重写OpenProcess（NtOpenProcess）" class="headerlink" title="逆向重写OpenProcess（NtOpenProcess）"></a>逆向重写OpenProcess（NtOpenProcess）</h2><h3 id="在dll中寻找OpenProcess"><a href="#在dll中寻找OpenProcess" class="headerlink" title="在dll中寻找OpenProcess"></a>在dll中寻找OpenProcess</h3><p>在本机的System32\kernel32.dll里没有找到，只找到OpenProcessStub()，这个函数会直接调用OpenProcess。在System32\KernelBase.dll里找到了OpenProcess，然后用ida f5，改了以下符号名是下面这个样子。</p><p>其中ObjectAttributes.Length这个参数有问题，64位是48，32位是24，msdn里是<code>sizeof(OBJECT_ATTRIBUTES)</code>。</p><p>如果有dalao看到这里肯定发现，system32目录下的是64位的dll，但我原本是想找32位的，很尴尬。</p><h3 id="KernelBase"><a href="#KernelBase" class="headerlink" title="KernelBase"></a>KernelBase</h3><p>MSDN上找到一份关于win7的资料[5]，大概意思是把部分kernel32和advapi32的函数移到了kernelbase里，并称kernelbase为low-level binaries，应该是低权限的意思。目的是为了以后的网络工程开发和减少攻击面。</p><h3 id="OpenProcess调用过程（x32）"><a href="#OpenProcess调用过程（x32）" class="headerlink" title="OpenProcess调用过程（x32）"></a>OpenProcess调用过程（x32）</h3><p>在重写OpenProcess改用NtOpenProcess后（详细见下面重新OpenProcess），我重新跟踪了下调用OpenProcess的过程。</p><p><img src="https://s3.ax1x.com/2021/03/16/6y9jbj.png" alt="op32"></p><p>首先main函数call OpenProcess，跳转到kernel.dll；然后jmp到kernelbase.dll；在kernelbase.dll里才是OpenProcess的主要代码，其中会调用ntdll的NtOpenProcess；而NtOpenProcess会调用系统调用。</p><h3 id="OpenProcess调用过程（x64）"><a href="#OpenProcess调用过程（x64）" class="headerlink" title="OpenProcess调用过程（x64）"></a>OpenProcess调用过程（x64）</h3><p>64位和32差不多，先是main call OpenProcess跳转到kernel.dll；然后jmp到kernelbase.dll；kernelbase.dll里是主要代码，不同点是ObjectAttributes.Length的值，以及32位调用的NtOpenProcess，在64中改成了ntdll的ZwOpenProcess；而ZwOpenProcess同样调用了系统调用。</p><p><img src="https://s3.ax1x.com/2021/03/16/6yCuPx.png" alt="op64"></p><h3 id="重写OpenProcess（NtOpenProcess）"><a href="#重写OpenProcess（NtOpenProcess）" class="headerlink" title="重写OpenProcess（NtOpenProcess）"></a>重写OpenProcess（NtOpenProcess）</h3><p>直接引用ntdef.h会引发下面的错误：</p><p>error C2338: Windows headers require the default packing option. Changing this can lead to memory corruption. This diagnostic can be disabled by building with WINDOWS_IGNORE_PACKING_MISMATCH defined.</p><p>最终代替OpenProcess的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">USHORT Length;</span><br><span class="line">USHORT MaximumLength;</span><br><span class="line">PWSTR  Buffer;</span><br><span class="line">&#125;UNICODE_STRING, *PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_ATTRIBUTES</span> &#123;</span></span><br><span class="line">ULONG Length;</span><br><span class="line">HANDLE RootDirectory;</span><br><span class="line">PUNICODE_STRING ObjectName;</span><br><span class="line">ULONG Attributes;</span><br><span class="line">PVOID SecurityDescriptor;</span><br><span class="line">PVOID SecurityQualityOfService;</span><br><span class="line">&#125;OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> &#123;</span></span><br><span class="line">HANDLE UniqueProcess;</span><br><span class="line">HANDLE UniqueThread;</span><br><span class="line">&#125;CLIENT_ID, *PCLIENT_ID;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">long</span> <span class="params">(WINAPI* PNtOpenProcess)</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PHANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">PCLIENT_ID ClientId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hTarget = OpenProcess((PROCESS_CREATE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION), false, pid);</span></span><br><span class="line">HMODULE mdNT = GetModuleHandleW(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line">PNtOpenProcess NtOpenProcess = (PNtOpenProcess)GetProcAddress(mdNT, <span class="string">&quot;NtOpenProcess&quot;</span>);</span><br><span class="line">OBJECT_ATTRIBUTES ObjectAttributes = &#123; <span class="keyword">sizeof</span>(OBJECT_ATTRIBUTES) &#125;; <span class="comment">// 0x18</span></span><br><span class="line">CLIENT_ID ClientId = &#123; (HANDLE)pid, <span class="number">0</span> &#125;;</span><br><span class="line">DWORD nts = NtOpenProcess(&amp;hTarget, (PROCESS_CREATE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION), &amp;ObjectAttributes, &amp;ClientId);</span><br></pre></td></tr></table></figure><p>其中ObjectAttributes.Length我一开始照抄48（后面才发现，照抄的是64位版本的openprocess。），然后NtOpenProcess给我返回了0xC000000D，MSDN中的说明是传入非法参数，再仔细看Members条目，发现这个参数应该为<code>sizeof(OBJECT_ATTRIBUTES)</code>，vs中调试发现这个结构体的长度为24，修改后就能正常用了。原因是32和64的OBJECT_ATTRIBUTES结构长度不一样。</p><h2 id="R0和R3通信"><a href="#R0和R3通信" class="headerlink" title="R0和R3通信"></a>R0和R3通信</h2><p>后面查资料才知道，windwos程序运行在r3（用户态）层；驱动在r1，r2；系统代码在r0（内核态）层。r0权限最高。</p><p>ntdll提供api使得r3层面的程序能够执行r0层的代码。而ntdll的native api都是成对出现的，分别以Nt和Zw开头。</p><h2 id="逆向重写VirtualAllocEx（NtAllocateVirtualMemory）"><a href="#逆向重写VirtualAllocEx（NtAllocateVirtualMemory）" class="headerlink" title="逆向重写VirtualAllocEx（NtAllocateVirtualMemory）"></a>逆向重写VirtualAllocEx（NtAllocateVirtualMemory）</h2><h3 id="KernelBase-dll中的VirtualAllocEx"><a href="#KernelBase-dll中的VirtualAllocEx" class="headerlink" title="KernelBase.dll中的VirtualAllocEx"></a>KernelBase.dll中的VirtualAllocEx</h3><p>VirtualAllocEx会直接调用VirtualAllocExNuma；然后VirtualAllocExNuma调用NtAllocateVirtualMemory。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">long</span> <span class="params">(WINAPI* PNtAllocateVirtualMemory)</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">PVOID* BaseAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG_PTR ZeroBits,</span></span></span><br><span class="line"><span class="function"><span class="params">PSIZE_T RegionSize,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG AllocationType,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG Protect</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pszPathname = (PWSTR)VirtualAllocEx(hTarget, NULL, pathnameLen, MEM_COMMIT, PAGE_READWRITE);</span></span><br><span class="line">PNtAllocateVirtualMemory NtAllocateVirtualMemory = (PNtAllocateVirtualMemory)GetProcAddress(mdNT, <span class="string">&quot;NtAllocateVirtualMemory&quot;</span>);</span><br><span class="line">nts = NtAllocateVirtualMemory(hTarget, (PVOID*)&amp;pszPathname, <span class="number">0</span>, (SIZE_T*)&amp;pathnameLen, MEM_COMMIT &amp; <span class="number">0xFFFFFFC0</span>, PAGE_READWRITE);</span><br></pre></td></tr></table></figure><h2 id="逆向重写WriteProcessMemory（NtWriteVirtualMemory）"><a href="#逆向重写WriteProcessMemory（NtWriteVirtualMemory）" class="headerlink" title="逆向重写WriteProcessMemory（NtWriteVirtualMemory）"></a>逆向重写WriteProcessMemory（NtWriteVirtualMemory）</h2><h3 id="KernelBase-dll中的WriteProcessMemory"><a href="#KernelBase-dll中的WriteProcessMemory" class="headerlink" title="KernelBase.dll中的WriteProcessMemory"></a>KernelBase.dll中的WriteProcessMemory</h3><p>WriteProcessMemory中调用了NtQueryVirtualMemory，NtProtectVirtualMemory，NtWriteVirtualMemory，NtFlushInstructionCache。后三个在MSDN中似乎都没有资料。</p><p>其中 NtQueryVirtualMemory 用于获取虚拟内存的属性。</p><p>在第三方网站查询得到 NtProtectVirtualMemory[7] 用于改变虚拟内存区域的保护状态。</p><p>关于 NtFlushInstructionCache 的资料没有找到多少，说是用于刷新指令缓存，不知道具体有什么用。</p><p>同样在第三方网站查询得到 NtWriteVirtualMemory[8] 用于写入内存。所以只需要直接调用这个即可。</p><h3 id="重写-1"><a href="#重写-1" class="headerlink" title="重写"></a>重写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">long</span><span class="params">(WINAPI* PNtWriteVirtualMemory)</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">PVOID BaseAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">PVOID Buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG BufferSize,</span></span></span><br><span class="line"><span class="function"><span class="params">PULONG NumberOfBytesWritten</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteProcessMemory(hTarget, (LPVOID)memoryAddr, buf, bufSize, &amp;byw);</span></span><br><span class="line">PNtWriteVirtualMemory NtWriteVirtualMemory = (PNtWriteVirtualMemory)GetProcAddress(mdNT, <span class="string">&quot;NtWriteVirtualMemory&quot;</span>);</span><br><span class="line">NtWriteVirtualMemory(hTarget, memoryAddr, buf, bufSize, &amp;byw);</span><br></pre></td></tr></table></figure><h2 id="逆向重写LoadLibraryExW（LdrLoadDll）"><a href="#逆向重写LoadLibraryExW（LdrLoadDll）" class="headerlink" title="逆向重写LoadLibraryExW（LdrLoadDll）"></a>逆向重写LoadLibraryExW（LdrLoadDll）</h2><p>32位下调用过程如下，不管调用哪个版本，最终都会去到LoadLibraryExW。</p><p>LoadLibraryA -&gt; LoadLibraryExA -&gt;LoadLibraryExW，LoadLibraryW -&gt; LoadLibraryExW</p><h3 id="KernelBase-dll中的LoadLibraryExW"><a href="#KernelBase-dll中的LoadLibraryExW" class="headerlink" title="KernelBase.dll中的LoadLibraryExW"></a>KernelBase.dll中的LoadLibraryExW</h3><p>首先通过传入的dwFlags参数确认传入的dll名称是不是unicode编码，不是就设置错误代码为0xC000000D（传入参数非法）。</p><p>然后转换成UNICODE_STRING（RtlInitUnicodeString）。</p><p>转换后会进行检查，去掉unicode字符串末尾的空格。如果全是空格同样会设置错误代码为0xC000000D。</p><p>接着有一段代码会调用 LdrGetDllPath，这段代码如果调用 LoadLibraryW 进入的 LoadLibraryExW 不会触发。</p><p>然后又有一系列从 LoadLibraryW 进入不会触发的if语句。</p><p>最后调用 LdrLoadDll。</p><p>需要注意的是，要选择Release模式，debug模式会出问题，不能正确获得ShellCode地址。</p><h3 id="重写-2"><a href="#重写-2" class="headerlink" title="重写"></a>重写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __declspec(naked) ShellCode(PVOID addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// para 3 UNICODE_STRING pathname</span></span><br><span class="line">    <span class="comment">// [addr+0x0] 2:  USHORT  Length</span></span><br><span class="line">    <span class="comment">// [addr+0x2] 2:  USHORT  MaximumLength</span></span><br><span class="line">    <span class="comment">// [addr+0x4] 4:  PWSTR   Buffer        = addr+8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [addr+0x8] 0x14: wchar_t dllPathname</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// para 2</span></span><br><span class="line">    <span class="comment">// [addr+0x98] 4: ULONG LoadFlags = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// para 4</span></span><br><span class="line">    <span class="comment">// [addr+0x9C] 4: PVOID BaseAddress = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [addr+0x100] 4: PVOID LdrLoadDll</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [addr+0x200] : shellcode</span></span><br><span class="line">__asm &#123;</span><br><span class="line">pushad;</span><br><span class="line">mov eax, addr;</span><br><span class="line"><span class="comment">// para 4</span></span><br><span class="line">mov ebx, eax;</span><br><span class="line">add ebx, <span class="number">0x9c</span>;</span><br><span class="line">push ebx;</span><br><span class="line"><span class="comment">// para 3</span></span><br><span class="line">mov ebx, eax;</span><br><span class="line">push ebx;</span><br><span class="line"><span class="comment">// para 2</span></span><br><span class="line">mov ebx, eax;</span><br><span class="line">add ebx, <span class="number">0x98</span>;</span><br><span class="line">push ebx;</span><br><span class="line"><span class="comment">// para 1</span></span><br><span class="line">mov ebx, <span class="number">1</span>;</span><br><span class="line">push ebx;</span><br><span class="line"><span class="comment">// call LdrLoadDll</span></span><br><span class="line">add eax, <span class="number">0x100</span>;</span><br><span class="line">mov edx, [eax];</span><br><span class="line">call edx;</span><br><span class="line">popad;</span><br><span class="line">mov eax, addr;</span><br><span class="line">add eax, <span class="number">0x9C</span>;</span><br><span class="line">mov eax, [eax];</span><br><span class="line">ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写入参数及shellcode"><a href="#写入参数及shellcode" class="headerlink" title="写入参数及shellcode"></a>写入参数及shellcode</h4><p>这里需要用NtWriteVirtualMemory写入参数及shellcode。</p><p>第三个参数 UNICODE_STRING pathname 我直接选择自己构建，MaximumLength就是dll路径字符串的字节数（包括末尾的零），而Length必须是字符串不包括末尾\x0\x0的字节数，否则会LdrLoadDll会找不到dll并返回0xC0000135。</p><h2 id="逆向重写CreateRemoteThreadEx（NtCreateThreadEx）"><a href="#逆向重写CreateRemoteThreadEx（NtCreateThreadEx）" class="headerlink" title="逆向重写CreateRemoteThreadEx（NtCreateThreadEx）"></a>逆向重写CreateRemoteThreadEx（NtCreateThreadEx）</h2><h3 id="KernelBase-dll中的CreateRemoteThreadEx"><a href="#KernelBase-dll中的CreateRemoteThreadEx" class="headerlink" title="KernelBase.dll中的CreateRemoteThreadEx"></a>KernelBase.dll中的CreateRemoteThreadEx</h3><p>CreateRemoteThread会直接调用CreateRemoteThreadEx</p><p>然后CreateRemoteThreadEx会搞一堆奇奇怪怪的检测，并调用NtCreateThreadEx。</p><p>在网上找到定义[9]，照着定义和ida写了下。其中调用了个BaseFormatObjectAttributes，但传了两个零进去发现其实什么也没干。</p><h3 id="重写-3"><a href="#重写-3" class="headerlink" title="重写"></a>重写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">long</span><span class="params">(WINAPI* PNtCreateThreadEx)</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PHANDLE hThread,</span></span></span><br><span class="line"><span class="function"><span class="params">ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG StackZeroBits,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG SizeOfStackCommit,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG SizeOfStackReserve,</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpBytesBuffer</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line">PNtCreateThreadEx NtCreateThreadEx = (PNtCreateThreadEx)GetProcAddress(mdNT, <span class="string">&quot;NtCreateThreadEx&quot;</span>);</span><br><span class="line">nts = NtCreateThreadEx(</span><br><span class="line">    &amp;hDll,</span><br><span class="line">    <span class="number">0x1FFFFF</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    hTarget,</span><br><span class="line">    (LPTHREAD_START_ROUTINE)(pVirtualMemory + <span class="number">0x200</span>),</span><br><span class="line">    (PVOID)pVirtualMemory,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="用RtlCreateUserThread代替CreateRemoteThread"><a href="#用RtlCreateUserThread代替CreateRemoteThread" class="headerlink" title="用RtlCreateUserThread代替CreateRemoteThread"></a>用RtlCreateUserThread代替CreateRemoteThread</h2><p>据说RtlCreateUserThread是NtCreateThread的一个小型封装。抄了一下Metasploit的代码[11]。</p><p>Metasploit会先用CraeteRemoteThread，没有足够空间时再使用RtlCreateUserThread。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">long</span><span class="params">(WINAPI* PRtlCreateUserThread)</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">PSECURITY_DESCRIPTOR SecurityDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">BOOLEAN CreateSuspended,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG StackZeroBits,</span></span></span><br><span class="line"><span class="function"><span class="params">PULONG StackReserved,</span></span></span><br><span class="line"><span class="function"><span class="params">PULONG StackCommit,</span></span></span><br><span class="line"><span class="function"><span class="params">PVOID StartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">PVOID StartParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">PCLIENT_ID ClientID</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line">PRtlCreateUserThread RtlCreateUserThread = (PRtlCreateUserThread)GetProcAddress(mdNT, <span class="string">&quot;RtlCreateUserThread&quot;</span>);</span><br><span class="line">nts = RtlCreateUserThread(</span><br><span class="line">    hTarget,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (LPTHREAD_START_ROUTINE)(pVirtualMemory + <span class="number">0x200</span>),</span><br><span class="line">    (PVOID)pVirtualMemory,</span><br><span class="line">    &amp;hDll,</span><br><span class="line">    <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] UNICODE_STRING ：<a href="https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_unicode_string">https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_unicode_string</a></p><p>[2] OBJECT_ATTRIBUTES：<a href="https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_object_attributes">https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_object_attributes</a></p><p>[3] CLIENT_ID：<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tsts/a11e7129-685b-4535-8d37-21d4596ac057">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tsts/a11e7129-685b-4535-8d37-21d4596ac057</a></p><p>[4] NtOpenProcess：<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-ntopenprocess">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-ntopenprocess</a></p><p>[5] New Low-Level Binaries（win7）：<a href="https://docs.microsoft.com/en-us/windows/win32/win7appqual/new-low-level-binaries">https://docs.microsoft.com/en-us/windows/win32/win7appqual/new-low-level-binaries</a></p><p>[6] r0和r3之间的通信：<a href="https://blog.csdn.net/qq_33526144/article/details/103503011">https://blog.csdn.net/qq_33526144/article/details/103503011</a></p><p>[7] NtQueryVirtualMemory：<a href="http://www.codewarrior.cn/ntdoc/winnt/mm/NtProtectVirtualMemory.htm">http://www.codewarrior.cn/ntdoc/winnt/mm/NtProtectVirtualMemory.htm</a></p><p>[8] NtWriteProcessMemory：<a href="http://www.codewarrior.cn/ntdoc/winnt/mm/NtWriteVirtualMemory.htm">http://www.codewarrior.cn/ntdoc/winnt/mm/NtWriteVirtualMemory.htm</a></p><p>[9] NtCreateThread：<a href="https://securityxploded.com/ntcreatethreadex.php">https://securityxploded.com/ntcreatethreadex.php</a></p><p>[10] RtlCreateUserThread：<a href="https://undocumented.ntinternals.net/index.html?page=UserMode/Undocumented%20Functions/Executable%20Images/RtlCreateUserThread.html">https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FExecutable%20Images%2FRtlCreateUserThread.html</a></p><p>[11] RtlCreateUserThread Metasploit例子：<a href="https://github.com/rapid7/meterpreter/blob/6d43284689240f4261cae44a47f0fb557c1dde27/source/common/arch/win/remote_thread.c#L77">https://github.com/rapid7/meterpreter/blob/6d43284689240f4261cae44a47f0fb557c1dde27/source/common/arch/win/remote_thread.c#L77</a></p><p>[12] RtlCreateUserThread mimikatz例子：<a href="https://github.com/gentilkiwi/mimikatz/blob/d5676aa66cb3f01afc373b0a2f8fcc1a2822fd27/modules/kull_m_remotelib.c#L59">https://github.com/gentilkiwi/mimikatz/blob/d5676aa66cb3f01afc373b0a2f8fcc1a2822fd27/modules/kull_m_remotelib.c#L59</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/dll/">dll</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/03/16/dllRemoteInject/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>windows核心编程 dll笔记</title>
      <link>https://windgodm.github.io/blog/2021/03/16/winViaC-dll/</link>
      <guid>https://windgodm.github.io/blog/2021/03/16/winViaC-dll/</guid>
      <pubDate>Tue, 16 Mar 2021 08:52:35 GMT</pubDate>
      
      <description>看windows核心编程dll注入部分的时候做的一些笔记</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="windows核心编程-dll笔记"><a href="#windows核心编程-dll笔记" class="headerlink" title="windows核心编程 dll笔记"></a>windows核心编程 dll笔记</h1><h2 id="构建及使用dll"><a href="#构建及使用dll" class="headerlink" title="构建及使用dll"></a>构建及使用dll</h2><p>以下是核心编程的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .\Mylib\MyLib.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYLIB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLIB extern <span class="meta-string">&quot;C&quot;</span> __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">MYLIB <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="function">MYLIB <span class="keyword">int</span> <span class="title">DllFun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .\Mylib\MyLib1.cpp */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLIB extern <span class="meta-string">&quot;C&quot;</span> __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyLib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dll_num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DllFun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dll_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .\MyExe.cpp */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyLib\MyLib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dll_num = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; DllFun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extern “C”修饰符用于指明使用C++。</p><h2 id="载入dll模块"><a href="#载入dll模块" class="headerlink" title="载入dll模块"></a>载入dll模块</h2><h3 id="显式载入"><a href="#显式载入" class="headerlink" title="显式载入"></a>显式载入</h3><p>将dll映射到进程的地址空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">LoadLibrary</span><span class="params">(PCTSTR pszDLLPathName)</span></span>;</span><br><span class="line"><span class="function">HMODULE <span class="title">LoadLibraryEx</span><span class="params">(PCTSTR pszDLLPathName,</span></span></span><br><span class="line"><span class="function"><span class="params">                      HANDLE hFile,</span></span></span><br><span class="line"><span class="function"><span class="params">                      DWORD dwFlags)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值是被映射到的虚拟内存地址。（此处HMODULE等价于HINSTANCE）</p><p>通过GetLastError确定是否成功载入。</p><h3 id="显式链接到导出符号"><a href="#显式链接到导出符号" class="headerlink" title="显式链接到导出符号"></a>显式链接到导出符号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FARPROC <span class="title">GetProcAddress</span><span class="params">(HMODULE hInstDll, PCSTR pszSymbolName)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="显式卸载"><a href="#显式卸载" class="headerlink" title="显式卸载"></a>显式卸载</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FreeLibrary</span><span class="params">(HMODULE hInstDll)</span></span>;</span><br><span class="line"><span class="function">VOID <span class="title">FreeLivraryAndExitThread</span><span class="params">(HMODULE hInstDll, DWORD dwExitCode)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="dll搜索顺序"><a href="#dll搜索顺序" class="headerlink" title="dll搜索顺序"></a>dll搜索顺序</h3><ul><li>当前目录</li><li>windows系统目录</li><li>16位windows系统目录（windows目录下的system子目录）</li><li>windows目录</li><li>path环境变量中的目录</li></ul><h2 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain"></a>DllMain</h2><h3 id="fdwReason"><a href="#fdwReason" class="headerlink" title="fdwReason"></a>fdwReason</h3><p><strong>DLL_PROCESS_ATTACH：</strong><br>第一次将DLL<strong>映射到进程中</strong>时，会调用DllMain并传入该信号。<br>通常此时应该通过HeapCreate创建需要的堆。<br>返回值用于表示是否初始化成功。</p><p><strong>DLL_THREAD_ATTACH：</strong><br>进程创建一个线程时触发。</p><p><strong>DLL_THREAD_DETACH：</strong><br>ExitThread触发。</p><p><strong>DLL_PROCESS_DETACH：</strong><br>撤销映射时传入该信号。<br>通常执行HeapDestroy销毁初始化时创建的堆。</p><h2 id="模块的基地址重定位"><a href="#模块的基地址重定位" class="headerlink" title="模块的基地址重定位"></a>模块的基地址重定位</h2><p>重定位段(relocation section)包含一个字节偏移量的列表，记录机器指令的内存地址，用于需要重定位时遍历修改内存映像中的地址。</p><h2 id="RemoteInject（CreateRemoteThread）"><a href="#RemoteInject（CreateRemoteThread）" class="headerlink" title="RemoteInject（CreateRemoteThread）"></a>RemoteInject（CreateRemoteThread）</h2><h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><ul><li><p>获取目标进程pid，并打开目标进程。</p></li><li><p>在目标进程中申请空间，写入注入dll的路径。</p></li><li><p>获取LoadLibrary在Kernel32.dll的真实地址。</p></li><li><p>通过远程创建线程，在目标进程中创建一个线程，执行LoadLibrary(dllPathname)。</p></li><li><p>释放申请的空间，并关闭句柄。</p></li></ul><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>因为是在目标进程中执行LoadLibrary(dllPathname)的，所以需要先把dll路径写入目标进程中，并作为LoadLibrary的参数。</p><p>直接调用LoadLibrary时，链接器会生成一个调用，调用导入段中的一个转换函数。即先跳转到转换函数，再跳转到实际函数。<br>而转换函数在不同进程中是会变的，但Kernel32.dll在所有进程中映射的地址是一样的，所以需要获取LoadLibrary在Kernel32.dll中的地址。</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">RemoteInject.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetPidByName</span><span class="params">(WCHAR* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">wchar_t</span> targetName[<span class="number">20</span>] = <span class="string">L&quot;Target.exe&quot;</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> dllPathname[] = <span class="string">L&quot;E:\\MyDll.dll&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> pathnameLen = (<span class="number">1</span> + lstrlenW(dllPathname)) * <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>);</span><br><span class="line">DWORD pid = <span class="number">0</span>, byw = <span class="number">0</span>;</span><br><span class="line">HANDLE hTarget = <span class="number">0</span>, hDll = <span class="number">0</span>;</span><br><span class="line">PWSTR pszPathname = <span class="number">0</span>;</span><br><span class="line">PTHREAD_START_ROUTINE realAddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__try &#123;</span><br><span class="line"><span class="comment">// 1 get pid</span></span><br><span class="line">pid = GetPidByName(targetName);</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;e:Get pid failed\n&quot;</span>;</span><br><span class="line">__leave;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pid:&quot;</span> &lt;&lt; pid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 open process</span></span><br><span class="line">hTarget = OpenProcess((PROCESS_CREATE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION), <span class="literal">false</span>, pid);</span><br><span class="line"><span class="keyword">if</span> (hTarget == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;e:Open process failed\n&quot;</span>;</span><br><span class="line">__leave;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 alloc memory for dll pathname</span></span><br><span class="line">pszPathname = (PWSTR)VirtualAllocEx(hTarget, <span class="literal">NULL</span>, pathnameLen, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pszPathname == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;e:Alloc memory failed\n&quot;</span>;</span><br><span class="line">__leave;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pathname addr: &quot;</span> &lt;&lt; pszPathname &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 write dll pathname</span></span><br><span class="line">WriteProcessMemory(hTarget, (LPVOID)pszPathname, dllPathname, pathnameLen, &amp;byw);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dll pathname(len, write len): &quot;</span> &lt;&lt; pathnameLen &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; byw &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 get the real address of LoadLibraryW in Kernel32.dll</span></span><br><span class="line">HMODULE mh = GetModuleHandleW(<span class="string">L&quot;Kernel32.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (mh == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;e:kernel\n&quot;</span>;</span><br><span class="line">__leave;</span><br><span class="line">&#125;</span><br><span class="line">realAddr = (PTHREAD_START_ROUTINE)GetProcAddress(mh, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 create a remote thread to call LoadLibraryW(dllPathname)</span></span><br><span class="line">hDll = CreateRemoteThread(hTarget, <span class="literal">NULL</span>, <span class="number">0</span>, realAddr, pszPathname, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hDll == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;e:create remote thread failed\n&quot;</span>;</span><br><span class="line">__leave;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hDll: &quot;</span> &lt;&lt; hDll &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait</span></span><br><span class="line">WaitForSingleObject(hDll, INFINITE);</span><br><span class="line">&#125;</span><br><span class="line">__finally &#123;</span><br><span class="line"><span class="comment">// clean</span></span><br><span class="line"><span class="keyword">if</span> (hDll != <span class="literal">NULL</span>) &#123;</span><br><span class="line">CloseHandle(hDll);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hTarget != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (pszPathname != <span class="literal">NULL</span>)</span><br><span class="line">VirtualFreeEx(hTarget, pszPathname, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"></span><br><span class="line">CloseHandle(hTarget);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetPidByName</span><span class="params">(WCHAR* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hsnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hsnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">printf_s(<span class="string">&quot;CreateToolhelp32Snapshot error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROCESSENTRY32 pe&#123;&#125;;</span><br><span class="line">pe.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = Process32First(hsnapshot, &amp;pe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (wcscmp(pe.szExeFile, name) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> pe.th32ProcessID;</span><br><span class="line">&#125;</span><br><span class="line">flag = Process32Next(hsnapshot, &amp;pe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloseHandle(hsnapshot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ImageWalk"><a href="#ImageWalk" class="headerlink" title="ImageWalk"></a>ImageWalk</h2><p>遍历内存区块查询对应的信息</p><h3 id="MEMORY-BASIC-INFORMATION"><a href="#MEMORY-BASIC-INFORMATION" class="headerlink" title="MEMORY_BASIC_INFORMATION"></a>MEMORY_BASIC_INFORMATION</h3><p>AllocationBase：内存单元起始地址</p><p>BaseAddress：模块基地址</p><p>RegionSize：模块所以页面的大小</p><h3 id="C6262-堆栈溢出警告"><a href="#C6262-堆栈溢出警告" class="headerlink" title="C6262 堆栈溢出警告"></a>C6262 堆栈溢出警告</h3><p>C6262：函数使用了堆栈的“26300”个字节: 超过了 /analyze:stacksize ‘16384’。 请考虑将某些数据移到堆中。</p><p>其中有一个变量为 char szBuf[260 * 100]，260是路径长度最大值，100是个数，这里减少下个数避免这个警告。</p><p>其他解决方式如malloc或new就不再深究了。</p><h2 id="小笔记"><a href="#小笔记" class="headerlink" title="小笔记"></a>小笔记</h2><p>__try和try：据说Release模式下，如果没有throw模块，vc会优化掉try catch</p><p>线性地址：逻辑地址（偏移）+ 基地址</p><p>HMODULE：模块句柄，win32下通常是被载入模块的线性地址</p><p>MAX_PATH：宏常量，通常为260，代表编译器支持的最长路径长度</p><p>sz：string zero，表示以零结尾的字符串，即c字符串</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>C6262：<a href="https://blog.csdn.net/mxclxp/article/details/7991127">https://blog.csdn.net/mxclxp/article/details/7991127</a></p><p>随书代码下载页面：<a href="https://www.wintellect.com/windows-via-cc-by-jeffrey-richter-and-christopher-nasarre/">https://www.wintellect.com/windows-via-cc-by-jeffrey-richter-and-christopher-nasarre/</a></p><p>随书代码下载地址：<a href="https://www.wintellect.com/wp-content/uploads/2017/11/Windows-via-C-Code-January-29-2008.zip">https://www.wintellect.com/wp-content/uploads/2017/11/Windows-via-C-Code-January-29-2008.zip</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Windows/">Windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/dll/">dll</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/windows-via-c/">windows_via_c</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/03/16/winViaC-dll/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>geek20</title>
      <link>https://windgodm.github.io/blog/2020/12/08/geek20/</link>
      <guid>https://windgodm.github.io/blog/2020/12/08/geek20/</guid>
      <pubDate>Tue, 08 Dec 2020 09:48:04 GMT</pubDate>
      
      <description>2020年极客大挑战部分wp（除了web基本都有）</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="/blog/ctf_wp/geek20.html">geek challenge 20th</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/CTF/">CTF</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/geek-challenge/">geek_challenge</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/pwn/">pwn</category>
      
      <category domain="https://windgodm.github.io/blog/tags/crypt/">crypt</category>
      
      <category domain="https://windgodm.github.io/blog/tags/misc/">misc</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      
      <comments>https://windgodm.github.io/blog/2020/12/08/geek20/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
